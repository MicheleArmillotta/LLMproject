[
  {
    "function_name": "dtModify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "4521-4576",
    "snippet": "int dtModify(tid_t tid, struct inode *ip,\n\t struct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\n{\n\tint rc;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\ts8 *stbl;\n\tint entry_si;\t\t/* entry slot index */\n\tstruct ldtentry *entry;\n\n\t/*\n\t *\tsearch for the entry to modify:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to modify).\n\t */\n\tif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page of named entry\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* get slot index of the entry */\n\tstbl = DT_GETSTBL(p);\n\tentry_si = stbl[index];\n\n\t/* linelock entry */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = entry_si;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* get the head/only segment */\n\tentry = (struct ldtentry *) & p->slot[entry_si];\n\n\t/* substitute the inode number of the entry */\n\tentry->inumber = cpu_to_le32(new_ino);\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_ino"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 4552
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "ip",
            "key",
            "orig_ino",
            "&btstack",
            "flag"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nint dtModify(tid_t tid, struct inode *ip,\n\t struct component_name * key, ino_t * orig_ino, ino_t new_ino, int flag)\n{\n\tint rc;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\ts8 *stbl;\n\tint entry_si;\t\t/* entry slot index */\n\tstruct ldtentry *entry;\n\n\t/*\n\t *\tsearch for the entry to modify:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to modify).\n\t */\n\tif ((rc = dtSearch(ip, key, orig_ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page of named entry\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* get slot index of the entry */\n\tstbl = DT_GETSTBL(p);\n\tentry_si = stbl[index];\n\n\t/* linelock entry */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = entry_si;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* get the head/only segment */\n\tentry = (struct ldtentry *) & p->slot[entry_si];\n\n\t/* substitute the inode number of the entry */\n\tentry->inumber = cpu_to_le32(new_ino);\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtLinelockFreelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "4441-4500",
    "snippet": "static void dtLinelockFreelist(dtpage_t * p,\t/* directory page */\n\t\t\t       int m,\t/* max slot index */\n\t\t\t       struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\tstruct dtslot *t;\n\tint si;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tfsi = p->header.freelist;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\tn = 1;\n\txsi = fsi;\n\n\tt = &p->slot[fsi];\n\tsi = t->next;\n\n\t/* find the last/only segment */\n\twhile (si < m && si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\n\t\tt = &p->slot[si];\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
      "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
      "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
      "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtLinelockFreelist(dtpage_t * p,\t/* directory page */\n\t\t\t       int m,\t/* max slot index */\n\t\t\t       struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\tstruct dtslot *t;\n\tint si;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tfsi = p->header.freelist;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\tn = 1;\n\txsi = fsi;\n\n\tt = &p->slot[fsi];\n\tsi = t->next;\n\n\t/* find the last/only segment */\n\twhile (si < m && si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\n\t\tt = &p->slot[si];\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n}"
  },
  {
    "function_name": "dtTruncateEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "4361-4435",
    "snippet": "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\n{\n\tint tsi;\t\t/* truncate entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint fsi, xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\ttsi = stbl[ti];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = tsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[tsi];\n\tASSERT(p->header.flag & BT_INTERNAL);\n\t((struct idtentry *) t)->namlen = 0;\n\tsi = ((struct idtentry *) t)->next;\n\t((struct idtentry *) t)->next = -1;\n\n\tn = 1;\n\tfreecnt = 0;\n\tfsi = si;\n\txsi = tsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tif (freecnt == 0)\n\t\treturn;\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
      "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
      "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
      "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.flag & BT_INTERNAL"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\n{\n\tint tsi;\t\t/* truncate entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint fsi, xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\ttsi = stbl[ti];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = tsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[tsi];\n\tASSERT(p->header.flag & BT_INTERNAL);\n\t((struct idtentry *) t)->namlen = 0;\n\tsi = ((struct idtentry *) t)->next;\n\t((struct idtentry *) t)->next = -1;\n\n\tn = 1;\n\tfreecnt = 0;\n\tfsi = si;\n\txsi = tsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tif (freecnt == 0)\n\t\treturn;\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n}"
  },
  {
    "function_name": "dtDeleteEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "4266-4347",
    "snippet": "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
      "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
      "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
      "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&stbl[fi]",
            "&stbl[fi + 1]",
            "si - fi - 1"
          ],
          "line": 4344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}"
  },
  {
    "function_name": "dtMoveEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "4065-4252",
    "snippet": "static void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index)\n{\n\tint ssi, next;\t\t/* src slot index */\n\tint di;\t\t\t/* dst entry index */\n\tint dsi;\t\t/* dst slot index */\n\ts8 *sstbl, *dstbl;\t/* sorted entry table */\n\tint snamlen, len;\n\tstruct ldtentry *slh, *dlh = NULL;\n\tstruct idtentry *sih, *dih = NULL;\n\tstruct dtslot *h, *s, *d;\n\tstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\n\tstruct lv *slv, *dlv;\n\tint xssi, ns, nd;\n\tint sfsi;\n\n\tsstbl = (s8 *) & sp->slot[sp->header.stblindex];\n\tdstbl = (s8 *) & dp->slot[dp->header.stblindex];\n\n\tdsi = dp->header.freelist;\t/* first (whole page) free slot */\n\tsfsi = sp->header.freelist;\n\n\t/* linelock destination entry slot */\n\tdlv = & ddtlck->lv[ddtlck->index];\n\tdlv->offset = dsi;\n\n\t/* linelock source entry slot */\n\tslv = & sdtlck->lv[sdtlck->index];\n\tslv->offset = sstbl[si];\n\txssi = slv->offset - 1;\n\n\t/*\n\t * move entries\n\t */\n\tns = nd = 0;\n\tfor (di = 0; si < sp->header.nextindex; si++, di++) {\n\t\tssi = sstbl[si];\n\t\tdstbl[di] = dsi;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (ssi != xssi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tslv->length = ns;\n\t\t\tsdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\tslv++;\n\t\t\telse {\n\t\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t}\n\n\t\t\tslv->offset = ssi;\n\t\t\tns = 0;\n\t\t}\n\n\t\t/*\n\t\t * move head/only segment of an entry\n\t\t */\n\t\t/* get dst slot */\n\t\th = d = &dp->slot[dsi];\n\n\t\t/* get src slot and move */\n\t\ts = &sp->slot[ssi];\n\t\tif (sp->header.flag & BT_LEAF) {\n\t\t\t/* get source entry */\n\t\t\tslh = (struct ldtentry *) s;\n\t\t\tdlh = (struct ldtentry *) h;\n\t\t\tsnamlen = slh->namlen;\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN);\n\t\t\t\tdlh->index = slh->index; /* little-endian */\n\t\t\t} else\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN_LEGACY);\n\n\t\t\tmemcpy(dlh, slh, 6 + len * 2);\n\n\t\t\tnext = slh->next;\n\n\t\t\t/* update dst head/only segment next field */\n\t\t\tdsi++;\n\t\t\tdlh->next = dsi;\n\t\t} else {\n\t\t\tsih = (struct idtentry *) s;\n\t\t\tsnamlen = sih->namlen;\n\n\t\t\tlen = min(snamlen, DTIHDRDATALEN);\n\t\t\tdih = (struct idtentry *) h;\n\t\t\tmemcpy(dih, sih, 10 + len * 2);\n\t\t\tnext = sih->next;\n\n\t\t\tdsi++;\n\t\t\tdih->next = dsi;\n\t\t}\n\n\t\t/* free src head/only segment */\n\t\ts->next = sfsi;\n\t\ts->cnt = 1;\n\t\tsfsi = ssi;\n\n\t\tns++;\n\t\tnd++;\n\t\txssi = ssi;\n\n\t\t/*\n\t\t * move additional segment(s) of the entry\n\t\t */\n\t\tsnamlen -= len;\n\t\twhile ((ssi = next) >= 0) {\n\t\t\t/* is next slot contiguous ? */\n\t\t\tif (ssi != xssi + 1) {\n\t\t\t\t/* close current linelock */\n\t\t\t\tslv->length = ns;\n\t\t\t\tsdtlck->index++;\n\n\t\t\t\t/* open new linelock */\n\t\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\t\tslv++;\n\t\t\t\telse {\n\t\t\t\t\tsdtlck =\n\t\t\t\t\t    (struct dt_lock *)\n\t\t\t\t\t    txLinelock(sdtlck);\n\t\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t\t}\n\n\t\t\t\tslv->offset = ssi;\n\t\t\t\tns = 0;\n\t\t\t}\n\n\t\t\t/* get next source segment */\n\t\t\ts = &sp->slot[ssi];\n\n\t\t\t/* get next destination free slot */\n\t\t\td++;\n\n\t\t\tlen = min(snamlen, DTSLOTDATALEN);\n\t\t\tUniStrncpy_le(d->name, s->name, len);\n\n\t\t\tns++;\n\t\t\tnd++;\n\t\t\txssi = ssi;\n\n\t\t\tdsi++;\n\t\t\td->next = dsi;\n\n\t\t\t/* free source segment */\n\t\t\tnext = s->next;\n\t\t\ts->next = sfsi;\n\t\t\ts->cnt = 1;\n\t\t\tsfsi = ssi;\n\n\t\t\tsnamlen -= len;\n\t\t}\t\t/* end while */\n\n\t\t/* terminate dst last/only segment */\n\t\tif (h == d) {\n\t\t\t/* single segment entry */\n\t\t\tif (dp->header.flag & BT_LEAF)\n\t\t\t\tdlh->next = -1;\n\t\t\telse\n\t\t\t\tdih->next = -1;\n\t\t} else\n\t\t\t/* multi-segment entry */\n\t\t\td->next = -1;\n\t}\t\t\t/* end for */\n\n\t/* close current linelock */\n\tslv->length = ns;\n\tsdtlck->index++;\n\t*sdtlock = sdtlck;\n\n\tdlv->length = nd;\n\tddtlck->index++;\n\t*ddtlock = ddtlck;\n\n\t/* update source header */\n\tsp->header.freelist = sfsi;\n\tsp->header.freecnt += nd;\n\n\t/* update destination header */\n\tdp->header.nextindex = di;\n\n\tdp->header.freelist = dsi;\n\tdp->header.freecnt -= nd;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
      "static void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UniStrncpy_le",
          "args": [
            "d->name",
            "s->name",
            "len"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrncpy_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "55-67",
          "snippet": "static inline __le16 *UniStrncpy_le(__le16 * ucs1, const __le16 * ucs2,\n\t\t\t\t  size_t n)\n{\n\t__le16 *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = *ucs2++;\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline __le16 *UniStrncpy_le(__le16 * ucs1, const __le16 * ucs2,\n\t\t\t\t  size_t n)\n{\n\t__le16 *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = *ucs2++;\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "snamlen",
            "DTSLOTDATALEN"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "sdtlck"
          ],
          "line": 4189
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dih",
            "sih",
            "10 + len * 2"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dlh",
            "slh",
            "6 + len * 2"
          ],
          "line": 4143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);\n\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index)\n{\n\tint ssi, next;\t\t/* src slot index */\n\tint di;\t\t\t/* dst entry index */\n\tint dsi;\t\t/* dst slot index */\n\ts8 *sstbl, *dstbl;\t/* sorted entry table */\n\tint snamlen, len;\n\tstruct ldtentry *slh, *dlh = NULL;\n\tstruct idtentry *sih, *dih = NULL;\n\tstruct dtslot *h, *s, *d;\n\tstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\n\tstruct lv *slv, *dlv;\n\tint xssi, ns, nd;\n\tint sfsi;\n\n\tsstbl = (s8 *) & sp->slot[sp->header.stblindex];\n\tdstbl = (s8 *) & dp->slot[dp->header.stblindex];\n\n\tdsi = dp->header.freelist;\t/* first (whole page) free slot */\n\tsfsi = sp->header.freelist;\n\n\t/* linelock destination entry slot */\n\tdlv = & ddtlck->lv[ddtlck->index];\n\tdlv->offset = dsi;\n\n\t/* linelock source entry slot */\n\tslv = & sdtlck->lv[sdtlck->index];\n\tslv->offset = sstbl[si];\n\txssi = slv->offset - 1;\n\n\t/*\n\t * move entries\n\t */\n\tns = nd = 0;\n\tfor (di = 0; si < sp->header.nextindex; si++, di++) {\n\t\tssi = sstbl[si];\n\t\tdstbl[di] = dsi;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (ssi != xssi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tslv->length = ns;\n\t\t\tsdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\tslv++;\n\t\t\telse {\n\t\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t}\n\n\t\t\tslv->offset = ssi;\n\t\t\tns = 0;\n\t\t}\n\n\t\t/*\n\t\t * move head/only segment of an entry\n\t\t */\n\t\t/* get dst slot */\n\t\th = d = &dp->slot[dsi];\n\n\t\t/* get src slot and move */\n\t\ts = &sp->slot[ssi];\n\t\tif (sp->header.flag & BT_LEAF) {\n\t\t\t/* get source entry */\n\t\t\tslh = (struct ldtentry *) s;\n\t\t\tdlh = (struct ldtentry *) h;\n\t\t\tsnamlen = slh->namlen;\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN);\n\t\t\t\tdlh->index = slh->index; /* little-endian */\n\t\t\t} else\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN_LEGACY);\n\n\t\t\tmemcpy(dlh, slh, 6 + len * 2);\n\n\t\t\tnext = slh->next;\n\n\t\t\t/* update dst head/only segment next field */\n\t\t\tdsi++;\n\t\t\tdlh->next = dsi;\n\t\t} else {\n\t\t\tsih = (struct idtentry *) s;\n\t\t\tsnamlen = sih->namlen;\n\n\t\t\tlen = min(snamlen, DTIHDRDATALEN);\n\t\t\tdih = (struct idtentry *) h;\n\t\t\tmemcpy(dih, sih, 10 + len * 2);\n\t\t\tnext = sih->next;\n\n\t\t\tdsi++;\n\t\t\tdih->next = dsi;\n\t\t}\n\n\t\t/* free src head/only segment */\n\t\ts->next = sfsi;\n\t\ts->cnt = 1;\n\t\tsfsi = ssi;\n\n\t\tns++;\n\t\tnd++;\n\t\txssi = ssi;\n\n\t\t/*\n\t\t * move additional segment(s) of the entry\n\t\t */\n\t\tsnamlen -= len;\n\t\twhile ((ssi = next) >= 0) {\n\t\t\t/* is next slot contiguous ? */\n\t\t\tif (ssi != xssi + 1) {\n\t\t\t\t/* close current linelock */\n\t\t\t\tslv->length = ns;\n\t\t\t\tsdtlck->index++;\n\n\t\t\t\t/* open new linelock */\n\t\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\t\tslv++;\n\t\t\t\telse {\n\t\t\t\t\tsdtlck =\n\t\t\t\t\t    (struct dt_lock *)\n\t\t\t\t\t    txLinelock(sdtlck);\n\t\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t\t}\n\n\t\t\t\tslv->offset = ssi;\n\t\t\t\tns = 0;\n\t\t\t}\n\n\t\t\t/* get next source segment */\n\t\t\ts = &sp->slot[ssi];\n\n\t\t\t/* get next destination free slot */\n\t\t\td++;\n\n\t\t\tlen = min(snamlen, DTSLOTDATALEN);\n\t\t\tUniStrncpy_le(d->name, s->name, len);\n\n\t\t\tns++;\n\t\t\tnd++;\n\t\t\txssi = ssi;\n\n\t\t\tdsi++;\n\t\t\td->next = dsi;\n\n\t\t\t/* free source segment */\n\t\t\tnext = s->next;\n\t\t\ts->next = sfsi;\n\t\t\ts->cnt = 1;\n\t\t\tsfsi = ssi;\n\n\t\t\tsnamlen -= len;\n\t\t}\t\t/* end while */\n\n\t\t/* terminate dst last/only segment */\n\t\tif (h == d) {\n\t\t\t/* single segment entry */\n\t\t\tif (dp->header.flag & BT_LEAF)\n\t\t\t\tdlh->next = -1;\n\t\t\telse\n\t\t\t\tdih->next = -1;\n\t\t} else\n\t\t\t/* multi-segment entry */\n\t\t\td->next = -1;\n\t}\t\t\t/* end for */\n\n\t/* close current linelock */\n\tslv->length = ns;\n\tsdtlck->index++;\n\t*sdtlock = sdtlck;\n\n\tdlv->length = nd;\n\tddtlck->index++;\n\t*ddtlock = ddtlck;\n\n\t/* update source header */\n\tsp->header.freelist = sfsi;\n\tsp->header.freecnt += nd;\n\n\t/* update destination header */\n\tdp->header.nextindex = di;\n\n\tdp->header.freelist = dsi;\n\tdp->header.freecnt -= nd;\n}"
  },
  {
    "function_name": "dtInsertEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3907-4054",
    "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
      "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
      "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
      "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_index",
          "args": [
            "data->leaf.tid",
            "data->leaf.ip",
            "le32_to_cpu(lh->index)",
            "bn",
            "n",
            "&mp",
            "&lblock"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "modify_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "524-542",
          "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lh->index"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "stbl + index + 1",
            "stbl + index",
            "nextindex - index"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UniStrncpy_to_le",
          "args": [
            "t->name",
            "kname",
            "len"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrncpy_to_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "87-99",
          "snippet": "static inline __le16 *UniStrncpy_to_le(__le16 * ucs1, const wchar_t * ucs2,\n\t\t\t\t       size_t n)\n{\n\t__le16 *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = cpu_to_le16(*ucs2++);\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline __le16 *UniStrncpy_to_le(__le16 * ucs1, const wchar_t * ucs2,\n\t\t\t\t       size_t n)\n{\n\t__le16 *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = cpu_to_le16(*ucs2++);\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "klen",
            "DTSLOTDATALEN"
          ],
          "line": 4000
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index)"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_index",
          "args": [
            "data->leaf.tid",
            "data->leaf.ip",
            "bn",
            "index"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "add_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "334-489",
          "snippet": "static u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&p->header.self"
          ],
          "line": 3950
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "data->leaf.ino"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
  },
  {
    "function_name": "dtGetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3843-3896",
    "snippet": "static void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UniStrncpy_from_le",
          "args": [
            "kname",
            "t->name",
            "len"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrncpy_from_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "104-116",
          "snippet": "static inline wchar_t *UniStrncpy_from_le(wchar_t * ucs1, const __le16 * ucs2,\n\t\t\t\t\t  size_t n)\n{\n\twchar_t *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = __le16_to_cpu(*ucs2++);\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline wchar_t *UniStrncpy_from_le(wchar_t * ucs1, const __le16 * ucs2,\n\t\t\t\t\t  size_t n)\n{\n\twchar_t *anchor = ucs1;\n\n\twhile (n-- && *ucs2)\t/* Copy the strings */\n\t\t*ucs1++ = __le16_to_cpu(*ucs2++);\n\n\tn++;\n\twhile (n--)\t\t/* Pad with nulls */\n\t\t*ucs1++ = 0;\n\treturn anchor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "namlen",
            "DTSLOTDATALEN"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}"
  },
  {
    "function_name": "ciGetLeafPrefixKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3776-3834",
    "snippet": "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t       int ri, struct component_name * key, int flag)\n{\n\tint klen, namlen;\n\twchar_t *pl, *pr, *kname;\n\tstruct component_name lkey;\n\tstruct component_name rkey;\n\n\tlkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (lkey.name == NULL)\n\t\treturn -ENOMEM;\n\n\trkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (rkey.name == NULL) {\n\t\tkfree(lkey.name);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* get left and right key */\n\tdtGetKey(lp, li, &lkey, flag);\n\tlkey.name[lkey.namlen] = 0;\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&lkey);\n\n\tdtGetKey(rp, ri, &rkey, flag);\n\trkey.name[rkey.namlen] = 0;\n\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&rkey);\n\n\t/* compute prefix */\n\tklen = 0;\n\tkname = key->name;\n\tnamlen = min(lkey.namlen, rkey.namlen);\n\tfor (pl = lkey.name, pr = rkey.name;\n\t     namlen; pl++, pr++, namlen--, klen++, kname++) {\n\t\t*kname = *pr;\n\t\tif (*pl != *pr) {\n\t\t\tkey->namlen = klen + 1;\n\t\t\tgoto free_names;\n\t\t}\n\t}\n\n\t/* l->namlen <= r->namlen since l <= r */\n\tif (lkey.namlen < rkey.namlen) {\n\t\t*kname = *pr;\n\t\tkey->namlen = klen + 1;\n\t} else\t\t\t/* l->namelen == r->namelen */\n\t\tkey->namlen = klen;\n\nfree_names:\n\tkfree(lkey.name);\n\tkfree(rkey.name);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rkey.name"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lkey.name"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "lkey.namlen",
            "rkey.namlen"
          ],
          "line": 3813
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ciToUpper",
          "args": [
            "&rkey"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtGetKey",
          "args": [
            "rp",
            "ri",
            "&rkey",
            "flag"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "dtGetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3843-3896",
          "snippet": "static void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ciToUpper",
          "args": [
            "&lkey"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lkey.name"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(JFS_NAME_MAX + 1) * sizeof(wchar_t)",
            "GFP_KERNEL"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t       int ri, struct component_name * key, int flag)\n{\n\tint klen, namlen;\n\twchar_t *pl, *pr, *kname;\n\tstruct component_name lkey;\n\tstruct component_name rkey;\n\n\tlkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (lkey.name == NULL)\n\t\treturn -ENOMEM;\n\n\trkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (rkey.name == NULL) {\n\t\tkfree(lkey.name);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* get left and right key */\n\tdtGetKey(lp, li, &lkey, flag);\n\tlkey.name[lkey.namlen] = 0;\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&lkey);\n\n\tdtGetKey(rp, ri, &rkey, flag);\n\trkey.name[rkey.namlen] = 0;\n\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&rkey);\n\n\t/* compute prefix */\n\tklen = 0;\n\tkname = key->name;\n\tnamlen = min(lkey.namlen, rkey.namlen);\n\tfor (pl = lkey.name, pr = rkey.name;\n\t     namlen; pl++, pr++, namlen--, klen++, kname++) {\n\t\t*kname = *pr;\n\t\tif (*pl != *pr) {\n\t\t\tkey->namlen = klen + 1;\n\t\t\tgoto free_names;\n\t\t}\n\t}\n\n\t/* l->namlen <= r->namlen since l <= r */\n\tif (lkey.namlen < rkey.namlen) {\n\t\t*kname = *pr;\n\t\tkey->namlen = klen + 1;\n\t} else\t\t\t/* l->namelen == r->namelen */\n\t\tkey->namlen = klen;\n\nfree_names:\n\tkfree(lkey.name);\n\tkfree(rkey.name);\n\treturn 0;\n}"
  },
  {
    "function_name": "ciCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3668-3763",
    "snippet": "static int ciCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si,\t/* entry slot index */\n\t\t     int flag)\n{\n\twchar_t *kname, x;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint i;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\t/*\n\t * leaf page entry\n\t */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tname = lh->name;\n\t\tnamlen = lh->namlen;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t}\n\t/*\n\t * internal page entry\n\t */\n\telse {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tname = ih->name;\n\t\tnamlen = ih->namlen;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t/* only uppercase if case-insensitive support is on */\n\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\telse\n\t\t\tx = le16_to_cpu(*name);\n\t\tif ((rc = *kname - x))\n\t\t\treturn rc;\n\t}\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t\t/* only uppercase if case-insensitive support is on */\n\t\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\t\telse\n\t\t\t\tx = le16_to_cpu(*name);\n\n\t\t\tif ((rc = *kname - x))\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "*name"
          ],
          "line": 3751
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UniToupper",
          "args": [
            "le16_to_cpu(*name)"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "UniToupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "121-138",
          "snippet": "static inline wchar_t UniToupper(wchar_t uc)\n{\n\tUNICASERANGE *rp;\n\n\tif (uc < sizeof(UniUpperTable)) {\t/* Latin characters */\n\t\treturn uc + UniUpperTable[uc];\t/* Use base tables */\n\t} else {\n\t\trp = UniUpperRange;\t/* Use range tables */\n\t\twhile (rp->start) {\n\t\t\tif (uc < rp->start)\t/* Before start of range */\n\t\t\t\treturn uc;\t/* Uppercase = input */\n\t\t\tif (uc <= rp->end)\t/* In range */\n\t\t\t\treturn uc + rp->table[uc - rp->start];\n\t\t\trp++;\t/* Try next range */\n\t\t}\n\t}\n\treturn uc;\t\t/* Past last range */\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline wchar_t UniToupper(wchar_t uc)\n{\n\tUNICASERANGE *rp;\n\n\tif (uc < sizeof(UniUpperTable)) {\t/* Latin characters */\n\t\treturn uc + UniUpperTable[uc];\t/* Use base tables */\n\t} else {\n\t\trp = UniUpperRange;\t/* Use range tables */\n\t\twhile (rp->start) {\n\t\t\tif (uc < rp->start)\t/* Before start of range */\n\t\t\t\treturn uc;\t/* Uppercase = input */\n\t\t\tif (uc <= rp->end)\t/* In range */\n\t\t\t\treturn uc + rp->table[uc - rp->start];\n\t\t\trp++;\t/* Try next range */\n\t\t}\n\t}\n\treturn uc;\t\t/* Past last range */\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "klen",
            "len"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int ciCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si,\t/* entry slot index */\n\t\t     int flag)\n{\n\twchar_t *kname, x;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint i;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\t/*\n\t * leaf page entry\n\t */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tname = lh->name;\n\t\tnamlen = lh->namlen;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t}\n\t/*\n\t * internal page entry\n\t */\n\telse {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tname = ih->name;\n\t\tnamlen = ih->namlen;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t/* only uppercase if case-insensitive support is on */\n\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\telse\n\t\t\tx = le16_to_cpu(*name);\n\t\tif ((rc = *kname - x))\n\t\t\treturn rc;\n\t}\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t\t/* only uppercase if case-insensitive support is on */\n\t\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\t\telse\n\t\t\t\tx = le16_to_cpu(*name);\n\n\t\t\tif ((rc = *kname - x))\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}"
  },
  {
    "function_name": "dtCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3592-3653",
    "snippet": "static int dtCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si)\n{\t\t\t\t/* entry slot index */\n\twchar_t *kname;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\tih = (struct idtentry *) & p->slot[si];\n\tsi = ih->next;\n\tname = ih->name;\n\tnamlen = ih->namlen;\n\tlen = min(namlen, DTIHDRDATALEN);\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\treturn rc;\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\tkname += len;\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\t\treturn rc;\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tkname += len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UniStrncmp_le",
          "args": [
            "kname",
            "name",
            "len"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrncmp_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "72-82",
          "snippet": "static inline int UniStrncmp_le(const wchar_t * ucs1, const __le16 * ucs2,\n\t\t\t\tsize_t n)\n{\n\tif (!n)\n\t\treturn 0;\t/* Null strings are equal */\n\twhile ((*ucs1 == __le16_to_cpu(*ucs2)) && *ucs1 && --n) {\n\t\tucs1++;\n\t\tucs2++;\n\t}\n\treturn (int) *ucs1 - (int) __le16_to_cpu(*ucs2);\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline int UniStrncmp_le(const wchar_t * ucs1, const __le16 * ucs2,\n\t\t\t\tsize_t n)\n{\n\tif (!n)\n\t\treturn 0;\t/* Null strings are equal */\n\twhile ((*ucs1 == __le16_to_cpu(*ucs2)) && *ucs1 && --n) {\n\t\tucs1++;\n\t\tucs2++;\n\t}\n\treturn (int) *ucs1 - (int) __le16_to_cpu(*ucs2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "klen",
            "len"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\n\nstatic int dtCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si)\n{\t\t\t\t/* entry slot index */\n\twchar_t *kname;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\tih = (struct idtentry *) & p->slot[si];\n\tsi = ih->next;\n\tname = ih->name;\n\tnamlen = ih->namlen;\n\tlen = min(namlen, DTIHDRDATALEN);\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\treturn rc;\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\tkname += len;\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\t\treturn rc;\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tkname += len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}"
  },
  {
    "function_name": "dtReadNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3416-3579",
    "snippet": "static int dtReadNext(struct inode *ip, loff_t * offset,\n\t\t      struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) offset;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tint pn;\n\ts8 *stbl;\n\tstruct btframe *btsp, *parent;\n\tpxd_t *xd;\n\n\t/*\n\t * get leftmost leaf page pinned\n\t */\n\tif ((rc = dtReadFirst(ip, btstack)))\n\t\treturn rc;\n\n\t/* get leaf page */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/* get the start offset (pn:index) */\n\tpn = dtoffset->pn - 1;\t/* Now pn = 0 represents leftmost leaf */\n\tindex = dtoffset->index;\n\n\t/* start at leftmost page ? */\n\tif (pn == 0) {\n\t\t/* offset beyond eof ? */\n\t\tif (index < p->header.nextindex)\n\t\t\tgoto out;\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = index = 0;\n\t\tgoto a;\n\t}\n\n\t/* start at non-leftmost page: scan parent pages for large pn */\n\tif (p->header.flag & BT_ROOT) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\t/* start after next leaf page ? */\n\tif (pn > 1)\n\t\tgoto b;\n\n\t/* get leaf page pn = 1 */\n      a:\n\tbn = le64_to_cpu(p->header.next);\n\n\t/* unpin leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* offset beyond eof ? */\n\tif (bn == 0) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\tgoto c;\n\n\t/*\n\t * scan last internal page level to get target leaf page\n\t */\n      b:\n\t/* unpin leftmost leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* get left most parent page */\n\tbtsp = btstack->top;\n\tparent = btsp - 1;\n\tbn = parent->bn;\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* scan parent pages at last internal page level */\n\twhile (pn >= p->header.nextindex) {\n\t\tpn -= p->header.nextindex;\n\n\t\t/* get next parent page address */\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin current parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next parent page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* update parent page stack frame */\n\t\tparent->bn = bn;\n\t}\n\n\t/* get leaf page address */\n\tstbl = DT_GETSTBL(p);\n\txd = (pxd_t *) & p->slot[stbl[pn]];\n\tbn = addressPXD(xd);\n\n\t/* unpin parent page */\n\tDT_PUTPAGE(mp);\n\n\t/*\n\t * get target leaf page\n\t */\n      c:\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * leaf page has been completed:\n\t * start with 1st entry of next leaf page\n\t */\n\tif (index >= p->header.nextindex) {\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next leaf page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = 0;\n\t}\n\n      out:\n\t/* return target leaf page pinned */\n\tbtsp = btstack->top;\n\tbtsp->bn = bn;\n\tbtsp->index = dtoffset->index;\n\tbtsp->mp = mp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.next"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "xd"
          ],
          "line": 3532
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack->top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtReadFirst",
          "args": [
            "ip",
            "btstack"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "dtReadFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3344-3403",
          "snippet": "static int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtReadNext(struct inode *ip, loff_t * offset,\n\t\t      struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) offset;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tint pn;\n\ts8 *stbl;\n\tstruct btframe *btsp, *parent;\n\tpxd_t *xd;\n\n\t/*\n\t * get leftmost leaf page pinned\n\t */\n\tif ((rc = dtReadFirst(ip, btstack)))\n\t\treturn rc;\n\n\t/* get leaf page */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/* get the start offset (pn:index) */\n\tpn = dtoffset->pn - 1;\t/* Now pn = 0 represents leftmost leaf */\n\tindex = dtoffset->index;\n\n\t/* start at leftmost page ? */\n\tif (pn == 0) {\n\t\t/* offset beyond eof ? */\n\t\tif (index < p->header.nextindex)\n\t\t\tgoto out;\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = index = 0;\n\t\tgoto a;\n\t}\n\n\t/* start at non-leftmost page: scan parent pages for large pn */\n\tif (p->header.flag & BT_ROOT) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\t/* start after next leaf page ? */\n\tif (pn > 1)\n\t\tgoto b;\n\n\t/* get leaf page pn = 1 */\n      a:\n\tbn = le64_to_cpu(p->header.next);\n\n\t/* unpin leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* offset beyond eof ? */\n\tif (bn == 0) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\tgoto c;\n\n\t/*\n\t * scan last internal page level to get target leaf page\n\t */\n      b:\n\t/* unpin leftmost leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* get left most parent page */\n\tbtsp = btstack->top;\n\tparent = btsp - 1;\n\tbn = parent->bn;\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* scan parent pages at last internal page level */\n\twhile (pn >= p->header.nextindex) {\n\t\tpn -= p->header.nextindex;\n\n\t\t/* get next parent page address */\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin current parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next parent page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* update parent page stack frame */\n\t\tparent->bn = bn;\n\t}\n\n\t/* get leaf page address */\n\tstbl = DT_GETSTBL(p);\n\txd = (pxd_t *) & p->slot[stbl[pn]];\n\tbn = addressPXD(xd);\n\n\t/* unpin parent page */\n\tDT_PUTPAGE(mp);\n\n\t/*\n\t * get target leaf page\n\t */\n      c:\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * leaf page has been completed:\n\t * start with 1st entry of next leaf page\n\t */\n\tif (index >= p->header.nextindex) {\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next leaf page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = 0;\n\t}\n\n      out:\n\t/* return target leaf page pinned */\n\tbtsp = btstack->top;\n\tbtsp->bn = bn;\n\tbtsp->index = dtoffset->index;\n\tbtsp->mp = mp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtReadFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3344-3403",
    "snippet": "static int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "xd"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "xd"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_PUSH",
          "args": [
            "btstack",
            "bn",
            "0"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_STACK_DUMP",
          "args": [
            "btstack"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "BT_STACK_DUMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_btree.h",
          "lines": "144-152",
          "snippet": "static inline void BT_STACK_DUMP(struct btstack *btstack)\n{\n\tint i;\n\tprintk(\"btstack dump:\\n\");\n\tfor (i = 0; i < MAXTREEHEIGHT; i++)\n\t\tprintk(KERN_ERR \"bn = %Lx, index = %d\\n\",\n\t\t       (long long)btstack->stack[i].bn,\n\t\t       btstack->stack[i].index);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void BT_STACK_DUMP(struct btstack *btstack)\n{\n\tint i;\n\tprintk(\"btstack dump:\\n\");\n\tfor (i = 0; i < MAXTREEHEIGHT; i++)\n\t\tprintk(KERN_ERR \"bn = %Lx, index = %d\\n\",\n\t\t       (long long)btstack->stack[i].bn,\n\t\t       btstack->stack[i].index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"btstack overrun\\n\""
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_STACK_FULL",
          "args": [
            "btstack"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "psize",
            "p",
            "rc"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "btstack"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}"
  },
  {
    "function_name": "jfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "3005-3336",
    "snippet": "int jfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *ip = file_inode(file);\n\tstruct nls_table *codepage = JFS_SBI(ip->i_sb)->nls_tab;\n\tint rc = 0;\n\tloff_t dtpos;\t/* legacy OS/2 style position */\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) &dtpos;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\ts8 *stbl;\n\tstruct btstack btstack;\n\tint i, next;\n\tstruct ldtentry *d;\n\tstruct dtslot *t;\n\tint d_namleft, len, outlen;\n\tunsigned long dirent_buf;\n\tchar *name_ptr;\n\tu32 dir_index;\n\tint do_index = 0;\n\tuint loop_count = 0;\n\tstruct jfs_dirent *jfs_dirent;\n\tint jfs_dirents;\n\tint overflow, fix_page, page_fixed = 0;\n\tstatic int unique_pos = 2;\t/* If we can't fix broken index */\n\n\tif (ctx->pos == DIREND)\n\t\treturn 0;\n\n\tif (DO_INDEX(ip)) {\n\t\t/*\n\t\t * persistent index is stored in directory entries.\n\t\t * Special cases:\t 0 = .\n\t\t *\t\t\t 1 = ..\n\t\t *\t\t\t-1 = End of directory\n\t\t */\n\t\tdo_index = 1;\n\n\t\tdir_index = (u32) ctx->pos;\n\n\t\t/*\n\t\t * NFSv4 reserves cookies 1 and 2 for . and .. so the value\n\t\t * we return to the vfs is one greater than the one we use\n\t\t * internally.\n\t\t */\n\t\tif (dir_index)\n\t\t\tdir_index--;\n\n\t\tif (dir_index > 1) {\n\t\t\tstruct dir_table_slot dirtab_slot;\n\n\t\t\tif (dtEmpty(ip) ||\n\t\t\t    (dir_index >= JFS_IP(ip)->next_index)) {\n\t\t\t\t/* Stale position.  Directory has shrunk */\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t      repeat:\n\t\t\trc = read_index(ip, dir_index, &dirtab_slot);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (dirtab_slot.flag == DIR_INDEX_FREE) {\n\t\t\t\tif (loop_count++ > JFS_IP(ip)->next_index) {\n\t\t\t\t\tjfs_err(\"jfs_readdir detected \"\n\t\t\t\t\t\t   \"infinite loop!\");\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdir_index = le32_to_cpu(dirtab_slot.addr2);\n\t\t\t\tif (dir_index == -1) {\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tbn = addressDTS(&dirtab_slot);\n\t\t\tindex = dirtab_slot.slot;\n\t\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\t\tjfs_err(\"jfs_readdir: bad index table\");\n\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dir_index == 0) {\n\t\t\t\t/*\n\t\t\t\t * self \".\"\n\t\t\t\t */\n\t\t\t\tctx->pos = 1;\n\t\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * parent \"..\"\n\t\t\t */\n\t\t\tctx->pos = 2;\n\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Find first entry of left-most leaf\n\t\t\t */\n\t\t\tif (dtEmpty(ip)) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ((rc = dtReadFirst(ip, &btstack)))\n\t\t\t\treturn rc;\n\n\t\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Legacy filesystem - OS/2 & Linux JFS < 0.3.6\n\t\t *\n\t\t * pn = 0; index = 1:\tFirst entry \".\"\n\t\t * pn = 0; index = 2:\tSecond entry \"..\"\n\t\t * pn > 0:\t\tReal entries, pn=1 -> leftmost page\n\t\t * pn = index = -1:\tNo more entries\n\t\t */\n\t\tdtpos = ctx->pos;\n\t\tif (dtpos < 2) {\n\t\t\t/* build \".\" entry */\n\t\t\tctx->pos = 1;\n\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\treturn 0;\n\t\t\tdtoffset->index = 2;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtoffset->pn == 0) {\n\t\t\tif (dtoffset->index == 2) {\n\t\t\t\t/* build \"..\" entry */\n\t\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tjfs_err(\"jfs_readdir called with \"\n\t\t\t\t\t\"invalid offset!\");\n\t\t\t}\n\t\t\tdtoffset->pn = 1;\n\t\t\tdtoffset->index = 0;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtEmpty(ip)) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((rc = dtReadNext(ip, &ctx->pos, &btstack))) {\n\t\t\tjfs_err(\"jfs_readdir: unexpected rc = %d \"\n\t\t\t\t\"from dtReadNext\", rc);\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t\t/* get start leaf page and index */\n\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\t/* offset beyond directory eof ? */\n\t\tif (bn < 0) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdirent_buf = __get_free_page(GFP_KERNEL);\n\tif (dirent_buf == 0) {\n\t\tDT_PUTPAGE(mp);\n\t\tjfs_warn(\"jfs_readdir: __get_free_page failed!\");\n\t\tctx->pos = DIREND;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (1) {\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\tjfs_dirents = 0;\n\t\toverflow = fix_page = 0;\n\n\t\tstbl = DT_GETSTBL(p);\n\n\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\td = (struct ldtentry *) & p->slot[stbl[i]];\n\n\t\t\tif (((long) jfs_dirent + d->namlen + 1) >\n\t\t\t    (dirent_buf + PAGE_SIZE)) {\n\t\t\t\t/* DBCS codepages could overrun dirent_buf */\n\t\t\t\tindex = i;\n\t\t\t\toverflow = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_namleft = d->namlen;\n\t\t\tname_ptr = jfs_dirent->name;\n\t\t\tjfs_dirent->ino = le32_to_cpu(d->inumber);\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN);\n\t\t\t\tjfs_dirent->position = le32_to_cpu(d->index);\n\t\t\t\t/*\n\t\t\t\t * d->index should always be valid, but it\n\t\t\t\t * isn't.  fsck.jfs doesn't create the\n\t\t\t\t * directory index for the lost+found\n\t\t\t\t * directory.  Rather than let it go,\n\t\t\t\t * we can try to fix it.\n\t\t\t\t */\n\t\t\t\tif ((jfs_dirent->position < 2) ||\n\t\t\t\t    (jfs_dirent->position >=\n\t\t\t\t     JFS_IP(ip)->next_index)) {\n\t\t\t\t\tif (!page_fixed && !isReadOnly(ip)) {\n\t\t\t\t\t\tfix_page = 1;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * setting overflow and setting\n\t\t\t\t\t\t * index to i will cause the\n\t\t\t\t\t\t * same page to be processed\n\t\t\t\t\t\t * again starting here\n\t\t\t\t\t\t */\n\t\t\t\t\t\toverflow = 1;\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tjfs_dirent->position = unique_pos++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We add 1 to the index because we may\n\t\t\t\t * use a value of 2 internally, and NFSv4\n\t\t\t\t * doesn't like that.\n\t\t\t\t */\n\t\t\t\tjfs_dirent->position++;\n\t\t\t} else {\n\t\t\t\tjfs_dirent->position = dtpos;\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN_LEGACY);\n\t\t\t}\n\n\t\t\t/* copy the name of head/only segment */\n\t\t\toutlen = jfs_strfromUCS_le(name_ptr, d->name, len,\n\t\t\t\t\t\t   codepage);\n\t\t\tjfs_dirent->name_len = outlen;\n\n\t\t\t/* copy name in the additional segment(s) */\n\t\t\tnext = d->next;\n\t\t\twhile (next >= 0) {\n\t\t\t\tt = (struct dtslot *) & p->slot[next];\n\t\t\t\tname_ptr += outlen;\n\t\t\t\td_namleft -= len;\n\t\t\t\t/* Sanity Check */\n\t\t\t\tif (d_namleft == 0) {\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"JFS:Dtree error: ino = %ld, bn=%lld, index = %d\\n\",\n\t\t\t\t\t\t  (long)ip->i_ino,\n\t\t\t\t\t\t  (long long)bn,\n\t\t\t\t\t\t  i);\n\t\t\t\t\tgoto skip_one;\n\t\t\t\t}\n\t\t\t\tlen = min(d_namleft, DTSLOTDATALEN);\n\t\t\t\toutlen = jfs_strfromUCS_le(name_ptr, t->name,\n\t\t\t\t\t\t\t   len, codepage);\n\t\t\t\tjfs_dirent->name_len += outlen;\n\n\t\t\t\tnext = t->next;\n\t\t\t}\n\n\t\t\tjfs_dirents++;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\nskip_one:\n\t\t\tif (!do_index)\n\t\t\t\tdtoffset->index++;\n\t\t}\n\n\t\tif (!overflow) {\n\t\t\t/* Point to next leaf page */\n\t\t\tif (p->header.flag & BT_ROOT)\n\t\t\t\tbn = 0;\n\t\t\telse {\n\t\t\t\tbn = le64_to_cpu(p->header.next);\n\t\t\t\tindex = 0;\n\t\t\t\t/* update offset (pn:index) for new page */\n\t\t\t\tif (!do_index) {\n\t\t\t\t\tdtoffset->pn++;\n\t\t\t\t\tdtoffset->index = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_fixed = 0;\n\t\t}\n\n\t\t/* unpin previous leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\twhile (jfs_dirents--) {\n\t\t\tctx->pos = jfs_dirent->position;\n\t\t\tif (!dir_emit(ctx, jfs_dirent->name,\n\t\t\t\t    jfs_dirent->name_len,\n\t\t\t\t    jfs_dirent->ino, DT_UNKNOWN))\n\t\t\t\tgoto out;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\n\t\t}\n\n\t\tif (fix_page) {\n\t\t\tadd_missing_indices(ip, bn);\n\t\t\tpage_fixed = 1;\n\t\t}\n\n\t\tif (!overflow && (bn == 0)) {\n\t\t\tctx->pos = DIREND;\n\t\t\tbreak;\n\t\t}\n\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tfree_page(dirent_buf);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n      out:\n\tfree_page(dirent_buf);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "dirent_buf"
          ],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_missing_indices",
          "args": [
            "ip",
            "bn"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "add_missing_indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2918-2969",
          "snippet": "static void add_missing_indices(struct inode *inode, s64 bn)\n{\n\tstruct ldtentry *d;\n\tstruct dt_lock *dtlck;\n\tint i;\n\tuint index;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint rc;\n\ts8 *stbl;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\n\ttid = txBegin(inode->i_sb, 0);\n\n\tDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"DT_GETPAGE failed!\\n\");\n\t\tgoto end;\n\t}\n\tBT_MARK_DIRTY(mp, inode);\n\n\tASSERT(p->header.flag & BT_LEAF);\n\n\ttlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\n\tif (BT_IS_ROOT(mp))\n\t\ttlck->type |= tlckBTROOT;\n\n\tdtlck = (struct dt_lock *) &tlck->lock;\n\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\td = (struct ldtentry *) &p->slot[stbl[i]];\n\t\tindex = le32_to_cpu(d->index);\n\t\tif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\n\t\t\td->index = cpu_to_le32(add_index(tid, inode, bn, i));\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = &dtlck->lv[dtlck->index];\n\t\t\tlv->offset = stbl[i];\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\tDT_PUTPAGE(mp);\n\t(void) txCommit(tid, 1, &inode, 0);\nend:\n\ttxEnd(tid);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic void add_missing_indices(struct inode *inode, s64 bn)\n{\n\tstruct ldtentry *d;\n\tstruct dt_lock *dtlck;\n\tint i;\n\tuint index;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint rc;\n\ts8 *stbl;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\n\ttid = txBegin(inode->i_sb, 0);\n\n\tDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"DT_GETPAGE failed!\\n\");\n\t\tgoto end;\n\t}\n\tBT_MARK_DIRTY(mp, inode);\n\n\tASSERT(p->header.flag & BT_LEAF);\n\n\ttlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\n\tif (BT_IS_ROOT(mp))\n\t\ttlck->type |= tlckBTROOT;\n\n\tdtlck = (struct dt_lock *) &tlck->lock;\n\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\td = (struct ldtentry *) &p->slot[stbl[i]];\n\t\tindex = le32_to_cpu(d->index);\n\t\tif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\n\t\t\td->index = cpu_to_le32(add_index(tid, inode, bn, i));\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = &dtlck->lv[dtlck->index];\n\t\t\tlv->offset = stbl[i];\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\tDT_PUTPAGE(mp);\n\t(void) txCommit(tid, 1, &inode, 0);\nend:\n\ttxEnd(tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_jfs_dirent",
          "args": [
            "jfs_dirent"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "next_jfs_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2985-2992",
          "snippet": "static inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\n{\n\treturn (struct jfs_dirent *)\n\t\t((char *)dirent +\n\t\t ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\n\t\t   sizeof (loff_t) - 1) &\n\t\t  ~(sizeof (loff_t) - 1)));\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\n{\n\treturn (struct jfs_dirent *)\n\t\t((char *)dirent +\n\t\t ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\n\t\t   sizeof (loff_t) - 1) &\n\t\t  ~(sizeof (loff_t) - 1)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "jfs_dirent->name",
            "jfs_dirent->name_len",
            "jfs_dirent->ino",
            "DT_UNKNOWN"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.next"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_strfromUCS_le",
          "args": [
            "name_ptr",
            "t->name",
            "len",
            "codepage"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_strfromUCS_le",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.c",
          "lines": "32-74",
          "snippet": "int jfs_strfromUCS_le(char *to, const __le16 * from,\n\t\t      int len, struct nls_table *codepage)\n{\n\tint i;\n\tint outlen = 0;\n\tstatic int warn_again = 5;\t/* Only warn up to 5 times total */\n\tint warn = !!warn_again;\t/* once per string */\n\n\tif (codepage) {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tint charlen;\n\t\t\tcharlen =\n\t\t\t    codepage->uni2char(le16_to_cpu(from[i]),\n\t\t\t\t\t       &to[outlen],\n\t\t\t\t\t       NLS_MAX_CHARSET_SIZE);\n\t\t\tif (charlen > 0)\n\t\t\t\toutlen += charlen;\n\t\t\telse\n\t\t\t\tto[outlen++] = '?';\n\t\t}\n\t} else {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tif (unlikely(le16_to_cpu(from[i]) & 0xff00)) {\n\t\t\t\tto[i] = '?';\n\t\t\t\tif (unlikely(warn)) {\n\t\t\t\t\twarn--;\n\t\t\t\t\twarn_again--;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\"non-latin1 character 0x%x found in JFS file name\\n\",\n\t\t\t\t\t       le16_to_cpu(from[i]));\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\"mount with iocharset=utf8 to access\\n\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\tto[i] = (char) (le16_to_cpu(from[i]));\n\t\t}\n\t\toutlen = i;\n\t}\n\tto[outlen] = 0;\n\treturn outlen;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint jfs_strfromUCS_le(char *to, const __le16 * from,\n\t\t      int len, struct nls_table *codepage)\n{\n\tint i;\n\tint outlen = 0;\n\tstatic int warn_again = 5;\t/* Only warn up to 5 times total */\n\tint warn = !!warn_again;\t/* once per string */\n\n\tif (codepage) {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tint charlen;\n\t\t\tcharlen =\n\t\t\t    codepage->uni2char(le16_to_cpu(from[i]),\n\t\t\t\t\t       &to[outlen],\n\t\t\t\t\t       NLS_MAX_CHARSET_SIZE);\n\t\t\tif (charlen > 0)\n\t\t\t\toutlen += charlen;\n\t\t\telse\n\t\t\t\tto[outlen++] = '?';\n\t\t}\n\t} else {\n\t\tfor (i = 0; (i < len) && from[i]; i++) {\n\t\t\tif (unlikely(le16_to_cpu(from[i]) & 0xff00)) {\n\t\t\t\tto[i] = '?';\n\t\t\t\tif (unlikely(warn)) {\n\t\t\t\t\twarn--;\n\t\t\t\t\twarn_again--;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\"non-latin1 character 0x%x found in JFS file name\\n\",\n\t\t\t\t\t       le16_to_cpu(from[i]));\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\"mount with iocharset=utf8 to access\\n\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t\tto[i] = (char) (le16_to_cpu(from[i]));\n\t\t}\n\t\toutlen = i;\n\t}\n\tto[outlen] = 0;\n\treturn outlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "d_namleft",
            "DTSLOTDATALEN"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "ip->i_sb",
            "\"JFS:Dtree error: ino = %ld, bn=%lld, index = %d\\n\"",
            "(long)ip->i_ino",
            "(long long)bn",
            "i"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isReadOnly",
          "args": [
            "ip"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "isReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "222-227",
          "snippet": "static inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int isReadOnly(struct inode *inode)\n{\n\tif (JFS_SBI(inode->i_sb)->log)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 3225
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->index"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"jfs_readdir: __get_free_page failed!\""
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtReadNext",
          "args": [
            "ip",
            "&ctx->pos",
            "&btstack"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "dtReadNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3416-3579",
          "snippet": "static int dtReadNext(struct inode *ip, loff_t * offset,\n\t\t      struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) offset;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tint pn;\n\ts8 *stbl;\n\tstruct btframe *btsp, *parent;\n\tpxd_t *xd;\n\n\t/*\n\t * get leftmost leaf page pinned\n\t */\n\tif ((rc = dtReadFirst(ip, btstack)))\n\t\treturn rc;\n\n\t/* get leaf page */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/* get the start offset (pn:index) */\n\tpn = dtoffset->pn - 1;\t/* Now pn = 0 represents leftmost leaf */\n\tindex = dtoffset->index;\n\n\t/* start at leftmost page ? */\n\tif (pn == 0) {\n\t\t/* offset beyond eof ? */\n\t\tif (index < p->header.nextindex)\n\t\t\tgoto out;\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = index = 0;\n\t\tgoto a;\n\t}\n\n\t/* start at non-leftmost page: scan parent pages for large pn */\n\tif (p->header.flag & BT_ROOT) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\t/* start after next leaf page ? */\n\tif (pn > 1)\n\t\tgoto b;\n\n\t/* get leaf page pn = 1 */\n      a:\n\tbn = le64_to_cpu(p->header.next);\n\n\t/* unpin leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* offset beyond eof ? */\n\tif (bn == 0) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\tgoto c;\n\n\t/*\n\t * scan last internal page level to get target leaf page\n\t */\n      b:\n\t/* unpin leftmost leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* get left most parent page */\n\tbtsp = btstack->top;\n\tparent = btsp - 1;\n\tbn = parent->bn;\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* scan parent pages at last internal page level */\n\twhile (pn >= p->header.nextindex) {\n\t\tpn -= p->header.nextindex;\n\n\t\t/* get next parent page address */\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin current parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next parent page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* update parent page stack frame */\n\t\tparent->bn = bn;\n\t}\n\n\t/* get leaf page address */\n\tstbl = DT_GETSTBL(p);\n\txd = (pxd_t *) & p->slot[stbl[pn]];\n\tbn = addressPXD(xd);\n\n\t/* unpin parent page */\n\tDT_PUTPAGE(mp);\n\n\t/*\n\t * get target leaf page\n\t */\n      c:\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * leaf page has been completed:\n\t * start with 1st entry of next leaf page\n\t */\n\tif (index >= p->header.nextindex) {\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next leaf page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = 0;\n\t}\n\n      out:\n\t/* return target leaf page pinned */\n\tbtsp = btstack->top;\n\tbtsp->bn = bn;\n\tbtsp->index = dtoffset->index;\n\tbtsp->mp = mp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtReadNext(struct inode *ip, loff_t * offset,\n\t\t      struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) offset;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\tint pn;\n\ts8 *stbl;\n\tstruct btframe *btsp, *parent;\n\tpxd_t *xd;\n\n\t/*\n\t * get leftmost leaf page pinned\n\t */\n\tif ((rc = dtReadFirst(ip, btstack)))\n\t\treturn rc;\n\n\t/* get leaf page */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/* get the start offset (pn:index) */\n\tpn = dtoffset->pn - 1;\t/* Now pn = 0 represents leftmost leaf */\n\tindex = dtoffset->index;\n\n\t/* start at leftmost page ? */\n\tif (pn == 0) {\n\t\t/* offset beyond eof ? */\n\t\tif (index < p->header.nextindex)\n\t\t\tgoto out;\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = index = 0;\n\t\tgoto a;\n\t}\n\n\t/* start at non-leftmost page: scan parent pages for large pn */\n\tif (p->header.flag & BT_ROOT) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\t/* start after next leaf page ? */\n\tif (pn > 1)\n\t\tgoto b;\n\n\t/* get leaf page pn = 1 */\n      a:\n\tbn = le64_to_cpu(p->header.next);\n\n\t/* unpin leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* offset beyond eof ? */\n\tif (bn == 0) {\n\t\tbn = -1;\n\t\tgoto out;\n\t}\n\n\tgoto c;\n\n\t/*\n\t * scan last internal page level to get target leaf page\n\t */\n      b:\n\t/* unpin leftmost leaf page */\n\tDT_PUTPAGE(mp);\n\n\t/* get left most parent page */\n\tbtsp = btstack->top;\n\tparent = btsp - 1;\n\tbn = parent->bn;\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* scan parent pages at last internal page level */\n\twhile (pn >= p->header.nextindex) {\n\t\tpn -= p->header.nextindex;\n\n\t\t/* get next parent page address */\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin current parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next parent page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* update parent page stack frame */\n\t\tparent->bn = bn;\n\t}\n\n\t/* get leaf page address */\n\tstbl = DT_GETSTBL(p);\n\txd = (pxd_t *) & p->slot[stbl[pn]];\n\tbn = addressPXD(xd);\n\n\t/* unpin parent page */\n\tDT_PUTPAGE(mp);\n\n\t/*\n\t * get target leaf page\n\t */\n      c:\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/*\n\t * leaf page has been completed:\n\t * start with 1st entry of next leaf page\n\t */\n\tif (index >= p->header.nextindex) {\n\t\tbn = le64_to_cpu(p->header.next);\n\n\t\t/* unpin leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* offset beyond eof ? */\n\t\tif (bn == 0) {\n\t\t\tbn = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* get next leaf page */\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* start with 1st entry of next leaf page */\n\t\tdtoffset->pn++;\n\t\tdtoffset->index = 0;\n\t}\n\n      out:\n\t/* return target leaf page pinned */\n\tbtsp = btstack->top;\n\tbtsp->bn = bn;\n\tbtsp->index = dtoffset->index;\n\tbtsp->mp = mp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtEmpty",
          "args": [
            "ip"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_readdir called with \"\n\t\t\t\t\t\"invalid offset!\""
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "PARENT(ip)",
            "DT_DIR"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARENT",
          "args": [
            "ip"
          ],
          "line": 3151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\".\"",
            "1",
            "ip->i_ino",
            "DT_DIR"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtReadFirst",
          "args": [
            "ip",
            "&btstack"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "dtReadFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3344-3403",
          "snippet": "static int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tint psize = 288;\t/* initial in-line directory */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tstruct btframe *btsp;\n\tpxd_t *xd;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend leftmost path of the tree\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * leftmost leaf page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/* return leftmost entry */\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = 0;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tjfs_error(ip->i_sb, \"btstack overrun\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, 0);\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\txd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(xd);\n\t\tpsize = lengthPXD(xd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtEmpty",
          "args": [
            "ip"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "PARENT(ip)",
            "DT_DIR"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARENT",
          "args": [
            "ip"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\".\"",
            "1",
            "ip->i_ino",
            "DT_DIR"
          ],
          "line": 3106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_readdir: bad index table\""
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressDTS",
          "args": [
            "&dirtab_slot"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"jfs_readdir detected \"\n\t\t\t\t\t\t   \"infinite loop!\""
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_index",
          "args": [
            "ip",
            "dir_index",
            "&dirtab_slot"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "549-567",
          "snippet": "static int read_index(struct inode *ip, u32 index,\n\t\t     struct dir_table_slot * dirtab_slot)\n{\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\tstruct dir_table_slot *slot;\n\n\tslot = find_index(ip, index, &mp, &lblock);\n\tif (!slot) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\n\n\tif (mp)\n\t\trelease_metapage(mp);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int read_index(struct inode *ip, u32 index,\n\t\t     struct dir_table_slot * dirtab_slot)\n{\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\tstruct dir_table_slot *slot;\n\n\tslot = find_index(ip, index, &mp, &lblock);\n\tif (!slot) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\n\n\tif (mp)\n\t\trelease_metapage(mp);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtEmpty",
          "args": [
            "ip"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);\n\nint jfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *ip = file_inode(file);\n\tstruct nls_table *codepage = JFS_SBI(ip->i_sb)->nls_tab;\n\tint rc = 0;\n\tloff_t dtpos;\t/* legacy OS/2 style position */\n\tstruct dtoffset {\n\t\ts16 pn;\n\t\ts16 index;\n\t\ts32 unused;\n\t} *dtoffset = (struct dtoffset *) &dtpos;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index;\n\ts8 *stbl;\n\tstruct btstack btstack;\n\tint i, next;\n\tstruct ldtentry *d;\n\tstruct dtslot *t;\n\tint d_namleft, len, outlen;\n\tunsigned long dirent_buf;\n\tchar *name_ptr;\n\tu32 dir_index;\n\tint do_index = 0;\n\tuint loop_count = 0;\n\tstruct jfs_dirent *jfs_dirent;\n\tint jfs_dirents;\n\tint overflow, fix_page, page_fixed = 0;\n\tstatic int unique_pos = 2;\t/* If we can't fix broken index */\n\n\tif (ctx->pos == DIREND)\n\t\treturn 0;\n\n\tif (DO_INDEX(ip)) {\n\t\t/*\n\t\t * persistent index is stored in directory entries.\n\t\t * Special cases:\t 0 = .\n\t\t *\t\t\t 1 = ..\n\t\t *\t\t\t-1 = End of directory\n\t\t */\n\t\tdo_index = 1;\n\n\t\tdir_index = (u32) ctx->pos;\n\n\t\t/*\n\t\t * NFSv4 reserves cookies 1 and 2 for . and .. so the value\n\t\t * we return to the vfs is one greater than the one we use\n\t\t * internally.\n\t\t */\n\t\tif (dir_index)\n\t\t\tdir_index--;\n\n\t\tif (dir_index > 1) {\n\t\t\tstruct dir_table_slot dirtab_slot;\n\n\t\t\tif (dtEmpty(ip) ||\n\t\t\t    (dir_index >= JFS_IP(ip)->next_index)) {\n\t\t\t\t/* Stale position.  Directory has shrunk */\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t      repeat:\n\t\t\trc = read_index(ip, dir_index, &dirtab_slot);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (dirtab_slot.flag == DIR_INDEX_FREE) {\n\t\t\t\tif (loop_count++ > JFS_IP(ip)->next_index) {\n\t\t\t\t\tjfs_err(\"jfs_readdir detected \"\n\t\t\t\t\t\t   \"infinite loop!\");\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tdir_index = le32_to_cpu(dirtab_slot.addr2);\n\t\t\t\tif (dir_index == -1) {\n\t\t\t\t\tctx->pos = DIREND;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tbn = addressDTS(&dirtab_slot);\n\t\t\tindex = dirtab_slot.slot;\n\t\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\t\tif (rc) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (p->header.flag & BT_INTERNAL) {\n\t\t\t\tjfs_err(\"jfs_readdir: bad index table\");\n\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dir_index == 0) {\n\t\t\t\t/*\n\t\t\t\t * self \".\"\n\t\t\t\t */\n\t\t\t\tctx->pos = 1;\n\t\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * parent \"..\"\n\t\t\t */\n\t\t\tctx->pos = 2;\n\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Find first entry of left-most leaf\n\t\t\t */\n\t\t\tif (dtEmpty(ip)) {\n\t\t\t\tctx->pos = DIREND;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ((rc = dtReadFirst(ip, &btstack)))\n\t\t\t\treturn rc;\n\n\t\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Legacy filesystem - OS/2 & Linux JFS < 0.3.6\n\t\t *\n\t\t * pn = 0; index = 1:\tFirst entry \".\"\n\t\t * pn = 0; index = 2:\tSecond entry \"..\"\n\t\t * pn > 0:\t\tReal entries, pn=1 -> leftmost page\n\t\t * pn = index = -1:\tNo more entries\n\t\t */\n\t\tdtpos = ctx->pos;\n\t\tif (dtpos < 2) {\n\t\t\t/* build \".\" entry */\n\t\t\tctx->pos = 1;\n\t\t\tif (!dir_emit(ctx, \".\", 1, ip->i_ino, DT_DIR))\n\t\t\t\treturn 0;\n\t\t\tdtoffset->index = 2;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtoffset->pn == 0) {\n\t\t\tif (dtoffset->index == 2) {\n\t\t\t\t/* build \"..\" entry */\n\t\t\t\tif (!dir_emit(ctx, \"..\", 2, PARENT(ip), DT_DIR))\n\t\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tjfs_err(\"jfs_readdir called with \"\n\t\t\t\t\t\"invalid offset!\");\n\t\t\t}\n\t\t\tdtoffset->pn = 1;\n\t\t\tdtoffset->index = 0;\n\t\t\tctx->pos = dtpos;\n\t\t}\n\n\t\tif (dtEmpty(ip)) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((rc = dtReadNext(ip, &ctx->pos, &btstack))) {\n\t\t\tjfs_err(\"jfs_readdir: unexpected rc = %d \"\n\t\t\t\t\"from dtReadNext\", rc);\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t\t/* get start leaf page and index */\n\t\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t\t/* offset beyond directory eof ? */\n\t\tif (bn < 0) {\n\t\t\tctx->pos = DIREND;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdirent_buf = __get_free_page(GFP_KERNEL);\n\tif (dirent_buf == 0) {\n\t\tDT_PUTPAGE(mp);\n\t\tjfs_warn(\"jfs_readdir: __get_free_page failed!\");\n\t\tctx->pos = DIREND;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (1) {\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\tjfs_dirents = 0;\n\t\toverflow = fix_page = 0;\n\n\t\tstbl = DT_GETSTBL(p);\n\n\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\td = (struct ldtentry *) & p->slot[stbl[i]];\n\n\t\t\tif (((long) jfs_dirent + d->namlen + 1) >\n\t\t\t    (dirent_buf + PAGE_SIZE)) {\n\t\t\t\t/* DBCS codepages could overrun dirent_buf */\n\t\t\t\tindex = i;\n\t\t\t\toverflow = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td_namleft = d->namlen;\n\t\t\tname_ptr = jfs_dirent->name;\n\t\t\tjfs_dirent->ino = le32_to_cpu(d->inumber);\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN);\n\t\t\t\tjfs_dirent->position = le32_to_cpu(d->index);\n\t\t\t\t/*\n\t\t\t\t * d->index should always be valid, but it\n\t\t\t\t * isn't.  fsck.jfs doesn't create the\n\t\t\t\t * directory index for the lost+found\n\t\t\t\t * directory.  Rather than let it go,\n\t\t\t\t * we can try to fix it.\n\t\t\t\t */\n\t\t\t\tif ((jfs_dirent->position < 2) ||\n\t\t\t\t    (jfs_dirent->position >=\n\t\t\t\t     JFS_IP(ip)->next_index)) {\n\t\t\t\t\tif (!page_fixed && !isReadOnly(ip)) {\n\t\t\t\t\t\tfix_page = 1;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * setting overflow and setting\n\t\t\t\t\t\t * index to i will cause the\n\t\t\t\t\t\t * same page to be processed\n\t\t\t\t\t\t * again starting here\n\t\t\t\t\t\t */\n\t\t\t\t\t\toverflow = 1;\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tjfs_dirent->position = unique_pos++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We add 1 to the index because we may\n\t\t\t\t * use a value of 2 internally, and NFSv4\n\t\t\t\t * doesn't like that.\n\t\t\t\t */\n\t\t\t\tjfs_dirent->position++;\n\t\t\t} else {\n\t\t\t\tjfs_dirent->position = dtpos;\n\t\t\t\tlen = min(d_namleft, DTLHDRDATALEN_LEGACY);\n\t\t\t}\n\n\t\t\t/* copy the name of head/only segment */\n\t\t\toutlen = jfs_strfromUCS_le(name_ptr, d->name, len,\n\t\t\t\t\t\t   codepage);\n\t\t\tjfs_dirent->name_len = outlen;\n\n\t\t\t/* copy name in the additional segment(s) */\n\t\t\tnext = d->next;\n\t\t\twhile (next >= 0) {\n\t\t\t\tt = (struct dtslot *) & p->slot[next];\n\t\t\t\tname_ptr += outlen;\n\t\t\t\td_namleft -= len;\n\t\t\t\t/* Sanity Check */\n\t\t\t\tif (d_namleft == 0) {\n\t\t\t\t\tjfs_error(ip->i_sb,\n\t\t\t\t\t\t  \"JFS:Dtree error: ino = %ld, bn=%lld, index = %d\\n\",\n\t\t\t\t\t\t  (long)ip->i_ino,\n\t\t\t\t\t\t  (long long)bn,\n\t\t\t\t\t\t  i);\n\t\t\t\t\tgoto skip_one;\n\t\t\t\t}\n\t\t\t\tlen = min(d_namleft, DTSLOTDATALEN);\n\t\t\t\toutlen = jfs_strfromUCS_le(name_ptr, t->name,\n\t\t\t\t\t\t\t   len, codepage);\n\t\t\t\tjfs_dirent->name_len += outlen;\n\n\t\t\t\tnext = t->next;\n\t\t\t}\n\n\t\t\tjfs_dirents++;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\nskip_one:\n\t\t\tif (!do_index)\n\t\t\t\tdtoffset->index++;\n\t\t}\n\n\t\tif (!overflow) {\n\t\t\t/* Point to next leaf page */\n\t\t\tif (p->header.flag & BT_ROOT)\n\t\t\t\tbn = 0;\n\t\t\telse {\n\t\t\t\tbn = le64_to_cpu(p->header.next);\n\t\t\t\tindex = 0;\n\t\t\t\t/* update offset (pn:index) for new page */\n\t\t\t\tif (!do_index) {\n\t\t\t\t\tdtoffset->pn++;\n\t\t\t\t\tdtoffset->index = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_fixed = 0;\n\t\t}\n\n\t\t/* unpin previous leaf page */\n\t\tDT_PUTPAGE(mp);\n\n\t\tjfs_dirent = (struct jfs_dirent *) dirent_buf;\n\t\twhile (jfs_dirents--) {\n\t\t\tctx->pos = jfs_dirent->position;\n\t\t\tif (!dir_emit(ctx, jfs_dirent->name,\n\t\t\t\t    jfs_dirent->name_len,\n\t\t\t\t    jfs_dirent->ino, DT_UNKNOWN))\n\t\t\t\tgoto out;\n\t\t\tjfs_dirent = next_jfs_dirent(jfs_dirent);\n\t\t}\n\n\t\tif (fix_page) {\n\t\t\tadd_missing_indices(ip, bn);\n\t\t\tpage_fixed = 1;\n\t\t}\n\n\t\tif (!overflow && (bn == 0)) {\n\t\t\tctx->pos = DIREND;\n\t\t\tbreak;\n\t\t}\n\n\t\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tfree_page(dirent_buf);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n      out:\n\tfree_page(dirent_buf);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "next_jfs_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2985-2992",
    "snippet": "static inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\n{\n\treturn (struct jfs_dirent *)\n\t\t((char *)dirent +\n\t\t ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\n\t\t   sizeof (loff_t) - 1) &\n\t\t  ~(sizeof (loff_t) - 1)));\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)\n{\n\treturn (struct jfs_dirent *)\n\t\t((char *)dirent +\n\t\t ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +\n\t\t   sizeof (loff_t) - 1) &\n\t\t  ~(sizeof (loff_t) - 1)));\n}"
  },
  {
    "function_name": "add_missing_indices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2918-2969",
    "snippet": "static void add_missing_indices(struct inode *inode, s64 bn)\n{\n\tstruct ldtentry *d;\n\tstruct dt_lock *dtlck;\n\tint i;\n\tuint index;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint rc;\n\ts8 *stbl;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\n\ttid = txBegin(inode->i_sb, 0);\n\n\tDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"DT_GETPAGE failed!\\n\");\n\t\tgoto end;\n\t}\n\tBT_MARK_DIRTY(mp, inode);\n\n\tASSERT(p->header.flag & BT_LEAF);\n\n\ttlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\n\tif (BT_IS_ROOT(mp))\n\t\ttlck->type |= tlckBTROOT;\n\n\tdtlck = (struct dt_lock *) &tlck->lock;\n\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\td = (struct ldtentry *) &p->slot[stbl[i]];\n\t\tindex = le32_to_cpu(d->index);\n\t\tif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\n\t\t\td->index = cpu_to_le32(add_index(tid, inode, bn, i));\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = &dtlck->lv[dtlck->index];\n\t\t\tlv->offset = stbl[i];\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\tDT_PUTPAGE(mp);\n\t(void) txCommit(tid, 1, &inode, 0);\nend:\n\ttxEnd(tid);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "txEnd",
          "args": [
            "tid"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "txEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "500-577",
          "snippet": "void txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nvoid txEnd(tid_t tid)\n{\n\tstruct tblock *tblk = tid_to_tblock(tid);\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txEnd: tid = %d\", tid);\n\tTXN_LOCK();\n\n\t/*\n\t * wakeup transactions waiting on the page locked\n\t * by the current transaction\n\t */\n\tTXN_WAKEUP(&tblk->waitor);\n\n\tlog = JFS_SBI(tblk->sb)->log;\n\n\t/*\n\t * Lazy commit thread can't free this guy until we mark it UNLOCKED,\n\t * otherwise, we would be left with a transaction that may have been\n\t * reused.\n\t *\n\t * Lazy commit thread will turn off tblkGC_LAZY before calling this\n\t * routine.\n\t */\n\tif (tblk->flag & tblkGC_LAZY) {\n\t\tjfs_info(\"txEnd called w/lazy tid: %d, tblk = 0x%p\", tid, tblk);\n\t\tTXN_UNLOCK();\n\n\t\tspin_lock_irq(&log->gclock);\t// LOGGC_LOCK\n\t\ttblk->flag |= tblkGC_UNLOCKED;\n\t\tspin_unlock_irq(&log->gclock);\t// LOGGC_UNLOCK\n\t\treturn;\n\t}\n\n\tjfs_info(\"txEnd: tid: %d, tblk = 0x%p\", tid, tblk);\n\n\tassert(tblk->next == 0);\n\n\t/*\n\t * insert tblock back on freelist\n\t */\n\ttblk->next = TxAnchor.freetid;\n\tTxAnchor.freetid = tid;\n\n\t/*\n\t * mark the tblock not active\n\t */\n\tif (--log->active == 0) {\n\t\tclear_bit(log_FLUSH, &log->flag);\n\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t\tTXN_UNLOCK();\n\n\t\t\t/* write dirty metadata & forward log syncpt */\n\t\t\tjfs_syncpt(log, 1);\n\n\t\t\tjfs_info(\"log barrier off: 0x%x\", log->lsn);\n\n\t\t\t/* enable new transactions start */\n\t\t\tclear_bit(log_SYNCBARRIER, &log->flag);\n\n\t\t\t/* wakeup all waitors for logsync barrier */\n\t\t\tTXN_WAKEUP(&log->syncwait);\n\n\t\t\tgoto wakeup;\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\nwakeup:\n\t/*\n\t * wakeup all waitors for a free tblock\n\t */\n\tTXN_WAKEUP(&TxAnchor.freewait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txCommit",
          "args": [
            "tid",
            "1",
            "&inode",
            "0"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "txCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1135-1368",
          "snippet": "int txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic int diLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck, struct commit * cd);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic int txLog(struct jfs_log * log, struct tblock * tblk,\n\t\tstruct commit * cd);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\nint txCommit(tid_t tid,\t\t/* transaction identifier */\n\t     int nip,\t\t/* number of inodes to commit */\n\t     struct inode **iplist,\t/* list of inode to commit */\n\t     int flag)\n{\n\tint rc = 0;\n\tstruct commit cd;\n\tstruct jfs_log *log;\n\tstruct tblock *tblk;\n\tstruct lrd *lrd;\n\tstruct inode *ip;\n\tstruct jfs_inode_info *jfs_ip;\n\tint k, n;\n\tino_t top;\n\tstruct super_block *sb;\n\n\tjfs_info(\"txCommit, tid = %d, flag = %d\", tid, flag);\n\t/* is read-only file system ? */\n\tif (isReadOnly(iplist[0])) {\n\t\trc = -EROFS;\n\t\tgoto TheEnd;\n\t}\n\n\tsb = cd.sb = iplist[0]->i_sb;\n\tcd.tid = tid;\n\n\tif (tid == 0)\n\t\ttid = txBegin(sb, 0);\n\ttblk = tid_to_tblock(tid);\n\n\t/*\n\t * initialize commit structure\n\t */\n\tlog = JFS_SBI(sb)->log;\n\tcd.log = log;\n\n\t/* initialize log record descriptor in commit */\n\tlrd = &cd.lrd;\n\tlrd->logtid = cpu_to_le32(tblk->logtid);\n\tlrd->backchain = 0;\n\n\ttblk->xflag |= flag;\n\n\tif ((flag & (COMMIT_FORCE | COMMIT_SYNC)) == 0)\n\t\ttblk->xflag |= COMMIT_LAZY;\n\t/*\n\t *\tprepare non-journaled objects for commit\n\t *\n\t * flush data pages of non-journaled file\n\t * to prevent the file getting non-initialized disk blocks\n\t * in case of crash.\n\t * (new blocks - )\n\t */\n\tcd.iplist = iplist;\n\tcd.nip = nip;\n\n\t/*\n\t *\tacquire transaction lock on (on-disk) inodes\n\t *\n\t * update on-disk inode from in-memory inode\n\t * acquiring transaction locks for AFTER records\n\t * on the on-disk inode of file object\n\t *\n\t * sort the inodes array by inode number in descending order\n\t * to prevent deadlock when acquiring transaction lock\n\t * of on-disk inodes on multiple on-disk inode pages by\n\t * multiple concurrent transactions\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\ttop = (cd.iplist[k])->i_ino;\n\t\tfor (n = k + 1; n < cd.nip; n++) {\n\t\t\tip = cd.iplist[n];\n\t\t\tif (ip->i_ino > top) {\n\t\t\t\ttop = ip->i_ino;\n\t\t\t\tcd.iplist[n] = cd.iplist[k];\n\t\t\t\tcd.iplist[k] = ip;\n\t\t\t}\n\t\t}\n\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * BUGBUG - This code has temporarily been removed.  The\n\t\t * intent is to ensure that any file data is written before\n\t\t * the metadata is committed to the journal.  This prevents\n\t\t * uninitialized data from appearing in a file after the\n\t\t * journal has been replayed.  (The uninitialized data\n\t\t * could be sensitive data removed by another user.)\n\t\t *\n\t\t * The problem now is that we are holding the IWRITELOCK\n\t\t * on the inode, and calling filemap_fdatawrite on an\n\t\t * unmapped page will cause a deadlock in jfs_get_block.\n\t\t *\n\t\t * The long term solution is to pare down the use of\n\t\t * IWRITELOCK.  We are currently holding it too long.\n\t\t * We could also be smarter about which data pages need\n\t\t * to be written before the transaction is committed and\n\t\t * when we don't need to worry about it at all.\n\t\t *\n\t\t * if ((!S_ISDIR(ip->i_mode))\n\t\t *    && (tblk->flag & COMMIT_DELETE) == 0)\n\t\t *\tfilemap_write_and_wait(ip->i_mapping);\n\t\t */\n\n\t\t/*\n\t\t * Mark inode as not dirty.  It will still be on the dirty\n\t\t * inode list, but we'll know not to commit it again unless\n\t\t * it gets marked dirty again\n\t\t */\n\t\tclear_cflag(COMMIT_Dirty, ip);\n\n\t\t/* inherit anonymous tlock(s) of inode */\n\t\tif (jfs_ip->atlhead) {\n\t\t\tlid_to_tlock(jfs_ip->atltail)->next = tblk->next;\n\t\t\ttblk->next = jfs_ip->atlhead;\n\t\t\tif (!tblk->last)\n\t\t\t\ttblk->last = jfs_ip->atltail;\n\t\t\tjfs_ip->atlhead = jfs_ip->atltail = 0;\n\t\t\tTXN_LOCK();\n\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\n\t\t/*\n\t\t * acquire transaction lock on on-disk inode page\n\t\t * (become first tlock of the tblk's tlock list)\n\t\t */\n\t\tif (((rc = diWrite(tid, ip))))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *\twrite log records from transaction locks\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif ((rc = txLog(log, tblk, &cd)))\n\t\tgoto TheEnd;\n\n\t/*\n\t * Ensure that inode isn't reused before\n\t * lazy commit thread finishes processing\n\t */\n\tif (tblk->xflag & COMMIT_DELETE) {\n\t\tihold(tblk->u.ip);\n\t\t/*\n\t\t * Avoid a rare deadlock\n\t\t *\n\t\t * If the inode is locked, we may be blocked in\n\t\t * jfs_commit_inode.  If so, we don't want the\n\t\t * lazy_commit thread doing the last iput() on the inode\n\t\t * since that may block on the locked inode.  Instead,\n\t\t * commit the transaction synchronously, so the last iput\n\t\t * will be done by the calling thread (or later)\n\t\t */\n\t\t/*\n\t\t * I believe this code is no longer needed.  Splitting I_LOCK\n\t\t * into two bits, I_NEW and I_SYNC should prevent this\n\t\t * deadlock as well.  But since I don't have a JFS testload\n\t\t * to verify this, only a trivial s/I_LOCK/I_SYNC/ was done.\n\t\t * Joern\n\t\t */\n\t\tif (tblk->u.ip->i_state & I_SYNC)\n\t\t\ttblk->xflag &= ~COMMIT_LAZY;\n\t}\n\n\tASSERT((!(tblk->xflag & COMMIT_DELETE)) ||\n\t       ((tblk->u.ip->i_nlink == 0) &&\n\t\t!test_cflag(COMMIT_Nolink, tblk->u.ip)));\n\n\t/*\n\t *\twrite COMMIT log record\n\t */\n\tlrd->type = cpu_to_le16(LOG_COMMIT);\n\tlrd->length = 0;\n\tlmLog(log, tblk, lrd, NULL);\n\n\tlmGroupCommit(log, tblk);\n\n\t/*\n\t *\t- transaction is now committed -\n\t */\n\n\t/*\n\t * force pages in careful update\n\t * (imap addressing structure update)\n\t */\n\tif (flag & COMMIT_FORCE)\n\t\ttxForce(tblk);\n\n\t/*\n\t *\tupdate allocation map.\n\t *\n\t * update inode allocation map and inode:\n\t * free pager lock on memory object of inode if any.\n\t * update block allocation map.\n\t *\n\t * txUpdateMap() resets XAD_NEW in XAD.\n\t */\n\tif (tblk->xflag & COMMIT_FORCE)\n\t\ttxUpdateMap(tblk);\n\n\t/*\n\t *\tfree transaction locks and pageout/free pages\n\t */\n\ttxRelease(tblk);\n\n\tif ((tblk->flag & tblkGC_LAZY) == 0)\n\t\ttxUnlock(tblk);\n\n\n\t/*\n\t *\treset in-memory object state\n\t */\n\tfor (k = 0; k < cd.nip; k++) {\n\t\tip = cd.iplist[k];\n\t\tjfs_ip = JFS_IP(ip);\n\n\t\t/*\n\t\t * reset in-memory inode state\n\t\t */\n\t\tjfs_ip->bxflag = 0;\n\t\tjfs_ip->blid = 0;\n\t}\n\n      out:\n\tif (rc != 0)\n\t\ttxAbort(tid, 1);\n\n      TheEnd:\n\tjfs_info(\"txCommit: tid = %d, returning %d\", tid, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "add_index(tid, inode, bn, i)"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_index",
          "args": [
            "tid",
            "inode",
            "bn",
            "i"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "add_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "334-489",
          "snippet": "static u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "inode"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "d->index"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_IS_ROOT",
          "args": [
            "mp"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "inode",
            "mp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "p->header.flag & BT_LEAF"
          ],
          "line": 2942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "inode"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"DT_GETPAGE failed!\\n\""
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "inode",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txBegin",
          "args": [
            "inode->i_sb",
            "0"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "txBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "361-447",
          "snippet": "tid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int TxLockVHWM;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int TxLockVHWM;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\n\ntid_t txBegin(struct super_block *sb, int flag)\n{\n\ttid_t t;\n\tstruct tblock *tblk;\n\tstruct jfs_log *log;\n\n\tjfs_info(\"txBegin: flag = 0x%x\", flag);\n\tlog = JFS_SBI(sb)->log;\n\n\tTXN_LOCK();\n\n\tINCREMENT(TxStat.txBegin);\n\n      retry:\n\tif (!(flag & COMMIT_FORCE)) {\n\t\t/*\n\t\t * synchronize with logsync barrier\n\t\t */\n\t\tif (test_bit(log_SYNCBARRIER, &log->flag) ||\n\t\t    test_bit(log_QUIESCE, &log->flag)) {\n\t\t\tINCREMENT(TxStat.txBegin_barrier);\n\t\t\tTXN_SLEEP(&log->syncwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\tif (flag == 0) {\n\t\t/*\n\t\t * Don't begin transaction if we're getting starved for tlocks\n\t\t * unless COMMIT_FORCE or COMMIT_INODE (which may ultimately\n\t\t * free tlocks)\n\t\t */\n\t\tif (TxAnchor.tlocksInUse > TxLockVHWM) {\n\t\t\tINCREMENT(TxStat.txBegin_lockslow);\n\t\t\tTXN_SLEEP(&TxAnchor.lowlockwait);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t/*\n\t * allocate transaction id/block\n\t */\n\tif ((t = TxAnchor.freetid) == 0) {\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\ttblk = tid_to_tblock(t);\n\n\tif ((tblk->next == 0) && !(flag & COMMIT_FORCE)) {\n\t\t/* Don't let a non-forced transaction take the last tblk */\n\t\tjfs_info(\"txBegin: waiting for free tid\");\n\t\tINCREMENT(TxStat.txBegin_freetid);\n\t\tTXN_SLEEP(&TxAnchor.freewait);\n\t\tgoto retry;\n\t}\n\n\tTxAnchor.freetid = tblk->next;\n\n\t/*\n\t * initialize transaction\n\t */\n\n\t/*\n\t * We can't zero the whole thing or we screw up another thread being\n\t * awakened after sleeping on tblk->waitor\n\t *\n\t * memset(tblk, 0, sizeof(struct tblock));\n\t */\n\ttblk->next = tblk->last = tblk->xflag = tblk->flag = tblk->lsn = 0;\n\n\ttblk->sb = sb;\n\t++log->logtid;\n\ttblk->logtid = log->logtid;\n\n\t++log->active;\n\n\tHIGHWATERMARK(stattx.maxtid, t);\t/* statistics */\n\tINCREMENT(stattx.ntid);\t/* statistics */\n\n\tTXN_UNLOCK();\n\n\tjfs_info(\"txBegin: returning tid = %d\", t);\n\n\treturn t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic void add_missing_indices(struct inode *inode, s64 bn)\n{\n\tstruct ldtentry *d;\n\tstruct dt_lock *dtlck;\n\tint i;\n\tuint index;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint rc;\n\ts8 *stbl;\n\ttid_t tid;\n\tstruct tlock *tlck;\n\n\ttid = txBegin(inode->i_sb, 0);\n\n\tDT_GETPAGE(inode, bn, mp, PSIZE, p, rc);\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"DT_GETPAGE failed!\\n\");\n\t\tgoto end;\n\t}\n\tBT_MARK_DIRTY(mp, inode);\n\n\tASSERT(p->header.flag & BT_LEAF);\n\n\ttlck = txLock(tid, inode, mp, tlckDTREE | tlckENTRY);\n\tif (BT_IS_ROOT(mp))\n\t\ttlck->type |= tlckBTROOT;\n\n\tdtlck = (struct dt_lock *) &tlck->lock;\n\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\td = (struct ldtentry *) &p->slot[stbl[i]];\n\t\tindex = le32_to_cpu(d->index);\n\t\tif ((index < 2) || (index >= JFS_IP(inode)->next_index)) {\n\t\t\td->index = cpu_to_le32(add_index(tid, inode, bn, i));\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = &dtlck->lv[dtlck->index];\n\t\t\tlv->offset = stbl[i];\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\t\t}\n\t}\n\n\tDT_PUTPAGE(mp);\n\t(void) txCommit(tid, 1, &inode, 0);\nend:\n\ttxEnd(tid);\n}"
  },
  {
    "function_name": "dtInitRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2826-2909",
    "snippet": "void dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "idotdot"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "(struct metapage *) & jfs_ip->bxflag",
            "tlckDTREE | tlckENTRY | tlckBTROOT"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Stale",
            "ip"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "tid",
            "ip",
            "0",
            "COMMIT_PWMAP"
          ],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_to_tblock",
          "args": [
            "tid"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_dirtable_inline",
          "args": [
            "ip"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_dirtable_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "212-215",
          "snippet": "static inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nvoid dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}"
  },
  {
    "function_name": "dtRelink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2747-2818",
    "snippet": "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\n{\n\tint rc;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the prev page\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.next = cpu_to_le64(nextbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nextbn"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\"",
            "tlck",
            "ip",
            "mp"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckRELINK"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "prevbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "prevbn"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\"",
            "tlck",
            "ip",
            "mp"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.prev"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\n{\n\tint rc;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the prev page\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.next = cpu_to_le64(nextbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtSearchNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2642-2733",
    "snippet": "static int dtSearchNode(struct inode *ip, s64 lmxaddr, pxd_t * kpxd,\n\t\t\tstruct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint psize = 288;\t/* initial in-line directory */\n\ts8 *stbl;\n\tint i;\n\tpxd_t *pxd;\n\tstruct btframe *btsp;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend tree to the level with specified leftmost page\n\t *\n\t *  by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* does the xaddr of leftmost page of the levevl\n\t\t * matches levevl search key ?\n\t\t */\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tif (lmxaddr == 0)\n\t\t\t\tbreak;\n\t\t} else if (addressPXD(&p->header.self) == lmxaddr)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\tpxd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t *\tsearch each page at the current levevl\n\t */\n      loop:\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\tpxd = (pxd_t *) & p->slot[stbl[i]];\n\n\t\t/* found the specified router entry */\n\t\tif (addressPXD(pxd) == addressPXD(kpxd) &&\n\t\t    lengthPXD(pxd) == lengthPXD(kpxd)) {\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = i;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* get the right sibling page if any */\n\tif (p->header.next)\n\t\tbn = le64_to_cpu(p->header.next);\n\telse {\n\t\tDT_PUTPAGE(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* unpin current page */\n\tDT_PUTPAGE(mp);\n\n\t/* get the right sibling page */\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tgoto loop;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.next"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "kpxd"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "kpxd"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "psize",
            "p",
            "rc"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "btstack"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtSearchNode(struct inode *ip, s64 lmxaddr, pxd_t * kpxd,\n\t\t\tstruct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint psize = 288;\t/* initial in-line directory */\n\ts8 *stbl;\n\tint i;\n\tpxd_t *pxd;\n\tstruct btframe *btsp;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend tree to the level with specified leftmost page\n\t *\n\t *  by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* does the xaddr of leftmost page of the levevl\n\t\t * matches levevl search key ?\n\t\t */\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tif (lmxaddr == 0)\n\t\t\t\tbreak;\n\t\t} else if (addressPXD(&p->header.self) == lmxaddr)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\tpxd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t *\tsearch each page at the current levevl\n\t */\n      loop:\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\tpxd = (pxd_t *) & p->slot[stbl[i]];\n\n\t\t/* found the specified router entry */\n\t\tif (addressPXD(pxd) == addressPXD(kpxd) &&\n\t\t    lengthPXD(pxd) == lengthPXD(kpxd)) {\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = i;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* get the right sibling page if any */\n\tif (p->header.next)\n\t\tbn = le64_to_cpu(p->header.next);\n\telse {\n\t\tDT_PUTPAGE(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* unpin current page */\n\tDT_PUTPAGE(mp);\n\n\t/* get the right sibling page */\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tgoto loop;\n}"
  },
  {
    "function_name": "dtRelocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2445-2629",
    "snippet": "int dtRelocate(tid_t tid, struct inode *ip, s64 lmxaddr, pxd_t * opxd,\n\t       s64 nxaddr)\n{\n\tint rc = 0;\n\tstruct metapage *mp, *pmp, *lmp, *rmp;\n\tdtpage_t *p, *pp, *rp = 0, *lp= 0;\n\ts64 bn;\n\tint index;\n\tstruct btstack btstack;\n\tpxd_t *pxd;\n\ts64 oxaddr, nextbn, prevbn;\n\tint xlen, xsize;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct pxd_lock *pxdlock;\n\ts8 *stbl;\n\tstruct lv *lv;\n\n\toxaddr = addressPXD(opxd);\n\txlen = lengthPXD(opxd);\n\n\tjfs_info(\"dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d\",\n\t\t   (long long)lmxaddr, (long long)oxaddr, (long long)nxaddr,\n\t\t   xlen);\n\n\t/*\n\t *\t1. get the internal parent dtpage covering\n\t *\trouter entry for the tartget page to be relocated;\n\t */\n\trc = dtSearchNode(ip, lmxaddr, opxd, &btstack);\n\tif (rc)\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\tjfs_info(\"dtRelocate: parent router entry validated.\");\n\n\t/*\n\t *\t2. relocate the target dtpage\n\t */\n\t/* read in the target page from src extent */\n\tDT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\n\tif (rc) {\n\t\t/* release the pinned parent page */\n\t\tDT_PUTPAGE(pmp);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * read in sibling pages if any to update sibling pointers;\n\t */\n\trmp = NULL;\n\tif (p->header.next) {\n\t\tnextbn = le64_to_cpu(p->header.next);\n\t\tDT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tDT_PUTPAGE(pmp);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\tlmp = NULL;\n\tif (p->header.prev) {\n\t\tprevbn = le64_to_cpu(p->header.prev);\n\t\tDT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tDT_PUTPAGE(pmp);\n\t\t\tif (rmp)\n\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* at this point, all xtpages to be updated are in memory */\n\n\t/*\n\t * update sibling pointers of sibling dtpages if any;\n\t */\n\tif (lmp) {\n\t\ttlck = txLock(tid, ip, lmp, tlckDTREE | tlckRELINK);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t/* linelock header */\n\t\tASSERT(dtlck->index == 0);\n\t\tlv = & dtlck->lv[0];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tlp->header.next = cpu_to_le64(nxaddr);\n\t\tDT_PUTPAGE(lmp);\n\t}\n\n\tif (rmp) {\n\t\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckRELINK);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t/* linelock header */\n\t\tASSERT(dtlck->index == 0);\n\t\tlv = & dtlck->lv[0];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\trp->header.prev = cpu_to_le64(nxaddr);\n\t\tDT_PUTPAGE(rmp);\n\t}\n\n\t/*\n\t * update the target dtpage to be relocated\n\t *\n\t * write LOG_REDOPAGE of LOG_NEW type for dst page\n\t * for the whole target page (logredo() will apply\n\t * after image and update bmap for allocation of the\n\t * dst extent), and update bmap for allocation of\n\t * the dst extent;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\t/* linelock header */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t/* update the self address in the dtpage header */\n\tpxd = &p->header.self;\n\tPXDaddress(pxd, nxaddr);\n\n\t/* the dst page is the same as the src page, i.e.,\n\t * linelock for afterimage of the whole page;\n\t */\n\tlv->offset = 0;\n\tlv->length = p->header.maxslot;\n\tdtlck->index++;\n\n\t/* update the buffer extent descriptor of the dtpage */\n\txsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* unpin the relocated page */\n\tDT_PUTPAGE(mp);\n\tjfs_info(\"dtRelocate: target dtpage relocated.\");\n\n\t/* the moved extent is dtpage, then a LOG_NOREDOPAGE log rec\n\t * needs to be written (in logredo(), the LOG_NOREDOPAGE log rec\n\t * will also force a bmap update ).\n\t */\n\n\t/*\n\t *\t3. acquire maplock for the source extent to be freed;\n\t */\n\t/* for dtpage relocation, write a LOG_NOREDOPAGE record\n\t * for the source dtpage (logredo() will init NoRedoPage\n\t * filter and will also update bmap for free of the source\n\t * dtpage), and upadte bmap for free of the source dtpage;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tPXDaddress(&pxdlock->pxd, oxaddr);\n\tPXDlength(&pxdlock->pxd, xlen);\n\tpxdlock->index = 1;\n\n\t/*\n\t *\t4. update the parent router entry for relocation;\n\t *\n\t * acquire tlck for the parent entry covering the target dtpage;\n\t * write LOG_REDOPAGE to apply after image only;\n\t */\n\tjfs_info(\"dtRelocate: update parent router entry.\");\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* update the PXD with the new address */\n\tstbl = DT_GETSTBL(pp);\n\tpxd = (pxd_t *) & pp->slot[stbl[index]];\n\tPXDaddress(pxd, nxaddr);\n\tlv->offset = stbl[index];\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* unpin the parent dtpage */\n\tDT_PUTPAGE(pmp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "nxaddr"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "pp"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "pmp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelocate: update parent router entry.\""
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "&pxdlock->pxd",
            "xlen"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckDTREE | tlckFREE"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelocate: target dtpage relocated.\""
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nxaddr"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "lmp"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nxaddr"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "prevbn",
            "lmp",
            "PSIZE",
            "lp",
            "rc"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.prev"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "rmp",
            "PSIZE",
            "rp",
            "rc"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "oxaddr",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelocate: parent router entry validated.\""
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "pmp",
            "pp",
            "index"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSearchNode",
          "args": [
            "ip",
            "lmxaddr",
            "opxd",
            "&btstack"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearchNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2642-2733",
          "snippet": "static int dtSearchNode(struct inode *ip, s64 lmxaddr, pxd_t * kpxd,\n\t\t\tstruct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint psize = 288;\t/* initial in-line directory */\n\ts8 *stbl;\n\tint i;\n\tpxd_t *pxd;\n\tstruct btframe *btsp;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend tree to the level with specified leftmost page\n\t *\n\t *  by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* does the xaddr of leftmost page of the levevl\n\t\t * matches levevl search key ?\n\t\t */\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tif (lmxaddr == 0)\n\t\t\t\tbreak;\n\t\t} else if (addressPXD(&p->header.self) == lmxaddr)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\tpxd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t *\tsearch each page at the current levevl\n\t */\n      loop:\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\tpxd = (pxd_t *) & p->slot[stbl[i]];\n\n\t\t/* found the specified router entry */\n\t\tif (addressPXD(pxd) == addressPXD(kpxd) &&\n\t\t    lengthPXD(pxd) == lengthPXD(kpxd)) {\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = i;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* get the right sibling page if any */\n\tif (p->header.next)\n\t\tbn = le64_to_cpu(p->header.next);\n\telse {\n\t\tDT_PUTPAGE(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* unpin current page */\n\tDT_PUTPAGE(mp);\n\n\t/* get the right sibling page */\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tgoto loop;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int dtSearchNode(struct inode *ip, s64 lmxaddr, pxd_t * kpxd,\n\t\t\tstruct btstack * btstack)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint psize = 288;\t/* initial in-line directory */\n\ts8 *stbl;\n\tint i;\n\tpxd_t *pxd;\n\tstruct btframe *btsp;\n\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/*\n\t *\tdescend tree to the level with specified leftmost page\n\t *\n\t *  by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/* does the xaddr of leftmost page of the levevl\n\t\t * matches levevl search key ?\n\t\t */\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tif (lmxaddr == 0)\n\t\t\t\tbreak;\n\t\t} else if (addressPXD(&p->header.self) == lmxaddr)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * descend down to leftmost child page\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -ESTALE;\n\t\t}\n\n\t\t/* get the leftmost entry */\n\t\tstbl = DT_GETSTBL(p);\n\t\tpxd = (pxd_t *) & p->slot[stbl[0]];\n\n\t\t/* get the child page block address */\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t *\tsearch each page at the current levevl\n\t */\n      loop:\n\tstbl = DT_GETSTBL(p);\n\tfor (i = 0; i < p->header.nextindex; i++) {\n\t\tpxd = (pxd_t *) & p->slot[stbl[i]];\n\n\t\t/* found the specified router entry */\n\t\tif (addressPXD(pxd) == addressPXD(kpxd) &&\n\t\t    lengthPXD(pxd) == lengthPXD(kpxd)) {\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = i;\n\t\t\tbtsp->mp = mp;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* get the right sibling page if any */\n\tif (p->header.next)\n\t\tbn = le64_to_cpu(p->header.next);\n\telse {\n\t\tDT_PUTPAGE(mp);\n\t\treturn -ESTALE;\n\t}\n\n\t/* unpin current page */\n\tDT_PUTPAGE(mp);\n\n\t/* get the right sibling page */\n\tDT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tgoto loop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d\"",
            "(long long)lmxaddr",
            "(long long)oxaddr",
            "(long long)nxaddr",
            "xlen"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "opxd"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "opxd"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nint dtRelocate(tid_t tid, struct inode *ip, s64 lmxaddr, pxd_t * opxd,\n\t       s64 nxaddr)\n{\n\tint rc = 0;\n\tstruct metapage *mp, *pmp, *lmp, *rmp;\n\tdtpage_t *p, *pp, *rp = 0, *lp= 0;\n\ts64 bn;\n\tint index;\n\tstruct btstack btstack;\n\tpxd_t *pxd;\n\ts64 oxaddr, nextbn, prevbn;\n\tint xlen, xsize;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct pxd_lock *pxdlock;\n\ts8 *stbl;\n\tstruct lv *lv;\n\n\toxaddr = addressPXD(opxd);\n\txlen = lengthPXD(opxd);\n\n\tjfs_info(\"dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d\",\n\t\t   (long long)lmxaddr, (long long)oxaddr, (long long)nxaddr,\n\t\t   xlen);\n\n\t/*\n\t *\t1. get the internal parent dtpage covering\n\t *\trouter entry for the tartget page to be relocated;\n\t */\n\trc = dtSearchNode(ip, lmxaddr, opxd, &btstack);\n\tif (rc)\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, pmp, pp, index);\n\tjfs_info(\"dtRelocate: parent router entry validated.\");\n\n\t/*\n\t *\t2. relocate the target dtpage\n\t */\n\t/* read in the target page from src extent */\n\tDT_GETPAGE(ip, oxaddr, mp, PSIZE, p, rc);\n\tif (rc) {\n\t\t/* release the pinned parent page */\n\t\tDT_PUTPAGE(pmp);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * read in sibling pages if any to update sibling pointers;\n\t */\n\trmp = NULL;\n\tif (p->header.next) {\n\t\tnextbn = le64_to_cpu(p->header.next);\n\t\tDT_GETPAGE(ip, nextbn, rmp, PSIZE, rp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tDT_PUTPAGE(pmp);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\tlmp = NULL;\n\tif (p->header.prev) {\n\t\tprevbn = le64_to_cpu(p->header.prev);\n\t\tDT_GETPAGE(ip, prevbn, lmp, PSIZE, lp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\tDT_PUTPAGE(pmp);\n\t\t\tif (rmp)\n\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* at this point, all xtpages to be updated are in memory */\n\n\t/*\n\t * update sibling pointers of sibling dtpages if any;\n\t */\n\tif (lmp) {\n\t\ttlck = txLock(tid, ip, lmp, tlckDTREE | tlckRELINK);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t/* linelock header */\n\t\tASSERT(dtlck->index == 0);\n\t\tlv = & dtlck->lv[0];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tlp->header.next = cpu_to_le64(nxaddr);\n\t\tDT_PUTPAGE(lmp);\n\t}\n\n\tif (rmp) {\n\t\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckRELINK);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t/* linelock header */\n\t\tASSERT(dtlck->index == 0);\n\t\tlv = & dtlck->lv[0];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\trp->header.prev = cpu_to_le64(nxaddr);\n\t\tDT_PUTPAGE(rmp);\n\t}\n\n\t/*\n\t * update the target dtpage to be relocated\n\t *\n\t * write LOG_REDOPAGE of LOG_NEW type for dst page\n\t * for the whole target page (logredo() will apply\n\t * after image and update bmap for allocation of the\n\t * dst extent), and update bmap for allocation of\n\t * the dst extent;\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\t/* linelock header */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t/* update the self address in the dtpage header */\n\tpxd = &p->header.self;\n\tPXDaddress(pxd, nxaddr);\n\n\t/* the dst page is the same as the src page, i.e.,\n\t * linelock for afterimage of the whole page;\n\t */\n\tlv->offset = 0;\n\tlv->length = p->header.maxslot;\n\tdtlck->index++;\n\n\t/* update the buffer extent descriptor of the dtpage */\n\txsize = xlen << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* unpin the relocated page */\n\tDT_PUTPAGE(mp);\n\tjfs_info(\"dtRelocate: target dtpage relocated.\");\n\n\t/* the moved extent is dtpage, then a LOG_NOREDOPAGE log rec\n\t * needs to be written (in logredo(), the LOG_NOREDOPAGE log rec\n\t * will also force a bmap update ).\n\t */\n\n\t/*\n\t *\t3. acquire maplock for the source extent to be freed;\n\t */\n\t/* for dtpage relocation, write a LOG_NOREDOPAGE record\n\t * for the source dtpage (logredo() will init NoRedoPage\n\t * filter and will also update bmap for free of the source\n\t * dtpage), and upadte bmap for free of the source dtpage;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tPXDaddress(&pxdlock->pxd, oxaddr);\n\tPXDlength(&pxdlock->pxd, xlen);\n\tpxdlock->index = 1;\n\n\t/*\n\t *\t4. update the parent router entry for relocation;\n\t *\n\t * acquire tlck for the parent entry covering the target dtpage;\n\t * write LOG_REDOPAGE to apply after image only;\n\t */\n\tjfs_info(\"dtRelocate: update parent router entry.\");\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* update the PXD with the new address */\n\tstbl = DT_GETSTBL(pp);\n\tpxd = (pxd_t *) & pp->slot[stbl[index]];\n\tPXDaddress(pxd, nxaddr);\n\tlv->offset = stbl[index];\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* unpin the parent dtpage */\n\tDT_PUTPAGE(pmp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dtDeleteUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2237-2436",
    "snippet": "static int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtTruncateEntry",
          "args": [
            "p",
            "0",
            "&dtlck"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "dtTruncateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4361-4435",
          "snippet": "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\n{\n\tint tsi;\t\t/* truncate entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint fsi, xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\ttsi = stbl[ti];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = tsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[tsi];\n\tASSERT(p->header.flag & BT_INTERNAL);\n\t((struct idtentry *) t)->namlen = 0;\n\tsi = ((struct idtentry *) t)->next;\n\t((struct idtentry *) t)->next = -1;\n\n\tn = 1;\n\tfreecnt = 0;\n\tfsi = si;\n\txsi = tsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tif (freecnt == 0)\n\t\treturn;\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock)\n{\n\tint tsi;\t\t/* truncate entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint fsi, xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\ttsi = stbl[ti];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = tsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[tsi];\n\tASSERT(p->header.flag & BT_INTERNAL);\n\t((struct idtentry *) t)->namlen = 0;\n\tsi = ((struct idtentry *) t)->next;\n\t((struct idtentry *) t)->next = -1;\n\n\tn = 1;\n\tfreecnt = 0;\n\tfsi = si;\n\txsi = tsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tif (freecnt == 0)\n\t\treturn;\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtDeleteEntry",
          "args": [
            "p",
            "index",
            "&dtlck"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4266-4347",
          "snippet": "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "xlen"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "&p->header.self"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtRelink",
          "args": [
            "tid",
            "ip",
            "p"
          ],
          "line": 2361
        },
        "resolved": true,
        "details": {
          "function_name": "dtRelink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2747-2818",
          "snippet": "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\n{\n\tint rc;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the prev page\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.next = cpu_to_le64(nextbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p)\n{\n\tint rc;\n\tstruct metapage *mp;\n\ts64 nextbn, prevbn;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\n\tnextbn = le64_to_cpu(p->header.next);\n\tprevbn = le64_to_cpu(p->header.prev);\n\n\t/* update prev pointer of the next page */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t *\n\t\t * action: update prev pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(prevbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/* update next pointer of the previous page */\n\tif (prevbn != 0) {\n\t\tDT_GETPAGE(ip, prevbn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the prev page\n\t\t *\n\t\t * action: update next pointer;\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.next = cpu_to_le64(nextbn);\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckDTREE | tlckFREE"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInitRoot",
          "args": [
            "tid",
            "ip",
            "PARENT(ip)"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "dtInitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2826-2909",
          "snippet": "void dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nvoid dtInitRoot(tid_t tid, struct inode *ip, u32 idotdot)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tdtroot_t *p;\n\tint fsi;\n\tstruct dtslot *f;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *lv;\n\tu16 xflag_save;\n\n\t/*\n\t * If this was previously an non-empty directory, we need to remove\n\t * the old directory table.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (!jfs_dirtable_inline(ip)) {\n\t\t\tstruct tblock *tblk = tid_to_tblock(tid);\n\t\t\t/*\n\t\t\t * We're playing games with the tid's xflag.  If\n\t\t\t * we're removing a regular file, the file's xtree\n\t\t\t * is committed with COMMIT_PMAP, but we always\n\t\t\t * commit the directories xtree with COMMIT_PWMAP.\n\t\t\t */\n\t\t\txflag_save = tblk->xflag;\n\t\t\ttblk->xflag = 0;\n\t\t\t/*\n\t\t\t * xtTruncate isn't guaranteed to fully truncate\n\t\t\t * the xtree.  The caller needs to check i_size\n\t\t\t * after committing the transaction to see if\n\t\t\t * additional truncation is needed.  The\n\t\t\t * COMMIT_Stale flag tells caller that we\n\t\t\t * initiated the truncation.\n\t\t\t */\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tset_cflag(COMMIT_Stale, ip);\n\n\t\t\ttblk->xflag = xflag_save;\n\t\t} else\n\t\t\tip->i_size = 1;\n\n\t\tjfs_ip->next_index = 2;\n\t} else\n\t\tip->i_size = IDATASIZE;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action: directory initialization;\n\t */\n\ttlck = txLock(tid, ip, (struct metapage *) & jfs_ip->bxflag,\n\t\t      tlckDTREE | tlckENTRY | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\tp = &jfs_ip->i_dtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\n\tp->header.nextindex = 0;\n\n\t/* init freelist */\n\tfsi = 1;\n\tf = &p->slot[fsi];\n\n\t/* init data area of root */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tp->header.freelist = 1;\n\tp->header.freecnt = 8;\n\n\t/* init '..' entry */\n\tp->header.idotdot = cpu_to_le32(idotdot);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PARENT",
          "args": [
            "ip"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "parent->bn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "btstack"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "xlen"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_PUTPAGE",
          "args": [
            "fmp"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "fmp"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PARENT",
          "args": [
            "ip"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_IS_ROOT",
          "args": [
            "fmp"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "2082-2224",
    "snippet": "int dtDelete(tid_t tid,\n\t struct inode *ip, struct component_name * key, ino_t * ino, int flag)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp, *imp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint i;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\tu32 table_index, next_index;\n\tstruct metapage *nmp;\n\tdtpage_t *np;\n\n\t/*\n\t *\tsearch for the entry to delete:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to delete).\n\t */\n\tif ((rc = dtSearch(ip, key, ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/*\n\t * We need to find put the index of the next entry into the\n\t * directory index table in order to resume a readdir from this\n\t * entry.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tstbl = DT_GETSTBL(p);\n\t\tldtentry = (struct ldtentry *) & p->slot[stbl[index]];\n\t\ttable_index = le32_to_cpu(ldtentry->index);\n\t\tif (index == (p->header.nextindex - 1)) {\n\t\t\t/*\n\t\t\t * Last entry in this leaf page\n\t\t\t */\n\t\t\tif ((p->header.flag & BT_ROOT)\n\t\t\t    || (p->header.next == 0))\n\t\t\t\tnext_index = -1;\n\t\t\telse {\n\t\t\t\t/* Read next leaf page */\n\t\t\t\tDT_GETPAGE(ip, le64_to_cpu(p->header.next),\n\t\t\t\t\t   nmp, PSIZE, np, rc);\n\t\t\t\tif (rc)\n\t\t\t\t\tnext_index = -1;\n\t\t\t\telse {\n\t\t\t\t\tstbl = DT_GETSTBL(np);\n\t\t\t\t\tldtentry =\n\t\t\t\t\t    (struct ldtentry *) & np->\n\t\t\t\t\t    slot[stbl[0]];\n\t\t\t\t\tnext_index =\n\t\t\t\t\t    le32_to_cpu(ldtentry->index);\n\t\t\t\t\tDT_PUTPAGE(nmp);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tldtentry =\n\t\t\t    (struct ldtentry *) & p->slot[stbl[index + 1]];\n\t\t\tnext_index = le32_to_cpu(ldtentry->index);\n\t\t}\n\t\tfree_index(tid, ip, table_index, next_index);\n\t}\n\t/*\n\t * the leaf page becomes empty, delete the page\n\t */\n\tif (p->header.nextindex == 1) {\n\t\t/* delete empty page */\n\t\trc = dtDeleteUp(tid, ip, mp, p, &btstack);\n\t}\n\t/*\n\t * the leaf page has other entries remaining:\n\t *\n\t * delete the entry from the leaf page.\n\t */\n\telse {\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/*\n\t\t * Do not assume that dtlck->index will be zero.  During a\n\t\t * rename within a directory, this transaction may have\n\t\t * modified this page already when adding the new entry.\n\t\t */\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = & dtlck->lv[dtlck->index];\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the leaf entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/*\n\t\t * Update directory index table for entries moved in stbl\n\t\t */\n\t\tif (DO_INDEX(ip) && index < p->header.nextindex) {\n\t\t\ts64 lblock;\n\n\t\t\timp = NULL;\n\t\t\tstbl = DT_GETSTBL(p);\n\t\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & p->slot[stbl[i]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     bn, i, &imp, &lblock);\n\t\t\t}\n\t\t\tif (imp)\n\t\t\t\trelease_metapage(imp);\n\t\t}\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "imp"
          ],
          "line": 2217
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_index",
          "args": [
            "tid",
            "ip",
            "le32_to_cpu(ldtentry->index)",
            "bn",
            "i",
            "&imp",
            "&lblock"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "modify_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "524-542",
          "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldtentry->index"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtDeleteEntry",
          "args": [
            "p",
            "index",
            "&dtlck"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4266-4347",
          "snippet": "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\ts8 *stbl;\n\tstruct dtslot *t;\n\tint si, freecnt;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tstbl = DT_GETSTBL(p);\n\tfsi = stbl[fi];\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\t/* get the head/only segment */\n\tt = &p->slot[fsi];\n\tif (p->header.flag & BT_LEAF)\n\t\tsi = ((struct ldtentry *) t)->next;\n\telse\n\t\tsi = ((struct idtentry *) t)->next;\n\tt->next = si;\n\tt->cnt = 1;\n\n\tn = freecnt = 1;\n\txsi = fsi;\n\n\t/* find the last/only segment */\n\twhile (si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\t\tfreecnt++;\n\n\t\tt = &p->slot[si];\n\t\tt->cnt = 1;\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* update freelist */\n\tt->next = p->header.freelist;\n\tp->header.freelist = fsi;\n\tp->header.freecnt += freecnt;\n\n\t/* if delete from middle,\n\t * shift left the succedding entries in the stbl\n\t */\n\tsi = p->header.nextindex;\n\tif (fi < si - 1)\n\t\tmemmove(&stbl[fi], &stbl[fi + 1], si - fi - 1);\n\n\tp->header.nextindex--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtDeleteUp",
          "args": [
            "tid",
            "ip",
            "mp",
            "p",
            "&btstack"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "dtDeleteUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "2237-2436",
          "snippet": "static int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtDeleteUp(tid_t tid, struct inode *ip,\n\t   struct metapage * fmp, dtpage_t * fp, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\tint index, nextindex;\n\tint xlen;\n\tstruct btframe *parent;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tstruct pxd_lock *pxdlock;\n\tint i;\n\n\t/*\n\t *\tkeep the root leaf page which has become empty\n\t */\n\tif (BT_IS_ROOT(fmp)) {\n\t\t/*\n\t\t * reset the root\n\t\t *\n\t\t * dtInitRoot() acquires txlock on the root\n\t\t */\n\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\tDT_PUTPAGE(fmp);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tfree the non-root leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the page\n\t *\n\t * write FREEXTENT|NOREDOPAGE log record\n\t * N.B. linelock is overlaid as freed extent descriptor, and\n\t * the buffer page is freed;\n\t */\n\ttlck = txMaplock(tid, ip, tlckDTREE | tlckFREE);\n\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\tpxdlock->flag = mlckFREEPXD;\n\tpxdlock->pxd = fp->header.self;\n\tpxdlock->index = 1;\n\n\t/* update sibling pointers */\n\tif ((rc = dtRelink(tid, ip, fp))) {\n\t\tBT_PUTPAGE(fmp);\n\t\treturn rc;\n\t}\n\n\txlen = lengthPXD(&fp->header.self);\n\n\t/* Free quota allocation. */\n\tdquot_free_block(ip, xlen);\n\n\t/* free/invalidate its buffer page */\n\tdiscard_metapage(fmp);\n\n\t/*\n\t *\tpropagate page deletion up the directory tree\n\t *\n\t * If the delete from the parent page makes it empty,\n\t * continue all the way up the tree.\n\t * stop if the root page is reached (which is never deleted) or\n\t * if the entry deletion does not empty the page.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* pin the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, mp, PSIZE, p, rc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t/*\n\t\t * free the extent of the child page deleted\n\t\t */\n\t\tindex = parent->index;\n\n\t\t/*\n\t\t * delete the entry for the child page from parent\n\t\t */\n\t\tnextindex = p->header.nextindex;\n\n\t\t/*\n\t\t * the parent has the single entry being deleted:\n\t\t *\n\t\t * free the parent page which has become empty.\n\t\t */\n\t\tif (nextindex == 1) {\n\t\t\t/*\n\t\t\t * keep the root internal page which has become empty\n\t\t\t */\n\t\t\tif (p->header.flag & BT_ROOT) {\n\t\t\t\t/*\n\t\t\t\t * reset the root\n\t\t\t\t *\n\t\t\t\t * dtInitRoot() acquires txlock on the root\n\t\t\t\t */\n\t\t\t\tdtInitRoot(tid, ip, PARENT(ip));\n\n\t\t\t\tDT_PUTPAGE(mp);\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * free the parent page\n\t\t\t */\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * acquire a transaction lock on the page\n\t\t\t\t *\n\t\t\t\t * write FREEXTENT|NOREDOPAGE log record\n\t\t\t\t */\n\t\t\t\ttlck =\n\t\t\t\t    txMaplock(tid, ip,\n\t\t\t\t\t      tlckDTREE | tlckFREE);\n\t\t\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tpxdlock->pxd = p->header.self;\n\t\t\t\tpxdlock->index = 1;\n\n\t\t\t\t/* update sibling pointers */\n\t\t\t\tif ((rc = dtRelink(tid, ip, p))) {\n\t\t\t\t\tDT_PUTPAGE(mp);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\txlen = lengthPXD(&p->header.self);\n\n\t\t\t\t/* Free quota allocation */\n\t\t\t\tdquot_free_block(ip, xlen);\n\n\t\t\t\t/* free/invalidate its buffer page */\n\t\t\t\tdiscard_metapage(mp);\n\n\t\t\t\t/* propagate up */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * the parent has other entries remaining:\n\t\t *\n\t\t * delete the router entry from the parent page.\n\t\t */\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the page\n\t\t *\n\t\t * action: router entry deletion\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the router entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/* reset key of new leftmost entry of level (for consistency) */\n\t\tif (index == 0 &&\n\t\t    ((p->header.flag & BT_ROOT) || p->header.prev == 0))\n\t\t\tdtTruncateEntry(p, 0, &dtlck);\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\n\t\t/* exit propagation up */\n\t\tbreak;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size -= PSIZE;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_index",
          "args": [
            "tid",
            "ip",
            "table_index",
            "next_index"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "free_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "496-517",
          "snippet": "static void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\n\tdirtab_slot = find_index(ip, index, &mp, &lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tdirtab_slot->flag = DIR_INDEX_FREE;\n\tdirtab_slot->slot = dirtab_slot->addr1 = 0;\n\tdirtab_slot->addr2 = cpu_to_le32(next);\n\n\tif (mp) {\n\t\tlock_index(tid, ip, mp, index);\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\n\tdirtab_slot = find_index(ip, index, &mp, &lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tdirtab_slot->flag = DIR_INDEX_FREE;\n\tdirtab_slot->slot = dirtab_slot->addr1 = 0;\n\tdirtab_slot->addr2 = cpu_to_le32(next);\n\n\tif (mp) {\n\t\tlock_index(tid, ip, mp, index);\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "nmp"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "np"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "le64_to_cpu(p->header.next)",
            "nmp",
            "PSIZE",
            "np",
            "rc"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->header.next"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack.top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSearch",
          "args": [
            "ip",
            "key",
            "ino",
            "&btstack",
            "flag"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "dtSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "580-808",
          "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nint dtDelete(tid_t tid,\n\t struct inode *ip, struct component_name * key, ino_t * ino, int flag)\n{\n\tint rc = 0;\n\ts64 bn;\n\tstruct metapage *mp, *imp;\n\tdtpage_t *p;\n\tint index;\n\tstruct btstack btstack;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint i;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\tu32 table_index, next_index;\n\tstruct metapage *nmp;\n\tdtpage_t *np;\n\n\t/*\n\t *\tsearch for the entry to delete:\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to delete).\n\t */\n\tif ((rc = dtSearch(ip, key, ino, &btstack, flag)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tDT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/*\n\t * We need to find put the index of the next entry into the\n\t * directory index table in order to resume a readdir from this\n\t * entry.\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tstbl = DT_GETSTBL(p);\n\t\tldtentry = (struct ldtentry *) & p->slot[stbl[index]];\n\t\ttable_index = le32_to_cpu(ldtentry->index);\n\t\tif (index == (p->header.nextindex - 1)) {\n\t\t\t/*\n\t\t\t * Last entry in this leaf page\n\t\t\t */\n\t\t\tif ((p->header.flag & BT_ROOT)\n\t\t\t    || (p->header.next == 0))\n\t\t\t\tnext_index = -1;\n\t\t\telse {\n\t\t\t\t/* Read next leaf page */\n\t\t\t\tDT_GETPAGE(ip, le64_to_cpu(p->header.next),\n\t\t\t\t\t   nmp, PSIZE, np, rc);\n\t\t\t\tif (rc)\n\t\t\t\t\tnext_index = -1;\n\t\t\t\telse {\n\t\t\t\t\tstbl = DT_GETSTBL(np);\n\t\t\t\t\tldtentry =\n\t\t\t\t\t    (struct ldtentry *) & np->\n\t\t\t\t\t    slot[stbl[0]];\n\t\t\t\t\tnext_index =\n\t\t\t\t\t    le32_to_cpu(ldtentry->index);\n\t\t\t\t\tDT_PUTPAGE(nmp);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tldtentry =\n\t\t\t    (struct ldtentry *) & p->slot[stbl[index + 1]];\n\t\t\tnext_index = le32_to_cpu(ldtentry->index);\n\t\t}\n\t\tfree_index(tid, ip, table_index, next_index);\n\t}\n\t/*\n\t * the leaf page becomes empty, delete the page\n\t */\n\tif (p->header.nextindex == 1) {\n\t\t/* delete empty page */\n\t\trc = dtDeleteUp(tid, ip, mp, p, &btstack);\n\t}\n\t/*\n\t * the leaf page has other entries remaining:\n\t *\n\t * delete the entry from the leaf page.\n\t */\n\telse {\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the leaf page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/*\n\t\t * Do not assume that dtlck->index will be zero.  During a\n\t\t * rename within a directory, this transaction may have\n\t\t * modified this page already when adding the new entry.\n\t\t */\n\n\t\t/* linelock header */\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\t/* linelock stbl of non-root leaf page */\n\t\tif (!(p->header.flag & BT_ROOT)) {\n\t\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\tlv = & dtlck->lv[dtlck->index];\n\t\t\ti = index >> L2DTSLOTSIZE;\n\t\t\tlv->offset = p->header.stblindex + i;\n\t\t\tlv->length =\n\t\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) -\n\t\t\t    i + 1;\n\t\t\tdtlck->index++;\n\t\t}\n\n\t\t/* free the leaf entry */\n\t\tdtDeleteEntry(p, index, &dtlck);\n\n\t\t/*\n\t\t * Update directory index table for entries moved in stbl\n\t\t */\n\t\tif (DO_INDEX(ip) && index < p->header.nextindex) {\n\t\t\ts64 lblock;\n\n\t\t\timp = NULL;\n\t\t\tstbl = DT_GETSTBL(p);\n\t\t\tfor (i = index; i < p->header.nextindex; i++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & p->slot[stbl[i]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     bn, i, &imp, &lblock);\n\t\t\t}\n\t\t\tif (imp)\n\t\t\t\trelease_metapage(imp);\n\t\t}\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dtSplitRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "1875-2070",
    "snippet": "static int dtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct metapage *smp;\n\tdtroot_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\n\ts64 rbn;\n\tint xlen;\n\tint xsize;\n\tstruct dtslot *f;\n\ts8 *stbl;\n\tint fsi, stblsize, n;\n\tstruct idtentry *s;\n\tpxd_t *ppxd;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint rc;\n\n\t/* get split root page */\n\tsmp = split->mp;\n\tsp = &JFS_IP(ip)->i_dtroot;\n\n\t/*\n\t *\tallocate/initialize a single (right) child page\n\t *\n\t * N.B. at first split, a one (or two) block to fit new entry\n\t * is allocated; at subsequent split, a full page is allocated;\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\trmp = get_metapage(ip, rbn, xsize, 1);\n\tif (!rmp)\n\t\treturn -EIO;\n\n\trp = rmp->data;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t *\tmove in-line root page into new right page extent\n\t */\n\t/* linelock header + copied entries + new stbl (1st slot) in new page */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = 10;\t/* 1 + 8 + 1 */\n\tdtlck->index++;\n\n\tn = xsize >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\n\n\t/* copy old stbl to new stbl at start of extended area */\n\trp->header.stblindex = DTROOTMAXSLOT;\n\tstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\n\tmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\n\trp->header.nextindex = sp->header.nextindex;\n\n\t/* copy old data area to start of new data area */\n\tmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = DTROOTMAXSLOT + stblsize;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\trp->header.freelist = n;\n\telse {\n\t\trp->header.freelist = fsi;\n\n\t\tdo {\n\t\t\tf = &rp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\trp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\t\tstruct metapage *mp = NULL;\n\t\tstruct ldtentry *ldtentry;\n\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tdtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\n\n\t/*\n\t *\treset parent/root page\n\t *\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t *\n\t * The btree comparison code guarantees that the left-most key on any\n\t * level of the tree is never used, so it doesn't need to be filled in.\n\t */\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode)\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\t/* update page header of root */\n\tif (sp->header.flag & BT_LEAF) {\n\t\tsp->header.flag &= ~BT_LEAF;\n\t\tsp->header.flag |= BT_INTERNAL;\n\t}\n\n\t/* init the first entry */\n\ts = (struct idtentry *) & sp->slot[DTENTRYSTART];\n\tppxd = (pxd_t *) s;\n\t*ppxd = *pxd;\n\ts->next = -1;\n\ts->namlen = 0;\n\n\tstbl = sp->header.stbl;\n\tstbl[0] = DTENTRYSTART;\n\tsp->header.nextindex = 1;\n\n\t/* init freelist */\n\tfsi = DTENTRYSTART + 1;\n\tf = &sp->slot[fsi];\n\n\t/* init free region of remaining area */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tsp->header.freelist = DTENTRYSTART + 1;\n\tsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\n\n\t*rmpp = rmp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "smp",
            "tlckDTREE | tlckNEW | tlckBTROOT"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsertEntry",
          "args": [
            "rp",
            "split->index",
            "split->key",
            "split->data",
            "&dtlck"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_index",
          "args": [
            "tid",
            "ip",
            "le32_to_cpu(ldtentry->index)",
            "rbn",
            "n",
            "&mp",
            "&lblock"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "modify_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "524-542",
          "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldtentry->index"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "rp"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rp->slot[1]",
            "&sp->slot[1]",
            "IDATASIZE"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stbl",
            "sp->header.stbl",
            "sp->header.nextindex"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "rmp",
            "ip"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "lengthPXD(pxd)"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "rbn",
            "xsize",
            "1"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct metapage *smp;\n\tdtroot_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\n\ts64 rbn;\n\tint xlen;\n\tint xsize;\n\tstruct dtslot *f;\n\ts8 *stbl;\n\tint fsi, stblsize, n;\n\tstruct idtentry *s;\n\tpxd_t *ppxd;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint rc;\n\n\t/* get split root page */\n\tsmp = split->mp;\n\tsp = &JFS_IP(ip)->i_dtroot;\n\n\t/*\n\t *\tallocate/initialize a single (right) child page\n\t *\n\t * N.B. at first split, a one (or two) block to fit new entry\n\t * is allocated; at subsequent split, a full page is allocated;\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\trmp = get_metapage(ip, rbn, xsize, 1);\n\tif (!rmp)\n\t\treturn -EIO;\n\n\trp = rmp->data;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t *\tmove in-line root page into new right page extent\n\t */\n\t/* linelock header + copied entries + new stbl (1st slot) in new page */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = 10;\t/* 1 + 8 + 1 */\n\tdtlck->index++;\n\n\tn = xsize >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\n\n\t/* copy old stbl to new stbl at start of extended area */\n\trp->header.stblindex = DTROOTMAXSLOT;\n\tstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\n\tmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\n\trp->header.nextindex = sp->header.nextindex;\n\n\t/* copy old data area to start of new data area */\n\tmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = DTROOTMAXSLOT + stblsize;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\trp->header.freelist = n;\n\telse {\n\t\trp->header.freelist = fsi;\n\n\t\tdo {\n\t\t\tf = &rp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\trp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\t\tstruct metapage *mp = NULL;\n\t\tstruct ldtentry *ldtentry;\n\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tdtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\n\n\t/*\n\t *\treset parent/root page\n\t *\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t *\n\t * The btree comparison code guarantees that the left-most key on any\n\t * level of the tree is never used, so it doesn't need to be filled in.\n\t */\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode)\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\t/* update page header of root */\n\tif (sp->header.flag & BT_LEAF) {\n\t\tsp->header.flag &= ~BT_LEAF;\n\t\tsp->header.flag |= BT_INTERNAL;\n\t}\n\n\t/* init the first entry */\n\ts = (struct idtentry *) & sp->slot[DTENTRYSTART];\n\tppxd = (pxd_t *) s;\n\t*ppxd = *pxd;\n\ts->next = -1;\n\ts->namlen = 0;\n\n\tstbl = sp->header.stbl;\n\tstbl[0] = DTENTRYSTART;\n\tsp->header.nextindex = 1;\n\n\t/* init freelist */\n\tfsi = DTENTRYSTART + 1;\n\tf = &sp->slot[fsi];\n\n\t/* init free region of remaining area */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tsp->header.freelist = DTENTRYSTART + 1;\n\tsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\n\n\t*rmpp = rmp;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtExtendPage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "1642-1854",
    "snippet": "static int dtExtendPage(tid_t tid,\n\t     struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint rc;\n\tstruct metapage *smp, *pmp, *mp;\n\tdtpage_t *sp, *pp;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd, *tpxd;\n\tint xlen, xsize;\n\tint newstblindex, newstblsize;\n\tint oldstblindex, oldstblsize;\n\tint fsi, last;\n\tstruct dtslot *f;\n\tstruct btframe *parent;\n\tint n;\n\tstruct dt_lock *dtlck;\n\ts64 xaddr, txaddr;\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\tstruct lv *lv;\n\tuint type;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\n\t/* get page to extend */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/* get parent/root page */\n\tparent = BT_POP(btstack);\n\tDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\n\tif (rc)\n\t\treturn (rc);\n\n\t/*\n\t *\textend the extent\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\n\txaddr = addressPXD(pxd);\n\ttpxd = &sp->header.self;\n\ttxaddr = addressPXD(tpxd);\n\t/* in-place extension */\n\tif (xaddr == txaddr) {\n\t\ttype = tlckEXTEND;\n\t}\n\t/* relocation */\n\telse {\n\t\ttype = tlckNEW;\n\n\t\t/* save moved extent descriptor for later free */\n\t\ttlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tpxdlock->pxd = sp->header.self;\n\t\tpxdlock->index = 1;\n\n\t\t/*\n\t\t * Update directory index table to reflect new page address\n\t\t */\n\t\tif (DO_INDEX(ip)) {\n\t\t\ts64 lblock;\n\n\t\t\tmp = NULL;\n\t\t\tstbl = DT_GETSTBL(sp);\n\t\t\tfor (n = 0; n < sp->header.nextindex; n++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & sp->slot[stbl[n]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     xaddr, n, &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t *\textend the page\n\t */\n\tsp->header.self = *pxd;\n\n\tjfs_info(\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\", ip, smp, sp);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the extended/leaf page\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | type);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[0];\n\n\t/* update buffer extent descriptor of extended page */\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\n\t/*\n\t * copy old stbl to new stbl at start of extended area\n\t */\n\toldstblindex = sp->header.stblindex;\n\toldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\n\tnewstblindex = sp->header.maxslot;\n\tn = xsize >> L2DTSLOTSIZE;\n\tnewstblsize = (n + 31) >> L2DTSLOTSIZE;\n\tmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\n\t       sp->header.nextindex);\n\n\t/*\n\t * in-line extension: linelock old area of extended page\n\t */\n\tif (type == tlckEXTEND) {\n\t\t/* linelock header */\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\t\tlv++;\n\n\t\t/* linelock new stbl of extended page */\n\t\tlv->offset = newstblindex;\n\t\tlv->length = newstblsize;\n\t}\n\t/*\n\t * relocation: linelock whole relocated area\n\t */\n\telse {\n\t\tlv->offset = 0;\n\t\tlv->length = sp->header.maxslot + newstblsize;\n\t}\n\n\tdtlck->index++;\n\n\tsp->header.maxslot = n;\n\tsp->header.stblindex = newstblindex;\n\t/* sp->header.nextindex remains the same */\n\n\t/*\n\t * add old stbl region at head of freelist\n\t */\n\tfsi = oldstblindex;\n\tf = &sp->slot[fsi];\n\tlast = sp->header.freelist;\n\tfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\n\t\tf->next = last;\n\t\tlast = fsi;\n\t}\n\tsp->header.freelist = last;\n\tsp->header.freecnt += oldstblsize;\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = newstblindex + newstblsize;\n\tf = &sp->slot[fsi];\n\tfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\tsp->header.freelist = n;\n\telse {\n\t\tdo {\n\t\t\tf = &sp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\tsp->header.freecnt += sp->header.maxslot - n;\n\n\t/*\n\t * insert the new entry\n\t */\n\tdtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\n\n\tBT_MARK_DIRTY(pmp, ip);\n\t/*\n\t * linelock any freeslots residing in old extent\n\t */\n\tif (type == tlckEXTEND) {\n\t\tn = sp->header.maxslot >> 2;\n\t\tif (sp->header.freelist < n)\n\t\t\tdtLinelockFreelist(sp, n, &dtlck);\n\t}\n\n\t/*\n\t *\tupdate parent entry on the parent/root page\n\t */\n\t/*\n\t * acquire a transaction lock on the parent/root page\n\t */\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* linelock parent entry - 1st slot */\n\tlv->offset = 1;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* update the parent pxd for page extension */\n\ttpxd = (pxd_t *) & pp->slot[1];\n\t*tpxd = *pxd;\n\n\tDT_PUTPAGE(pmp);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "pmp"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "pmp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtLinelockFreelist",
          "args": [
            "sp",
            "n",
            "&dtlck"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "dtLinelockFreelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4441-4500",
          "snippet": "static void dtLinelockFreelist(dtpage_t * p,\t/* directory page */\n\t\t\t       int m,\t/* max slot index */\n\t\t\t       struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\tstruct dtslot *t;\n\tint si;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tfsi = p->header.freelist;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\tn = 1;\n\txsi = fsi;\n\n\tt = &p->slot[fsi];\n\tsi = t->next;\n\n\t/* find the last/only segment */\n\twhile (si < m && si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\n\t\tt = &p->slot[si];\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtLinelockFreelist(dtpage_t * p,\t/* directory page */\n\t\t\t       int m,\t/* max slot index */\n\t\t\t       struct dt_lock ** dtlock)\n{\n\tint fsi;\t\t/* free entry slot index */\n\tstruct dtslot *t;\n\tint si;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\n\t/* get free entry slot index */\n\tfsi = p->header.freelist;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\tlv = & dtlck->lv[dtlck->index];\n\n\tlv->offset = fsi;\n\n\tn = 1;\n\txsi = fsi;\n\n\tt = &p->slot[fsi];\n\tsi = t->next;\n\n\t/* find the last/only segment */\n\twhile (si < m && si >= 0) {\n\t\t/* is next slot contiguous ? */\n\t\tif (si != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = si;\n\t\t\tn = 0;\n\t\t}\n\n\t\tn++;\n\t\txsi = si;\n\n\t\tt = &p->slot[si];\n\t\tsi = t->next;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "pmp",
            "ip"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsertEntry",
          "args": [
            "sp",
            "split->index",
            "split->key",
            "split->data",
            "&dtlck"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sp->slot[newstblindex]",
            "&sp->slot[oldstblindex]",
            "sp->header.nextindex"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\"",
            "ip",
            "smp",
            "sp"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_index",
          "args": [
            "tid",
            "ip",
            "le32_to_cpu(ldtentry->index)",
            "xaddr",
            "n",
            "&mp",
            "&lblock"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "modify_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "524-542",
          "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldtentry->index"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "sp"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txMaplock",
          "args": [
            "tid",
            "ip",
            "tlckDTREE | tlckRELOCATE"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "txMaplock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "995-1061",
          "snippet": "struct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txMaplock(tid_t tid, struct inode *ip, int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tlid_t lid;\n\tstruct tblock *tblk;\n\tstruct tlock *tlck;\n\tstruct maplock *maplock;\n\n\tTXN_LOCK();\n\n\t/*\n\t * allocate a tlock\n\t */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\t/* bind the tlock and the object */\n\ttlck->flag = tlckINODELOCK;\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\ttlck->ip = ip;\n\ttlck->mp = NULL;\n\n\ttlck->type = type;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t}\n\t}\n\n\tTXN_UNLOCK();\n\n\t/* initialize type dependent area for maplock */\n\tmaplock = (struct maplock *) & tlck->lock;\n\tmaplock->next = 0;\n\tmaplock->maxcnt = 0;\n\tmaplock->index = 0;\n\n\treturn tlck;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "tpxd"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "parent->bn",
            "pmp",
            "PSIZE",
            "pp",
            "rc"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "btstack"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PAGE",
          "args": [
            "ip",
            "smp"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtExtendPage(tid_t tid,\n\t     struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint rc;\n\tstruct metapage *smp, *pmp, *mp;\n\tdtpage_t *sp, *pp;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd, *tpxd;\n\tint xlen, xsize;\n\tint newstblindex, newstblsize;\n\tint oldstblindex, oldstblsize;\n\tint fsi, last;\n\tstruct dtslot *f;\n\tstruct btframe *parent;\n\tint n;\n\tstruct dt_lock *dtlck;\n\ts64 xaddr, txaddr;\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\tstruct lv *lv;\n\tuint type;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\n\t/* get page to extend */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/* get parent/root page */\n\tparent = BT_POP(btstack);\n\tDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\n\tif (rc)\n\t\treturn (rc);\n\n\t/*\n\t *\textend the extent\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\n\txaddr = addressPXD(pxd);\n\ttpxd = &sp->header.self;\n\ttxaddr = addressPXD(tpxd);\n\t/* in-place extension */\n\tif (xaddr == txaddr) {\n\t\ttype = tlckEXTEND;\n\t}\n\t/* relocation */\n\telse {\n\t\ttype = tlckNEW;\n\n\t\t/* save moved extent descriptor for later free */\n\t\ttlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tpxdlock->pxd = sp->header.self;\n\t\tpxdlock->index = 1;\n\n\t\t/*\n\t\t * Update directory index table to reflect new page address\n\t\t */\n\t\tif (DO_INDEX(ip)) {\n\t\t\ts64 lblock;\n\n\t\t\tmp = NULL;\n\t\t\tstbl = DT_GETSTBL(sp);\n\t\t\tfor (n = 0; n < sp->header.nextindex; n++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & sp->slot[stbl[n]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     xaddr, n, &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t *\textend the page\n\t */\n\tsp->header.self = *pxd;\n\n\tjfs_info(\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\", ip, smp, sp);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the extended/leaf page\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | type);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[0];\n\n\t/* update buffer extent descriptor of extended page */\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\n\t/*\n\t * copy old stbl to new stbl at start of extended area\n\t */\n\toldstblindex = sp->header.stblindex;\n\toldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\n\tnewstblindex = sp->header.maxslot;\n\tn = xsize >> L2DTSLOTSIZE;\n\tnewstblsize = (n + 31) >> L2DTSLOTSIZE;\n\tmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\n\t       sp->header.nextindex);\n\n\t/*\n\t * in-line extension: linelock old area of extended page\n\t */\n\tif (type == tlckEXTEND) {\n\t\t/* linelock header */\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\t\tlv++;\n\n\t\t/* linelock new stbl of extended page */\n\t\tlv->offset = newstblindex;\n\t\tlv->length = newstblsize;\n\t}\n\t/*\n\t * relocation: linelock whole relocated area\n\t */\n\telse {\n\t\tlv->offset = 0;\n\t\tlv->length = sp->header.maxslot + newstblsize;\n\t}\n\n\tdtlck->index++;\n\n\tsp->header.maxslot = n;\n\tsp->header.stblindex = newstblindex;\n\t/* sp->header.nextindex remains the same */\n\n\t/*\n\t * add old stbl region at head of freelist\n\t */\n\tfsi = oldstblindex;\n\tf = &sp->slot[fsi];\n\tlast = sp->header.freelist;\n\tfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\n\t\tf->next = last;\n\t\tlast = fsi;\n\t}\n\tsp->header.freelist = last;\n\tsp->header.freecnt += oldstblsize;\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = newstblindex + newstblsize;\n\tf = &sp->slot[fsi];\n\tfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\tsp->header.freelist = n;\n\telse {\n\t\tdo {\n\t\t\tf = &sp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\tsp->header.freecnt += sp->header.maxslot - n;\n\n\t/*\n\t * insert the new entry\n\t */\n\tdtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\n\n\tBT_MARK_DIRTY(pmp, ip);\n\t/*\n\t * linelock any freeslots residing in old extent\n\t */\n\tif (type == tlckEXTEND) {\n\t\tn = sp->header.maxslot >> 2;\n\t\tif (sp->header.freelist < n)\n\t\t\tdtLinelockFreelist(sp, n, &dtlck);\n\t}\n\n\t/*\n\t *\tupdate parent entry on the parent/root page\n\t */\n\t/*\n\t * acquire a transaction lock on the parent/root page\n\t */\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* linelock parent entry - 1st slot */\n\tlv->offset = 1;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* update the parent pxd for page extension */\n\ttpxd = (pxd_t *) & pp->slot[1];\n\t*tpxd = *pxd;\n\n\tDT_PUTPAGE(pmp);\n\treturn 0;\n}"
  },
  {
    "function_name": "dtSplitPage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "1330-1628",
    "snippet": "static int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t    struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts64 nextbn;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tint skip, nextindex, half, left, nxt, off, si;\n\tstruct ldtentry *ldtentry;\n\tstruct idtentry *idtentry;\n\tu8 *stbl;\n\tstruct dtslot *f;\n\tint fsi, stblsize;\n\tint n;\n\tstruct dt_lock *sdtlck, *rdtlck;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *slv, *rlv, *lv;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\trdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp = (dtpage_t *) rmp->data;\n\t*rpp = rp;\n\trp->header.self = *pxd;\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the split page\n\t *\n\t * action:\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\tsdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock header of split page */\n\tASSERT(sdtlck->index == 0);\n\tslv = & sdtlck->lv[0];\n\tslv->offset = 0;\n\tslv->length = 1;\n\tsdtlck->index++;\n\n\t/*\n\t * initialize/update sibling pointers between sp and rp\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\t/*\n\t * initialize new right page\n\t */\n\trp->header.flag = sp->header.flag;\n\n\t/* compute sorted entry table at start of extent data area */\n\trp->header.nextindex = 0;\n\trp->header.stblindex = 1;\n\n\tn = PSIZE >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\t/* in unit of slot */\n\n\t/* init freelist */\n\tfsi = rp->header.stblindex + stblsize;\n\trp->header.freelist = fsi;\n\trp->header.freecnt = rp->header.maxslot - fsi;\n\n\t/*\n\t *\tsequential append at tail: append without split\n\t *\n\t * If splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. Adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * If we're wrong it's no big deal, we'll just do the split the right\n\t * way next time.\n\t * (It may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left,\n\t * but it's not. Be my guest.)\n\t */\n\tif (nextbn == 0 && split->index == sp->header.nextindex) {\n\t\t/* linelock header + stbl (first slot) of new page */\n\t\trlv = & rdtlck->lv[rdtlck->index];\n\t\trlv->offset = 0;\n\t\trlv->length = 2;\n\t\trdtlck->index++;\n\n\t\t/*\n\t\t * initialize freelist of new right page\n\t\t */\n\t\tf = &rp->slot[fsi];\n\t\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\t\tf->next = fsi;\n\t\tf->next = -1;\n\n\t\t/* insert entry at the first entry of the new right page */\n\t\tdtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update prev pointer of previous right sibling page;\n\t */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tdiscard_metapage(rmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header of previous right sibling page */\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and right pages.\n\t */\n\tskip = split->index;\n\thalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\t/* swag */\n\tleft = 0;\n\n\t/*\n\t *\tcompute fill factor for split pages\n\t *\n\t * <nxt> traces the next entry to move to rp\n\t * <off> traces the next entry to stay in sp\n\t */\n\tstbl = (u8 *) & sp->slot[sp->header.stblindex];\n\tnextindex = sp->header.nextindex;\n\tfor (nxt = off = 0; nxt < nextindex; ++off) {\n\t\tif (off == skip)\n\t\t\t/* check for fill factor with new entry size */\n\t\t\tn = split->nslot;\n\t\telse {\n\t\t\tsi = stbl[nxt];\n\t\t\tswitch (sp->header.flag & BT_TYPE) {\n\t\t\tcase BT_LEAF:\n\t\t\t\tldtentry = (struct ldtentry *) & sp->slot[si];\n\t\t\t\tif (DO_INDEX(ip))\n\t\t\t\t\tn = NDTLEAF(ldtentry->namlen);\n\t\t\t\telse\n\t\t\t\t\tn = NDTLEAF_LEGACY(ldtentry->\n\t\t\t\t\t\t\t   namlen);\n\t\t\t\tbreak;\n\n\t\t\tcase BT_INTERNAL:\n\t\t\t\tidtentry = (struct idtentry *) & sp->slot[si];\n\t\t\t\tn = NDTINTERNAL(idtentry->namlen);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++nxt;\t/* advance to next entry to move in sp */\n\t\t}\n\n\t\tleft += n;\n\t\tif (left >= half)\n\t\t\tbreak;\n\t}\n\n\t/* <nxt> poins to the 1st entry to move */\n\n\t/*\n\t *\tmove entries to right page\n\t *\n\t * dtMoveEntry() initializes rp and reserves entry for insertion\n\t *\n\t * split page moved out entries are linelocked;\n\t * new/right page moved in entries are linelocked;\n\t */\n\t/* linelock header + stbl of new right page */\n\trlv = & rdtlck->lv[rdtlck->index];\n\trlv->offset = 0;\n\trlv->length = 5;\n\trdtlck->index++;\n\n\tdtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\n\n\tsp->header.nextindex = nxt;\n\n\t/*\n\t * finalize freelist of new right page\n\t */\n\tfsi = rp->header.freelist;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\n\t\tmp = NULL;\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\n\t/*\n\t * the skipped index was on the left page,\n\t */\n\tif (skip <= off) {\n\t\t/* insert the new entry in the split page */\n\t\tdtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\n\n\t\t/* linelock stbl of split page */\n\t\tif (sdtlck->index >= sdtlck->maxcnt)\n\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\tslv = & sdtlck->lv[sdtlck->index];\n\t\tn = skip >> L2DTSLOTSIZE;\n\t\tslv->offset = sp->header.stblindex + n;\n\t\tslv->length =\n\t\t    ((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tsdtlck->index++;\n\t}\n\t/*\n\t * the skipped index was on the right page,\n\t */\n\telse {\n\t\t/* adjust the skip index to reflect the new position */\n\t\tskip -= nxt;\n\n\t\t/* insert the new entry in the right page */\n\t\tdtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\n\t}\n\n      out:\n\t*rmpp = rmp;\n\t*rpxdp = *pxd;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dtInsertEntry",
          "args": [
            "rp",
            "skip",
            "split->key",
            "split->data",
            "&rdtlck"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "sdtlck"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "modify_index",
          "args": [
            "tid",
            "ip",
            "le32_to_cpu(ldtentry->index)",
            "rbn",
            "n",
            "&mp",
            "&lblock"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "modify_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "524-542",
          "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ldtentry->index"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "rp"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtMoveEntry",
          "args": [
            "sp",
            "nxt",
            "rp",
            "&sdtlck",
            "&rdtlck",
            "DO_INDEX(ip)"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "dtMoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "4065-4252",
          "snippet": "static void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index)\n{\n\tint ssi, next;\t\t/* src slot index */\n\tint di;\t\t\t/* dst entry index */\n\tint dsi;\t\t/* dst slot index */\n\ts8 *sstbl, *dstbl;\t/* sorted entry table */\n\tint snamlen, len;\n\tstruct ldtentry *slh, *dlh = NULL;\n\tstruct idtentry *sih, *dih = NULL;\n\tstruct dtslot *h, *s, *d;\n\tstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\n\tstruct lv *slv, *dlv;\n\tint xssi, ns, nd;\n\tint sfsi;\n\n\tsstbl = (s8 *) & sp->slot[sp->header.stblindex];\n\tdstbl = (s8 *) & dp->slot[dp->header.stblindex];\n\n\tdsi = dp->header.freelist;\t/* first (whole page) free slot */\n\tsfsi = sp->header.freelist;\n\n\t/* linelock destination entry slot */\n\tdlv = & ddtlck->lv[ddtlck->index];\n\tdlv->offset = dsi;\n\n\t/* linelock source entry slot */\n\tslv = & sdtlck->lv[sdtlck->index];\n\tslv->offset = sstbl[si];\n\txssi = slv->offset - 1;\n\n\t/*\n\t * move entries\n\t */\n\tns = nd = 0;\n\tfor (di = 0; si < sp->header.nextindex; si++, di++) {\n\t\tssi = sstbl[si];\n\t\tdstbl[di] = dsi;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (ssi != xssi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tslv->length = ns;\n\t\t\tsdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\tslv++;\n\t\t\telse {\n\t\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t}\n\n\t\t\tslv->offset = ssi;\n\t\t\tns = 0;\n\t\t}\n\n\t\t/*\n\t\t * move head/only segment of an entry\n\t\t */\n\t\t/* get dst slot */\n\t\th = d = &dp->slot[dsi];\n\n\t\t/* get src slot and move */\n\t\ts = &sp->slot[ssi];\n\t\tif (sp->header.flag & BT_LEAF) {\n\t\t\t/* get source entry */\n\t\t\tslh = (struct ldtentry *) s;\n\t\t\tdlh = (struct ldtentry *) h;\n\t\t\tsnamlen = slh->namlen;\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN);\n\t\t\t\tdlh->index = slh->index; /* little-endian */\n\t\t\t} else\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN_LEGACY);\n\n\t\t\tmemcpy(dlh, slh, 6 + len * 2);\n\n\t\t\tnext = slh->next;\n\n\t\t\t/* update dst head/only segment next field */\n\t\t\tdsi++;\n\t\t\tdlh->next = dsi;\n\t\t} else {\n\t\t\tsih = (struct idtentry *) s;\n\t\t\tsnamlen = sih->namlen;\n\n\t\t\tlen = min(snamlen, DTIHDRDATALEN);\n\t\t\tdih = (struct idtentry *) h;\n\t\t\tmemcpy(dih, sih, 10 + len * 2);\n\t\t\tnext = sih->next;\n\n\t\t\tdsi++;\n\t\t\tdih->next = dsi;\n\t\t}\n\n\t\t/* free src head/only segment */\n\t\ts->next = sfsi;\n\t\ts->cnt = 1;\n\t\tsfsi = ssi;\n\n\t\tns++;\n\t\tnd++;\n\t\txssi = ssi;\n\n\t\t/*\n\t\t * move additional segment(s) of the entry\n\t\t */\n\t\tsnamlen -= len;\n\t\twhile ((ssi = next) >= 0) {\n\t\t\t/* is next slot contiguous ? */\n\t\t\tif (ssi != xssi + 1) {\n\t\t\t\t/* close current linelock */\n\t\t\t\tslv->length = ns;\n\t\t\t\tsdtlck->index++;\n\n\t\t\t\t/* open new linelock */\n\t\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\t\tslv++;\n\t\t\t\telse {\n\t\t\t\t\tsdtlck =\n\t\t\t\t\t    (struct dt_lock *)\n\t\t\t\t\t    txLinelock(sdtlck);\n\t\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t\t}\n\n\t\t\t\tslv->offset = ssi;\n\t\t\t\tns = 0;\n\t\t\t}\n\n\t\t\t/* get next source segment */\n\t\t\ts = &sp->slot[ssi];\n\n\t\t\t/* get next destination free slot */\n\t\t\td++;\n\n\t\t\tlen = min(snamlen, DTSLOTDATALEN);\n\t\t\tUniStrncpy_le(d->name, s->name, len);\n\n\t\t\tns++;\n\t\t\tnd++;\n\t\t\txssi = ssi;\n\n\t\t\tdsi++;\n\t\t\td->next = dsi;\n\n\t\t\t/* free source segment */\n\t\t\tnext = s->next;\n\t\t\ts->next = sfsi;\n\t\t\ts->cnt = 1;\n\t\t\tsfsi = ssi;\n\n\t\t\tsnamlen -= len;\n\t\t}\t\t/* end while */\n\n\t\t/* terminate dst last/only segment */\n\t\tif (h == d) {\n\t\t\t/* single segment entry */\n\t\t\tif (dp->header.flag & BT_LEAF)\n\t\t\t\tdlh->next = -1;\n\t\t\telse\n\t\t\t\tdih->next = -1;\n\t\t} else\n\t\t\t/* multi-segment entry */\n\t\t\td->next = -1;\n\t}\t\t\t/* end for */\n\n\t/* close current linelock */\n\tslv->length = ns;\n\tsdtlck->index++;\n\t*sdtlock = sdtlck;\n\n\tdlv->length = nd;\n\tddtlck->index++;\n\t*ddtlock = ddtlck;\n\n\t/* update source header */\n\tsp->header.freelist = sfsi;\n\tsp->header.freecnt += nd;\n\n\t/* update destination header */\n\tdp->header.nextindex = di;\n\n\tdp->header.freelist = dsi;\n\tdp->header.freecnt -= nd;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index);\n\nstatic void dtMoveEntry(dtpage_t * sp, int si, dtpage_t * dp,\n\t\t\tstruct dt_lock ** sdtlock, struct dt_lock ** ddtlock,\n\t\t\tint do_index)\n{\n\tint ssi, next;\t\t/* src slot index */\n\tint di;\t\t\t/* dst entry index */\n\tint dsi;\t\t/* dst slot index */\n\ts8 *sstbl, *dstbl;\t/* sorted entry table */\n\tint snamlen, len;\n\tstruct ldtentry *slh, *dlh = NULL;\n\tstruct idtentry *sih, *dih = NULL;\n\tstruct dtslot *h, *s, *d;\n\tstruct dt_lock *sdtlck = *sdtlock, *ddtlck = *ddtlock;\n\tstruct lv *slv, *dlv;\n\tint xssi, ns, nd;\n\tint sfsi;\n\n\tsstbl = (s8 *) & sp->slot[sp->header.stblindex];\n\tdstbl = (s8 *) & dp->slot[dp->header.stblindex];\n\n\tdsi = dp->header.freelist;\t/* first (whole page) free slot */\n\tsfsi = sp->header.freelist;\n\n\t/* linelock destination entry slot */\n\tdlv = & ddtlck->lv[ddtlck->index];\n\tdlv->offset = dsi;\n\n\t/* linelock source entry slot */\n\tslv = & sdtlck->lv[sdtlck->index];\n\tslv->offset = sstbl[si];\n\txssi = slv->offset - 1;\n\n\t/*\n\t * move entries\n\t */\n\tns = nd = 0;\n\tfor (di = 0; si < sp->header.nextindex; si++, di++) {\n\t\tssi = sstbl[si];\n\t\tdstbl[di] = dsi;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (ssi != xssi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tslv->length = ns;\n\t\t\tsdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\tslv++;\n\t\t\telse {\n\t\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t}\n\n\t\t\tslv->offset = ssi;\n\t\t\tns = 0;\n\t\t}\n\n\t\t/*\n\t\t * move head/only segment of an entry\n\t\t */\n\t\t/* get dst slot */\n\t\th = d = &dp->slot[dsi];\n\n\t\t/* get src slot and move */\n\t\ts = &sp->slot[ssi];\n\t\tif (sp->header.flag & BT_LEAF) {\n\t\t\t/* get source entry */\n\t\t\tslh = (struct ldtentry *) s;\n\t\t\tdlh = (struct ldtentry *) h;\n\t\t\tsnamlen = slh->namlen;\n\n\t\t\tif (do_index) {\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN);\n\t\t\t\tdlh->index = slh->index; /* little-endian */\n\t\t\t} else\n\t\t\t\tlen = min(snamlen, DTLHDRDATALEN_LEGACY);\n\n\t\t\tmemcpy(dlh, slh, 6 + len * 2);\n\n\t\t\tnext = slh->next;\n\n\t\t\t/* update dst head/only segment next field */\n\t\t\tdsi++;\n\t\t\tdlh->next = dsi;\n\t\t} else {\n\t\t\tsih = (struct idtentry *) s;\n\t\t\tsnamlen = sih->namlen;\n\n\t\t\tlen = min(snamlen, DTIHDRDATALEN);\n\t\t\tdih = (struct idtentry *) h;\n\t\t\tmemcpy(dih, sih, 10 + len * 2);\n\t\t\tnext = sih->next;\n\n\t\t\tdsi++;\n\t\t\tdih->next = dsi;\n\t\t}\n\n\t\t/* free src head/only segment */\n\t\ts->next = sfsi;\n\t\ts->cnt = 1;\n\t\tsfsi = ssi;\n\n\t\tns++;\n\t\tnd++;\n\t\txssi = ssi;\n\n\t\t/*\n\t\t * move additional segment(s) of the entry\n\t\t */\n\t\tsnamlen -= len;\n\t\twhile ((ssi = next) >= 0) {\n\t\t\t/* is next slot contiguous ? */\n\t\t\tif (ssi != xssi + 1) {\n\t\t\t\t/* close current linelock */\n\t\t\t\tslv->length = ns;\n\t\t\t\tsdtlck->index++;\n\n\t\t\t\t/* open new linelock */\n\t\t\t\tif (sdtlck->index < sdtlck->maxcnt)\n\t\t\t\t\tslv++;\n\t\t\t\telse {\n\t\t\t\t\tsdtlck =\n\t\t\t\t\t    (struct dt_lock *)\n\t\t\t\t\t    txLinelock(sdtlck);\n\t\t\t\t\tslv = & sdtlck->lv[0];\n\t\t\t\t}\n\n\t\t\t\tslv->offset = ssi;\n\t\t\t\tns = 0;\n\t\t\t}\n\n\t\t\t/* get next source segment */\n\t\t\ts = &sp->slot[ssi];\n\n\t\t\t/* get next destination free slot */\n\t\t\td++;\n\n\t\t\tlen = min(snamlen, DTSLOTDATALEN);\n\t\t\tUniStrncpy_le(d->name, s->name, len);\n\n\t\t\tns++;\n\t\t\tnd++;\n\t\t\txssi = ssi;\n\n\t\t\tdsi++;\n\t\t\td->next = dsi;\n\n\t\t\t/* free source segment */\n\t\t\tnext = s->next;\n\t\t\ts->next = sfsi;\n\t\t\ts->cnt = 1;\n\t\t\tsfsi = ssi;\n\n\t\t\tsnamlen -= len;\n\t\t}\t\t/* end while */\n\n\t\t/* terminate dst last/only segment */\n\t\tif (h == d) {\n\t\t\t/* single segment entry */\n\t\t\tif (dp->header.flag & BT_LEAF)\n\t\t\t\tdlh->next = -1;\n\t\t\telse\n\t\t\t\tdih->next = -1;\n\t\t} else\n\t\t\t/* multi-segment entry */\n\t\t\td->next = -1;\n\t}\t\t\t/* end for */\n\n\t/* close current linelock */\n\tslv->length = ns;\n\tsdtlck->index++;\n\t*sdtlock = sdtlck;\n\n\tdlv->length = nd;\n\tddtlck->index++;\n\t*ddtlock = ddtlck;\n\n\t/* update source header */\n\tsp->header.freelist = sfsi;\n\tsp->header.freecnt += nd;\n\n\t/* update destination header */\n\tdp->header.nextindex = di;\n\n\tdp->header.freelist = dsi;\n\tdp->header.freecnt -= nd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDTINTERNAL",
          "args": [
            "idtentry->namlen"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDTLEAF_LEGACY",
          "args": [
            "ldtentry->\n\t\t\t\t\t\t\t   namlen"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDTLEAF",
          "args": [
            "ldtentry->namlen"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "rbn"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\"",
            "tlck",
            "ip",
            "mp"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckRELINK"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "rmp"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "nextbn",
            "mp",
            "PSIZE",
            "p",
            "rc"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "rbn"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "addressPXD(&sp->header.self)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "&sp->header.self"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "nextbn"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sp->header.next"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sdtlck->index == 0"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "rmp",
            "ip"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\"",
            "ip",
            "smp",
            "rmp"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "lengthPXD(pxd)"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "ip",
            "rbn",
            "PSIZE",
            "1"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PAGE",
          "args": [
            "ip",
            "smp"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t    struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts64 nextbn;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tint skip, nextindex, half, left, nxt, off, si;\n\tstruct ldtentry *ldtentry;\n\tstruct idtentry *idtentry;\n\tu8 *stbl;\n\tstruct dtslot *f;\n\tint fsi, stblsize;\n\tint n;\n\tstruct dt_lock *sdtlck, *rdtlck;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *slv, *rlv, *lv;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\trdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp = (dtpage_t *) rmp->data;\n\t*rpp = rp;\n\trp->header.self = *pxd;\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the split page\n\t *\n\t * action:\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\tsdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock header of split page */\n\tASSERT(sdtlck->index == 0);\n\tslv = & sdtlck->lv[0];\n\tslv->offset = 0;\n\tslv->length = 1;\n\tsdtlck->index++;\n\n\t/*\n\t * initialize/update sibling pointers between sp and rp\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\t/*\n\t * initialize new right page\n\t */\n\trp->header.flag = sp->header.flag;\n\n\t/* compute sorted entry table at start of extent data area */\n\trp->header.nextindex = 0;\n\trp->header.stblindex = 1;\n\n\tn = PSIZE >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\t/* in unit of slot */\n\n\t/* init freelist */\n\tfsi = rp->header.stblindex + stblsize;\n\trp->header.freelist = fsi;\n\trp->header.freecnt = rp->header.maxslot - fsi;\n\n\t/*\n\t *\tsequential append at tail: append without split\n\t *\n\t * If splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. Adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * If we're wrong it's no big deal, we'll just do the split the right\n\t * way next time.\n\t * (It may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left,\n\t * but it's not. Be my guest.)\n\t */\n\tif (nextbn == 0 && split->index == sp->header.nextindex) {\n\t\t/* linelock header + stbl (first slot) of new page */\n\t\trlv = & rdtlck->lv[rdtlck->index];\n\t\trlv->offset = 0;\n\t\trlv->length = 2;\n\t\trdtlck->index++;\n\n\t\t/*\n\t\t * initialize freelist of new right page\n\t\t */\n\t\tf = &rp->slot[fsi];\n\t\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\t\tf->next = fsi;\n\t\tf->next = -1;\n\n\t\t/* insert entry at the first entry of the new right page */\n\t\tdtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update prev pointer of previous right sibling page;\n\t */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tdiscard_metapage(rmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header of previous right sibling page */\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and right pages.\n\t */\n\tskip = split->index;\n\thalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\t/* swag */\n\tleft = 0;\n\n\t/*\n\t *\tcompute fill factor for split pages\n\t *\n\t * <nxt> traces the next entry to move to rp\n\t * <off> traces the next entry to stay in sp\n\t */\n\tstbl = (u8 *) & sp->slot[sp->header.stblindex];\n\tnextindex = sp->header.nextindex;\n\tfor (nxt = off = 0; nxt < nextindex; ++off) {\n\t\tif (off == skip)\n\t\t\t/* check for fill factor with new entry size */\n\t\t\tn = split->nslot;\n\t\telse {\n\t\t\tsi = stbl[nxt];\n\t\t\tswitch (sp->header.flag & BT_TYPE) {\n\t\t\tcase BT_LEAF:\n\t\t\t\tldtentry = (struct ldtentry *) & sp->slot[si];\n\t\t\t\tif (DO_INDEX(ip))\n\t\t\t\t\tn = NDTLEAF(ldtentry->namlen);\n\t\t\t\telse\n\t\t\t\t\tn = NDTLEAF_LEGACY(ldtentry->\n\t\t\t\t\t\t\t   namlen);\n\t\t\t\tbreak;\n\n\t\t\tcase BT_INTERNAL:\n\t\t\t\tidtentry = (struct idtentry *) & sp->slot[si];\n\t\t\t\tn = NDTINTERNAL(idtentry->namlen);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++nxt;\t/* advance to next entry to move in sp */\n\t\t}\n\n\t\tleft += n;\n\t\tif (left >= half)\n\t\t\tbreak;\n\t}\n\n\t/* <nxt> poins to the 1st entry to move */\n\n\t/*\n\t *\tmove entries to right page\n\t *\n\t * dtMoveEntry() initializes rp and reserves entry for insertion\n\t *\n\t * split page moved out entries are linelocked;\n\t * new/right page moved in entries are linelocked;\n\t */\n\t/* linelock header + stbl of new right page */\n\trlv = & rdtlck->lv[rdtlck->index];\n\trlv->offset = 0;\n\trlv->length = 5;\n\trdtlck->index++;\n\n\tdtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\n\n\tsp->header.nextindex = nxt;\n\n\t/*\n\t * finalize freelist of new right page\n\t */\n\tfsi = rp->header.freelist;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\n\t\tmp = NULL;\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\n\t/*\n\t * the skipped index was on the left page,\n\t */\n\tif (skip <= off) {\n\t\t/* insert the new entry in the split page */\n\t\tdtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\n\n\t\t/* linelock stbl of split page */\n\t\tif (sdtlck->index >= sdtlck->maxcnt)\n\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\tslv = & sdtlck->lv[sdtlck->index];\n\t\tn = skip >> L2DTSLOTSIZE;\n\t\tslv->offset = sp->header.stblindex + n;\n\t\tslv->length =\n\t\t    ((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tsdtlck->index++;\n\t}\n\t/*\n\t * the skipped index was on the right page,\n\t */\n\telse {\n\t\t/* adjust the skip index to reflect the new position */\n\t\tskip -= nxt;\n\n\t\t/* insert the new entry in the right page */\n\t\tdtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\n\t}\n\n      out:\n\t*rmpp = rmp;\n\t*rpxdp = *pxd;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dtSplitUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "930-1316",
    "snippet": "static int dtSplitUp(tid_t tid,\n\t  struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page split from sp */\n\tpxd_t rpxd;\t\t/* new right page extent descriptor */\n\tstruct metapage *lmp;\n\tdtpage_t *lp;\t\t/* left child page */\n\tint skip;\t\t/* index of entry of insertion */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\ts64 xaddr, nxaddr;\n\tint xlen, xsize;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct component_name key = { 0, NULL };\n\tddata_t *data = split->data;\n\tint n;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint quota_allocation = 0;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\tkey.name = kmalloc((JFS_NAME_MAX + 2) * sizeof(wchar_t), GFP_NOFS);\n\tif (!key.name) {\n\t\tDT_PUTPAGE(smp);\n\t\trc = -ENOMEM;\n\t\tgoto dtSplitUp_Exit;\n\t}\n\n\t/*\n\t *\tsplit leaf page\n\t *\n\t * The split routines insert the new entry, and\n\t * acquire txLock as appropriate.\n\t */\n\t/*\n\t *\tsplit root leaf page:\n\t */\n\tif (sp->header.flag & BT_ROOT) {\n\t\t/*\n\t\t * allocate a single extent child page\n\t\t */\n\t\txlen = 1;\n\t\tn = sbi->bsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tn -= DTROOTMAXSLOT - sp->header.freecnt; /* header + entries */\n\t\tif (n <= split->nslot)\n\t\t\txlen++;\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\n\t\t\tDT_PUTPAGE(smp);\n\t\t\tgoto freeKeyName;\n\t\t}\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, xaddr);\n\t\tPXDlength(pxd, xlen);\n\t\tsplit->pxdlist = &pxdlist;\n\t\trc = dtSplitRoot(tid, ip, split, &rmp);\n\n\t\tif (rc)\n\t\t\tdbFree(ip, xaddr, xlen);\n\t\telse\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\tDT_PUTPAGE(smp);\n\n\t\tif (!DO_INDEX(ip))\n\t\t\tip->i_size = xlen << sbi->l2bsize;\n\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\textend first leaf page\n\t *\n\t * extend the 1st extent if less than buffer page size\n\t * (dtExtendPage() reurns leaf page unpinned)\n\t */\n\tpxd = &sp->header.self;\n\txlen = lengthPXD(pxd);\n\txsize = xlen << sbi->l2bsize;\n\tif (xsize < PSIZE) {\n\t\txaddr = addressPXD(pxd);\n\t\tn = xsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tif ((n + sp->header.freecnt) <= split->nslot)\n\t\t\tn = xlen + (xlen << 1);\n\t\telse\n\t\t\tn = xlen;\n\n\t\t/* Allocate blocks to quota. */\n\t\trc = dquot_alloc_block(ip, n);\n\t\tif (rc)\n\t\t\tgoto extendOut;\n\t\tquota_allocation += n;\n\n\t\tif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\n\t\t\t\t    (s64) n, &nxaddr)))\n\t\t\tgoto extendOut;\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, nxaddr);\n\t\tPXDlength(pxd, xlen + n);\n\t\tsplit->pxdlist = &pxdlist;\n\t\tif ((rc = dtExtendPage(tid, ip, split, btstack))) {\n\t\t\tnxaddr = addressPXD(pxd);\n\t\t\tif (xaddr != nxaddr) {\n\t\t\t\t/* free relocated extent */\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, nxaddr, (s64) xlen);\n\t\t\t} else {\n\t\t\t\t/* free extended delta */\n\t\t\t\txlen = lengthPXD(pxd) - n;\n\t\t\t\txaddr = addressPXD(pxd) + xlen;\n\t\t\t\tdbFree(ip, xaddr, (s64) n);\n\t\t\t}\n\t\t} else if (!DO_INDEX(ip))\n\t\t\tip->i_size = lengthPXD(pxd) << sbi->l2bsize;\n\n\n\t      extendOut:\n\t\tDT_PUTPAGE(smp);\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\tsplit leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * return <rp> pinned and its extent descriptor <rpxd>\n\t */\n\t/*\n\t * allocate new directory page extent and\n\t * new index page(s) to cover page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tn = btstack->nsplit;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\txlen = sbi->nbperpage;\n\tfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, xlen);\n\t\t\tpxdlist.maxnpxd++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tsplit->pxdlist = &pxdlist;\n\tif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size += PSIZE;\n\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 4 pages pinned at any time:\n\t * two children, left parent and right parent (when the parent splits).\n\t * keep the child pages pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages (<lp>, <rp>) pinned */\n\t\tlmp = smp;\n\t\tlp = sp;\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(lmp);\n\t\t\tDT_PUTPAGE(rmp);\n\t\t\tgoto splitOut;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * compute the key for the router entry\n\t\t *\n\t\t * key suffix compression:\n\t\t * for internal pages that have leaf pages as children,\n\t\t * retain only what's needed to distinguish between\n\t\t * the new entry and the entry on the page to its left.\n\t\t * If the keys compare equal, retain the entire key.\n\t\t *\n\t\t * note that compression is performed only at computing\n\t\t * router key at the lowest internal level.\n\t\t * further compression of the key between pairs of higher\n\t\t * level internal pages loses too much information and\n\t\t * the search may fail.\n\t\t * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}\n\t\t * results in two adjacent parent entries (a)(xx).\n\t\t * if split occurs between these two entries, and\n\t\t * if compression is applied, the router key of parent entry\n\t\t * of right page (x) will divert search for x into right\n\t\t * subtree and miss x in the left subtree.)\n\t\t *\n\t\t * the entire key must be retained for the next-to-leftmost\n\t\t * internal key at any level of the tree, or search may fail\n\t\t * (e.g., ?)\n\t\t */\n\t\tswitch (rp->header.flag & BT_TYPE) {\n\t\tcase BT_LEAF:\n\t\t\t/*\n\t\t\t * compute the length of prefix for suffix compression\n\t\t\t * between last entry of left page and first entry\n\t\t\t * of right page\n\t\t\t */\n\t\t\tif ((sp->header.flag & BT_ROOT && skip > 1) ||\n\t\t\t    sp->header.prev != 0 || skip > 1) {\n\t\t\t\t/* compute uppercase router prefix key */\n\t\t\t\trc = ciGetLeafPrefixKey(lp,\n\t\t\t\t\t\t\tlp->header.nextindex-1,\n\t\t\t\t\t\t\trp, 0, &key,\n\t\t\t\t\t\t\tsbi->mntflag);\n\t\t\t\tif (rc) {\n\t\t\t\t\tDT_PUTPAGE(lmp);\n\t\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\t\tgoto splitOut;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* next to leftmost entry of\n\t\t\t\t   lowest internal level */\n\n\t\t\t\t/* compute uppercase router key */\n\t\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\t\tkey.name[key.namlen] = 0;\n\n\t\t\t\tif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\n\t\t\t\t\tciToUpper(&key);\n\t\t\t}\n\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tcase BT_INTERNAL:\n\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"dtSplitUp(): UFO!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unpin left child page */\n\t\tDT_PUTPAGE(lmp);\n\n\t\t/*\n\t\t * compute the data for the router entry\n\t\t */\n\t\tdata->xd = rpxd;\t/* child page xd */\n\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (n > sp->header.freecnt) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->nslot = n;\n\t\t\tsplit->key = &key;\n\t\t\t/* split->data = data; */\n\n\t\t\t/* unpin right child page */\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    dtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\n\t\t\tif (rc) {\n\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\tgoto splitOut;\n\t\t\t}\n\n\t\t\t/* smp and rmp are pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert router entry in parent page\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\n\t\t\t/* linelock header */\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\n\t\t\t/* linelock stbl of non-root parent page */\n\t\t\tif (!(sp->header.flag & BT_ROOT)) {\n\t\t\t\tlv++;\n\t\t\t\tn = skip >> L2DTSLOTSIZE;\n\t\t\t\tlv->offset = sp->header.stblindex + n;\n\t\t\t\tlv->length =\n\t\t\t\t    ((sp->header.nextindex -\n\t\t\t\t      1) >> L2DTSLOTSIZE) - n + 1;\n\t\t\t\tdtlck->index++;\n\t\t\t}\n\n\t\t\tdtInsertEntry(sp, skip, &key, data, &dtlck);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current split and its right page */\n\tDT_PUTPAGE(smp);\n\tDT_PUTPAGE(rmp);\n\n\t/*\n\t * free remaining extents allocated for split\n\t */\n      splitOut:\n\tn = pxdlist.npxd;\n\tpxd = &pxdlist.pxd[n];\n\tfor (; n < pxdlist.maxnpxd; n++, pxd++)\n\t\tdbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\n\n      freeKeyName:\n\tkfree(key.name);\n\n\t/* Rollback quota allocation */\n\tif (rc && quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n      dtSplitUp_Exit:\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "quota_allocation"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key.name"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "addressPXD(pxd)",
            "(s64) lengthPXD(pxd)"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtInsertEntry",
          "args": [
            "sp",
            "skip",
            "&key",
            "data",
            "&dtlck"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "smp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "smp",
            "ip"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSplitPage",
          "args": [
            "tid",
            "ip",
            "split",
            "&rmp",
            "&rp",
            "&rpxd"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "dtSplitPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "1330-1628",
          "snippet": "static int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t    struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts64 nextbn;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tint skip, nextindex, half, left, nxt, off, si;\n\tstruct ldtentry *ldtentry;\n\tstruct idtentry *idtentry;\n\tu8 *stbl;\n\tstruct dtslot *f;\n\tint fsi, stblsize;\n\tint n;\n\tstruct dt_lock *sdtlck, *rdtlck;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *slv, *rlv, *lv;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\trdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp = (dtpage_t *) rmp->data;\n\t*rpp = rp;\n\trp->header.self = *pxd;\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the split page\n\t *\n\t * action:\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\tsdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock header of split page */\n\tASSERT(sdtlck->index == 0);\n\tslv = & sdtlck->lv[0];\n\tslv->offset = 0;\n\tslv->length = 1;\n\tsdtlck->index++;\n\n\t/*\n\t * initialize/update sibling pointers between sp and rp\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\t/*\n\t * initialize new right page\n\t */\n\trp->header.flag = sp->header.flag;\n\n\t/* compute sorted entry table at start of extent data area */\n\trp->header.nextindex = 0;\n\trp->header.stblindex = 1;\n\n\tn = PSIZE >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\t/* in unit of slot */\n\n\t/* init freelist */\n\tfsi = rp->header.stblindex + stblsize;\n\trp->header.freelist = fsi;\n\trp->header.freecnt = rp->header.maxslot - fsi;\n\n\t/*\n\t *\tsequential append at tail: append without split\n\t *\n\t * If splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. Adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * If we're wrong it's no big deal, we'll just do the split the right\n\t * way next time.\n\t * (It may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left,\n\t * but it's not. Be my guest.)\n\t */\n\tif (nextbn == 0 && split->index == sp->header.nextindex) {\n\t\t/* linelock header + stbl (first slot) of new page */\n\t\trlv = & rdtlck->lv[rdtlck->index];\n\t\trlv->offset = 0;\n\t\trlv->length = 2;\n\t\trdtlck->index++;\n\n\t\t/*\n\t\t * initialize freelist of new right page\n\t\t */\n\t\tf = &rp->slot[fsi];\n\t\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\t\tf->next = fsi;\n\t\tf->next = -1;\n\n\t\t/* insert entry at the first entry of the new right page */\n\t\tdtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update prev pointer of previous right sibling page;\n\t */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tdiscard_metapage(rmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header of previous right sibling page */\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and right pages.\n\t */\n\tskip = split->index;\n\thalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\t/* swag */\n\tleft = 0;\n\n\t/*\n\t *\tcompute fill factor for split pages\n\t *\n\t * <nxt> traces the next entry to move to rp\n\t * <off> traces the next entry to stay in sp\n\t */\n\tstbl = (u8 *) & sp->slot[sp->header.stblindex];\n\tnextindex = sp->header.nextindex;\n\tfor (nxt = off = 0; nxt < nextindex; ++off) {\n\t\tif (off == skip)\n\t\t\t/* check for fill factor with new entry size */\n\t\t\tn = split->nslot;\n\t\telse {\n\t\t\tsi = stbl[nxt];\n\t\t\tswitch (sp->header.flag & BT_TYPE) {\n\t\t\tcase BT_LEAF:\n\t\t\t\tldtentry = (struct ldtentry *) & sp->slot[si];\n\t\t\t\tif (DO_INDEX(ip))\n\t\t\t\t\tn = NDTLEAF(ldtentry->namlen);\n\t\t\t\telse\n\t\t\t\t\tn = NDTLEAF_LEGACY(ldtentry->\n\t\t\t\t\t\t\t   namlen);\n\t\t\t\tbreak;\n\n\t\t\tcase BT_INTERNAL:\n\t\t\t\tidtentry = (struct idtentry *) & sp->slot[si];\n\t\t\t\tn = NDTINTERNAL(idtentry->namlen);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++nxt;\t/* advance to next entry to move in sp */\n\t\t}\n\n\t\tleft += n;\n\t\tif (left >= half)\n\t\t\tbreak;\n\t}\n\n\t/* <nxt> poins to the 1st entry to move */\n\n\t/*\n\t *\tmove entries to right page\n\t *\n\t * dtMoveEntry() initializes rp and reserves entry for insertion\n\t *\n\t * split page moved out entries are linelocked;\n\t * new/right page moved in entries are linelocked;\n\t */\n\t/* linelock header + stbl of new right page */\n\trlv = & rdtlck->lv[rdtlck->index];\n\trlv->offset = 0;\n\trlv->length = 5;\n\trdtlck->index++;\n\n\tdtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\n\n\tsp->header.nextindex = nxt;\n\n\t/*\n\t * finalize freelist of new right page\n\t */\n\tfsi = rp->header.freelist;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\n\t\tmp = NULL;\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\n\t/*\n\t * the skipped index was on the left page,\n\t */\n\tif (skip <= off) {\n\t\t/* insert the new entry in the split page */\n\t\tdtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\n\n\t\t/* linelock stbl of split page */\n\t\tif (sdtlck->index >= sdtlck->maxcnt)\n\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\tslv = & sdtlck->lv[sdtlck->index];\n\t\tn = skip >> L2DTSLOTSIZE;\n\t\tslv->offset = sp->header.stblindex + n;\n\t\tslv->length =\n\t\t    ((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tsdtlck->index++;\n\t}\n\t/*\n\t * the skipped index was on the right page,\n\t */\n\telse {\n\t\t/* adjust the skip index to reflect the new position */\n\t\tskip -= nxt;\n\n\t\t/* insert the new entry in the right page */\n\t\tdtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\n\t}\n\n      out:\n\t*rmpp = rmp;\n\t*rpxdp = *pxd;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitPage(tid_t tid, struct inode *ip, struct dtsplit * split,\n\t    struct metapage ** rmpp, dtpage_t ** rpp, pxd_t * rpxdp)\n{\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page allocated */\n\ts64 rbn;\t\t/* new right page block number */\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts64 nextbn;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tint skip, nextindex, half, left, nxt, off, si;\n\tstruct ldtentry *ldtentry;\n\tstruct idtentry *idtentry;\n\tu8 *stbl;\n\tstruct dtslot *f;\n\tint fsi, stblsize;\n\tint n;\n\tstruct dt_lock *sdtlck, *rdtlck;\n\tstruct tlock *tlck;\n\tstruct dt_lock *dtlck;\n\tstruct lv *slv, *rlv, *lv;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/*\n\t * allocate the new right page for the split\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\trmp = get_metapage(ip, rbn, PSIZE, 1);\n\tif (rmp == NULL)\n\t\treturn -EIO;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tjfs_info(\"dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p\", ip, smp, rmp);\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\trdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp = (dtpage_t *) rmp->data;\n\t*rpp = rp;\n\trp->header.self = *pxd;\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the split page\n\t *\n\t * action:\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\tsdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock header of split page */\n\tASSERT(sdtlck->index == 0);\n\tslv = & sdtlck->lv[0];\n\tslv->offset = 0;\n\tslv->length = 1;\n\tsdtlck->index++;\n\n\t/*\n\t * initialize/update sibling pointers between sp and rp\n\t */\n\tnextbn = le64_to_cpu(sp->header.next);\n\trp->header.next = cpu_to_le64(nextbn);\n\trp->header.prev = cpu_to_le64(addressPXD(&sp->header.self));\n\tsp->header.next = cpu_to_le64(rbn);\n\n\t/*\n\t * initialize new right page\n\t */\n\trp->header.flag = sp->header.flag;\n\n\t/* compute sorted entry table at start of extent data area */\n\trp->header.nextindex = 0;\n\trp->header.stblindex = 1;\n\n\tn = PSIZE >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\t/* in unit of slot */\n\n\t/* init freelist */\n\tfsi = rp->header.stblindex + stblsize;\n\trp->header.freelist = fsi;\n\trp->header.freecnt = rp->header.maxslot - fsi;\n\n\t/*\n\t *\tsequential append at tail: append without split\n\t *\n\t * If splitting the last page on a level because of appending\n\t * a entry to it (skip is maxentry), it's likely that the access is\n\t * sequential. Adding an empty page on the side of the level is less\n\t * work and can push the fill factor much higher than normal.\n\t * If we're wrong it's no big deal, we'll just do the split the right\n\t * way next time.\n\t * (It may look like it's equally easy to do a similar hack for\n\t * reverse sorted data, that is, split the tree left,\n\t * but it's not. Be my guest.)\n\t */\n\tif (nextbn == 0 && split->index == sp->header.nextindex) {\n\t\t/* linelock header + stbl (first slot) of new page */\n\t\trlv = & rdtlck->lv[rdtlck->index];\n\t\trlv->offset = 0;\n\t\trlv->length = 2;\n\t\trdtlck->index++;\n\n\t\t/*\n\t\t * initialize freelist of new right page\n\t\t */\n\t\tf = &rp->slot[fsi];\n\t\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\t\tf->next = fsi;\n\t\tf->next = -1;\n\n\t\t/* insert entry at the first entry of the new right page */\n\t\tdtInsertEntry(rp, 0, split->key, split->data, &rdtlck);\n\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tnon-sequential insert (at possibly middle page)\n\t */\n\n\t/*\n\t * update prev pointer of previous right sibling page;\n\t */\n\tif (nextbn != 0) {\n\t\tDT_GETPAGE(ip, nextbn, mp, PSIZE, p, rc);\n\t\tif (rc) {\n\t\t\tdiscard_metapage(rmp);\n\t\t\treturn rc;\n\t\t}\n\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\t/*\n\t\t * acquire a transaction lock on the next page\n\t\t */\n\t\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckRELINK);\n\t\tjfs_info(\"dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p\",\n\t\t\ttlck, ip, mp);\n\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t\t/* linelock header of previous right sibling page */\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\n\t\tp->header.prev = cpu_to_le64(rbn);\n\n\t\tDT_PUTPAGE(mp);\n\t}\n\n\t/*\n\t * split the data between the split and right pages.\n\t */\n\tskip = split->index;\n\thalf = (PSIZE >> L2DTSLOTSIZE) >> 1;\t/* swag */\n\tleft = 0;\n\n\t/*\n\t *\tcompute fill factor for split pages\n\t *\n\t * <nxt> traces the next entry to move to rp\n\t * <off> traces the next entry to stay in sp\n\t */\n\tstbl = (u8 *) & sp->slot[sp->header.stblindex];\n\tnextindex = sp->header.nextindex;\n\tfor (nxt = off = 0; nxt < nextindex; ++off) {\n\t\tif (off == skip)\n\t\t\t/* check for fill factor with new entry size */\n\t\t\tn = split->nslot;\n\t\telse {\n\t\t\tsi = stbl[nxt];\n\t\t\tswitch (sp->header.flag & BT_TYPE) {\n\t\t\tcase BT_LEAF:\n\t\t\t\tldtentry = (struct ldtentry *) & sp->slot[si];\n\t\t\t\tif (DO_INDEX(ip))\n\t\t\t\t\tn = NDTLEAF(ldtentry->namlen);\n\t\t\t\telse\n\t\t\t\t\tn = NDTLEAF_LEGACY(ldtentry->\n\t\t\t\t\t\t\t   namlen);\n\t\t\t\tbreak;\n\n\t\t\tcase BT_INTERNAL:\n\t\t\t\tidtentry = (struct idtentry *) & sp->slot[si];\n\t\t\t\tn = NDTINTERNAL(idtentry->namlen);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t++nxt;\t/* advance to next entry to move in sp */\n\t\t}\n\n\t\tleft += n;\n\t\tif (left >= half)\n\t\t\tbreak;\n\t}\n\n\t/* <nxt> poins to the 1st entry to move */\n\n\t/*\n\t *\tmove entries to right page\n\t *\n\t * dtMoveEntry() initializes rp and reserves entry for insertion\n\t *\n\t * split page moved out entries are linelocked;\n\t * new/right page moved in entries are linelocked;\n\t */\n\t/* linelock header + stbl of new right page */\n\trlv = & rdtlck->lv[rdtlck->index];\n\trlv->offset = 0;\n\trlv->length = 5;\n\trdtlck->index++;\n\n\tdtMoveEntry(sp, nxt, rp, &sdtlck, &rdtlck, DO_INDEX(ip));\n\n\tsp->header.nextindex = nxt;\n\n\t/*\n\t * finalize freelist of new right page\n\t */\n\tfsi = rp->header.freelist;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\n\t\tmp = NULL;\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\n\t/*\n\t * the skipped index was on the left page,\n\t */\n\tif (skip <= off) {\n\t\t/* insert the new entry in the split page */\n\t\tdtInsertEntry(sp, skip, split->key, split->data, &sdtlck);\n\n\t\t/* linelock stbl of split page */\n\t\tif (sdtlck->index >= sdtlck->maxcnt)\n\t\t\tsdtlck = (struct dt_lock *) txLinelock(sdtlck);\n\t\tslv = & sdtlck->lv[sdtlck->index];\n\t\tn = skip >> L2DTSLOTSIZE;\n\t\tslv->offset = sp->header.stblindex + n;\n\t\tslv->length =\n\t\t    ((sp->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tsdtlck->index++;\n\t}\n\t/*\n\t * the skipped index was on the right page,\n\t */\n\telse {\n\t\t/* adjust the skip index to reflect the new position */\n\t\tskip -= nxt;\n\n\t\t/* insert the new entry in the right page */\n\t\tdtInsertEntry(rp, skip, split->key, split->data, &rdtlck);\n\t}\n\n      out:\n\t*rmpp = rmp;\n\t*rpxdp = *pxd;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtSplitRoot",
          "args": [
            "tid",
            "ip",
            "split",
            "&rmp"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "dtSplitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "1875-2070",
          "snippet": "static int dtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct metapage *smp;\n\tdtroot_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\n\ts64 rbn;\n\tint xlen;\n\tint xsize;\n\tstruct dtslot *f;\n\ts8 *stbl;\n\tint fsi, stblsize, n;\n\tstruct idtentry *s;\n\tpxd_t *ppxd;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint rc;\n\n\t/* get split root page */\n\tsmp = split->mp;\n\tsp = &JFS_IP(ip)->i_dtroot;\n\n\t/*\n\t *\tallocate/initialize a single (right) child page\n\t *\n\t * N.B. at first split, a one (or two) block to fit new entry\n\t * is allocated; at subsequent split, a full page is allocated;\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\trmp = get_metapage(ip, rbn, xsize, 1);\n\tif (!rmp)\n\t\treturn -EIO;\n\n\trp = rmp->data;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t *\tmove in-line root page into new right page extent\n\t */\n\t/* linelock header + copied entries + new stbl (1st slot) in new page */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = 10;\t/* 1 + 8 + 1 */\n\tdtlck->index++;\n\n\tn = xsize >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\n\n\t/* copy old stbl to new stbl at start of extended area */\n\trp->header.stblindex = DTROOTMAXSLOT;\n\tstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\n\tmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\n\trp->header.nextindex = sp->header.nextindex;\n\n\t/* copy old data area to start of new data area */\n\tmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = DTROOTMAXSLOT + stblsize;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\trp->header.freelist = n;\n\telse {\n\t\trp->header.freelist = fsi;\n\n\t\tdo {\n\t\t\tf = &rp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\trp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\t\tstruct metapage *mp = NULL;\n\t\tstruct ldtentry *ldtentry;\n\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tdtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\n\n\t/*\n\t *\treset parent/root page\n\t *\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t *\n\t * The btree comparison code guarantees that the left-most key on any\n\t * level of the tree is never used, so it doesn't need to be filled in.\n\t */\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode)\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\t/* update page header of root */\n\tif (sp->header.flag & BT_LEAF) {\n\t\tsp->header.flag &= ~BT_LEAF;\n\t\tsp->header.flag |= BT_INTERNAL;\n\t}\n\n\t/* init the first entry */\n\ts = (struct idtentry *) & sp->slot[DTENTRYSTART];\n\tppxd = (pxd_t *) s;\n\t*ppxd = *pxd;\n\ts->next = -1;\n\ts->namlen = 0;\n\n\tstbl = sp->header.stbl;\n\tstbl[0] = DTENTRYSTART;\n\tsp->header.nextindex = 1;\n\n\t/* init freelist */\n\tfsi = DTENTRYSTART + 1;\n\tf = &sp->slot[fsi];\n\n\t/* init free region of remaining area */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tsp->header.freelist = DTENTRYSTART + 1;\n\tsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\n\n\t*rmpp = rmp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitRoot(tid_t tid, struct inode *ip,\n\t\t       struct dtsplit * split, struct metapage ** rmpp);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitRoot(tid_t tid,\n\t    struct inode *ip, struct dtsplit * split, struct metapage ** rmpp)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct metapage *smp;\n\tdtroot_t *sp;\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\n\ts64 rbn;\n\tint xlen;\n\tint xsize;\n\tstruct dtslot *f;\n\ts8 *stbl;\n\tint fsi, stblsize, n;\n\tstruct idtentry *s;\n\tpxd_t *ppxd;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint rc;\n\n\t/* get split root page */\n\tsmp = split->mp;\n\tsp = &JFS_IP(ip)->i_dtroot;\n\n\t/*\n\t *\tallocate/initialize a single (right) child page\n\t *\n\t * N.B. at first split, a one (or two) block to fit new entry\n\t * is allocated; at subsequent split, a full page is allocated;\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\trbn = addressPXD(pxd);\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\trmp = get_metapage(ip, rbn, xsize, 1);\n\tif (!rmp)\n\t\treturn -EIO;\n\n\trp = rmp->data;\n\n\t/* Allocate blocks to quota. */\n\trc = dquot_alloc_block(ip, lengthPXD(pxd));\n\tif (rc) {\n\t\trelease_metapage(rmp);\n\t\treturn rc;\n\t}\n\n\tBT_MARK_DIRTY(rmp, ip);\n\t/*\n\t * acquire a transaction lock on the new right page\n\t */\n\ttlck = txLock(tid, ip, rmp, tlckDTREE | tlckNEW);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\trp->header.flag =\n\t    (sp->header.flag & BT_LEAF) ? BT_LEAF : BT_INTERNAL;\n\trp->header.self = *pxd;\n\n\t/* initialize sibling pointers */\n\trp->header.next = 0;\n\trp->header.prev = 0;\n\n\t/*\n\t *\tmove in-line root page into new right page extent\n\t */\n\t/* linelock header + copied entries + new stbl (1st slot) in new page */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = 10;\t/* 1 + 8 + 1 */\n\tdtlck->index++;\n\n\tn = xsize >> L2DTSLOTSIZE;\n\trp->header.maxslot = n;\n\tstblsize = (n + 31) >> L2DTSLOTSIZE;\n\n\t/* copy old stbl to new stbl at start of extended area */\n\trp->header.stblindex = DTROOTMAXSLOT;\n\tstbl = (s8 *) & rp->slot[DTROOTMAXSLOT];\n\tmemcpy(stbl, sp->header.stbl, sp->header.nextindex);\n\trp->header.nextindex = sp->header.nextindex;\n\n\t/* copy old data area to start of new data area */\n\tmemcpy(&rp->slot[1], &sp->slot[1], IDATASIZE);\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = DTROOTMAXSLOT + stblsize;\n\tf = &rp->slot[fsi];\n\tfor (fsi++; fsi < rp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\trp->header.freelist = n;\n\telse {\n\t\trp->header.freelist = fsi;\n\n\t\tdo {\n\t\t\tf = &rp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\trp->header.freecnt = sp->header.freecnt + rp->header.maxslot - n;\n\n\t/*\n\t * Update directory index table for entries now in right page\n\t */\n\tif ((rp->header.flag & BT_LEAF) && DO_INDEX(ip)) {\n\t\ts64 lblock;\n\t\tstruct metapage *mp = NULL;\n\t\tstruct ldtentry *ldtentry;\n\n\t\tstbl = DT_GETSTBL(rp);\n\t\tfor (n = 0; n < rp->header.nextindex; n++) {\n\t\t\tldtentry = (struct ldtentry *) & rp->slot[stbl[n]];\n\t\t\tmodify_index(tid, ip, le32_to_cpu(ldtentry->index),\n\t\t\t\t     rbn, n, &mp, &lblock);\n\t\t}\n\t\tif (mp)\n\t\t\trelease_metapage(mp);\n\t}\n\t/*\n\t * insert the new entry into the new right/child page\n\t * (skip index in the new right page will not change)\n\t */\n\tdtInsertEntry(rp, split->index, split->key, split->data, &dtlck);\n\n\t/*\n\t *\treset parent/root page\n\t *\n\t * set the 1st entry offset to 0, which force the left-most key\n\t * at any level of the tree to be less than any search key.\n\t *\n\t * The btree comparison code guarantees that the left-most key on any\n\t * level of the tree is never used, so it doesn't need to be filled in.\n\t */\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the root page (in-memory inode)\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckNEW | tlckBTROOT);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\n\t/* linelock root */\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\tlv->offset = 0;\n\tlv->length = DTROOTMAXSLOT;\n\tdtlck->index++;\n\n\t/* update page header of root */\n\tif (sp->header.flag & BT_LEAF) {\n\t\tsp->header.flag &= ~BT_LEAF;\n\t\tsp->header.flag |= BT_INTERNAL;\n\t}\n\n\t/* init the first entry */\n\ts = (struct idtentry *) & sp->slot[DTENTRYSTART];\n\tppxd = (pxd_t *) s;\n\t*ppxd = *pxd;\n\ts->next = -1;\n\ts->namlen = 0;\n\n\tstbl = sp->header.stbl;\n\tstbl[0] = DTENTRYSTART;\n\tsp->header.nextindex = 1;\n\n\t/* init freelist */\n\tfsi = DTENTRYSTART + 1;\n\tf = &sp->slot[fsi];\n\n\t/* init free region of remaining area */\n\tfor (fsi++; fsi < DTROOTMAXSLOT; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\tsp->header.freelist = DTENTRYSTART + 1;\n\tsp->header.freecnt = DTROOTMAXSLOT - (DTENTRYSTART + 1);\n\n\t*rmpp = rmp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "lmp"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"dtSplitUp(): UFO!\""
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDTINTERNAL",
          "args": [
            "key.namlen"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtGetKey",
          "args": [
            "rp",
            "0",
            "&key",
            "sbi->mntflag"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "dtGetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3843-3896",
          "snippet": "static void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void dtGetKey(dtpage_t * p, int i,\t/* entry index */\n\t\t     struct component_name * key, int flag)\n{\n\tint si;\n\ts8 *stbl;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint namlen, len;\n\twchar_t *kname;\n\t__le16 *name;\n\n\t/* get entry */\n\tstbl = DT_GETSTBL(p);\n\tsi = stbl[i];\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tnamlen = lh->namlen;\n\t\tname = lh->name;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tnamlen = ih->namlen;\n\t\tname = ih->name;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\tkey->namlen = namlen;\n\tkname = key->name;\n\n\t/*\n\t * move head/only segment\n\t */\n\tUniStrncpy_from_le(kname, name, len);\n\n\t/*\n\t * move additional segment(s)\n\t */\n\twhile (si >= 0) {\n\t\t/* get next segment */\n\t\tt = &p->slot[si];\n\t\tkname += len;\n\t\tnamlen -= len;\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tUniStrncpy_from_le(kname, t->name, len);\n\n\t\tsi = t->next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NDTINTERNAL",
          "args": [
            "key.namlen"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ciToUpper",
          "args": [
            "&key"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "lmp"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ciGetLeafPrefixKey",
          "args": [
            "lp",
            "lp->header.nextindex-1",
            "rp",
            "0",
            "&key",
            "sbi->mntflag"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "ciGetLeafPrefixKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3776-3834",
          "snippet": "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t       int ri, struct component_name * key, int flag)\n{\n\tint klen, namlen;\n\twchar_t *pl, *pr, *kname;\n\tstruct component_name lkey;\n\tstruct component_name rkey;\n\n\tlkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (lkey.name == NULL)\n\t\treturn -ENOMEM;\n\n\trkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (rkey.name == NULL) {\n\t\tkfree(lkey.name);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* get left and right key */\n\tdtGetKey(lp, li, &lkey, flag);\n\tlkey.name[lkey.namlen] = 0;\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&lkey);\n\n\tdtGetKey(rp, ri, &rkey, flag);\n\trkey.name[rkey.namlen] = 0;\n\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&rkey);\n\n\t/* compute prefix */\n\tklen = 0;\n\tkname = key->name;\n\tnamlen = min(lkey.namlen, rkey.namlen);\n\tfor (pl = lkey.name, pr = rkey.name;\n\t     namlen; pl++, pr++, namlen--, klen++, kname++) {\n\t\t*kname = *pr;\n\t\tif (*pl != *pr) {\n\t\t\tkey->namlen = klen + 1;\n\t\t\tgoto free_names;\n\t\t}\n\t}\n\n\t/* l->namlen <= r->namlen since l <= r */\n\tif (lkey.namlen < rkey.namlen) {\n\t\t*kname = *pr;\n\t\tkey->namlen = klen + 1;\n\t} else\t\t\t/* l->namelen == r->namelen */\n\t\tkey->namlen = klen;\n\nfree_names:\n\tkfree(lkey.name);\n\tkfree(rkey.name);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t       int ri, struct component_name * key, int flag)\n{\n\tint klen, namlen;\n\twchar_t *pl, *pr, *kname;\n\tstruct component_name lkey;\n\tstruct component_name rkey;\n\n\tlkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (lkey.name == NULL)\n\t\treturn -ENOMEM;\n\n\trkey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t),\n\t\t\t\t\tGFP_KERNEL);\n\tif (rkey.name == NULL) {\n\t\tkfree(lkey.name);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* get left and right key */\n\tdtGetKey(lp, li, &lkey, flag);\n\tlkey.name[lkey.namlen] = 0;\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&lkey);\n\n\tdtGetKey(rp, ri, &rkey, flag);\n\trkey.name[rkey.namlen] = 0;\n\n\n\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\tciToUpper(&rkey);\n\n\t/* compute prefix */\n\tklen = 0;\n\tkname = key->name;\n\tnamlen = min(lkey.namlen, rkey.namlen);\n\tfor (pl = lkey.name, pr = rkey.name;\n\t     namlen; pl++, pr++, namlen--, klen++, kname++) {\n\t\t*kname = *pr;\n\t\tif (*pl != *pr) {\n\t\t\tkey->namlen = klen + 1;\n\t\t\tgoto free_names;\n\t\t}\n\t}\n\n\t/* l->namlen <= r->namlen since l <= r */\n\tif (lkey.namlen < rkey.namlen) {\n\t\t*kname = *pr;\n\t\tkey->namlen = klen + 1;\n\t} else\t\t\t/* l->namelen == r->namelen */\n\t\tkey->namlen = klen;\n\nfree_names:\n\tkfree(lkey.name);\n\tkfree(rkey.name);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "lmp"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "parent->bn",
            "smp",
            "PSIZE",
            "sp",
            "rc"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_POP",
          "args": [
            "btstack"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PXDlength",
          "args": [
            "pxd",
            "xlen"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "PXDlength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "72-76",
          "snippet": "static inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDlength(pxd_t *pxd, __u32 len)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(~0xffffff)) |\n\t\t\tcpu_to_le32(len & 0xffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PXDaddress",
          "args": [
            "pxd",
            "xaddr"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "PXDaddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "78-83",
          "snippet": "static inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline void PXDaddress(pxd_t *pxd, __u64 addr)\n{\n\tpxd->len_addr = (pxd->len_addr & cpu_to_le32(0xffffff)) |\n\t\t\tcpu_to_le32((addr >> 32)<<24);\n\tpxd->addr2 = cpu_to_le32(addr & 0xffffffff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "0",
            "(s64) xlen",
            "&xaddr"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtExtendPage",
          "args": [
            "tid",
            "ip",
            "split",
            "btstack"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "dtExtendPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "1642-1854",
          "snippet": "static int dtExtendPage(tid_t tid,\n\t     struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint rc;\n\tstruct metapage *smp, *pmp, *mp;\n\tdtpage_t *sp, *pp;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd, *tpxd;\n\tint xlen, xsize;\n\tint newstblindex, newstblsize;\n\tint oldstblindex, oldstblsize;\n\tint fsi, last;\n\tstruct dtslot *f;\n\tstruct btframe *parent;\n\tint n;\n\tstruct dt_lock *dtlck;\n\ts64 xaddr, txaddr;\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\tstruct lv *lv;\n\tuint type;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\n\t/* get page to extend */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/* get parent/root page */\n\tparent = BT_POP(btstack);\n\tDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\n\tif (rc)\n\t\treturn (rc);\n\n\t/*\n\t *\textend the extent\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\n\txaddr = addressPXD(pxd);\n\ttpxd = &sp->header.self;\n\ttxaddr = addressPXD(tpxd);\n\t/* in-place extension */\n\tif (xaddr == txaddr) {\n\t\ttype = tlckEXTEND;\n\t}\n\t/* relocation */\n\telse {\n\t\ttype = tlckNEW;\n\n\t\t/* save moved extent descriptor for later free */\n\t\ttlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tpxdlock->pxd = sp->header.self;\n\t\tpxdlock->index = 1;\n\n\t\t/*\n\t\t * Update directory index table to reflect new page address\n\t\t */\n\t\tif (DO_INDEX(ip)) {\n\t\t\ts64 lblock;\n\n\t\t\tmp = NULL;\n\t\t\tstbl = DT_GETSTBL(sp);\n\t\t\tfor (n = 0; n < sp->header.nextindex; n++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & sp->slot[stbl[n]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     xaddr, n, &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t *\textend the page\n\t */\n\tsp->header.self = *pxd;\n\n\tjfs_info(\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\", ip, smp, sp);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the extended/leaf page\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | type);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[0];\n\n\t/* update buffer extent descriptor of extended page */\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\n\t/*\n\t * copy old stbl to new stbl at start of extended area\n\t */\n\toldstblindex = sp->header.stblindex;\n\toldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\n\tnewstblindex = sp->header.maxslot;\n\tn = xsize >> L2DTSLOTSIZE;\n\tnewstblsize = (n + 31) >> L2DTSLOTSIZE;\n\tmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\n\t       sp->header.nextindex);\n\n\t/*\n\t * in-line extension: linelock old area of extended page\n\t */\n\tif (type == tlckEXTEND) {\n\t\t/* linelock header */\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\t\tlv++;\n\n\t\t/* linelock new stbl of extended page */\n\t\tlv->offset = newstblindex;\n\t\tlv->length = newstblsize;\n\t}\n\t/*\n\t * relocation: linelock whole relocated area\n\t */\n\telse {\n\t\tlv->offset = 0;\n\t\tlv->length = sp->header.maxslot + newstblsize;\n\t}\n\n\tdtlck->index++;\n\n\tsp->header.maxslot = n;\n\tsp->header.stblindex = newstblindex;\n\t/* sp->header.nextindex remains the same */\n\n\t/*\n\t * add old stbl region at head of freelist\n\t */\n\tfsi = oldstblindex;\n\tf = &sp->slot[fsi];\n\tlast = sp->header.freelist;\n\tfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\n\t\tf->next = last;\n\t\tlast = fsi;\n\t}\n\tsp->header.freelist = last;\n\tsp->header.freecnt += oldstblsize;\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = newstblindex + newstblsize;\n\tf = &sp->slot[fsi];\n\tfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\tsp->header.freelist = n;\n\telse {\n\t\tdo {\n\t\t\tf = &sp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\tsp->header.freecnt += sp->header.maxslot - n;\n\n\t/*\n\t * insert the new entry\n\t */\n\tdtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\n\n\tBT_MARK_DIRTY(pmp, ip);\n\t/*\n\t * linelock any freeslots residing in old extent\n\t */\n\tif (type == tlckEXTEND) {\n\t\tn = sp->header.maxslot >> 2;\n\t\tif (sp->header.freelist < n)\n\t\t\tdtLinelockFreelist(sp, n, &dtlck);\n\t}\n\n\t/*\n\t *\tupdate parent entry on the parent/root page\n\t */\n\t/*\n\t * acquire a transaction lock on the parent/root page\n\t */\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* linelock parent entry - 1st slot */\n\tlv->offset = 1;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* update the parent pxd for page extension */\n\ttpxd = (pxd_t *) & pp->slot[1];\n\t*tpxd = *pxd;\n\n\tDT_PUTPAGE(pmp);\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtExtendPage(tid_t tid,\n\t     struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tint rc;\n\tstruct metapage *smp, *pmp, *mp;\n\tdtpage_t *sp, *pp;\n\tstruct pxdlist *pxdlist;\n\tpxd_t *pxd, *tpxd;\n\tint xlen, xsize;\n\tint newstblindex, newstblsize;\n\tint oldstblindex, oldstblsize;\n\tint fsi, last;\n\tstruct dtslot *f;\n\tstruct btframe *parent;\n\tint n;\n\tstruct dt_lock *dtlck;\n\ts64 xaddr, txaddr;\n\tstruct tlock *tlck;\n\tstruct pxd_lock *pxdlock;\n\tstruct lv *lv;\n\tuint type;\n\tstruct ldtentry *ldtentry;\n\tu8 *stbl;\n\n\t/* get page to extend */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\t/* get parent/root page */\n\tparent = BT_POP(btstack);\n\tDT_GETPAGE(ip, parent->bn, pmp, PSIZE, pp, rc);\n\tif (rc)\n\t\treturn (rc);\n\n\t/*\n\t *\textend the extent\n\t */\n\tpxdlist = split->pxdlist;\n\tpxd = &pxdlist->pxd[pxdlist->npxd];\n\tpxdlist->npxd++;\n\n\txaddr = addressPXD(pxd);\n\ttpxd = &sp->header.self;\n\ttxaddr = addressPXD(tpxd);\n\t/* in-place extension */\n\tif (xaddr == txaddr) {\n\t\ttype = tlckEXTEND;\n\t}\n\t/* relocation */\n\telse {\n\t\ttype = tlckNEW;\n\n\t\t/* save moved extent descriptor for later free */\n\t\ttlck = txMaplock(tid, ip, tlckDTREE | tlckRELOCATE);\n\t\tpxdlock = (struct pxd_lock *) & tlck->lock;\n\t\tpxdlock->flag = mlckFREEPXD;\n\t\tpxdlock->pxd = sp->header.self;\n\t\tpxdlock->index = 1;\n\n\t\t/*\n\t\t * Update directory index table to reflect new page address\n\t\t */\n\t\tif (DO_INDEX(ip)) {\n\t\t\ts64 lblock;\n\n\t\t\tmp = NULL;\n\t\t\tstbl = DT_GETSTBL(sp);\n\t\t\tfor (n = 0; n < sp->header.nextindex; n++) {\n\t\t\t\tldtentry =\n\t\t\t\t    (struct ldtentry *) & sp->slot[stbl[n]];\n\t\t\t\tmodify_index(tid, ip,\n\t\t\t\t\t     le32_to_cpu(ldtentry->index),\n\t\t\t\t\t     xaddr, n, &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t *\textend the page\n\t */\n\tsp->header.self = *pxd;\n\n\tjfs_info(\"dtExtendPage: ip:0x%p smp:0x%p sp:0x%p\", ip, smp, sp);\n\n\tBT_MARK_DIRTY(smp, ip);\n\t/*\n\t * acquire a transaction lock on the extended/leaf page\n\t */\n\ttlck = txLock(tid, ip, smp, tlckDTREE | type);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[0];\n\n\t/* update buffer extent descriptor of extended page */\n\txlen = lengthPXD(pxd);\n\txsize = xlen << JFS_SBI(sb)->l2bsize;\n\n\t/*\n\t * copy old stbl to new stbl at start of extended area\n\t */\n\toldstblindex = sp->header.stblindex;\n\toldstblsize = (sp->header.maxslot + 31) >> L2DTSLOTSIZE;\n\tnewstblindex = sp->header.maxslot;\n\tn = xsize >> L2DTSLOTSIZE;\n\tnewstblsize = (n + 31) >> L2DTSLOTSIZE;\n\tmemcpy(&sp->slot[newstblindex], &sp->slot[oldstblindex],\n\t       sp->header.nextindex);\n\n\t/*\n\t * in-line extension: linelock old area of extended page\n\t */\n\tif (type == tlckEXTEND) {\n\t\t/* linelock header */\n\t\tlv->offset = 0;\n\t\tlv->length = 1;\n\t\tdtlck->index++;\n\t\tlv++;\n\n\t\t/* linelock new stbl of extended page */\n\t\tlv->offset = newstblindex;\n\t\tlv->length = newstblsize;\n\t}\n\t/*\n\t * relocation: linelock whole relocated area\n\t */\n\telse {\n\t\tlv->offset = 0;\n\t\tlv->length = sp->header.maxslot + newstblsize;\n\t}\n\n\tdtlck->index++;\n\n\tsp->header.maxslot = n;\n\tsp->header.stblindex = newstblindex;\n\t/* sp->header.nextindex remains the same */\n\n\t/*\n\t * add old stbl region at head of freelist\n\t */\n\tfsi = oldstblindex;\n\tf = &sp->slot[fsi];\n\tlast = sp->header.freelist;\n\tfor (n = 0; n < oldstblsize; n++, fsi++, f++) {\n\t\tf->next = last;\n\t\tlast = fsi;\n\t}\n\tsp->header.freelist = last;\n\tsp->header.freecnt += oldstblsize;\n\n\t/*\n\t * append free region of newly extended area at tail of freelist\n\t */\n\t/* init free region of newly extended area */\n\tfsi = n = newstblindex + newstblsize;\n\tf = &sp->slot[fsi];\n\tfor (fsi++; fsi < sp->header.maxslot; f++, fsi++)\n\t\tf->next = fsi;\n\tf->next = -1;\n\n\t/* append new free region at tail of old freelist */\n\tfsi = sp->header.freelist;\n\tif (fsi == -1)\n\t\tsp->header.freelist = n;\n\telse {\n\t\tdo {\n\t\t\tf = &sp->slot[fsi];\n\t\t\tfsi = f->next;\n\t\t} while (fsi != -1);\n\n\t\tf->next = n;\n\t}\n\n\tsp->header.freecnt += sp->header.maxslot - n;\n\n\t/*\n\t * insert the new entry\n\t */\n\tdtInsertEntry(sp, split->index, split->key, split->data, &dtlck);\n\n\tBT_MARK_DIRTY(pmp, ip);\n\t/*\n\t * linelock any freeslots residing in old extent\n\t */\n\tif (type == tlckEXTEND) {\n\t\tn = sp->header.maxslot >> 2;\n\t\tif (sp->header.freelist < n)\n\t\t\tdtLinelockFreelist(sp, n, &dtlck);\n\t}\n\n\t/*\n\t *\tupdate parent entry on the parent/root page\n\t */\n\t/*\n\t * acquire a transaction lock on the parent/root page\n\t */\n\ttlck = txLock(tid, ip, pmp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tlv = & dtlck->lv[dtlck->index];\n\n\t/* linelock parent entry - 1st slot */\n\tlv->offset = 1;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\t/* update the parent pxd for page extension */\n\ttpxd = (pxd_t *) & pp->slot[1];\n\t*tpxd = *pxd;\n\n\tDT_PUTPAGE(pmp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbReAlloc",
          "args": [
            "sbi->ipbmap",
            "xaddr",
            "(s64) xlen",
            "(s64) n",
            "&nxaddr"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "dbReAlloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "977-1000",
          "snippet": "int\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);",
            "static int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);",
            "static int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);",
            "static int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocAny(struct bmap * bmp, s64 nblocks, int l2nb, s64 * results);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocNear(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks,\n\t\t       int l2nb, s64 * results);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmapLev(struct bmap * bmp, struct dmap * dp, int nblocks,\n\t\t\t  int l2nb,\n\t\t\t  s64 * results);\nstatic int dbAllocAG(struct bmap * bmp, int agno, s64 nblocks, int l2nb,\n\t\t     s64 * results);\nstatic int dbAllocCtl(struct bmap * bmp, s64 nblocks, int l2nb, s64 blkno,\n\t\t      s64 * results);\nstatic int dbExtend(struct inode *ip, s64 blkno, s64 nblocks, s64 addnblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint\ndbReAlloc(struct inode *ip,\n\t  s64 blkno, s64 nblocks, s64 addnblocks, s64 * results)\n{\n\tint rc;\n\n\t/* try to extend the allocation in place.\n\t */\n\tif ((rc = dbExtend(ip, blkno, nblocks, addnblocks)) == 0) {\n\t\t*results = blkno;\n\t\treturn (0);\n\t} else {\n\t\tif (rc != -ENOSPC)\n\t\t\treturn (rc);\n\t}\n\n\t/* could not extend the allocation in place, so allocate a\n\t * new set of blocks for the entire request (i.e. try to get\n\t * a range of contiguous blocks large enough to cover the\n\t * existing allocation plus the additional blocks.)\n\t */\n\treturn (dbAlloc\n\t\t(ip, blkno + nblocks - 1, addnblocks + nblocks, results));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "n"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "rmp"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "smp"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(JFS_NAME_MAX + 2) * sizeof(wchar_t)",
            "GFP_NOFS"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_PAGE",
          "args": [
            "ip",
            "smp"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitUp(tid_t tid,\n\t  struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page split from sp */\n\tpxd_t rpxd;\t\t/* new right page extent descriptor */\n\tstruct metapage *lmp;\n\tdtpage_t *lp;\t\t/* left child page */\n\tint skip;\t\t/* index of entry of insertion */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\ts64 xaddr, nxaddr;\n\tint xlen, xsize;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct component_name key = { 0, NULL };\n\tddata_t *data = split->data;\n\tint n;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint quota_allocation = 0;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\tkey.name = kmalloc((JFS_NAME_MAX + 2) * sizeof(wchar_t), GFP_NOFS);\n\tif (!key.name) {\n\t\tDT_PUTPAGE(smp);\n\t\trc = -ENOMEM;\n\t\tgoto dtSplitUp_Exit;\n\t}\n\n\t/*\n\t *\tsplit leaf page\n\t *\n\t * The split routines insert the new entry, and\n\t * acquire txLock as appropriate.\n\t */\n\t/*\n\t *\tsplit root leaf page:\n\t */\n\tif (sp->header.flag & BT_ROOT) {\n\t\t/*\n\t\t * allocate a single extent child page\n\t\t */\n\t\txlen = 1;\n\t\tn = sbi->bsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tn -= DTROOTMAXSLOT - sp->header.freecnt; /* header + entries */\n\t\tif (n <= split->nslot)\n\t\t\txlen++;\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\n\t\t\tDT_PUTPAGE(smp);\n\t\t\tgoto freeKeyName;\n\t\t}\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, xaddr);\n\t\tPXDlength(pxd, xlen);\n\t\tsplit->pxdlist = &pxdlist;\n\t\trc = dtSplitRoot(tid, ip, split, &rmp);\n\n\t\tif (rc)\n\t\t\tdbFree(ip, xaddr, xlen);\n\t\telse\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\tDT_PUTPAGE(smp);\n\n\t\tif (!DO_INDEX(ip))\n\t\t\tip->i_size = xlen << sbi->l2bsize;\n\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\textend first leaf page\n\t *\n\t * extend the 1st extent if less than buffer page size\n\t * (dtExtendPage() reurns leaf page unpinned)\n\t */\n\tpxd = &sp->header.self;\n\txlen = lengthPXD(pxd);\n\txsize = xlen << sbi->l2bsize;\n\tif (xsize < PSIZE) {\n\t\txaddr = addressPXD(pxd);\n\t\tn = xsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tif ((n + sp->header.freecnt) <= split->nslot)\n\t\t\tn = xlen + (xlen << 1);\n\t\telse\n\t\t\tn = xlen;\n\n\t\t/* Allocate blocks to quota. */\n\t\trc = dquot_alloc_block(ip, n);\n\t\tif (rc)\n\t\t\tgoto extendOut;\n\t\tquota_allocation += n;\n\n\t\tif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\n\t\t\t\t    (s64) n, &nxaddr)))\n\t\t\tgoto extendOut;\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, nxaddr);\n\t\tPXDlength(pxd, xlen + n);\n\t\tsplit->pxdlist = &pxdlist;\n\t\tif ((rc = dtExtendPage(tid, ip, split, btstack))) {\n\t\t\tnxaddr = addressPXD(pxd);\n\t\t\tif (xaddr != nxaddr) {\n\t\t\t\t/* free relocated extent */\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, nxaddr, (s64) xlen);\n\t\t\t} else {\n\t\t\t\t/* free extended delta */\n\t\t\t\txlen = lengthPXD(pxd) - n;\n\t\t\t\txaddr = addressPXD(pxd) + xlen;\n\t\t\t\tdbFree(ip, xaddr, (s64) n);\n\t\t\t}\n\t\t} else if (!DO_INDEX(ip))\n\t\t\tip->i_size = lengthPXD(pxd) << sbi->l2bsize;\n\n\n\t      extendOut:\n\t\tDT_PUTPAGE(smp);\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\tsplit leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * return <rp> pinned and its extent descriptor <rpxd>\n\t */\n\t/*\n\t * allocate new directory page extent and\n\t * new index page(s) to cover page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tn = btstack->nsplit;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\txlen = sbi->nbperpage;\n\tfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, xlen);\n\t\t\tpxdlist.maxnpxd++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tsplit->pxdlist = &pxdlist;\n\tif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size += PSIZE;\n\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 4 pages pinned at any time:\n\t * two children, left parent and right parent (when the parent splits).\n\t * keep the child pages pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages (<lp>, <rp>) pinned */\n\t\tlmp = smp;\n\t\tlp = sp;\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(lmp);\n\t\t\tDT_PUTPAGE(rmp);\n\t\t\tgoto splitOut;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * compute the key for the router entry\n\t\t *\n\t\t * key suffix compression:\n\t\t * for internal pages that have leaf pages as children,\n\t\t * retain only what's needed to distinguish between\n\t\t * the new entry and the entry on the page to its left.\n\t\t * If the keys compare equal, retain the entire key.\n\t\t *\n\t\t * note that compression is performed only at computing\n\t\t * router key at the lowest internal level.\n\t\t * further compression of the key between pairs of higher\n\t\t * level internal pages loses too much information and\n\t\t * the search may fail.\n\t\t * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}\n\t\t * results in two adjacent parent entries (a)(xx).\n\t\t * if split occurs between these two entries, and\n\t\t * if compression is applied, the router key of parent entry\n\t\t * of right page (x) will divert search for x into right\n\t\t * subtree and miss x in the left subtree.)\n\t\t *\n\t\t * the entire key must be retained for the next-to-leftmost\n\t\t * internal key at any level of the tree, or search may fail\n\t\t * (e.g., ?)\n\t\t */\n\t\tswitch (rp->header.flag & BT_TYPE) {\n\t\tcase BT_LEAF:\n\t\t\t/*\n\t\t\t * compute the length of prefix for suffix compression\n\t\t\t * between last entry of left page and first entry\n\t\t\t * of right page\n\t\t\t */\n\t\t\tif ((sp->header.flag & BT_ROOT && skip > 1) ||\n\t\t\t    sp->header.prev != 0 || skip > 1) {\n\t\t\t\t/* compute uppercase router prefix key */\n\t\t\t\trc = ciGetLeafPrefixKey(lp,\n\t\t\t\t\t\t\tlp->header.nextindex-1,\n\t\t\t\t\t\t\trp, 0, &key,\n\t\t\t\t\t\t\tsbi->mntflag);\n\t\t\t\tif (rc) {\n\t\t\t\t\tDT_PUTPAGE(lmp);\n\t\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\t\tgoto splitOut;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* next to leftmost entry of\n\t\t\t\t   lowest internal level */\n\n\t\t\t\t/* compute uppercase router key */\n\t\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\t\tkey.name[key.namlen] = 0;\n\n\t\t\t\tif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\n\t\t\t\t\tciToUpper(&key);\n\t\t\t}\n\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tcase BT_INTERNAL:\n\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"dtSplitUp(): UFO!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unpin left child page */\n\t\tDT_PUTPAGE(lmp);\n\n\t\t/*\n\t\t * compute the data for the router entry\n\t\t */\n\t\tdata->xd = rpxd;\t/* child page xd */\n\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (n > sp->header.freecnt) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->nslot = n;\n\t\t\tsplit->key = &key;\n\t\t\t/* split->data = data; */\n\n\t\t\t/* unpin right child page */\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    dtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\n\t\t\tif (rc) {\n\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\tgoto splitOut;\n\t\t\t}\n\n\t\t\t/* smp and rmp are pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert router entry in parent page\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\n\t\t\t/* linelock header */\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\n\t\t\t/* linelock stbl of non-root parent page */\n\t\t\tif (!(sp->header.flag & BT_ROOT)) {\n\t\t\t\tlv++;\n\t\t\t\tn = skip >> L2DTSLOTSIZE;\n\t\t\t\tlv->offset = sp->header.stblindex + n;\n\t\t\t\tlv->length =\n\t\t\t\t    ((sp->header.nextindex -\n\t\t\t\t      1) >> L2DTSLOTSIZE) - n + 1;\n\t\t\t\tdtlck->index++;\n\t\t\t}\n\n\t\t\tdtInsertEntry(sp, skip, &key, data, &dtlck);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current split and its right page */\n\tDT_PUTPAGE(smp);\n\tDT_PUTPAGE(rmp);\n\n\t/*\n\t * free remaining extents allocated for split\n\t */\n      splitOut:\n\tn = pxdlist.npxd;\n\tpxd = &pxdlist.pxd[n];\n\tfor (; n < pxdlist.maxnpxd; n++, pxd++)\n\t\tdbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\n\n      freeKeyName:\n\tkfree(key.name);\n\n\t/* Rollback quota allocation */\n\tif (rc && quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n      dtSplitUp_Exit:\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dtInsert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "821-916",
    "snippet": "int dtInsert(tid_t tid, struct inode *ip,\n\t struct component_name * name, ino_t * fsn, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\tdtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index;\n\tstruct dtsplit split;\t/* split information */\n\tddata_t data;\n\tstruct dt_lock *dtlck;\n\tint n;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\n\t/*\n\t *\tretrieve search result\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to insert).\n\t * n.b. dtSearch() may return index of (maxindex + 1) of\n\t * the full page.\n\t */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/*\n\t *\tinsert entry for new key\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (JFS_IP(ip)->next_index == DIREND) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -EMLINK;\n\t\t}\n\t\tn = NDTLEAF(name->namlen);\n\t\tdata.leaf.tid = tid;\n\t\tdata.leaf.ip = ip;\n\t} else {\n\t\tn = NDTLEAF_LEGACY(name->namlen);\n\t\tdata.leaf.ip = NULL;\t/* signifies legacy directory format */\n\t}\n\tdata.leaf.ino = *fsn;\n\n\t/*\n\t *\tleaf page does not have enough room for new entry:\n\t *\n\t *\textend/split the leaf page;\n\t *\n\t * dtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (n > p->header.freecnt) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.nslot = n;\n\t\tsplit.key = name;\n\t\tsplit.data = &data;\n\t\trc = dtSplitUp(tid, ip, &split, btstack);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tleaf page does have enough room for new entry:\n\t *\n\t *\tinsert the new data entry into the leaf page;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t/* linelock header */\n\tlv->offset = 0;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\tdtInsertEntry(p, index, name, &data, &dtlck);\n\n\t/* linelock stbl of non-root leaf page */\n\tif (!(p->header.flag & BT_ROOT)) {\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tn = index >> L2DTSLOTSIZE;\n\t\tlv->offset = p->header.stblindex + n;\n\t\tlv->length =\n\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tdtlck->index++;\n\t}\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
      "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "dtlck"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtInsertEntry",
          "args": [
            "p",
            "index",
            "name",
            "&data",
            "&dtlck"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "dtInsertEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3907-4054",
          "snippet": "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);",
            "static void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);",
            "static void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);",
            "static void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\nstatic void dtDeleteEntry(dtpage_t * p, int fi, struct dt_lock ** dtlock);\nstatic void dtTruncateEntry(dtpage_t * p, int ti, struct dt_lock ** dtlock);\nstatic void dtLinelockFreelist(dtpage_t * p, int m, struct dt_lock ** dtlock);\n\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock ** dtlock)\n{\n\tstruct dtslot *h, *t;\n\tstruct ldtentry *lh = NULL;\n\tstruct idtentry *ih = NULL;\n\tint hsi, fsi, klen, len, nextindex;\n\twchar_t *kname;\n\t__le16 *name;\n\ts8 *stbl;\n\tpxd_t *xd;\n\tstruct dt_lock *dtlck = *dtlock;\n\tstruct lv *lv;\n\tint xsi, n;\n\ts64 bn = 0;\n\tstruct metapage *mp = NULL;\n\n\tklen = key->namlen;\n\tkname = key->name;\n\n\t/* allocate a free slot */\n\thsi = fsi = p->header.freelist;\n\th = &p->slot[fsi];\n\tp->header.freelist = h->next;\n\t--p->header.freecnt;\n\n\t/* open new linelock */\n\tif (dtlck->index >= dtlck->maxcnt)\n\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\n\tlv = & dtlck->lv[dtlck->index];\n\tlv->offset = hsi;\n\n\t/* write head/only segment */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) h;\n\t\tlh->next = h->next;\n\t\tlh->inumber = cpu_to_le32(data->leaf.ino);\n\t\tlh->namlen = klen;\n\t\tname = lh->name;\n\t\tif (data->leaf.ip) {\n\t\t\tlen = min(klen, DTLHDRDATALEN);\n\t\t\tif (!(p->header.flag & BT_ROOT))\n\t\t\t\tbn = addressPXD(&p->header.self);\n\t\t\tlh->index = cpu_to_le32(add_index(data->leaf.tid,\n\t\t\t\t\t\t\t  data->leaf.ip,\n\t\t\t\t\t\t\t  bn, index));\n\t\t} else\n\t\t\tlen = min(klen, DTLHDRDATALEN_LEGACY);\n\t} else {\n\t\tih = (struct idtentry *) h;\n\t\tih->next = h->next;\n\t\txd = (pxd_t *) ih;\n\t\t*xd = data->xd;\n\t\tih->namlen = klen;\n\t\tname = ih->name;\n\t\tlen = min(klen, DTIHDRDATALEN);\n\t}\n\n\tUniStrncpy_to_le(name, kname, len);\n\n\tn = 1;\n\txsi = hsi;\n\n\t/* write additional segment(s) */\n\tt = h;\n\tklen -= len;\n\twhile (klen) {\n\t\t/* get free slot */\n\t\tfsi = p->header.freelist;\n\t\tt = &p->slot[fsi];\n\t\tp->header.freelist = t->next;\n\t\t--p->header.freecnt;\n\n\t\t/* is next slot contiguous ? */\n\t\tif (fsi != xsi + 1) {\n\t\t\t/* close current linelock */\n\t\t\tlv->length = n;\n\t\t\tdtlck->index++;\n\n\t\t\t/* open new linelock */\n\t\t\tif (dtlck->index < dtlck->maxcnt)\n\t\t\t\tlv++;\n\t\t\telse {\n\t\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\t\t\tlv = & dtlck->lv[0];\n\t\t\t}\n\n\t\t\tlv->offset = fsi;\n\t\t\tn = 0;\n\t\t}\n\n\t\tkname += len;\n\t\tlen = min(klen, DTSLOTDATALEN);\n\t\tUniStrncpy_to_le(t->name, kname, len);\n\n\t\tn++;\n\t\txsi = fsi;\n\t\tklen -= len;\n\t}\n\n\t/* close current linelock */\n\tlv->length = n;\n\tdtlck->index++;\n\n\t*dtlock = dtlck;\n\n\t/* terminate last/only segment */\n\tif (h == t) {\n\t\t/* single segment entry */\n\t\tif (p->header.flag & BT_LEAF)\n\t\t\tlh->next = -1;\n\t\telse\n\t\t\tih->next = -1;\n\t} else\n\t\t/* multi-segment entry */\n\t\tt->next = -1;\n\n\t/* if insert into middle, shift right succeeding entries in stbl */\n\tstbl = DT_GETSTBL(p);\n\tnextindex = p->header.nextindex;\n\tif (index < nextindex) {\n\t\tmemmove(stbl + index + 1, stbl + index, nextindex - index);\n\n\t\tif ((p->header.flag & BT_LEAF) && data->leaf.ip) {\n\t\t\ts64 lblock;\n\n\t\t\t/*\n\t\t\t * Need to update slot number for entries that moved\n\t\t\t * in the stbl\n\t\t\t */\n\t\t\tmp = NULL;\n\t\t\tfor (n = index + 1; n <= nextindex; n++) {\n\t\t\t\tlh = (struct ldtentry *) & (p->slot[stbl[n]]);\n\t\t\t\tmodify_index(data->leaf.tid, data->leaf.ip,\n\t\t\t\t\t     le32_to_cpu(lh->index), bn, n,\n\t\t\t\t\t     &mp, &lblock);\n\t\t\t}\n\t\t\tif (mp)\n\t\t\t\trelease_metapage(mp);\n\t\t}\n\t}\n\n\tstbl[index] = hsi;\n\n\t/* advance next available entry index of stbl */\n\t++p->header.nextindex;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dtlck->index == 0"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDTREE | tlckENTRY"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_MARK_DIRTY",
          "args": [
            "mp",
            "ip"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dtSplitUp",
          "args": [
            "tid",
            "ip",
            "&split",
            "btstack"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "dtSplitUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "930-1316",
          "snippet": "static int dtSplitUp(tid_t tid,\n\t  struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page split from sp */\n\tpxd_t rpxd;\t\t/* new right page extent descriptor */\n\tstruct metapage *lmp;\n\tdtpage_t *lp;\t\t/* left child page */\n\tint skip;\t\t/* index of entry of insertion */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\ts64 xaddr, nxaddr;\n\tint xlen, xsize;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct component_name key = { 0, NULL };\n\tddata_t *data = split->data;\n\tint n;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint quota_allocation = 0;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\tkey.name = kmalloc((JFS_NAME_MAX + 2) * sizeof(wchar_t), GFP_NOFS);\n\tif (!key.name) {\n\t\tDT_PUTPAGE(smp);\n\t\trc = -ENOMEM;\n\t\tgoto dtSplitUp_Exit;\n\t}\n\n\t/*\n\t *\tsplit leaf page\n\t *\n\t * The split routines insert the new entry, and\n\t * acquire txLock as appropriate.\n\t */\n\t/*\n\t *\tsplit root leaf page:\n\t */\n\tif (sp->header.flag & BT_ROOT) {\n\t\t/*\n\t\t * allocate a single extent child page\n\t\t */\n\t\txlen = 1;\n\t\tn = sbi->bsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tn -= DTROOTMAXSLOT - sp->header.freecnt; /* header + entries */\n\t\tif (n <= split->nslot)\n\t\t\txlen++;\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\n\t\t\tDT_PUTPAGE(smp);\n\t\t\tgoto freeKeyName;\n\t\t}\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, xaddr);\n\t\tPXDlength(pxd, xlen);\n\t\tsplit->pxdlist = &pxdlist;\n\t\trc = dtSplitRoot(tid, ip, split, &rmp);\n\n\t\tif (rc)\n\t\t\tdbFree(ip, xaddr, xlen);\n\t\telse\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\tDT_PUTPAGE(smp);\n\n\t\tif (!DO_INDEX(ip))\n\t\t\tip->i_size = xlen << sbi->l2bsize;\n\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\textend first leaf page\n\t *\n\t * extend the 1st extent if less than buffer page size\n\t * (dtExtendPage() reurns leaf page unpinned)\n\t */\n\tpxd = &sp->header.self;\n\txlen = lengthPXD(pxd);\n\txsize = xlen << sbi->l2bsize;\n\tif (xsize < PSIZE) {\n\t\txaddr = addressPXD(pxd);\n\t\tn = xsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tif ((n + sp->header.freecnt) <= split->nslot)\n\t\t\tn = xlen + (xlen << 1);\n\t\telse\n\t\t\tn = xlen;\n\n\t\t/* Allocate blocks to quota. */\n\t\trc = dquot_alloc_block(ip, n);\n\t\tif (rc)\n\t\t\tgoto extendOut;\n\t\tquota_allocation += n;\n\n\t\tif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\n\t\t\t\t    (s64) n, &nxaddr)))\n\t\t\tgoto extendOut;\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, nxaddr);\n\t\tPXDlength(pxd, xlen + n);\n\t\tsplit->pxdlist = &pxdlist;\n\t\tif ((rc = dtExtendPage(tid, ip, split, btstack))) {\n\t\t\tnxaddr = addressPXD(pxd);\n\t\t\tif (xaddr != nxaddr) {\n\t\t\t\t/* free relocated extent */\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, nxaddr, (s64) xlen);\n\t\t\t} else {\n\t\t\t\t/* free extended delta */\n\t\t\t\txlen = lengthPXD(pxd) - n;\n\t\t\t\txaddr = addressPXD(pxd) + xlen;\n\t\t\t\tdbFree(ip, xaddr, (s64) n);\n\t\t\t}\n\t\t} else if (!DO_INDEX(ip))\n\t\t\tip->i_size = lengthPXD(pxd) << sbi->l2bsize;\n\n\n\t      extendOut:\n\t\tDT_PUTPAGE(smp);\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\tsplit leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * return <rp> pinned and its extent descriptor <rpxd>\n\t */\n\t/*\n\t * allocate new directory page extent and\n\t * new index page(s) to cover page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tn = btstack->nsplit;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\txlen = sbi->nbperpage;\n\tfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, xlen);\n\t\t\tpxdlist.maxnpxd++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tsplit->pxdlist = &pxdlist;\n\tif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size += PSIZE;\n\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 4 pages pinned at any time:\n\t * two children, left parent and right parent (when the parent splits).\n\t * keep the child pages pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages (<lp>, <rp>) pinned */\n\t\tlmp = smp;\n\t\tlp = sp;\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(lmp);\n\t\t\tDT_PUTPAGE(rmp);\n\t\t\tgoto splitOut;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * compute the key for the router entry\n\t\t *\n\t\t * key suffix compression:\n\t\t * for internal pages that have leaf pages as children,\n\t\t * retain only what's needed to distinguish between\n\t\t * the new entry and the entry on the page to its left.\n\t\t * If the keys compare equal, retain the entire key.\n\t\t *\n\t\t * note that compression is performed only at computing\n\t\t * router key at the lowest internal level.\n\t\t * further compression of the key between pairs of higher\n\t\t * level internal pages loses too much information and\n\t\t * the search may fail.\n\t\t * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}\n\t\t * results in two adjacent parent entries (a)(xx).\n\t\t * if split occurs between these two entries, and\n\t\t * if compression is applied, the router key of parent entry\n\t\t * of right page (x) will divert search for x into right\n\t\t * subtree and miss x in the left subtree.)\n\t\t *\n\t\t * the entire key must be retained for the next-to-leftmost\n\t\t * internal key at any level of the tree, or search may fail\n\t\t * (e.g., ?)\n\t\t */\n\t\tswitch (rp->header.flag & BT_TYPE) {\n\t\tcase BT_LEAF:\n\t\t\t/*\n\t\t\t * compute the length of prefix for suffix compression\n\t\t\t * between last entry of left page and first entry\n\t\t\t * of right page\n\t\t\t */\n\t\t\tif ((sp->header.flag & BT_ROOT && skip > 1) ||\n\t\t\t    sp->header.prev != 0 || skip > 1) {\n\t\t\t\t/* compute uppercase router prefix key */\n\t\t\t\trc = ciGetLeafPrefixKey(lp,\n\t\t\t\t\t\t\tlp->header.nextindex-1,\n\t\t\t\t\t\t\trp, 0, &key,\n\t\t\t\t\t\t\tsbi->mntflag);\n\t\t\t\tif (rc) {\n\t\t\t\t\tDT_PUTPAGE(lmp);\n\t\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\t\tgoto splitOut;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* next to leftmost entry of\n\t\t\t\t   lowest internal level */\n\n\t\t\t\t/* compute uppercase router key */\n\t\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\t\tkey.name[key.namlen] = 0;\n\n\t\t\t\tif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\n\t\t\t\t\tciToUpper(&key);\n\t\t\t}\n\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tcase BT_INTERNAL:\n\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"dtSplitUp(): UFO!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unpin left child page */\n\t\tDT_PUTPAGE(lmp);\n\n\t\t/*\n\t\t * compute the data for the router entry\n\t\t */\n\t\tdata->xd = rpxd;\t/* child page xd */\n\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (n > sp->header.freecnt) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->nslot = n;\n\t\t\tsplit->key = &key;\n\t\t\t/* split->data = data; */\n\n\t\t\t/* unpin right child page */\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    dtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\n\t\t\tif (rc) {\n\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\tgoto splitOut;\n\t\t\t}\n\n\t\t\t/* smp and rmp are pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert router entry in parent page\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\n\t\t\t/* linelock header */\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\n\t\t\t/* linelock stbl of non-root parent page */\n\t\t\tif (!(sp->header.flag & BT_ROOT)) {\n\t\t\t\tlv++;\n\t\t\t\tn = skip >> L2DTSLOTSIZE;\n\t\t\t\tlv->offset = sp->header.stblindex + n;\n\t\t\t\tlv->length =\n\t\t\t\t    ((sp->header.nextindex -\n\t\t\t\t      1) >> L2DTSLOTSIZE) - n + 1;\n\t\t\t\tdtlck->index++;\n\t\t\t}\n\n\t\t\tdtInsertEntry(sp, skip, &key, data, &dtlck);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current split and its right page */\n\tDT_PUTPAGE(smp);\n\tDT_PUTPAGE(rmp);\n\n\t/*\n\t * free remaining extents allocated for split\n\t */\n      splitOut:\n\tn = pxdlist.npxd;\n\tpxd = &pxdlist.pxd[n];\n\tfor (; n < pxdlist.maxnpxd; n++, pxd++)\n\t\tdbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\n\n      freeKeyName:\n\tkfree(key.name);\n\n\t/* Rollback quota allocation */\n\tif (rc && quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n      dtSplitUp_Exit:\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
            "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
            "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
            "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
            "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);",
            "static void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nstatic int dtSplitUp(tid_t tid,\n\t  struct inode *ip, struct dtsplit * split, struct btstack * btstack)\n{\n\tstruct jfs_sb_info *sbi = JFS_SBI(ip->i_sb);\n\tint rc = 0;\n\tstruct metapage *smp;\n\tdtpage_t *sp;\t\t/* split page */\n\tstruct metapage *rmp;\n\tdtpage_t *rp;\t\t/* new right page split from sp */\n\tpxd_t rpxd;\t\t/* new right page extent descriptor */\n\tstruct metapage *lmp;\n\tdtpage_t *lp;\t\t/* left child page */\n\tint skip;\t\t/* index of entry of insertion */\n\tstruct btframe *parent;\t/* parent page entry on traverse stack */\n\ts64 xaddr, nxaddr;\n\tint xlen, xsize;\n\tstruct pxdlist pxdlist;\n\tpxd_t *pxd;\n\tstruct component_name key = { 0, NULL };\n\tddata_t *data = split->data;\n\tint n;\n\tstruct dt_lock *dtlck;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\tint quota_allocation = 0;\n\n\t/* get split page */\n\tsmp = split->mp;\n\tsp = DT_PAGE(ip, smp);\n\n\tkey.name = kmalloc((JFS_NAME_MAX + 2) * sizeof(wchar_t), GFP_NOFS);\n\tif (!key.name) {\n\t\tDT_PUTPAGE(smp);\n\t\trc = -ENOMEM;\n\t\tgoto dtSplitUp_Exit;\n\t}\n\n\t/*\n\t *\tsplit leaf page\n\t *\n\t * The split routines insert the new entry, and\n\t * acquire txLock as appropriate.\n\t */\n\t/*\n\t *\tsplit root leaf page:\n\t */\n\tif (sp->header.flag & BT_ROOT) {\n\t\t/*\n\t\t * allocate a single extent child page\n\t\t */\n\t\txlen = 1;\n\t\tn = sbi->bsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tn -= DTROOTMAXSLOT - sp->header.freecnt; /* header + entries */\n\t\tif (n <= split->nslot)\n\t\t\txlen++;\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr))) {\n\t\t\tDT_PUTPAGE(smp);\n\t\t\tgoto freeKeyName;\n\t\t}\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, xaddr);\n\t\tPXDlength(pxd, xlen);\n\t\tsplit->pxdlist = &pxdlist;\n\t\trc = dtSplitRoot(tid, ip, split, &rmp);\n\n\t\tif (rc)\n\t\t\tdbFree(ip, xaddr, xlen);\n\t\telse\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\tDT_PUTPAGE(smp);\n\n\t\tif (!DO_INDEX(ip))\n\t\t\tip->i_size = xlen << sbi->l2bsize;\n\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\textend first leaf page\n\t *\n\t * extend the 1st extent if less than buffer page size\n\t * (dtExtendPage() reurns leaf page unpinned)\n\t */\n\tpxd = &sp->header.self;\n\txlen = lengthPXD(pxd);\n\txsize = xlen << sbi->l2bsize;\n\tif (xsize < PSIZE) {\n\t\txaddr = addressPXD(pxd);\n\t\tn = xsize >> L2DTSLOTSIZE;\n\t\tn -= (n + 31) >> L2DTSLOTSIZE;\t/* stbl size */\n\t\tif ((n + sp->header.freecnt) <= split->nslot)\n\t\t\tn = xlen + (xlen << 1);\n\t\telse\n\t\t\tn = xlen;\n\n\t\t/* Allocate blocks to quota. */\n\t\trc = dquot_alloc_block(ip, n);\n\t\tif (rc)\n\t\t\tgoto extendOut;\n\t\tquota_allocation += n;\n\n\t\tif ((rc = dbReAlloc(sbi->ipbmap, xaddr, (s64) xlen,\n\t\t\t\t    (s64) n, &nxaddr)))\n\t\t\tgoto extendOut;\n\n\t\tpxdlist.maxnpxd = 1;\n\t\tpxdlist.npxd = 0;\n\t\tpxd = &pxdlist.pxd[0];\n\t\tPXDaddress(pxd, nxaddr);\n\t\tPXDlength(pxd, xlen + n);\n\t\tsplit->pxdlist = &pxdlist;\n\t\tif ((rc = dtExtendPage(tid, ip, split, btstack))) {\n\t\t\tnxaddr = addressPXD(pxd);\n\t\t\tif (xaddr != nxaddr) {\n\t\t\t\t/* free relocated extent */\n\t\t\t\txlen = lengthPXD(pxd);\n\t\t\t\tdbFree(ip, nxaddr, (s64) xlen);\n\t\t\t} else {\n\t\t\t\t/* free extended delta */\n\t\t\t\txlen = lengthPXD(pxd) - n;\n\t\t\t\txaddr = addressPXD(pxd) + xlen;\n\t\t\t\tdbFree(ip, xaddr, (s64) n);\n\t\t\t}\n\t\t} else if (!DO_INDEX(ip))\n\t\t\tip->i_size = lengthPXD(pxd) << sbi->l2bsize;\n\n\n\t      extendOut:\n\t\tDT_PUTPAGE(smp);\n\t\tgoto freeKeyName;\n\t}\n\n\t/*\n\t *\tsplit leaf page <sp> into <sp> and a new right page <rp>.\n\t *\n\t * return <rp> pinned and its extent descriptor <rpxd>\n\t */\n\t/*\n\t * allocate new directory page extent and\n\t * new index page(s) to cover page split(s)\n\t *\n\t * allocation hint: ?\n\t */\n\tn = btstack->nsplit;\n\tpxdlist.maxnpxd = pxdlist.npxd = 0;\n\txlen = sbi->nbperpage;\n\tfor (pxd = pxdlist.pxd; n > 0; n--, pxd++) {\n\t\tif ((rc = dbAlloc(ip, 0, (s64) xlen, &xaddr)) == 0) {\n\t\t\tPXDaddress(pxd, xaddr);\n\t\t\tPXDlength(pxd, xlen);\n\t\t\tpxdlist.maxnpxd++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tsplit->pxdlist = &pxdlist;\n\tif ((rc = dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd))) {\n\t\tDT_PUTPAGE(smp);\n\n\t\t/* undo allocation */\n\t\tgoto splitOut;\n\t}\n\n\tif (!DO_INDEX(ip))\n\t\tip->i_size += PSIZE;\n\n\t/*\n\t * propagate up the router entry for the leaf page just split\n\t *\n\t * insert a router entry for the new page into the parent page,\n\t * propagate the insert/split up the tree by walking back the stack\n\t * of (bn of parent page, index of child page entry in parent page)\n\t * that were traversed during the search for the page that split.\n\t *\n\t * the propagation of insert/split up the tree stops if the root\n\t * splits or the page inserted into doesn't have to split to hold\n\t * the new entry.\n\t *\n\t * the parent entry for the split page remains the same, and\n\t * a new entry is inserted at its right with the first key and\n\t * block number of the new right page.\n\t *\n\t * There are a maximum of 4 pages pinned at any time:\n\t * two children, left parent and right parent (when the parent splits).\n\t * keep the child pages pinned while working on the parent.\n\t * make sure that all pins are released at exit.\n\t */\n\twhile ((parent = BT_POP(btstack)) != NULL) {\n\t\t/* parent page specified by stack frame <parent> */\n\n\t\t/* keep current child pages (<lp>, <rp>) pinned */\n\t\tlmp = smp;\n\t\tlp = sp;\n\n\t\t/*\n\t\t * insert router entry in parent for new right child page <rp>\n\t\t */\n\t\t/* get the parent page <sp> */\n\t\tDT_GETPAGE(ip, parent->bn, smp, PSIZE, sp, rc);\n\t\tif (rc) {\n\t\t\tDT_PUTPAGE(lmp);\n\t\t\tDT_PUTPAGE(rmp);\n\t\t\tgoto splitOut;\n\t\t}\n\n\t\t/*\n\t\t * The new key entry goes ONE AFTER the index of parent entry,\n\t\t * because the split was to the right.\n\t\t */\n\t\tskip = parent->index + 1;\n\n\t\t/*\n\t\t * compute the key for the router entry\n\t\t *\n\t\t * key suffix compression:\n\t\t * for internal pages that have leaf pages as children,\n\t\t * retain only what's needed to distinguish between\n\t\t * the new entry and the entry on the page to its left.\n\t\t * If the keys compare equal, retain the entire key.\n\t\t *\n\t\t * note that compression is performed only at computing\n\t\t * router key at the lowest internal level.\n\t\t * further compression of the key between pairs of higher\n\t\t * level internal pages loses too much information and\n\t\t * the search may fail.\n\t\t * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}\n\t\t * results in two adjacent parent entries (a)(xx).\n\t\t * if split occurs between these two entries, and\n\t\t * if compression is applied, the router key of parent entry\n\t\t * of right page (x) will divert search for x into right\n\t\t * subtree and miss x in the left subtree.)\n\t\t *\n\t\t * the entire key must be retained for the next-to-leftmost\n\t\t * internal key at any level of the tree, or search may fail\n\t\t * (e.g., ?)\n\t\t */\n\t\tswitch (rp->header.flag & BT_TYPE) {\n\t\tcase BT_LEAF:\n\t\t\t/*\n\t\t\t * compute the length of prefix for suffix compression\n\t\t\t * between last entry of left page and first entry\n\t\t\t * of right page\n\t\t\t */\n\t\t\tif ((sp->header.flag & BT_ROOT && skip > 1) ||\n\t\t\t    sp->header.prev != 0 || skip > 1) {\n\t\t\t\t/* compute uppercase router prefix key */\n\t\t\t\trc = ciGetLeafPrefixKey(lp,\n\t\t\t\t\t\t\tlp->header.nextindex-1,\n\t\t\t\t\t\t\trp, 0, &key,\n\t\t\t\t\t\t\tsbi->mntflag);\n\t\t\t\tif (rc) {\n\t\t\t\t\tDT_PUTPAGE(lmp);\n\t\t\t\t\tDT_PUTPAGE(rmp);\n\t\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\t\tgoto splitOut;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* next to leftmost entry of\n\t\t\t\t   lowest internal level */\n\n\t\t\t\t/* compute uppercase router key */\n\t\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\t\tkey.name[key.namlen] = 0;\n\n\t\t\t\tif ((sbi->mntflag & JFS_OS2) == JFS_OS2)\n\t\t\t\t\tciToUpper(&key);\n\t\t\t}\n\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tcase BT_INTERNAL:\n\t\t\tdtGetKey(rp, 0, &key, sbi->mntflag);\n\t\t\tn = NDTINTERNAL(key.namlen);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tjfs_err(\"dtSplitUp(): UFO!\");\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unpin left child page */\n\t\tDT_PUTPAGE(lmp);\n\n\t\t/*\n\t\t * compute the data for the router entry\n\t\t */\n\t\tdata->xd = rpxd;\t/* child page xd */\n\n\t\t/*\n\t\t * parent page is full - split the parent page\n\t\t */\n\t\tif (n > sp->header.freecnt) {\n\t\t\t/* init for parent page split */\n\t\t\tsplit->mp = smp;\n\t\t\tsplit->index = skip;\t/* index at insert */\n\t\t\tsplit->nslot = n;\n\t\t\tsplit->key = &key;\n\t\t\t/* split->data = data; */\n\n\t\t\t/* unpin right child page */\n\t\t\tDT_PUTPAGE(rmp);\n\n\t\t\t/* The split routines insert the new entry,\n\t\t\t * acquire txLock as appropriate.\n\t\t\t * return <rp> pinned and its block number <rbn>.\n\t\t\t */\n\t\t\trc = (sp->header.flag & BT_ROOT) ?\n\t\t\t    dtSplitRoot(tid, ip, split, &rmp) :\n\t\t\t    dtSplitPage(tid, ip, split, &rmp, &rp, &rpxd);\n\t\t\tif (rc) {\n\t\t\t\tDT_PUTPAGE(smp);\n\t\t\t\tgoto splitOut;\n\t\t\t}\n\n\t\t\t/* smp and rmp are pinned */\n\t\t}\n\t\t/*\n\t\t * parent page is not full - insert router entry in parent page\n\t\t */\n\t\telse {\n\t\t\tBT_MARK_DIRTY(smp, ip);\n\t\t\t/*\n\t\t\t * acquire a transaction lock on the parent page\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, smp, tlckDTREE | tlckENTRY);\n\t\t\tdtlck = (struct dt_lock *) & tlck->lock;\n\t\t\tASSERT(dtlck->index == 0);\n\t\t\tlv = & dtlck->lv[0];\n\n\t\t\t/* linelock header */\n\t\t\tlv->offset = 0;\n\t\t\tlv->length = 1;\n\t\t\tdtlck->index++;\n\n\t\t\t/* linelock stbl of non-root parent page */\n\t\t\tif (!(sp->header.flag & BT_ROOT)) {\n\t\t\t\tlv++;\n\t\t\t\tn = skip >> L2DTSLOTSIZE;\n\t\t\t\tlv->offset = sp->header.stblindex + n;\n\t\t\t\tlv->length =\n\t\t\t\t    ((sp->header.nextindex -\n\t\t\t\t      1) >> L2DTSLOTSIZE) - n + 1;\n\t\t\t\tdtlck->index++;\n\t\t\t}\n\n\t\t\tdtInsertEntry(sp, skip, &key, data, &dtlck);\n\n\t\t\t/* exit propagate up */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* unpin current split and its right page */\n\tDT_PUTPAGE(smp);\n\tDT_PUTPAGE(rmp);\n\n\t/*\n\t * free remaining extents allocated for split\n\t */\n      splitOut:\n\tn = pxdlist.npxd;\n\tpxd = &pxdlist.pxd[n];\n\tfor (; n < pxdlist.maxnpxd; n++, pxd++)\n\t\tdbFree(ip, addressPXD(pxd), (s64) lengthPXD(pxd));\n\n      freeKeyName:\n\tkfree(key.name);\n\n\t/* Rollback quota allocation */\n\tif (rc && quota_allocation)\n\t\tdquot_free_block(ip, quota_allocation);\n\n      dtSplitUp_Exit:\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NDTLEAF_LEGACY",
          "args": [
            "name->namlen"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NDTLEAF",
          "args": [
            "name->namlen"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETSEARCH",
          "args": [
            "ip",
            "btstack->top",
            "bn",
            "mp",
            "p",
            "index"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\nstatic void dtInsertEntry(dtpage_t * p, int index, struct component_name * key,\n\t\t\t  ddata_t * data, struct dt_lock **);\n\nint dtInsert(tid_t tid, struct inode *ip,\n\t struct component_name * name, ino_t * fsn, struct btstack * btstack)\n{\n\tint rc = 0;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\tdtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index;\n\tstruct dtsplit split;\t/* split information */\n\tddata_t data;\n\tstruct dt_lock *dtlck;\n\tint n;\n\tstruct tlock *tlck;\n\tstruct lv *lv;\n\n\t/*\n\t *\tretrieve search result\n\t *\n\t * dtSearch() returns (leaf page pinned, index at which to insert).\n\t * n.b. dtSearch() may return index of (maxindex + 1) of\n\t * the full page.\n\t */\n\tDT_GETSEARCH(ip, btstack->top, bn, mp, p, index);\n\n\t/*\n\t *\tinsert entry for new key\n\t */\n\tif (DO_INDEX(ip)) {\n\t\tif (JFS_IP(ip)->next_index == DIREND) {\n\t\t\tDT_PUTPAGE(mp);\n\t\t\treturn -EMLINK;\n\t\t}\n\t\tn = NDTLEAF(name->namlen);\n\t\tdata.leaf.tid = tid;\n\t\tdata.leaf.ip = ip;\n\t} else {\n\t\tn = NDTLEAF_LEGACY(name->namlen);\n\t\tdata.leaf.ip = NULL;\t/* signifies legacy directory format */\n\t}\n\tdata.leaf.ino = *fsn;\n\n\t/*\n\t *\tleaf page does not have enough room for new entry:\n\t *\n\t *\textend/split the leaf page;\n\t *\n\t * dtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tif (n > p->header.freecnt) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.nslot = n;\n\t\tsplit.key = name;\n\t\tsplit.data = &data;\n\t\trc = dtSplitUp(tid, ip, &split, btstack);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tleaf page does have enough room for new entry:\n\t *\n\t *\tinsert the new data entry into the leaf page;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\t/*\n\t * acquire a transaction lock on the leaf page\n\t */\n\ttlck = txLock(tid, ip, mp, tlckDTREE | tlckENTRY);\n\tdtlck = (struct dt_lock *) & tlck->lock;\n\tASSERT(dtlck->index == 0);\n\tlv = & dtlck->lv[0];\n\n\t/* linelock header */\n\tlv->offset = 0;\n\tlv->length = 1;\n\tdtlck->index++;\n\n\tdtInsertEntry(p, index, name, &data, &dtlck);\n\n\t/* linelock stbl of non-root leaf page */\n\tif (!(p->header.flag & BT_ROOT)) {\n\t\tif (dtlck->index >= dtlck->maxcnt)\n\t\t\tdtlck = (struct dt_lock *) txLinelock(dtlck);\n\t\tlv = & dtlck->lv[dtlck->index];\n\t\tn = index >> L2DTSLOTSIZE;\n\t\tlv->offset = p->header.stblindex + n;\n\t\tlv->length =\n\t\t    ((p->header.nextindex - 1) >> L2DTSLOTSIZE) - n + 1;\n\t\tdtlck->index++;\n\t}\n\n\t/* unpin the leaf page */\n\tDT_PUTPAGE(mp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dtSearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "580-808",
    "snippet": "int dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);",
      "static int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);",
      "static int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);",
      "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
      "static int dtReadFirst(struct inode *ip, struct btstack * btstack);",
      "static int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);",
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ciKey.name"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_PUTPAGE",
          "args": [
            "mp"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lengthPXD",
          "args": [
            "pxd"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "lengthPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "86-89",
          "snippet": "static inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u32 lengthPXD(pxd_t *pxd)\n{\n\treturn le32_to_cpu((pxd)->len_addr) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressPXD",
          "args": [
            "pxd"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "addressPXD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_types.h",
          "lines": "91-95",
          "snippet": "static inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}",
          "includes": [
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n#include <linux/types.h>\n\nstatic inline __u64 addressPXD(pxd_t *pxd)\n{\n\t__u64 n = le32_to_cpu(pxd->len_addr) & ~0xffffff;\n\treturn (n << 8) + le32_to_cpu(pxd->addr2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_PUSH",
          "args": [
            "btstack",
            "bn",
            "index"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_STACK_DUMP",
          "args": [
            "btstack"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "BT_STACK_DUMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_btree.h",
          "lines": "144-152",
          "snippet": "static inline void BT_STACK_DUMP(struct btstack *btstack)\n{\n\tint i;\n\tprintk(\"btstack dump:\\n\");\n\tfor (i = 0; i < MAXTREEHEIGHT; i++)\n\t\tprintk(KERN_ERR \"bn = %Lx, index = %d\\n\",\n\t\t       (long long)btstack->stack[i].bn,\n\t\t       btstack->stack[i].index);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void BT_STACK_DUMP(struct btstack *btstack)\n{\n\tint i;\n\tprintk(\"btstack dump:\\n\");\n\tfor (i = 0; i < MAXTREEHEIGHT; i++)\n\t\tprintk(KERN_ERR \"bn = %Lx, index = %d\\n\",\n\t\t       (long long)btstack->stack[i].bn,\n\t\t       btstack->stack[i].index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "sb",
            "\"stack overrun!\\n\""
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BT_STACK_FULL",
          "args": [
            "btstack"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct ldtentry *) & p->slot[stbl[index]])->inumber"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dtCompare",
          "args": [
            "&ciKey",
            "p",
            "stbl[index]"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "dtCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3592-3653",
          "snippet": "static int dtCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si)\n{\t\t\t\t/* entry slot index */\n\twchar_t *kname;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\tih = (struct idtentry *) & p->slot[si];\n\tsi = ih->next;\n\tname = ih->name;\n\tnamlen = ih->namlen;\n\tlen = min(namlen, DTIHDRDATALEN);\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\treturn rc;\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\tkname += len;\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\t\treturn rc;\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tkname += len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\n\nstatic int dtCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si)\n{\t\t\t\t/* entry slot index */\n\twchar_t *kname;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\tih = (struct idtentry *) & p->slot[si];\n\tsi = ih->next;\n\tname = ih->name;\n\tnamlen = ih->namlen;\n\tlen = min(namlen, DTIHDRDATALEN);\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\treturn rc;\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\tkname += len;\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tif ((rc = UniStrncmp_le(kname, name, len)))\n\t\t\treturn rc;\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tkname += len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ciCompare",
          "args": [
            "&ciKey",
            "p",
            "stbl[index]",
            "JFS_SBI(sb)->mntflag"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ciCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "3668-3763",
          "snippet": "static int ciCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si,\t/* entry slot index */\n\t\t     int flag)\n{\n\twchar_t *kname, x;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint i;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\t/*\n\t * leaf page entry\n\t */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tname = lh->name;\n\t\tnamlen = lh->namlen;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t}\n\t/*\n\t * internal page entry\n\t */\n\telse {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tname = ih->name;\n\t\tnamlen = ih->namlen;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t/* only uppercase if case-insensitive support is on */\n\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\telse\n\t\t\tx = le16_to_cpu(*name);\n\t\tif ((rc = *kname - x))\n\t\t\treturn rc;\n\t}\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t\t/* only uppercase if case-insensitive support is on */\n\t\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\t\telse\n\t\t\t\tx = le16_to_cpu(*name);\n\n\t\t\tif ((rc = *kname - x))\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);",
            "static int dtCompare(struct component_name * key, dtpage_t * p, int si);",
            "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
            "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
            "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtCompare(struct component_name * key, dtpage_t * p, int si);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic int ciCompare(struct component_name * key,\t/* search key */\n\t\t     dtpage_t * p,\t/* directory page */\n\t\t     int si,\t/* entry slot index */\n\t\t     int flag)\n{\n\twchar_t *kname, x;\n\t__le16 *name;\n\tint klen, namlen, len, rc;\n\tstruct ldtentry *lh;\n\tstruct idtentry *ih;\n\tstruct dtslot *t;\n\tint i;\n\n\t/*\n\t * force the left-most key on internal pages, at any level of\n\t * the tree, to be less than any search key.\n\t * this obviates having to update the leftmost key on an internal\n\t * page when the user inserts a new key in the tree smaller than\n\t * anything that has been stored.\n\t *\n\t * (? if/when dtSearch() narrows down to 1st entry (index = 0),\n\t * at any internal page at any level of the tree,\n\t * it descends to child of the entry anyway -\n\t * ? make the entry as min size dummy entry)\n\t *\n\t * if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & BT_LEAF))\n\t * return (1);\n\t */\n\n\tkname = key->name;\n\tklen = key->namlen;\n\n\t/*\n\t * leaf page entry\n\t */\n\tif (p->header.flag & BT_LEAF) {\n\t\tlh = (struct ldtentry *) & p->slot[si];\n\t\tsi = lh->next;\n\t\tname = lh->name;\n\t\tnamlen = lh->namlen;\n\t\tif (flag & JFS_DIR_INDEX)\n\t\t\tlen = min(namlen, DTLHDRDATALEN);\n\t\telse\n\t\t\tlen = min(namlen, DTLHDRDATALEN_LEGACY);\n\t}\n\t/*\n\t * internal page entry\n\t */\n\telse {\n\t\tih = (struct idtentry *) & p->slot[si];\n\t\tsi = ih->next;\n\t\tname = ih->name;\n\t\tnamlen = ih->namlen;\n\t\tlen = min(namlen, DTIHDRDATALEN);\n\t}\n\n\t/* compare with head/only segment */\n\tlen = min(klen, len);\n\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t/* only uppercase if case-insensitive support is on */\n\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\telse\n\t\t\tx = le16_to_cpu(*name);\n\t\tif ((rc = *kname - x))\n\t\t\treturn rc;\n\t}\n\n\tklen -= len;\n\tnamlen -= len;\n\n\t/* compare with additional segment(s) */\n\twhile (klen > 0 && namlen > 0) {\n\t\t/* compare with next name segment */\n\t\tt = (struct dtslot *) & p->slot[si];\n\t\tlen = min(namlen, DTSLOTDATALEN);\n\t\tlen = min(klen, len);\n\t\tname = t->name;\n\t\tfor (i = 0; i < len; i++, kname++, name++) {\n\t\t\t/* only uppercase if case-insensitive support is on */\n\t\t\tif ((flag & JFS_OS2) == JFS_OS2)\n\t\t\t\tx = UniToupper(le16_to_cpu(*name));\n\t\t\telse\n\t\t\t\tx = le16_to_cpu(*name);\n\n\t\t\tif ((rc = *kname - x))\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tklen -= len;\n\t\tnamlen -= len;\n\t\tsi = t->next;\n\t}\n\n\treturn (klen - namlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DT_GETSTBL",
          "args": [
            "p"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DT_GETPAGE",
          "args": [
            "ip",
            "bn",
            "mp",
            "psize",
            "p",
            "rc"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BT_CLR",
          "args": [
            "btstack"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ciToUpper",
          "args": [
            "&ciKey"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UniStrcpy",
          "args": [
            "ciKey.name",
            "key->name"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "UniStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_unicode.h",
          "lines": "42-48",
          "snippet": "static inline wchar_t *UniStrcpy(wchar_t * ucs1, const wchar_t * ucs2)\n{\n\twchar_t *anchor = ucs1;\t/* save the start of result string */\n\n\twhile ((*ucs1++ = *ucs2++));\n\treturn anchor;\n}",
          "includes": [
            "#include \"jfs_types.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_types.h\"\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n\nstatic inline wchar_t *UniStrcpy(wchar_t * ucs1, const wchar_t * ucs2)\n{\n\twchar_t *anchor = ucs1;\t/* save the start of result string */\n\n\twhile ((*ucs1++ = *ucs2++));\n\treturn anchor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(JFS_NAME_MAX + 1) * sizeof(wchar_t)",
            "GFP_NOFS"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int dtSplitUp(tid_t tid, struct inode *ip,\n\t\t     struct dtsplit * split, struct btstack * btstack);\nstatic int dtExtendPage(tid_t tid, struct inode *ip,\n\t\t\tstruct dtsplit * split, struct btstack * btstack);\nstatic int dtDeleteUp(tid_t tid, struct inode *ip, struct metapage * fmp,\n\t\t      dtpage_t * fp, struct btstack * btstack);\nstatic int dtRelink(tid_t tid, struct inode *ip, dtpage_t * p);\nstatic int dtReadFirst(struct inode *ip, struct btstack * btstack);\nstatic int dtReadNext(struct inode *ip,\n\t\t      loff_t * offset, struct btstack * btstack);\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nint dtSearch(struct inode *ip, struct component_name * key, ino_t * data,\n\t     struct btstack * btstack, int flag)\n{\n\tint rc = 0;\n\tint cmp = 1;\t\t/* init for empty page */\n\ts64 bn;\n\tstruct metapage *mp;\n\tdtpage_t *p;\n\ts8 *stbl;\n\tint base, index, lim;\n\tstruct btframe *btsp;\n\tpxd_t *pxd;\n\tint psize = 288;\t/* initial in-line directory */\n\tino_t inumber;\n\tstruct component_name ciKey;\n\tstruct super_block *sb = ip->i_sb;\n\n\tciKey.name = kmalloc((JFS_NAME_MAX + 1) * sizeof(wchar_t), GFP_NOFS);\n\tif (!ciKey.name) {\n\t\trc = -ENOMEM;\n\t\tgoto dtSearch_Exit2;\n\t}\n\n\n\t/* uppercase search key for c-i directory */\n\tUniStrcpy(ciKey.name, key->name);\n\tciKey.namlen = key->namlen;\n\n\t/* only uppercase if case-insensitive support is on */\n\tif ((JFS_SBI(sb)->mntflag & JFS_OS2) == JFS_OS2) {\n\t\tciToUpper(&ciKey);\n\t}\n\tBT_CLR(btstack);\t/* reset stack */\n\n\t/* init level count for max pages to split */\n\tbtstack->nsplit = 1;\n\n\t/*\n\t *\tsearch down tree from root:\n\t *\n\t * between two consecutive entries of <Ki, Pi> and <Kj, Pj> of\n\t * internal page, child page Pi contains entry with k, Ki <= K < Kj.\n\t *\n\t * if entry with search key K is not found\n\t * internal page search find the entry with largest key Ki\n\t * less than K which point to the child page to search;\n\t * leaf page search find the entry with smallest key Kj\n\t * greater than K so that the returned index is the position of\n\t * the entry to be shifted right for insertion of new entry.\n\t * for empty tree, search key is greater than any key of the tree.\n\t *\n\t * by convention, root bn = 0.\n\t */\n\tfor (bn = 0;;) {\n\t\t/* get/pin the page to search */\n\t\tDT_GETPAGE(ip, bn, mp, psize, p, rc);\n\t\tif (rc)\n\t\t\tgoto dtSearch_Exit1;\n\n\t\t/* get sorted entry table of the page */\n\t\tstbl = DT_GETSTBL(p);\n\n\t\t/*\n\t\t * binary search with search key K on the current page.\n\t\t */\n\t\tfor (base = 0, lim = p->header.nextindex; lim; lim >>= 1) {\n\t\t\tindex = base + (lim >> 1);\n\n\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t/* uppercase leaf name to compare */\n\t\t\t\tcmp =\n\t\t\t\t    ciCompare(&ciKey, p, stbl[index],\n\t\t\t\t\t      JFS_SBI(sb)->mntflag);\n\t\t\t} else {\n\t\t\t\t/* router key is in uppercase */\n\n\t\t\t\tcmp = dtCompare(&ciKey, p, stbl[index]);\n\n\n\t\t\t}\n\t\t\tif (cmp == 0) {\n\t\t\t\t/*\n\t\t\t\t *\tsearch hit\n\t\t\t\t */\n\t\t\t\t/* search hit - leaf page:\n\t\t\t\t * return the entry found\n\t\t\t\t */\n\t\t\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t\t\tinumber = le32_to_cpu(\n\t\t\t((struct ldtentry *) & p->slot[stbl[index]])->inumber);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_LOOKUP\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_LOOKUP) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_CREATE\n\t\t\t\t\t */\n\t\t\t\t\tif (flag == JFS_CREATE) {\n\t\t\t\t\t\t*data = inumber;\n\t\t\t\t\t\trc = -EEXIST;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * search for JFS_REMOVE or JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\tif ((flag == JFS_REMOVE ||\n\t\t\t\t\t     flag == JFS_RENAME) &&\n\t\t\t\t\t    *data != inumber) {\n\t\t\t\t\t\trc = -ESTALE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME\n\t\t\t\t\t */\n\t\t\t\t\t/* save search result */\n\t\t\t\t\t*data = inumber;\n\t\t\t\t\tbtsp = btstack->top;\n\t\t\t\t\tbtsp->bn = bn;\n\t\t\t\t\tbtsp->index = index;\n\t\t\t\t\tbtsp->mp = mp;\n\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto dtSearch_Exit1;\n\t\t\t\t}\n\n\t\t\t\t/* search hit - internal page:\n\t\t\t\t * descend/search its child page\n\t\t\t\t */\n\t\t\t\tgoto getChild;\n\t\t\t}\n\n\t\t\tif (cmp > 0) {\n\t\t\t\tbase = index + 1;\n\t\t\t\t--lim;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t *\tsearch miss\n\t\t *\n\t\t * base is the smallest index with key (Kj) greater than\n\t\t * search key (K) and may be zero or (maxindex + 1) index.\n\t\t */\n\t\t/*\n\t\t * search miss - leaf page\n\t\t *\n\t\t * return location of entry (base) where new entry with\n\t\t * search key K is to be inserted.\n\t\t */\n\t\tif (p->header.flag & BT_LEAF) {\n\t\t\t/*\n\t\t\t * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME\n\t\t\t */\n\t\t\tif (flag == JFS_LOOKUP || flag == JFS_REMOVE ||\n\t\t\t    flag == JFS_RENAME) {\n\t\t\t\trc = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * search for JFS_CREATE|JFS_FINDDIR:\n\t\t\t *\n\t\t\t * save search result\n\t\t\t */\n\t\t\t*data = 0;\n\t\t\tbtsp = btstack->top;\n\t\t\tbtsp->bn = bn;\n\t\t\tbtsp->index = base;\n\t\t\tbtsp->mp = mp;\n\n\t\t\trc = 0;\n\t\t\tgoto dtSearch_Exit1;\n\t\t}\n\n\t\t/*\n\t\t * search miss - internal page\n\t\t *\n\t\t * if base is non-zero, decrement base by one to get the parent\n\t\t * entry of the child page to search.\n\t\t */\n\t\tindex = base ? base - 1 : base;\n\n\t\t/*\n\t\t * go down to child page\n\t\t */\n\t      getChild:\n\t\t/* update max. number of pages to split */\n\t\tif (BT_STACK_FULL(btstack)) {\n\t\t\t/* Something's corrupted, mark filesystem dirty so\n\t\t\t * chkdsk will fix it.\n\t\t\t */\n\t\t\tjfs_error(sb, \"stack overrun!\\n\");\n\t\t\tBT_STACK_DUMP(btstack);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbtstack->nsplit++;\n\n\t\t/* push (bn, index) of the parent page/entry */\n\t\tBT_PUSH(btstack, bn, index);\n\n\t\t/* get the child page block number */\n\t\tpxd = (pxd_t *) & p->slot[stbl[index]];\n\t\tbn = addressPXD(pxd);\n\t\tpsize = lengthPXD(pxd) << JFS_SBI(ip->i_sb)->l2bsize;\n\n\t\t/* unpin the parent page */\n\t\tDT_PUTPAGE(mp);\n\t}\n\n      out:\n\tDT_PUTPAGE(mp);\n\n      dtSearch_Exit1:\n\n\tkfree(ciKey.name);\n\n      dtSearch_Exit2:\n\n\treturn rc;\n}"
  },
  {
    "function_name": "read_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "549-567",
    "snippet": "static int read_index(struct inode *ip, u32 index,\n\t\t     struct dir_table_slot * dirtab_slot)\n{\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\tstruct dir_table_slot *slot;\n\n\tslot = find_index(ip, index, &mp, &lblock);\n\tif (!slot) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\n\n\tif (mp)\n\t\trelease_metapage(mp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dirtab_slot",
            "slot",
            "sizeof(struct dir_table_slot)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_index",
          "args": [
            "ip",
            "index",
            "&mp",
            "&lblock"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "249-302",
          "snippet": "static struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int read_index(struct inode *ip, u32 index,\n\t\t     struct dir_table_slot * dirtab_slot)\n{\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\tstruct dir_table_slot *slot;\n\n\tslot = find_index(ip, index, &mp, &lblock);\n\tif (!slot) {\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(dirtab_slot, slot, sizeof(struct dir_table_slot));\n\n\tif (mp)\n\t\trelease_metapage(mp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "modify_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "524-542",
    "snippet": "static void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Dirtable",
            "ip"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "*mp"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_index",
          "args": [
            "tid",
            "ip",
            "*mp",
            "index"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "lock_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "304-325",
          "snippet": "static inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DTSaddress",
          "args": [
            "dirtab_slot",
            "bn"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_index",
          "args": [
            "ip",
            "index",
            "mp",
            "lblock"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "249-302",
          "snippet": "static struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic void modify_index(tid_t tid, struct inode *ip, u32 index, s64 bn,\n\t\t\t int slot, struct metapage ** mp, s64 *lblock)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\n\tdirtab_slot = find_index(ip, index, mp, lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tDTSaddress(dirtab_slot, bn);\n\tdirtab_slot->slot = slot;\n\n\tif (*mp) {\n\t\tlock_index(tid, ip, *mp, index);\n\t\tmark_metapage_dirty(*mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
  },
  {
    "function_name": "free_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "496-517",
    "snippet": "static void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\n\tdirtab_slot = find_index(ip, index, &mp, &lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tdirtab_slot->flag = DIR_INDEX_FREE;\n\tdirtab_slot->slot = dirtab_slot->addr1 = 0;\n\tdirtab_slot->addr2 = cpu_to_le32(next);\n\n\tif (mp) {\n\t\tlock_index(tid, ip, mp, index);\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Dirtable",
            "ip"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_index",
          "args": [
            "tid",
            "ip",
            "mp",
            "index"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "lock_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "304-325",
          "snippet": "static inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "next"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_index",
          "args": [
            "ip",
            "index",
            "&mp",
            "&lblock"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "find_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "249-302",
          "snippet": "static struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic void free_index(tid_t tid, struct inode *ip, u32 index, u32 next)\n{\n\tstruct dir_table_slot *dirtab_slot;\n\ts64 lblock;\n\tstruct metapage *mp = NULL;\n\n\tdirtab_slot = find_index(ip, index, &mp, &lblock);\n\n\tif (!dirtab_slot)\n\t\treturn;\n\n\tdirtab_slot->flag = DIR_INDEX_FREE;\n\tdirtab_slot->slot = dirtab_slot->addr1 = 0;\n\tdirtab_slot->addr2 = cpu_to_le32(next);\n\n\tif (mp) {\n\t\tlock_index(tid, ip, mp, index);\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\t} else\n\t\tset_cflag(COMMIT_Dirtable, ip);\n}"
  },
  {
    "function_name": "add_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "334-489",
    "snippet": "static u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);",
      "static void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);",
      "static int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTSaddress",
          "args": [
            "dirtab_slot",
            "bn"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_index",
          "args": [
            "tid",
            "ip",
            "mp",
            "index"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "lock_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "304-325",
          "snippet": "static inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"add_index: get/read_metapage failed!\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_index_page",
          "args": [
            "ip",
            "blkno"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "read_index_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "208-220",
          "snippet": "static struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xtTruncate",
          "args": [
            "tid",
            "ip",
            "offset",
            "COMMIT_PWMAP"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "xtTruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3162-3692",
          "snippet": "s64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_TRUNCATE_LEAVES 50"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define MAX_TRUNCATE_LEAVES 50\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\ns64 xtTruncate(tid_t tid, struct inode *ip, s64 newsize, int flag)\n{\n\tint rc = 0;\n\ts64 teof;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\ts64 bn;\n\tint index, nextindex;\n\txad_t *xad;\n\ts64 xoff, xaddr;\n\tint xlen, len, freexlen;\n\tstruct btstack btstack;\n\tstruct btframe *parent;\n\tstruct tblock *tblk = NULL;\n\tstruct tlock *tlck = NULL;\n\tstruct xtlock *xtlck = NULL;\n\tstruct xdlistlock xadlock;\t/* maplock for COMMIT_WMAP */\n\tstruct pxd_lock *pxdlock;\t\t/* maplock for COMMIT_WMAP */\n\ts64 nfreed;\n\tint freed, log;\n\tint locked_leaves = 0;\n\n\t/* save object truncation type */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\ttblk->xflag |= flag;\n\t}\n\n\tnfreed = 0;\n\n\tflag &= COMMIT_MAP;\n\tassert(flag != COMMIT_PMAP);\n\n\tif (flag == COMMIT_PWMAP)\n\t\tlog = 1;\n\telse {\n\t\tlog = 0;\n\t\txadlock.flag = mlckFREEXADLIST;\n\t\txadlock.index = 1;\n\t}\n\n\t/*\n\t * if the newsize is not an integral number of pages,\n\t * the file between newsize and next page boundary will\n\t * be cleared.\n\t * if truncating into a file hole, it will cause\n\t * a full block to be allocated for the logical block.\n\t */\n\n\t/*\n\t * release page blocks of truncated region <teof, eof>\n\t *\n\t * free the data blocks from the leaf index blocks.\n\t * delete the parent index entries corresponding to\n\t * the freed child data/index blocks.\n\t * free the index blocks themselves which aren't needed\n\t * in new sized file.\n\t *\n\t * index blocks are updated only if the blocks are to be\n\t * retained in the new sized file.\n\t * if type is PMAP, the data and index pages are NOT\n\t * freed, and the data and index blocks are NOT freed\n\t * from working map.\n\t * (this will allow continued access of data/index of\n\t * temporary file (zerolink count file truncated to zero-length)).\n\t */\n\tteof = (newsize + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t    JFS_SBI(ip->i_sb)->l2bsize;\n\n\t/* clear stack */\n\tBT_CLR(&btstack);\n\n\t/*\n\t * start with root\n\t *\n\t * root resides in the inode\n\t */\n\tbn = 0;\n\n\t/*\n\t * first access of each page:\n\t */\n      getPage:\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\t/* process entries backward from last index */\n\tindex = le16_to_cpu(p->header.nextindex) - 1;\n\n\n\t/* Since this is the rightmost page at this level, and we may have\n\t * already freed a page that was formerly to the right, let's make\n\t * sure that the next pointer is zero.\n\t */\n\tif (p->header.next) {\n\t\tif (log)\n\t\t\t/*\n\t\t\t * Make sure this change to the header is logged.\n\t\t\t * If we really truncate this leaf, the flag\n\t\t\t * will be changed to tlckTRUNCATE\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE|tlckGROW);\n\t\tBT_MARK_DIRTY(mp, ip);\n\t\tp->header.next = 0;\n\t}\n\n\tif (p->header.flag & BT_INTERNAL)\n\t\tgoto getChild;\n\n\t/*\n\t *\tleaf page\n\t */\n\tfreed = 0;\n\n\t/* does region covered by leaf page precede Teof ? */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\tif (teof >= xoff + xlen) {\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/* (re)acquire tlock of the leaf page */\n\tif (log) {\n\t\tif (++locked_leaves > MAX_TRUNCATE_LEAVES) {\n\t\t\t/*\n\t\t\t * We need to limit the size of the transaction\n\t\t\t * to avoid exhausting pagecache & tlocks\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t\tnewsize = (xoff + xlen) << JFS_SBI(ip->i_sb)->l2bsize;\n\t\t\tgoto getParent;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\ttlck->type = tlckXTREE | tlckTRUNCATE;\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->hwm.offset = le16_to_cpu(p->header.nextindex) - 1;\n\t}\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/*\n\t * scan backward leaf page entries\n\t */\n\tfor (; index >= XTENTRYSTART; index--) {\n\t\txad = &p->xad[index];\n\t\txoff = offsetXAD(xad);\n\t\txlen = lengthXAD(xad);\n\t\txaddr = addressXAD(xad);\n\n\t\t/*\n\t\t * The \"data\" for a directory is indexed by the block\n\t\t * device's address space.  This metadata must be invalidated\n\t\t * here\n\t\t */\n\t\tif (S_ISDIR(ip->i_mode) && (teof == 0))\n\t\t\tinvalidate_xad_metapages(ip, *xad);\n\t\t/*\n\t\t * entry beyond eof: continue scan of current page\n\t\t *          xad\n\t\t * ---|---=======------->\n\t\t *   eof\n\t\t */\n\t\tif (teof < xoff) {\n\t\t\tnfreed += xlen;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * (xoff <= teof): last entry to be deleted from page;\n\t\t * If other entries remain in page: keep and update the page.\n\t\t */\n\n\t\t/*\n\t\t * eof == entry_start: delete the entry\n\t\t *           xad\n\t\t * -------|=======------->\n\t\t *       eof\n\t\t *\n\t\t */\n\t\tif (teof == xoff) {\n\t\t\tnfreed += xlen;\n\n\t\t\tif (index == XTENTRYSTART)\n\t\t\t\tbreak;\n\n\t\t\tnextindex = index;\n\t\t}\n\t\t/*\n\t\t * eof within the entry: truncate the entry.\n\t\t *          xad\n\t\t * -------===|===------->\n\t\t *          eof\n\t\t */\n\t\telse if (teof < xoff + xlen) {\n\t\t\t/* update truncated entry */\n\t\t\tlen = teof - xoff;\n\t\t\tfreexlen = xlen - len;\n\t\t\tXADlength(xad, len);\n\n\t\t\t/* save pxd of truncated extent in tlck */\n\t\t\txaddr += len;\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\txtlck->lwm.offset = (xtlck->lwm.offset) ?\n\t\t\t\t    min(index, (int)xtlck->lwm.offset) : index;\n\t\t\t\txtlck->lwm.length = index + 1 -\n\t\t\t\t    xtlck->lwm.offset;\n\t\t\t\txtlck->twm.offset = index;\n\t\t\t\tpxdlock = (struct pxd_lock *) & xtlck->pxdlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t}\n\t\t\t/* free truncated extent */\n\t\t\telse {\t/* COMMIT_WMAP */\n\n\t\t\t\tpxdlock = (struct pxd_lock *) & xadlock;\n\t\t\t\tpxdlock->flag = mlckFREEPXD;\n\t\t\t\tPXDaddress(&pxdlock->pxd, xaddr);\n\t\t\t\tPXDlength(&pxdlock->pxd, freexlen);\n\t\t\t\ttxFreeMap(ip, pxdlock, NULL, COMMIT_WMAP);\n\n\t\t\t\t/* reset map lock */\n\t\t\t\txadlock.flag = mlckFREEXADLIST;\n\t\t\t}\n\n\t\t\t/* current entry is new last entry; */\n\t\t\tnextindex = index + 1;\n\n\t\t\tnfreed += freexlen;\n\t\t}\n\t\t/*\n\t\t * eof beyond the entry:\n\t\t *          xad\n\t\t * -------=======---|--->\n\t\t *                 eof\n\t\t */\n\t\telse {\t\t/* (xoff + xlen < teof) */\n\n\t\t\tnextindex = index + 1;\n\t\t}\n\n\t\tif (nextindex < le16_to_cpu(p->header.nextindex)) {\n\t\t\tif (!log) {\t/* COMMIT_WAMP */\n\t\t\t\txadlock.xdlist = &p->xad[nextindex];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    nextindex;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tp->header.nextindex = cpu_to_le16(nextindex);\n\t\t}\n\n\t\tXT_PUTPAGE(mp);\n\n\t\t/* assert(freed == 0); */\n\t\tgoto getParent;\n\t}\t\t\t/* end scan of leaf page entries */\n\n\tfreed = 1;\n\n\t/*\n\t * leaf page become empty: free the page if type != PMAP\n\t */\n\tif (log) {\t\t/* COMMIT_PWMAP */\n\t\t/* txCommit() with tlckFREE:\n\t\t * free data extents covered by leaf [XTENTRYSTART:hwm);\n\t\t * invalidate leaf if COMMIT_PWMAP;\n\t\t * if (TRUNCATE), will write LOG_NOREDOPAGE;\n\t\t */\n\t\ttlck->type = tlckXTREE | tlckFREE;\n\t} else {\t\t/* COMMIT_WAMP */\n\n\t\t/* free data extents covered by leaf */\n\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\txadlock.count =\n\t\t    le16_to_cpu(p->header.nextindex) - XTENTRYSTART;\n\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL, COMMIT_WMAP);\n\t}\n\n\tif (p->header.flag & BT_ROOT) {\n\t\tp->header.flag &= ~BT_INTERNAL;\n\t\tp->header.flag |= BT_LEAF;\n\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\tgoto out;\n\t} else {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* page will be invalidated at tx completion\n\t\t\t */\n\t\t\tXT_PUTPAGE(mp);\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\tif (mp->lid)\n\t\t\t\tlid_to_tlock(mp->lid)->flag |= tlckFREELOCK;\n\n\t\t\t/* invalidate empty leaf page */\n\t\t\tdiscard_metapage(mp);\n\t\t}\n\t}\n\n\t/*\n\t * the leaf page become empty: delete the parent entry\n\t * for the leaf page if the parent page is to be kept\n\t * in the new sized file.\n\t */\n\n\t/*\n\t * go back up to the parent page\n\t */\n      getParent:\n\t/* pop/restore parent entry for the current child page */\n\tif ((parent = BT_POP(&btstack)) == NULL)\n\t\t/* current page must have been root */\n\t\tgoto out;\n\n\t/* get back the parent page */\n\tbn = parent->bn;\n\tXT_GETPAGE(ip, bn, mp, PSIZE, p, rc);\n\tif (rc)\n\t\treturn rc;\n\n\tindex = parent->index;\n\n\t/*\n\t * child page was not empty:\n\t */\n\tif (freed == 0) {\n\t\t/* has any entry deleted from parent ? */\n\t\tif (index < le16_to_cpu(p->header.nextindex) - 1) {\n\t\t\t/* (re)acquire tlock on the parent page */\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* txCommit() with tlckTRUNCATE:\n\t\t\t\t * free child extents covered by parent [);\n\t\t\t\t */\n\t\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\t\tif (!(tlck->type & tlckTRUNCATE)) {\n\t\t\t\t\txtlck->hwm.offset =\n\t\t\t\t\t    le16_to_cpu(p->header.\n\t\t\t\t\t\t\tnextindex) - 1;\n\t\t\t\t\ttlck->type =\n\t\t\t\t\t    tlckXTREE | tlckTRUNCATE;\n\t\t\t\t}\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\t/* free child extents covered by parent */\n\t\t\t\txadlock.xdlist = &p->xad[index + 1];\n\t\t\t\txadlock.count =\n\t\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t\t    index - 1;\n\t\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock,\n\t\t\t\t\t  NULL, COMMIT_WMAP);\n\t\t\t}\n\t\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\t\tp->header.nextindex = cpu_to_le16(index + 1);\n\t\t}\n\t\tXT_PUTPAGE(mp);\n\t\tgoto getParent;\n\t}\n\n\t/*\n\t * child page was empty:\n\t */\n\tnfreed += lengthXAD(&p->xad[index]);\n\n\t/*\n\t * During working map update, child page's tlock must be handled\n\t * before parent's.  This is because the parent's tlock will cause\n\t * the child's disk space to be marked available in the wmap, so\n\t * it's important that the child page be released by that time.\n\t *\n\t * ToDo:  tlocks should be on doubly-linked list, so we can\n\t * quickly remove it and add it to the end.\n\t */\n\n\t/*\n\t * Move parent page's tlock to the end of the tid's tlock list\n\t */\n\tif (log && mp->lid && (tblk->last != mp->lid) &&\n\t    lid_to_tlock(mp->lid)->tid) {\n\t\tlid_t lid = mp->lid;\n\t\tstruct tlock *prev;\n\n\t\ttlck = lid_to_tlock(lid);\n\n\t\tif (tblk->next == lid)\n\t\t\ttblk->next = tlck->next;\n\t\telse {\n\t\t\tfor (prev = lid_to_tlock(tblk->next);\n\t\t\t     prev->next != lid;\n\t\t\t     prev = lid_to_tlock(prev->next)) {\n\t\t\t\tassert(prev->next);\n\t\t\t}\n\t\t\tprev->next = tlck->next;\n\t\t}\n\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\n\t/*\n\t * parent page become empty: free the page\n\t */\n\tif (index == XTENTRYSTART) {\n\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t/* txCommit() with tlckFREE:\n\t\t\t * free child extents covered by parent;\n\t\t\t * invalidate parent if COMMIT_PWMAP;\n\t\t\t */\n\t\t\ttlck = txLock(tid, ip, mp, tlckXTREE);\n\t\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\t\txtlck->hwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex) - 1;\n\t\t\ttlck->type = tlckXTREE | tlckFREE;\n\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t/* free child extents covered by parent */\n\t\t\txadlock.xdlist = &p->xad[XTENTRYSTART];\n\t\t\txadlock.count =\n\t\t\t    le16_to_cpu(p->header.nextindex) -\n\t\t\t    XTENTRYSTART;\n\t\t\ttxFreeMap(ip, (struct maplock *) & xadlock, NULL,\n\t\t\t\t  COMMIT_WMAP);\n\t\t}\n\t\tBT_MARK_DIRTY(mp, ip);\n\n\t\tif (p->header.flag & BT_ROOT) {\n\t\t\tp->header.flag &= ~BT_INTERNAL;\n\t\t\tp->header.flag |= BT_LEAF;\n\t\t\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\t\t\tif (le16_to_cpu(p->header.maxentry) == XTROOTMAXSLOT) {\n\t\t\t\t/*\n\t\t\t\t * Shrink root down to allow inline\n\t\t\t\t * EA (otherwise fsck complains)\n\t\t\t\t */\n\t\t\t\tp->header.maxentry =\n\t\t\t\t    cpu_to_le16(XTROOTINITSLOT);\n\t\t\t\tJFS_IP(ip)->mode2 |= INLINEEA;\n\t\t\t}\n\n\t\t\tXT_PUTPAGE(mp);\t/* debug */\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (log) {\t/* COMMIT_PWMAP */\n\t\t\t\t/* page will be invalidated at tx completion\n\t\t\t\t */\n\t\t\t\tXT_PUTPAGE(mp);\n\t\t\t} else {\t/* COMMIT_WMAP */\n\n\t\t\t\tif (mp->lid)\n\t\t\t\t\tlid_to_tlock(mp->lid)->flag |=\n\t\t\t\t\t\ttlckFREELOCK;\n\n\t\t\t\t/* invalidate parent page */\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t}\n\n\t\t\t/* parent has become empty and freed:\n\t\t\t * go back up to its parent page\n\t\t\t */\n\t\t\t/* freed = 1; */\n\t\t\tgoto getParent;\n\t\t}\n\t}\n\t/*\n\t * parent page still has entries for front region;\n\t */\n\telse {\n\t\t/* try truncate region covered by preceding entry\n\t\t * (process backward)\n\t\t */\n\t\tindex--;\n\n\t\t/* go back down to the child page corresponding\n\t\t * to the entry\n\t\t */\n\t\tgoto getChild;\n\t}\n\n\t/*\n\t *\tinternal page: go down to child page of current entry\n\t */\n      getChild:\n\t/* save current parent entry for the child page */\n\tif (BT_STACK_FULL(&btstack)) {\n\t\tjfs_error(ip->i_sb, \"stack overrun!\\n\");\n\t\tXT_PUTPAGE(mp);\n\t\treturn -EIO;\n\t}\n\tBT_PUSH(&btstack, bn, index);\n\n\t/* get child page */\n\txad = &p->xad[index];\n\tbn = addressXAD(xad);\n\n\t/*\n\t * first access of each internal entry:\n\t */\n\t/* release parent page */\n\tXT_PUTPAGE(mp);\n\n\t/* process the child page */\n\tgoto getPage;\n\n      out:\n\t/*\n\t * update file resource stat\n\t */\n\t/* set size\n\t */\n\tif (S_ISDIR(ip->i_mode) && !newsize)\n\t\tip->i_size = 1;\t/* fsck hates zero-length directories */\n\telse\n\t\tip->i_size = newsize;\n\n\t/* update quota allocation to reflect freed blocks */\n\tdquot_free_block(ip, nfreed);\n\n\t/*\n\t * free tlock of invalidated pages\n\t */\n\tif (flag == COMMIT_WMAP)\n\t\ttxFreelock(ip);\n\n\treturn newsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mp->data",
            "0",
            "PSIZE"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_index_page",
          "args": [
            "ip",
            "blkno"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "get_index_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "227-239",
          "snippet": "static struct metapage *get_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn get_metapage(inode, xaddr, PSIZE, 1);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct metapage *get_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn get_metapage(inode, xaddr, PSIZE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"add_index: xtInsert failed!\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInsert",
          "args": [
            "tid",
            "ip",
            "0",
            "blkno",
            "sbi->nbperpage",
            "&xaddr",
            "0"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "xtInsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "537-670",
          "snippet": "int xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define XT_INSERT\t0x00000001"
          ],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define XT_INSERT\t0x00000001\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtInsert(tid_t tid,\t\t/* transaction id */\n\t     struct inode *ip, int xflag, s64 xoff, s32 xlen, s64 * xaddrp,\n\t     int flag)\n{\n\tint rc = 0;\n\ts64 xaddr, hint;\n\tstruct metapage *mp;\t/* meta-page buffer */\n\txtpage_t *p;\t\t/* base B+-tree index page */\n\ts64 bn;\n\tint index, nextindex;\n\tstruct btstack btstack;\t/* traverse stack */\n\tstruct xtsplit split;\t/* split information */\n\txad_t *xad;\n\tint cmp;\n\ts64 next;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\n\tjfs_info(\"xtInsert: nxoff:0x%lx nxlen:0x%x\", (ulong) xoff, xlen);\n\n\t/*\n\t *\tsearch for the entry location at which to insert:\n\t *\n\t * xtFastSearch() and xtSearch() both returns (leaf page\n\t * pinned, index at which to insert).\n\t * n.b. xtSearch() may return index of maxentry of\n\t * the full page.\n\t */\n\tif ((rc = xtSearch(ip, xoff, &next, &cmp, &btstack, XT_INSERT)))\n\t\treturn rc;\n\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* This test must follow XT_GETSEARCH since mp must be valid if\n\t * we branch to out: */\n\tif ((cmp == 0) || (next && (xlen > next - xoff))) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * allocate data extent requested\n\t *\n\t * allocation hint: last xad\n\t */\n\tif ((xaddr = *xaddrp) == 0) {\n\t\tif (index > XTENTRYSTART) {\n\t\t\txad = &p->xad[index - 1];\n\t\t\thint = addressXAD(xad) + lengthXAD(xad) - 1;\n\t\t} else\n\t\t\thint = 0;\n\t\tif ((rc = dquot_alloc_block(ip, xlen)))\n\t\t\tgoto out;\n\t\tif ((rc = dbAlloc(ip, hint, (s64) xlen, &xaddr))) {\n\t\t\tdquot_free_block(ip, xlen);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tinsert entry for new extent\n\t */\n\txflag |= XAD_NEW;\n\n\t/*\n\t *\tif the leaf page is full, split the page and\n\t *\tpropagate up the router entry for the new page from split\n\t *\n\t * The xtSplitUp() will insert the entry and unpin the leaf page.\n\t */\n\tnextindex = le16_to_cpu(p->header.nextindex);\n\tif (nextindex == le16_to_cpu(p->header.maxentry)) {\n\t\tsplit.mp = mp;\n\t\tsplit.index = index;\n\t\tsplit.flag = xflag;\n\t\tsplit.off = xoff;\n\t\tsplit.len = xlen;\n\t\tsplit.addr = xaddr;\n\t\tsplit.pxdlist = NULL;\n\t\tif ((rc = xtSplitUp(tid, ip, &split, &btstack))) {\n\t\t\t/* undo data extent allocation */\n\t\t\tif (*xaddrp == 0) {\n\t\t\t\tdbFree(ip, xaddr, (s64) xlen);\n\t\t\t\tdquot_free_block(ip, xlen);\n\t\t\t}\n\t\t\treturn rc;\n\t\t}\n\n\t\t*xaddrp = xaddr;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *\tinsert the new entry into the leaf page\n\t */\n\t/*\n\t * acquire a transaction lock on the leaf page;\n\t *\n\t * action: xad insertion/extension;\n\t */\n\tBT_MARK_DIRTY(mp, ip);\n\n\t/* if insert into middle, shift right remaining entries. */\n\tif (index < nextindex)\n\t\tmemmove(&p->xad[index + 1], &p->xad[index],\n\t\t\t(nextindex - index) * sizeof(xad_t));\n\n\t/* insert the new entry: mark the entry NEW */\n\txad = &p->xad[index];\n\tXT_PUTENTRY(xad, xflag, xoff, xlen, xaddr);\n\n\t/* advance next available entry index */\n\tle16_add_cpu(&p->header.nextindex, 1);\n\n\t/* Don't log it if there are no links to the file */\n\tif (!test_cflag(COMMIT_Nolink, ip)) {\n\t\ttlck = txLock(tid, ip, mp, tlckXTREE | tlckGROW);\n\t\txtlck = (struct xtlock *) & tlck->lock;\n\t\txtlck->lwm.offset =\n\t\t    (xtlck->lwm.offset) ? min(index,\n\t\t\t\t\t      (int)xtlck->lwm.offset) : index;\n\t\txtlck->lwm.length =\n\t\t    le16_to_cpu(p->header.nextindex) - xtlck->lwm.offset;\n\t}\n\n\t*xaddrp = xaddr;\n\n      out:\n\t/* unpin the leaf page */\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_cflag",
          "args": [
            "COMMIT_Dirtable",
            "ip"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_metapage_dirty",
          "args": [
            "mp"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mp->data",
            "temp_table",
            "sizeof(temp_table)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "llck->index == 0"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDATA"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&jfs_ip->i_dirtable",
            "temp_table",
            "sizeof (temp_table)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"add_index: get_metapage failed!\""
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "sbi->nbperpage"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbFree",
          "args": [
            "ip",
            "xaddr",
            "sbi->nbperpage"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "dbFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "331-399",
          "snippet": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nint dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\n\t/* block to be freed better be within the mapsize. */\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/**\n\t * TRIM the blocks, when mounted with discard option\n\t */\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\n\t/*\n\t * free the blocks a dmap at a time.\n\t */\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\t/* release previous dmap if any */\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\n\t\t/* get the buffer for the current dmap. */\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\n\t\t/* determine the number of blocks to be freed from\n\t\t * this dmap.\n\t\t */\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\n\t\t/* free the blocks. */\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\n\t/* write the last buffer. */\n\twrite_metapage(mp);\n\n\tIREAD_UNLOCK(ipbmap);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&jfs_ip->i_dirtable",
            "temp_table",
            "sizeof (temp_table)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"add_index: xtInsert failed!\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtInitRoot",
          "args": [
            "tid",
            "ip"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "xtInitRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "3073-3098",
          "snippet": "void xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\n\nvoid xtInitRoot(tid_t tid, struct inode *ip)\n{\n\txtpage_t *p;\n\n\t/*\n\t * acquire a transaction lock on the root\n\t *\n\t * action:\n\t */\n\ttxLock(tid, ip, (struct metapage *) &JFS_IP(ip)->bxflag,\n\t\t      tlckXTREE | tlckNEW);\n\tp = &JFS_IP(ip)->i_xtroot;\n\n\tp->header.flag = DXD_INDEX | BT_ROOT | BT_LEAF;\n\tp->header.nextindex = cpu_to_le16(XTENTRYSTART);\n\n\tif (S_ISDIR(ip->i_mode))\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT_DIR);\n\telse {\n\t\tp->header.maxentry = cpu_to_le16(XTROOTINITSLOT);\n\t\tip->i_size = 0;\n\t}\n\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "temp_table",
            "&jfs_ip->i_dirtable",
            "sizeof(temp_table)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ip",
            "sbi->nbperpage"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbAlloc",
          "args": [
            "ip",
            "0",
            "sbi->nbperpage",
            "&xaddr"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "dbAllocDmapBU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dmap.c",
          "lines": "3263-3364",
          "snippet": "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"jfs_discard.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_lock.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);",
            "static int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);",
            "static int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);",
            "static int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);",
            "static int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);",
            "static int blkstol2(s64 nb);",
            "static int cntlz(u32 value);",
            "static int cnttz(u32 word);",
            "static int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);",
            "static int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);",
            "static int dbInitDmapTree(struct dmap * dp);",
            "static int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);",
            "static int dbGetL2AGSize(s64 nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_discard.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_lock.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void dbAllocBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\tint nblocks);\nstatic int dbAdjCtl(struct bmap * bmp, s64 blkno, int newval, int alloc,\n\t\t    int level);\nstatic int dbAllocNext(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbAllocDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t       int nblocks);\nstatic int dbFindCtl(struct bmap * bmp, int l2nb, int level, s64 * blkno);\nstatic int dbFreeBits(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int dbFreeDmap(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t      int nblocks);\nstatic int blkstol2(s64 nb);\nstatic int cntlz(u32 value);\nstatic int cnttz(u32 word);\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks);\nstatic int dbInitDmap(struct dmap * dp, s64 blkno, int nblocks);\nstatic int dbInitDmapTree(struct dmap * dp);\nstatic int dbInitDmapCtl(struct dmapctl * dcp, int level, int i);\nstatic int dbGetL2AGSize(s64 nblocks);\n\nstatic int dbAllocDmapBU(struct bmap * bmp, struct dmap * dp, s64 blkno,\n\t\t\t int nblocks)\n{\n\tint rc;\n\tint dbitno, word, rembits, nb, nwords, wbitno, agno;\n\ts8 oldroot;\n\tstruct dmaptree *tp = (struct dmaptree *) & dp->tree;\n\n\t/* save the current value of the root (i.e. maximum free string)\n\t * of the dmap tree.\n\t */\n\toldroot = tp->stree[ROOT];\n\n\t/* determine the bit number and word within the dmap of the\n\t * starting block.\n\t */\n\tdbitno = blkno & (BPERDMAP - 1);\n\tword = dbitno >> L2DBWORD;\n\n\t/* block range better be within the dmap */\n\tassert(dbitno + nblocks <= BPERDMAP);\n\n\t/* allocate the bits of the dmap's words corresponding to the block\n\t * range. not all bits of the first and last words may be contained\n\t * within the block range.  if this is the case, we'll work against\n\t * those words (i.e. partial first and/or last) on an individual basis\n\t * (a single pass), allocating the bits of interest by hand and\n\t * updating the leaf corresponding to the dmap word. a single pass\n\t * will be used for all dmap words fully contained within the\n\t * specified range.  within this pass, the bits of all fully contained\n\t * dmap words will be marked as free in a single shot and the leaves\n\t * will be updated. a single leaf may describe the free space of\n\t * multiple dmap words, so we may update only a subset of the actual\n\t * leaves corresponding to the dmap words of the block range.\n\t */\n\tfor (rembits = nblocks; rembits > 0; rembits -= nb, dbitno += nb) {\n\t\t/* determine the bit number within the word and\n\t\t * the number of bits within the word.\n\t\t */\n\t\twbitno = dbitno & (DBWORD - 1);\n\t\tnb = min(rembits, DBWORD - wbitno);\n\n\t\t/* check if only part of a word is to be allocated.\n\t\t */\n\t\tif (nb < DBWORD) {\n\t\t\t/* allocate (set to 1) the appropriate bits within\n\t\t\t * this dmap word.\n\t\t\t */\n\t\t\tdp->wmap[word] |= cpu_to_le32(ONES << (DBWORD - nb)\n\t\t\t\t\t\t      >> wbitno);\n\n\t\t\tword++;\n\t\t} else {\n\t\t\t/* one or more dmap words are fully contained\n\t\t\t * within the block range.  determine how many\n\t\t\t * words and allocate (set to 1) the bits of these\n\t\t\t * words.\n\t\t\t */\n\t\t\tnwords = rembits >> L2DBWORD;\n\t\t\tmemset(&dp->wmap[word], (int) ONES, nwords * 4);\n\n\t\t\t/* determine how many bits */\n\t\t\tnb = nwords << L2DBWORD;\n\t\t\tword += nwords;\n\t\t}\n\t}\n\n\t/* update the free count for this dmap */\n\tle32_add_cpu(&dp->nfree, -nblocks);\n\n\t/* reconstruct summary tree */\n\tdbInitDmapTree(dp);\n\n\tBMAP_LOCK(bmp);\n\n\t/* if this allocation group is completely free,\n\t * update the highest active allocation group number\n\t * if this allocation group is the new max.\n\t */\n\tagno = blkno >> bmp->db_agl2size;\n\tif (agno > bmp->db_maxag)\n\t\tbmp->db_maxag = agno;\n\n\t/* update the free count for the allocation group and map */\n\tbmp->db_agfree[agno] -= nblocks;\n\tbmp->db_nfree -= nblocks;\n\n\tBMAP_UNLOCK(bmp);\n\n\t/* if the root has not changed, done. */\n\tif (tp->stree[ROOT] == oldroot)\n\t\treturn (0);\n\n\t/* root changed. bubble the change up to the dmap control pages.\n\t * if the adjustment of the upper level control pages fails,\n\t * backout the bit allocation (thus making everything consistent).\n\t */\n\tif ((rc = dbAdjCtl(bmp, blkno, tp->stree[ROOT], 1, 0)))\n\t\tdbFreeBits(bmp, dp, blkno, nblocks);\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ip",
            "sbi->nbperpage"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cflag",
          "args": [
            "COMMIT_Dirtable",
            "ip"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DTSaddress",
          "args": [
            "dirtab_slot",
            "bn"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "index - 1"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"add_index: next_index = %d.  Resetting!\"",
            "jfs_ip->next_index"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "DO_INDEX(ip)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DO_INDEX",
          "args": [
            "ip"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "sb"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic int ciCompare(struct component_name * key, dtpage_t * p, int si,\n\t\t     int flag);\nstatic void dtGetKey(dtpage_t * p, int i, struct component_name * key,\n\t\t     int flag);\nstatic int ciGetLeafPrefixKey(dtpage_t * lp, int li, dtpage_t * rp,\n\t\t\t      int ri, struct component_name * key, int flag);\n\nstatic u32 add_index(tid_t tid, struct inode *ip, s64 bn, int slot)\n{\n\tstruct super_block *sb = ip->i_sb;\n\tstruct jfs_sb_info *sbi = JFS_SBI(sb);\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tu64 blkno;\n\tstruct dir_table_slot *dirtab_slot;\n\tu32 index;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\tstruct metapage *mp;\n\ts64 offset;\n\tuint page_offset;\n\tstruct tlock *tlck;\n\ts64 xaddr;\n\n\tASSERT(DO_INDEX(ip));\n\n\tif (jfs_ip->next_index < 2) {\n\t\tjfs_warn(\"add_index: next_index = %d.  Resetting!\",\n\t\t\t   jfs_ip->next_index);\n\t\tjfs_ip->next_index = 2;\n\t}\n\n\tindex = jfs_ip->next_index++;\n\n\tif (index <= MAX_INLINE_DIRTABLE_ENTRY) {\n\t\t/*\n\t\t * i_size reflects size of index table, or 8 bytes per entry.\n\t\t */\n\t\tip->i_size = (loff_t) (index - 1) << 3;\n\n\t\t/*\n\t\t * dir table fits inline within inode\n\t\t */\n\t\tdirtab_slot = &jfs_ip->i_dirtable[index-2];\n\t\tdirtab_slot->flag = DIR_INDEX_VALID;\n\t\tdirtab_slot->slot = slot;\n\t\tDTSaddress(dirtab_slot, bn);\n\n\t\tset_cflag(COMMIT_Dirtable, ip);\n\n\t\treturn index;\n\t}\n\tif (index == (MAX_INLINE_DIRTABLE_ENTRY + 1)) {\n\t\tstruct dir_table_slot temp_table[12];\n\n\t\t/*\n\t\t * It's time to move the inline table to an external\n\t\t * page and begin to build the xtree\n\t\t */\n\t\tif (dquot_alloc_block(ip, sbi->nbperpage))\n\t\t\tgoto clean_up;\n\t\tif (dbAlloc(ip, 0, sbi->nbperpage, &xaddr)) {\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\n\t\t/*\n\t\t * Save the table, we're going to overwrite it with the\n\t\t * xtree root\n\t\t */\n\t\tmemcpy(temp_table, &jfs_ip->i_dirtable, sizeof(temp_table));\n\n\t\t/*\n\t\t * Initialize empty x-tree\n\t\t */\n\t\txtInitRoot(tid, ip);\n\n\t\t/*\n\t\t * Add the first block to the xtree\n\t\t */\n\t\tif (xtInsert(tid, ip, 0, 0, sbi->nbperpage, &xaddr, 0)) {\n\t\t\t/* This really shouldn't fail */\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tdbFree(ip, xaddr, sbi->nbperpage);\n\t\t\tdquot_free_block(ip, sbi->nbperpage);\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size = PSIZE;\n\n\t\tmp = get_index_page(ip, 0);\n\t\tif (!mp) {\n\t\t\tjfs_err(\"add_index: get_metapage failed!\");\n\t\t\txtTruncate(tid, ip, 0, COMMIT_PWMAP);\n\t\t\tmemcpy(&jfs_ip->i_dirtable, temp_table,\n\t\t\t       sizeof (temp_table));\n\t\t\tgoto clean_up;\n\t\t}\n\t\ttlck = txLock(tid, ip, mp, tlckDATA);\n\t\tllck = (struct linelock *) & tlck->lock;\n\t\tASSERT(llck->index == 0);\n\t\tlv = &llck->lv[0];\n\n\t\tlv->offset = 0;\n\t\tlv->length = 6;\t/* tlckDATA slot size is 16 bytes */\n\t\tllck->index++;\n\n\t\tmemcpy(mp->data, temp_table, sizeof(temp_table));\n\n\t\tmark_metapage_dirty(mp);\n\t\trelease_metapage(mp);\n\n\t\t/*\n\t\t * Logging is now directed by xtree tlocks\n\t\t */\n\t\tclear_cflag(COMMIT_Dirtable, ip);\n\t}\n\n\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\tpage_offset = offset & (PSIZE - 1);\n\tblkno = ((offset + 1) >> L2PSIZE) << sbi->l2nbperpage;\n\tif (page_offset == 0) {\n\t\t/*\n\t\t * This will be the beginning of a new page\n\t\t */\n\t\txaddr = 0;\n\t\tif (xtInsert(tid, ip, 0, blkno, sbi->nbperpage, &xaddr, 0)) {\n\t\t\tjfs_warn(\"add_index: xtInsert failed!\");\n\t\t\tgoto clean_up;\n\t\t}\n\t\tip->i_size += PSIZE;\n\n\t\tif ((mp = get_index_page(ip, blkno)))\n\t\t\tmemset(mp->data, 0, PSIZE);\t/* Just looks better */\n\t\telse\n\t\t\txtTruncate(tid, ip, offset, COMMIT_PWMAP);\n\t} else\n\t\tmp = read_index_page(ip, blkno);\n\n\tif (!mp) {\n\t\tjfs_err(\"add_index: get/read_metapage failed!\");\n\t\tgoto clean_up;\n\t}\n\n\tlock_index(tid, ip, mp, index);\n\n\tdirtab_slot =\n\t    (struct dir_table_slot *) ((char *) mp->data + page_offset);\n\tdirtab_slot->flag = DIR_INDEX_VALID;\n\tdirtab_slot->slot = slot;\n\tDTSaddress(dirtab_slot, bn);\n\n\tmark_metapage_dirty(mp);\n\trelease_metapage(mp);\n\n\treturn index;\n\n      clean_up:\n\n\tjfs_ip->next_index--;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "304-325",
    "snippet": "static inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txLinelock",
          "args": [
            "llck"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "txLinelock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "1068-1096",
          "snippet": "struct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct tlock *TxLock;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstruct tlock *TxLock;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\n\nstruct linelock *txLinelock(struct linelock * tlock)\n{\n\tlid_t lid;\n\tstruct tlock *tlck;\n\tstruct linelock *linelock;\n\n\tTXN_LOCK();\n\n\t/* allocate a TxLock structure */\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\tTXN_UNLOCK();\n\n\t/* initialize linelock */\n\tlinelock = (struct linelock *) tlck;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKLONG;\n\tlinelock->index = 0;\n\tif (tlck->flag & tlckDIRECTORY)\n\t\tlinelock->flag |= tlckDIRECTORY;\n\n\t/* append linelock after tlock */\n\tlinelock->next = tlock->next;\n\ttlock->next = lid;\n\n\treturn linelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txLock",
          "args": [
            "tid",
            "ip",
            "mp",
            "tlckDATA"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "txLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_txnmgr.c",
          "lines": "590-861",
          "snippet": "struct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;",
            "static struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;",
            "static int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);",
            "static void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);",
            "static void txForce(struct tblock * tblk);",
            "static void txUpdateMap(struct tblock * tblk);",
            "static void txRelease(struct tblock * tblk);",
            "static void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);",
            "static void LogSyncRelease(struct metapage * mp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tint freetid;\t\t/* index of a free tid structure */\n\tint freelock;\t\t/* index first free lock word */\n\twait_queue_head_t freewait;\t/* eventlist of free tblock */\n\twait_queue_head_t freelockwait;\t/* eventlist of free tlock */\n\twait_queue_head_t lowlockwait;\t/* eventlist of ample tlocks */\n\tint tlocksInUse;\t/* Number of tlocks in use */\n\tspinlock_t LazyLock;\t/* synchronize sync_queue & unlock_queue */\n/*\tstruct tblock *sync_queue; * Transactions waiting for data sync */\n\tstruct list_head unlock_queue;\t/* Txns waiting to be released */\n\tstruct list_head anon_list;\t/* inodes having anonymous txns */\n\tstruct list_head anon_list2;\t/* inodes having anonymous txns\n\t\t\t\t\t   that couldn't be sync'ed */\n} TxAnchor;\nstatic struct {\n\ttid_t maxtid;\t\t/* 4: biggest tid ever used */\n\tlid_t maxlid;\t\t/* 4: biggest lid ever used */\n\tint ntid;\t\t/* 4: # of transactions performed */\n\tint nlid;\t\t/* 4: # of tlocks acquired */\n\tint waitlock;\t\t/* 4: # of tlock wait */\n} stattx;\nstatic int dataLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void dtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void mapLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t\tstruct tlock * tlck);\nstatic void txAllocPMap(struct inode *ip, struct maplock * maplock,\n\t\tstruct tblock * tblk);\nstatic void txForce(struct tblock * tblk);\nstatic void txUpdateMap(struct tblock * tblk);\nstatic void txRelease(struct tblock * tblk);\nstatic void xtLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\n\t   struct tlock * tlck);\nstatic void LogSyncRelease(struct metapage * mp);\n\nstruct tlock *txLock(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t     int type)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\tint dir_xtree = 0;\n\tlid_t lid;\n\ttid_t xtid;\n\tstruct tlock *tlck;\n\tstruct xtlock *xtlck;\n\tstruct linelock *linelock;\n\txtpage_t *p;\n\tstruct tblock *tblk;\n\n\tTXN_LOCK();\n\n\tif (S_ISDIR(ip->i_mode) && (type & tlckXTREE) &&\n\t    !(mp->xflag & COMMIT_PAGE)) {\n\t\t/*\n\t\t * Directory inode is special.  It can have both an xtree tlock\n\t\t * and a dtree tlock associated with it.\n\t\t */\n\t\tdir_xtree = 1;\n\t\tlid = jfs_ip->xtlid;\n\t} else\n\t\tlid = mp->lid;\n\n\t/* is page not locked by a transaction ? */\n\tif (lid == 0)\n\t\tgoto allocateLock;\n\n\tjfs_info(\"txLock: tid:%d ip:0x%p mp:0x%p lid:%d\", tid, ip, mp, lid);\n\n\t/* is page locked by the requester transaction ? */\n\ttlck = lid_to_tlock(lid);\n\tif ((xtid = tlck->tid) == tid) {\n\t\tTXN_UNLOCK();\n\t\tgoto grantLock;\n\t}\n\n\t/*\n\t * is page locked by anonymous transaction/lock ?\n\t *\n\t * (page update without transaction (i.e., file write) is\n\t * locked under anonymous transaction tid = 0:\n\t * anonymous tlocks maintained on anonymous tlock list of\n\t * the inode of the page and available to all anonymous\n\t * transactions until txCommit() time at which point\n\t * they are transferred to the transaction tlock list of\n\t * the committing transaction of the inode)\n\t */\n\tif (xtid == 0) {\n\t\ttlck->tid = tid;\n\t\tTXN_UNLOCK();\n\t\ttblk = tid_to_tblock(tid);\n\t\t/*\n\t\t * The order of the tlocks in the transaction is important\n\t\t * (during truncate, child xtree pages must be freed before\n\t\t * parent's tlocks change the working map).\n\t\t * Take tlock off anonymous list and add to tail of\n\t\t * transaction list\n\t\t *\n\t\t * Note:  We really need to get rid of the tid & lid and\n\t\t * use list_head's.  This code is getting UGLY!\n\t\t */\n\t\tif (jfs_ip->atlhead == lid) {\n\t\t\tif (jfs_ip->atltail == lid) {\n\t\t\t\t/* only anonymous txn.\n\t\t\t\t * Remove from anon_list\n\t\t\t\t */\n\t\t\t\tTXN_LOCK();\n\t\t\t\tlist_del_init(&jfs_ip->anon_inode_list);\n\t\t\t\tTXN_UNLOCK();\n\t\t\t}\n\t\t\tjfs_ip->atlhead = tlck->next;\n\t\t} else {\n\t\t\tlid_t last;\n\t\t\tfor (last = jfs_ip->atlhead;\n\t\t\t     lid_to_tlock(last)->next != lid;\n\t\t\t     last = lid_to_tlock(last)->next) {\n\t\t\t\tassert(last);\n\t\t\t}\n\t\t\tlid_to_tlock(last)->next = tlck->next;\n\t\t\tif (jfs_ip->atltail == lid)\n\t\t\t\tjfs_ip->atltail = last;\n\t\t}\n\n\t\t/* insert the tlock at tail of transaction tlock list */\n\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\n\t\tgoto grantLock;\n\t}\n\n\tgoto waitLock;\n\n\t/*\n\t * allocate a tlock\n\t */\n      allocateLock:\n\tlid = txLockAlloc();\n\ttlck = lid_to_tlock(lid);\n\n\t/*\n\t * initialize tlock\n\t */\n\ttlck->tid = tid;\n\n\tTXN_UNLOCK();\n\n\t/* mark tlock for meta-data page */\n\tif (mp->xflag & COMMIT_PAGE) {\n\n\t\ttlck->flag = tlckPAGELOCK;\n\n\t\t/* mark the page dirty and nohomeok */\n\t\tmetapage_nohomeok(mp);\n\n\t\tjfs_info(\"locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p\",\n\t\t\t mp, mp->nohomeok, tid, tlck);\n\n\t\t/* if anonymous transaction, and buffer is on the group\n\t\t * commit synclist, mark inode to show this.  This will\n\t\t * prevent the buffer from being marked nohomeok for too\n\t\t * long a time.\n\t\t */\n\t\tif ((tid == 0) && mp->lsn)\n\t\t\tset_cflag(COMMIT_Synclist, ip);\n\t}\n\t/* mark tlock for in-memory inode */\n\telse\n\t\ttlck->flag = tlckINODELOCK;\n\n\tif (S_ISDIR(ip->i_mode))\n\t\ttlck->flag |= tlckDIRECTORY;\n\n\ttlck->type = 0;\n\n\t/* bind the tlock and the page */\n\ttlck->ip = ip;\n\ttlck->mp = mp;\n\tif (dir_xtree)\n\t\tjfs_ip->xtlid = lid;\n\telse\n\t\tmp->lid = lid;\n\n\t/*\n\t * enqueue transaction lock to transaction/inode\n\t */\n\t/* insert the tlock at tail of transaction tlock list */\n\tif (tid) {\n\t\ttblk = tid_to_tblock(tid);\n\t\tif (tblk->next)\n\t\t\tlid_to_tlock(tblk->last)->next = lid;\n\t\telse\n\t\t\ttblk->next = lid;\n\t\ttlck->next = 0;\n\t\ttblk->last = lid;\n\t}\n\t/* anonymous transaction:\n\t * insert the tlock at head of inode anonymous tlock list\n\t */\n\telse {\n\t\ttlck->next = jfs_ip->atlhead;\n\t\tjfs_ip->atlhead = lid;\n\t\tif (tlck->next == 0) {\n\t\t\t/* This inode's first anonymous transaction */\n\t\t\tjfs_ip->atltail = lid;\n\t\t\tTXN_LOCK();\n\t\t\tlist_add_tail(&jfs_ip->anon_inode_list,\n\t\t\t\t      &TxAnchor.anon_list);\n\t\t\tTXN_UNLOCK();\n\t\t}\n\t}\n\n\t/* initialize type dependent area for linelock */\n\tlinelock = (struct linelock *) & tlck->lock;\n\tlinelock->next = 0;\n\tlinelock->flag = tlckLINELOCK;\n\tlinelock->maxcnt = TLOCKSHORT;\n\tlinelock->index = 0;\n\n\tswitch (type & tlckTYPE) {\n\tcase tlckDTREE:\n\t\tlinelock->l2linesize = L2DTSLOTSIZE;\n\t\tbreak;\n\n\tcase tlckXTREE:\n\t\tlinelock->l2linesize = L2XTSLOTSIZE;\n\n\t\txtlck = (struct xtlock *) linelock;\n\t\txtlck->header.offset = 0;\n\t\txtlck->header.length = 2;\n\n\t\tif (type & tlckNEW) {\n\t\t\txtlck->lwm.offset = XTENTRYSTART;\n\t\t} else {\n\t\t\tif (mp->xflag & COMMIT_PAGE)\n\t\t\t\tp = (xtpage_t *) mp->data;\n\t\t\telse\n\t\t\t\tp = &jfs_ip->i_xtroot;\n\t\t\txtlck->lwm.offset =\n\t\t\t    le16_to_cpu(p->header.nextindex);\n\t\t}\n\t\txtlck->lwm.length = 0;\t/* ! */\n\t\txtlck->twm.offset = 0;\n\t\txtlck->hwm.offset = 0;\n\n\t\txtlck->index = 2;\n\t\tbreak;\n\n\tcase tlckINODE:\n\t\tlinelock->l2linesize = L2INODESLOTSIZE;\n\t\tbreak;\n\n\tcase tlckDATA:\n\t\tlinelock->l2linesize = L2DATASLOTSIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tjfs_err(\"UFO tlock:0x%p\", tlck);\n\t}\n\n\t/*\n\t * update tlock vector\n\t */\n      grantLock:\n\ttlck->type |= type;\n\n\treturn tlck;\n\n\t/*\n\t * page is being locked by another transaction:\n\t */\n      waitLock:\n\t/* Only locks on ipimap or ipaimap should reach here */\n\t/* assert(jfs_ip->fileset == AGGREGATE_I); */\n\tif (jfs_ip->fileset != AGGREGATE_I) {\n\t\tprintk(KERN_ERR \"txLock: trying to lock locked page!\");\n\t\tprint_hex_dump(KERN_ERR, \"ip: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       ip, sizeof(*ip), 0);\n\t\tprint_hex_dump(KERN_ERR, \"mp: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       mp, sizeof(*mp), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Locker's tblock: \",\n\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4, tid_to_tblock(tid),\n\t\t\t       sizeof(struct tblock), 0);\n\t\tprint_hex_dump(KERN_ERR, \"Tlock: \", DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t       tlck, sizeof(*tlck), 0);\n\t\tBUG();\n\t}\n\tINCREMENT(stattx.waitlock);\t/* statistics */\n\tTXN_UNLOCK();\n\trelease_metapage(mp);\n\tTXN_LOCK();\n\txtid = tlck->tid;\t/* reacquire after dropping TXN_LOCK */\n\n\tjfs_info(\"txLock: in waitLock, tid = %d, xtid = %d, lid = %d\",\n\t\t tid, xtid, lid);\n\n\t/* Recheck everything since dropping TXN_LOCK */\n\tif (xtid && (tlck->mp == mp) && (mp->lid == lid))\n\t\tTXN_SLEEP_DROP_LOCK(&tid_to_tblock(xtid)->waitor);\n\telse\n\t\tTXN_UNLOCK();\n\tjfs_info(\"txLock: awakened     tid = %d, lid = %d\", tid, lid);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic inline void lock_index(tid_t tid, struct inode *ip, struct metapage * mp,\n\t\t\t      u32 index)\n{\n\tstruct tlock *tlck;\n\tstruct linelock *llck;\n\tstruct lv *lv;\n\n\ttlck = txLock(tid, ip, mp, tlckDATA);\n\tllck = (struct linelock *) tlck->lock;\n\n\tif (llck->index >= llck->maxcnt)\n\t\tllck = txLinelock(llck);\n\tlv = &llck->lv[llck->index];\n\n\t/*\n\t *\tLinelock slot size is twice the size of directory table\n\t *\tslot size.  512 entries per page.\n\t */\n\tlv->offset = ((index - 2) & 511) >> 1;\n\tlv->length = 1;\n\tllck->index++;\n}"
  },
  {
    "function_name": "find_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "249-302",
    "snippet": "static struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"free_index: error reading directory table\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_index_page",
          "args": [
            "ip",
            "blkno"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "read_index_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
          "lines": "208-220",
          "snippet": "static struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_unicode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "*mp"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_dirtable_inline",
          "args": [
            "ip"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_dirtable_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "212-215",
          "snippet": "static inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline int jfs_dirtable_inline(struct inode *inode)\n{\n\treturn (JFS_IP(inode)->next_index <= (MAX_INLINE_DIRTABLE_ENTRY + 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"find_entry called with index >= next_index\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_warn",
          "args": [
            "\"find_entry called with index = %d\"",
            "index"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_IP",
          "args": [
            "ip"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_IP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "207-210",
          "snippet": "static inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_inode_info *JFS_IP(struct inode *inode)\n{\n\treturn list_entry(inode, struct jfs_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct dir_table_slot *find_index(struct inode *ip, u32 index,\n\t\t\t\t\t struct metapage ** mp, s64 *lblock)\n{\n\tstruct jfs_inode_info *jfs_ip = JFS_IP(ip);\n\ts64 blkno;\n\ts64 offset;\n\tint page_offset;\n\tstruct dir_table_slot *slot;\n\tstatic int maxWarnings = 10;\n\n\tif (index < 2) {\n\t\tif (maxWarnings) {\n\t\t\tjfs_warn(\"find_entry called with index = %d\", index);\n\t\t\tmaxWarnings--;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tif (index >= jfs_ip->next_index) {\n\t\tjfs_warn(\"find_entry called with index >= next_index\");\n\t\treturn NULL;\n\t}\n\n\tif (jfs_dirtable_inline(ip)) {\n\t\t/*\n\t\t * Inline directory table\n\t\t */\n\t\t*mp = NULL;\n\t\tslot = &jfs_ip->i_dirtable[index - 2];\n\t} else {\n\t\toffset = (index - 2) * sizeof(struct dir_table_slot);\n\t\tpage_offset = offset & (PSIZE - 1);\n\t\tblkno = ((offset + 1) >> L2PSIZE) <<\n\t\t    JFS_SBI(ip->i_sb)->l2nbperpage;\n\n\t\tif (*mp && (*lblock != blkno)) {\n\t\t\trelease_metapage(*mp);\n\t\t\t*mp = NULL;\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\t*lblock = blkno;\n\t\t\t*mp = read_index_page(ip, blkno);\n\t\t}\n\t\tif (!(*mp)) {\n\t\t\tjfs_err(\"free_index: error reading directory table\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tslot =\n\t\t    (struct dir_table_slot *) ((char *) (*mp)->data +\n\t\t\t\t\t       page_offset);\n\t}\n\treturn slot;\n}"
  },
  {
    "function_name": "get_index_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "227-239",
    "snippet": "static struct metapage *get_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn get_metapage(inode, xaddr, PSIZE, 1);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_metapage",
          "args": [
            "inode",
            "xaddr",
            "PSIZE",
            "1"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtLookup",
          "args": [
            "inode",
            "blkno",
            "1",
            "&xflag",
            "&xaddr",
            "&xlen",
            "1"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "xtLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "146-219",
          "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct metapage *get_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn get_metapage(inode, xaddr, PSIZE, 1);\n}"
  },
  {
    "function_name": "read_index_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_dtree.c",
    "lines": "208-220",
    "snippet": "static struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_unicode.h\"",
      "#include \"jfs_dmap.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/slab.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_metapage",
          "args": [
            "inode",
            "xaddr",
            "PSIZE",
            "1"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xtLookup",
          "args": [
            "inode",
            "blkno",
            "1",
            "&xflag",
            "&xaddr",
            "&xlen",
            "1"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xtLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "146-219",
          "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_unicode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/fs.h>\n\nstatic struct metapage *read_index_page(struct inode *inode, s64 blkno)\n{\n\tint rc;\n\ts64 xaddr;\n\tint xflag;\n\ts32 xlen;\n\n\trc = xtLookup(inode, blkno, 1, &xflag, &xaddr, &xlen, 1);\n\tif (rc || (xaddr == 0))\n\t\treturn NULL;\n\n\treturn read_metapage(inode, xaddr, PSIZE, 1);\n}"
  }
]