[
  {
    "function_name": "cachefiles_determine_cache_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/security.c",
    "lines": "79-116",
    "snippet": "int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\tstruct dentry *root,\n\t\t\t\t\tconst struct cred **_saved_cred)\n{\n\tstruct cred *new;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* duplicate the cache creds for COW (the override is currently in\n\t * force, so we can use prepare_creds() to do this) */\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tcachefiles_end_secure(cache, *_saved_cred);\n\n\t/* use the cache root dir's security context as the basis with\n\t * which create files */\n\tret = set_create_files_as(new, root->d_inode);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\tcachefiles_begin_secure(cache, _saved_cred);\n\t\t_leave(\" = %d [cfa]\", ret);\n\t\treturn ret;\n\t}\n\n\tput_cred(cache->cache_cred);\n\tcache->cache_cred = new;\n\n\tcachefiles_begin_secure(cache, _saved_cred);\n\tret = cachefiles_check_cache_dir(cache, root);\n\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_check_cache_dir",
          "args": [
            "cache",
            "root"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_cache_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/security.c",
          "lines": "53-71",
          "snippet": "static int cachefiles_check_cache_dir(struct cachefiles_cache *cache,\n\t\t\t\t      struct dentry *root)\n{\n\tint ret;\n\n\tret = security_inode_mkdir(root->d_inode, root, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Security denies permission to make dirs: error %d\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\tret = security_inode_create(root->d_inode, root, 0);\n\tif (ret < 0)\n\t\tpr_err(\"Security denies permission to create files: error %d\",\n\t\t       ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cred.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/fs.h>\n\nstatic int cachefiles_check_cache_dir(struct cachefiles_cache *cache,\n\t\t\t\t      struct dentry *root)\n{\n\tint ret;\n\n\tret = security_inode_mkdir(root->d_inode, root, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Security denies permission to make dirs: error %d\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\tret = security_inode_create(root->d_inode, root, 0);\n\tif (ret < 0)\n\t\tpr_err(\"Security denies permission to create files: error %d\",\n\t\t       ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "_saved_cred"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cache->cache_cred"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_create_files_as",
          "args": [
            "new",
            "root->d_inode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "*_saved_cred"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/fs.h>\n\nint cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\tstruct dentry *root,\n\t\t\t\t\tconst struct cred **_saved_cred)\n{\n\tstruct cred *new;\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* duplicate the cache creds for COW (the override is currently in\n\t * force, so we can use prepare_creds() to do this) */\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tcachefiles_end_secure(cache, *_saved_cred);\n\n\t/* use the cache root dir's security context as the basis with\n\t * which create files */\n\tret = set_create_files_as(new, root->d_inode);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\tcachefiles_begin_secure(cache, _saved_cred);\n\t\t_leave(\" = %d [cfa]\", ret);\n\t\treturn ret;\n\t}\n\n\tput_cred(cache->cache_cred);\n\tcache->cache_cred = new;\n\n\tcachefiles_begin_secure(cache, _saved_cred);\n\tret = cachefiles_check_cache_dir(cache, root);\n\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_check_cache_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/security.c",
    "lines": "53-71",
    "snippet": "static int cachefiles_check_cache_dir(struct cachefiles_cache *cache,\n\t\t\t\t      struct dentry *root)\n{\n\tint ret;\n\n\tret = security_inode_mkdir(root->d_inode, root, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Security denies permission to make dirs: error %d\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\tret = security_inode_create(root->d_inode, root, 0);\n\tif (ret < 0)\n\t\tpr_err(\"Security denies permission to create files: error %d\",\n\t\t       ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Security denies permission to create files: error %d\"",
            "ret"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_create",
          "args": [
            "root->d_inode",
            "root",
            "0"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Security denies permission to make dirs: error %d\"",
            "ret"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_mkdir",
          "args": [
            "root->d_inode",
            "root",
            "0"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/fs.h>\n\nstatic int cachefiles_check_cache_dir(struct cachefiles_cache *cache,\n\t\t\t\t      struct dentry *root)\n{\n\tint ret;\n\n\tret = security_inode_mkdir(root->d_inode, root, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Security denies permission to make dirs: error %d\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\tret = security_inode_create(root->d_inode, root, 0);\n\tif (ret < 0)\n\t\tpr_err(\"Security denies permission to create files: error %d\",\n\t\t       ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_get_security_ID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/security.c",
    "lines": "20-48",
    "snippet": "int cachefiles_get_security_ID(struct cachefiles_cache *cache)\n{\n\tstruct cred *new;\n\tint ret;\n\n\t_enter(\"{%s}\", cache->secctx);\n\n\tnew = prepare_kernel_cred(current);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (cache->secctx) {\n\t\tret = set_security_override_from_ctx(new, cache->secctx);\n\t\tif (ret < 0) {\n\t\t\tput_cred(new);\n\t\t\tpr_err(\"Security denies permission to nominate security context: error %d\\n\",\n\t\t\t       ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcache->cache_cred = new;\n\tret = 0;\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/cred.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Security denies permission to nominate security context: error %d\\n\"",
            "ret"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_security_override_from_ctx",
          "args": [
            "new",
            "cache->secctx"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_kernel_cred",
          "args": [
            "current"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s}\"",
            "cache->secctx"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/cred.h>\n#include <linux/fs.h>\n\nint cachefiles_get_security_ID(struct cachefiles_cache *cache)\n{\n\tstruct cred *new;\n\tint ret;\n\n\t_enter(\"{%s}\", cache->secctx);\n\n\tnew = prepare_kernel_cred(current);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (cache->secctx) {\n\t\tret = set_security_override_from_ctx(new, cache->secctx);\n\t\tif (ret < 0) {\n\t\t\tput_cred(new);\n\t\t\tpr_err(\"Security denies permission to nominate security context: error %d\\n\",\n\t\t\t       ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcache->cache_cred = new;\n\tret = 0;\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  }
]