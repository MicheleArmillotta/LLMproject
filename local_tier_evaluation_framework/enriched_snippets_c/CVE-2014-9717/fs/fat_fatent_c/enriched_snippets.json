[
  {
    "function_name": "fat_count_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "652-695",
    "snippet": "int fat_count_free_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tunsigned long reada_blocks, reada_mask, cur_block;\n\tint err = 0, free;\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid)\n\t\tgoto out;\n\n\treada_blocks = FAT_READA_SIZE >> sb->s_blocksize_bits;\n\treada_mask = reada_blocks - 1;\n\tcur_block = 0;\n\n\tfree = 0;\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, FAT_START_ENT);\n\twhile (fatent.entry < sbi->max_cluster) {\n\t\t/* readahead of fat blocks */\n\t\tif ((cur_block & reada_mask) == 0) {\n\t\t\tunsigned long rest = sbi->fat_length - cur_block;\n\t\t\tfat_ent_reada(sb, &fatent, min(reada_blocks, rest));\n\t\t}\n\t\tcur_block++;\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE)\n\t\t\t\tfree++;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\tsbi->free_clusters = free;\n\tsbi->free_clus_valid = 1;\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\nout:\n\tunlock_fat(sbi);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define FAT_READA_SIZE\t\t(128 * 1024)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_fat",
          "args": [
            "sbi"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "284-287",
          "snippet": "static inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "&fatent"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_fsinfo_dirty",
          "args": [
            "sb"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "mark_fsinfo_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "311-319",
          "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_next",
          "args": [
            "sbi",
            "&fatent"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "425-433",
          "snippet": "static inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->ent_get",
          "args": [
            "&fatent"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_ent_read_block",
          "args": [
            "sb",
            "&fatent"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "435-445",
          "snippet": "static inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_reada",
          "args": [
            "sb",
            "&fatent",
            "min(reada_blocks, rest)"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "639-650",
          "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "reada_blocks",
            "rest"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_set_entry",
          "args": [
            "&fatent",
            "FAT_START_ENT"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "333-337",
          "snippet": "static inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define FAT_READA_SIZE\t\t(128 * 1024)\n\nint fat_count_free_clusters(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tunsigned long reada_blocks, reada_mask, cur_block;\n\tint err = 0, free;\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid)\n\t\tgoto out;\n\n\treada_blocks = FAT_READA_SIZE >> sb->s_blocksize_bits;\n\treada_mask = reada_blocks - 1;\n\tcur_block = 0;\n\n\tfree = 0;\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, FAT_START_ENT);\n\twhile (fatent.entry < sbi->max_cluster) {\n\t\t/* readahead of fat blocks */\n\t\tif ((cur_block & reada_mask) == 0) {\n\t\t\tunsigned long rest = sbi->fat_length - cur_block;\n\t\t\tfat_ent_reada(sb, &fatent, min(reada_blocks, rest));\n\t\t}\n\t\tcur_block++;\n\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE)\n\t\t\t\tfree++;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\tsbi->free_clusters = free;\n\tsbi->free_clus_valid = 1;\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\nout:\n\tunlock_fat(sbi);\n\treturn err;\n}"
  },
  {
    "function_name": "fat_ent_reada",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "639-650",
    "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_breadahead",
          "args": [
            "sb",
            "blocknr + i"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->ent_blocknr",
          "args": [
            "sb",
            "fatent->entry",
            "&offset",
            "&blocknr"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
  },
  {
    "function_name": "fat_free_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "553-633",
    "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_fsinfo_dirty",
          "args": [
            "sb"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "mark_fsinfo_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "311-319",
          "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_fat",
          "args": [
            "sbi"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "284-287",
          "snippet": "static inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_mirror_bhs",
          "args": [
            "sb",
            "bhs",
            "nr_bhs"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "fat_mirror_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "378-407",
          "snippet": "static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_bhs",
          "args": [
            "bhs",
            "nr_bhs"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "269-282",
          "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_collect_bhs",
          "args": [
            "bhs",
            "&nr_bhs",
            "&fatent"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "fat_collect_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "447-463",
          "snippet": "static void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->ent_put",
          "args": [
            "&fatent",
            "FAT_ENT_FREE"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "fat_clus_to_blknr(sbi, first_cl)",
            "nr_clus * sbi->sec_per_clus",
            "GFP_NOFS",
            "0"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_clus_to_blknr",
          "args": [
            "sbi",
            "first_cl"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "fat_clus_to_blknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "219-223",
          "snippet": "static inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline sector_t fat_clus_to_blknr(struct msdos_sb_info *sbi, int clus)\n{\n\treturn ((sector_t)clus - FAT_START_ENT) * sbi->sec_per_clus\n\t\t+ sbi->data_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"%s: deleting FAT entry beyond EOF\"",
            "__func__"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_read",
          "args": [
            "inode",
            "&fatent",
            "cluster"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "639-650",
          "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fat_alloc_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "465-551",
    "snippet": "int fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "inode",
            "cluster[0]"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_mirror_bhs",
          "args": [
            "sb",
            "bhs",
            "nr_bhs"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "fat_mirror_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "378-407",
          "snippet": "static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_bhs",
          "args": [
            "bhs",
            "nr_bhs"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "269-282",
          "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_needs_sync",
          "args": [
            "inode"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "inode_needs_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1751-1758",
          "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_fsinfo_dirty",
          "args": [
            "sb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "mark_fsinfo_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "311-319",
          "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_fat",
          "args": [
            "sbi"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "284-287",
          "snippet": "static inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_next",
          "args": [
            "sbi",
            "&fatent"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "425-433",
          "snippet": "static inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_collect_bhs",
          "args": [
            "bhs",
            "&nr_bhs",
            "&fatent"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "fat_collect_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "447-463",
          "snippet": "static void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->ent_put",
          "args": [
            "&prev_ent",
            "entry"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->ent_put",
          "args": [
            "&fatent",
            "FAT_ENT_EOF"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->ent_get",
          "args": [
            "&fatent"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_ent_read_block",
          "args": [
            "sb",
            "&fatent"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_read_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "435-445",
          "snippet": "static inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_set_entry",
          "args": [
            "&fatent",
            "fatent.entry"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "333-337",
          "snippet": "static inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_cluster > (MAX_BUF_PER_PAGE / 2)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_alloc_clusters(struct inode *inode, int *cluster, int nr_cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent, prev_ent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, count, err, nr_bhs, idx_clus;\n\n\tBUG_ON(nr_cluster > (MAX_BUF_PER_PAGE / 2));\t/* fixed limit */\n\n\tlock_fat(sbi);\n\tif (sbi->free_clusters != -1 && sbi->free_clus_valid &&\n\t    sbi->free_clusters < nr_cluster) {\n\t\tunlock_fat(sbi);\n\t\treturn -ENOSPC;\n\t}\n\n\terr = nr_bhs = idx_clus = 0;\n\tcount = FAT_START_ENT;\n\tfatent_init(&prev_ent);\n\tfatent_init(&fatent);\n\tfatent_set_entry(&fatent, sbi->prev_free + 1);\n\twhile (count < sbi->max_cluster) {\n\t\tif (fatent.entry >= sbi->max_cluster)\n\t\t\tfatent.entry = FAT_START_ENT;\n\t\tfatent_set_entry(&fatent, fatent.entry);\n\t\terr = fat_ent_read_block(sb, &fatent);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Find the free entries in a block */\n\t\tdo {\n\t\t\tif (ops->ent_get(&fatent) == FAT_ENT_FREE) {\n\t\t\t\tint entry = fatent.entry;\n\n\t\t\t\t/* make the cluster chain */\n\t\t\t\tops->ent_put(&fatent, FAT_ENT_EOF);\n\t\t\t\tif (prev_ent.nr_bhs)\n\t\t\t\t\tops->ent_put(&prev_ent, entry);\n\n\t\t\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\n\t\t\t\tsbi->prev_free = entry;\n\t\t\t\tif (sbi->free_clusters != -1)\n\t\t\t\t\tsbi->free_clusters--;\n\n\t\t\t\tcluster[idx_clus] = entry;\n\t\t\t\tidx_clus++;\n\t\t\t\tif (idx_clus == nr_cluster)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/*\n\t\t\t\t * fat_collect_bhs() gets ref-count of bhs,\n\t\t\t\t * so we can still use the prev_ent.\n\t\t\t\t */\n\t\t\t\tprev_ent = fatent;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == sbi->max_cluster)\n\t\t\t\tbreak;\n\t\t} while (fat_ent_next(sbi, &fatent));\n\t}\n\n\t/* Couldn't allocate the free entries */\n\tsbi->free_clusters = 0;\n\tsbi->free_clus_valid = 1;\n\terr = -ENOSPC;\n\nout:\n\tunlock_fat(sbi);\n\tmark_fsinfo_dirty(sb);\n\tfatent_brelse(&fatent);\n\tif (!err) {\n\t\tif (inode_needs_sync(inode))\n\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (!err)\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t}\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\n\tif (err && idx_clus)\n\t\tfat_free_clusters(inode, cluster[0]);\n\n\treturn err;\n}"
  },
  {
    "function_name": "fat_collect_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "447-463",
    "snippet": "static void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "fatent->bhs[n]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_collect_bhs(struct buffer_head **bhs, int *nr_bhs,\n\t\t\t    struct fat_entry *fatent)\n{\n\tint n, i;\n\n\tfor (n = 0; n < fatent->nr_bhs; n++) {\n\t\tfor (i = 0; i < *nr_bhs; i++) {\n\t\t\tif (fatent->bhs[n] == bhs[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == *nr_bhs) {\n\t\t\tget_bh(fatent->bhs[n]);\n\t\t\tbhs[i] = fatent->bhs[n];\n\t\t\t(*nr_bhs)++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "fat_ent_read_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "435-445",
    "snippet": "static inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->ent_bread",
          "args": [
            "sb",
            "fatent",
            "offset",
            "blocknr"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->ent_blocknr",
          "args": [
            "sb",
            "fatent->entry",
            "&offset",
            "&blocknr"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "fatent"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_read_block(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint offset;\n\n\tfatent_brelse(fatent);\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\treturn ops->ent_bread(sb, fatent, offset, blocknr);\n}"
  },
  {
    "function_name": "fat_ent_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "425-433",
    "snippet": "static inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sbi->fatent_ops->ent_next",
          "args": [
            "fatent"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_next(struct msdos_sb_info *sbi,\n\t\t\t       struct fat_entry *fatent)\n{\n\tif (sbi->fatent_ops->ent_next(fatent)) {\n\t\tif (fatent->entry < sbi->max_cluster)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_ent_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "409-423",
    "snippet": "int fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_mirror_bhs",
          "args": [
            "sb",
            "fatent->bhs",
            "fatent->nr_bhs"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "fat_mirror_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "378-407",
          "snippet": "static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_bhs",
          "args": [
            "fatent->bhs",
            "fatent->nr_bhs"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "269-282",
          "snippet": "int fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_sync_bhs(struct buffer_head **bhs, int nr_bhs)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < nr_bhs; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE);\n\n\tfor (i = 0; i < nr_bhs; i++) {\n\t\twait_on_buffer(bhs[i]);\n\t\tif (!err && !buffer_uptodate(bhs[i]))\n\t\t\terr = -EIO;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->ent_put",
          "args": [
            "fatent",
            "new"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}"
  },
  {
    "function_name": "fat_mirror_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "378-407",
    "snippet": "static int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "c_bh"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "c_bh"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "c_bh",
            "sbi->fat_inode"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "c_bh"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "c_bh->b_data",
            "bhs[n]->b_data",
            "sb->s_blocksize"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "backup_fat + bhs[n]->b_blocknr"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat_mirror_bhs(struct super_block *sb, struct buffer_head **bhs,\n\t\t\t  int nr_bhs)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *c_bh;\n\tint err, n, copy;\n\n\terr = 0;\n\tfor (copy = 1; copy < sbi->fats; copy++) {\n\t\tsector_t backup_fat = sbi->fat_length * copy;\n\n\t\tfor (n = 0; n < nr_bhs; n++) {\n\t\t\tc_bh = sb_getblk(sb, backup_fat + bhs[n]->b_blocknr);\n\t\t\tif (!c_bh) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(c_bh->b_data, bhs[n]->b_data, sb->s_blocksize);\n\t\t\tset_buffer_uptodate(c_bh);\n\t\t\tmark_buffer_dirty_inode(c_bh, sbi->fat_inode);\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\t\terr = sync_dirty_buffer(c_bh);\n\t\t\tbrelse(c_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn err;\n}"
  },
  {
    "function_name": "fat_ent_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "351-375",
    "snippet": "int fat_ent_read(struct inode *inode, struct fat_entry *fatent, int entry)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tint err, offset;\n\tsector_t blocknr;\n\n\tif (entry < FAT_START_ENT || sbi->max_cluster <= entry) {\n\t\tfatent_brelse(fatent);\n\t\tfat_fs_error(sb, \"invalid access to FAT (entry 0x%08x)\", entry);\n\t\treturn -EIO;\n\t}\n\n\tfatent_set_entry(fatent, entry);\n\tops->ent_blocknr(sb, entry, &offset, &blocknr);\n\n\tif (!fat_ent_update_ptr(sb, fatent, offset, blocknr)) {\n\t\tfatent_brelse(fatent);\n\t\terr = ops->ent_bread(sb, fatent, offset, blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ops->ent_get(fatent);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->ent_get",
          "args": [
            "fatent"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->ent_bread",
          "args": [
            "sb",
            "fatent",
            "offset",
            "blocknr"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "fatent"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_update_ptr",
          "args": [
            "sb",
            "fatent",
            "offset",
            "blocknr"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_update_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "321-349",
          "snippet": "static inline int fat_ent_update_ptr(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent,\n\t\t\t\t     int offset, sector_t blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\t/* Is this fatent's blocks including this entry? */\n\tif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\n\t\treturn 0;\n\tif (sbi->fat_bits == 12) {\n\t\tif ((offset + 1) < sb->s_blocksize) {\n\t\t\t/* This entry is on bhs[0]. */\n\t\t\tif (fatent->nr_bhs == 2) {\n\t\t\t\tbrelse(bhs[1]);\n\t\t\t\tfatent->nr_bhs = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This entry needs the next block. */\n\t\t\tif (fatent->nr_bhs != 2)\n\t\t\t\treturn 0;\n\t\t\tif (bhs[1]->b_blocknr != (blocknr + 1))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tops->ent_set_ptr(fatent, offset);\n\treturn 1;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_update_ptr(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent,\n\t\t\t\t     int offset, sector_t blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\t/* Is this fatent's blocks including this entry? */\n\tif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\n\t\treturn 0;\n\tif (sbi->fat_bits == 12) {\n\t\tif ((offset + 1) < sb->s_blocksize) {\n\t\t\t/* This entry is on bhs[0]. */\n\t\t\tif (fatent->nr_bhs == 2) {\n\t\t\t\tbrelse(bhs[1]);\n\t\t\t\tfatent->nr_bhs = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This entry needs the next block. */\n\t\t\tif (fatent->nr_bhs != 2)\n\t\t\t\treturn 0;\n\t\t\tif (bhs[1]->b_blocknr != (blocknr + 1))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tops->ent_set_ptr(fatent, offset);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->ent_blocknr",
          "args": [
            "sb",
            "entry",
            "&offset",
            "&blocknr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatent_set_entry",
          "args": [
            "fatent",
            "entry"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "333-337",
          "snippet": "static inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_set_entry(struct fat_entry *fatent, int entry)\n{\n\tfatent->entry = entry;\n\tfatent->u.ent32_p = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"invalid access to FAT (entry 0x%08x)\"",
            "entry"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_ent_read(struct inode *inode, struct fat_entry *fatent, int entry)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tint err, offset;\n\tsector_t blocknr;\n\n\tif (entry < FAT_START_ENT || sbi->max_cluster <= entry) {\n\t\tfatent_brelse(fatent);\n\t\tfat_fs_error(sb, \"invalid access to FAT (entry 0x%08x)\", entry);\n\t\treturn -EIO;\n\t}\n\n\tfatent_set_entry(fatent, entry);\n\tops->ent_blocknr(sb, entry, &offset, &blocknr);\n\n\tif (!fat_ent_update_ptr(sb, fatent, offset, blocknr)) {\n\t\tfatent_brelse(fatent);\n\t\terr = ops->ent_bread(sb, fatent, offset, blocknr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ops->ent_get(fatent);\n}"
  },
  {
    "function_name": "fat_ent_update_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "321-349",
    "snippet": "static inline int fat_ent_update_ptr(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent,\n\t\t\t\t     int offset, sector_t blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\t/* Is this fatent's blocks including this entry? */\n\tif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\n\t\treturn 0;\n\tif (sbi->fat_bits == 12) {\n\t\tif ((offset + 1) < sb->s_blocksize) {\n\t\t\t/* This entry is on bhs[0]. */\n\t\t\tif (fatent->nr_bhs == 2) {\n\t\t\t\tbrelse(bhs[1]);\n\t\t\t\tfatent->nr_bhs = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This entry needs the next block. */\n\t\t\tif (fatent->nr_bhs != 2)\n\t\t\t\treturn 0;\n\t\t\tif (bhs[1]->b_blocknr != (blocknr + 1))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tops->ent_set_ptr(fatent, offset);\n\treturn 1;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->ent_set_ptr",
          "args": [
            "fatent",
            "offset"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[1]"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int fat_ent_update_ptr(struct super_block *sb,\n\t\t\t\t     struct fat_entry *fatent,\n\t\t\t\t     int offset, sector_t blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\t/* Is this fatent's blocks including this entry? */\n\tif (!fatent->nr_bhs || bhs[0]->b_blocknr != blocknr)\n\t\treturn 0;\n\tif (sbi->fat_bits == 12) {\n\t\tif ((offset + 1) < sb->s_blocksize) {\n\t\t\t/* This entry is on bhs[0]. */\n\t\t\tif (fatent->nr_bhs == 2) {\n\t\t\t\tbrelse(bhs[1]);\n\t\t\t\tfatent->nr_bhs = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* This entry needs the next block. */\n\t\t\tif (fatent->nr_bhs != 2)\n\t\t\t\treturn 0;\n\t\t\tif (bhs[1]->b_blocknr != (blocknr + 1))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tops->ent_set_ptr(fatent, offset);\n\treturn 1;\n}"
  },
  {
    "function_name": "mark_fsinfo_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "311-319",
    "snippet": "static void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "sbi->fsinfo_inode",
            "I_DIRTY_SYNC"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void mark_fsinfo_dirty(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (sb->s_flags & MS_RDONLY || sbi->fat_bits != 32)\n\t\treturn;\n\n\t__mark_inode_dirty(sbi->fsinfo_inode, I_DIRTY_SYNC);\n}"
  },
  {
    "function_name": "fat_ent_access_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "289-309",
    "snippet": "void fat_ent_access_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tmutex_init(&sbi->fat_lock);\n\n\tswitch (sbi->fat_bits) {\n\tcase 32:\n\t\tsbi->fatent_shift = 2;\n\t\tsbi->fatent_ops = &fat32_ops;\n\t\tbreak;\n\tcase 16:\n\t\tsbi->fatent_shift = 1;\n\t\tsbi->fatent_ops = &fat16_ops;\n\t\tbreak;\n\tcase 12:\n\t\tsbi->fatent_shift = -1;\n\t\tsbi->fatent_ops = &fat12_ops;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct fatent_operations fat12_ops = {\n\t.ent_blocknr\t= fat12_ent_blocknr,\n\t.ent_set_ptr\t= fat12_ent_set_ptr,\n\t.ent_bread\t= fat12_ent_bread,\n\t.ent_get\t= fat12_ent_get,\n\t.ent_put\t= fat12_ent_put,\n\t.ent_next\t= fat12_ent_next,\n};",
      "static struct fatent_operations fat16_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat16_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat16_ent_get,\n\t.ent_put\t= fat16_ent_put,\n\t.ent_next\t= fat16_ent_next,\n};",
      "static struct fatent_operations fat32_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat32_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat32_ent_get,\n\t.ent_put\t= fat32_ent_put,\n\t.ent_next\t= fat32_ent_next,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->fat_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct fatent_operations fat12_ops = {\n\t.ent_blocknr\t= fat12_ent_blocknr,\n\t.ent_set_ptr\t= fat12_ent_set_ptr,\n\t.ent_bread\t= fat12_ent_bread,\n\t.ent_get\t= fat12_ent_get,\n\t.ent_put\t= fat12_ent_put,\n\t.ent_next\t= fat12_ent_next,\n};\nstatic struct fatent_operations fat16_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat16_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat16_ent_get,\n\t.ent_put\t= fat16_ent_put,\n\t.ent_next\t= fat16_ent_next,\n};\nstatic struct fatent_operations fat32_ops = {\n\t.ent_blocknr\t= fat_ent_blocknr,\n\t.ent_set_ptr\t= fat32_ent_set_ptr,\n\t.ent_bread\t= fat_ent_bread,\n\t.ent_get\t= fat32_ent_get,\n\t.ent_put\t= fat32_ent_put,\n\t.ent_next\t= fat32_ent_next,\n};\n\nvoid fat_ent_access_init(struct super_block *sb)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tmutex_init(&sbi->fat_lock);\n\n\tswitch (sbi->fat_bits) {\n\tcase 32:\n\t\tsbi->fatent_shift = 2;\n\t\tsbi->fatent_ops = &fat32_ops;\n\t\tbreak;\n\tcase 16:\n\t\tsbi->fatent_shift = 1;\n\t\tsbi->fatent_ops = &fat16_ops;\n\t\tbreak;\n\tcase 12:\n\t\tsbi->fatent_shift = -1;\n\t\tsbi->fatent_ops = &fat12_ops;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "unlock_fat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "284-287",
    "snippet": "static inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->fat_lock"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void unlock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_unlock(&sbi->fat_lock);\n}"
  },
  {
    "function_name": "lock_fat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "279-282",
    "snippet": "static inline void lock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_lock(&sbi->fat_lock);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->fat_lock"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline void lock_fat(struct msdos_sb_info *sbi)\n{\n\tmutex_lock(&sbi->fat_lock);\n}"
  },
  {
    "function_name": "fat32_ent_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "240-250",
    "snippet": "static int fat32_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent32_p < (__le32 *)(bh->b_data + (bh->b_size - 4))) {\n\t\tfatent->u.ent32_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent32_p = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat32_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent32_p < (__le32 *)(bh->b_data + (bh->b_size - 4))) {\n\t\tfatent->u.ent32_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent32_p = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "fat16_ent_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "228-238",
    "snippet": "static int fat16_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent16_p < (__le16 *)(bh->b_data + (bh->b_size - 2))) {\n\t\tfatent->u.ent16_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent16_p = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat16_ent_next(struct fat_entry *fatent)\n{\n\tconst struct buffer_head *bh = fatent->bhs[0];\n\tfatent->entry++;\n\tif (fatent->u.ent16_p < (__le16 *)(bh->b_data + (bh->b_size - 2))) {\n\t\tfatent->u.ent16_p++;\n\t\treturn 1;\n\t}\n\tfatent->u.ent16_p = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "fat12_ent_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "195-226",
    "snippet": "static int fat12_ent_next(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tstruct buffer_head **bhs = fatent->bhs;\n\tu8 *nextp = ent12_p[1] + 1 + (fatent->entry & 1);\n\n\tfatent->entry++;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 2)));\n\t\tWARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tif (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {\n\t\t\tent12_p[0] = nextp - 1;\n\t\t\tent12_p[1] = nextp;\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tWARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tWARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);\n\t\tent12_p[0] = nextp - 1;\n\t\tent12_p[1] = nextp;\n\t\tbrelse(bhs[0]);\n\t\tbhs[0] = bhs[1];\n\t\tfatent->nr_bhs = 1;\n\t\treturn 1;\n\t}\n\tent12_p[0] = NULL;\n\tent12_p[1] = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[0]"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ent12_p[1] != (u8 *)bhs[1]->b_data"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ent12_p[0] != (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1))"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ent12_p[1] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1))"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ent12_p[0] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 2))"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat12_ent_next(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tstruct buffer_head **bhs = fatent->bhs;\n\tu8 *nextp = ent12_p[1] + 1 + (fatent->entry & 1);\n\n\tfatent->entry++;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(ent12_p[0] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 2)));\n\t\tWARN_ON(ent12_p[1] > (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tif (nextp < (u8 *)(bhs[0]->b_data + (bhs[0]->b_size - 1))) {\n\t\t\tent12_p[0] = nextp - 1;\n\t\t\tent12_p[1] = nextp;\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tWARN_ON(ent12_p[0] != (u8 *)(bhs[0]->b_data +\n\t\t\t\t\t\t\t(bhs[0]->b_size - 1)));\n\t\tWARN_ON(ent12_p[1] != (u8 *)bhs[1]->b_data);\n\t\tent12_p[0] = nextp - 1;\n\t\tent12_p[1] = nextp;\n\t\tbrelse(bhs[0]);\n\t\tbhs[0] = bhs[1];\n\t\tfatent->nr_bhs = 1;\n\t\treturn 1;\n\t}\n\tent12_p[0] = NULL;\n\tent12_p[1] = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "fat32_ent_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "187-193",
    "snippet": "static void fat32_ent_put(struct fat_entry *fatent, int new)\n{\n\tWARN_ON(new & 0xf0000000);\n\tnew |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;\n\t*fatent->u.ent32_p = cpu_to_le32(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "fatent->bhs[0]",
            "fatent->fat_inode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*fatent->u.ent32_p"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "new & 0xf0000000"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat32_ent_put(struct fat_entry *fatent, int new)\n{\n\tWARN_ON(new & 0xf0000000);\n\tnew |= le32_to_cpu(*fatent->u.ent32_p) & ~0x0fffffff;\n\t*fatent->u.ent32_p = cpu_to_le32(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}"
  },
  {
    "function_name": "fat16_ent_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "178-185",
    "snippet": "static void fat16_ent_put(struct fat_entry *fatent, int new)\n{\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT16;\n\n\t*fatent->u.ent16_p = cpu_to_le16(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "fatent->bhs[0]",
            "fatent->fat_inode"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat16_ent_put(struct fat_entry *fatent, int new)\n{\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT16;\n\n\t*fatent->u.ent16_p = cpu_to_le16(new);\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n}"
  },
  {
    "function_name": "fat12_ent_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "156-176",
    "snippet": "static void fat12_ent_put(struct fat_entry *fatent, int new)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT12;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1) {\n\t\t*ent12_p[0] = (new << 4) | (*ent12_p[0] & 0x0f);\n\t\t*ent12_p[1] = new >> 4;\n\t} else {\n\t\t*ent12_p[0] = new & 0xff;\n\t\t*ent12_p[1] = (*ent12_p[1] & 0xf0) | (new >> 8);\n\t}\n\tspin_unlock(&fat12_entry_lock);\n\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n\tif (fatent->nr_bhs == 2)\n\t\tmark_buffer_dirty_inode(fatent->bhs[1], fatent->fat_inode);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(fat12_entry_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "fatent->bhs[1]",
            "fatent->fat_inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fat12_entry_lock"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fat12_entry_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(fat12_entry_lock);\n\nstatic void fat12_ent_put(struct fat_entry *fatent, int new)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\n\tif (new == FAT_ENT_EOF)\n\t\tnew = EOF_FAT12;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1) {\n\t\t*ent12_p[0] = (new << 4) | (*ent12_p[0] & 0x0f);\n\t\t*ent12_p[1] = new >> 4;\n\t} else {\n\t\t*ent12_p[0] = new & 0xff;\n\t\t*ent12_p[1] = (*ent12_p[1] & 0xf0) | (new >> 8);\n\t}\n\tspin_unlock(&fat12_entry_lock);\n\n\tmark_buffer_dirty_inode(fatent->bhs[0], fatent->fat_inode);\n\tif (fatent->nr_bhs == 2)\n\t\tmark_buffer_dirty_inode(fatent->bhs[1], fatent->fat_inode);\n}"
  },
  {
    "function_name": "fat32_ent_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "147-154",
    "snippet": "static int fat32_ent_get(struct fat_entry *fatent)\n{\n\tint next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;\n\tWARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));\n\tif (next >= BAD_FAT32)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(unsigned long)fatent->u.ent32_p & (4 - 1)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*fatent->u.ent32_p"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat32_ent_get(struct fat_entry *fatent)\n{\n\tint next = le32_to_cpu(*fatent->u.ent32_p) & 0x0fffffff;\n\tWARN_ON((unsigned long)fatent->u.ent32_p & (4 - 1));\n\tif (next >= BAD_FAT32)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}"
  },
  {
    "function_name": "fat16_ent_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "138-145",
    "snippet": "static int fat16_ent_get(struct fat_entry *fatent)\n{\n\tint next = le16_to_cpu(*fatent->u.ent16_p);\n\tWARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));\n\tif (next >= BAD_FAT16)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(unsigned long)fatent->u.ent16_p & (2 - 1)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "*fatent->u.ent16_p"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat16_ent_get(struct fat_entry *fatent)\n{\n\tint next = le16_to_cpu(*fatent->u.ent16_p);\n\tWARN_ON((unsigned long)fatent->u.ent16_p & (2 - 1));\n\tif (next >= BAD_FAT16)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}"
  },
  {
    "function_name": "fat12_ent_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "120-136",
    "snippet": "static int fat12_ent_get(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tint next;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1)\n\t\tnext = (*ent12_p[0] >> 4) | (*ent12_p[1] << 4);\n\telse\n\t\tnext = (*ent12_p[1] << 8) | *ent12_p[0];\n\tspin_unlock(&fat12_entry_lock);\n\n\tnext &= 0x0fff;\n\tif (next >= BAD_FAT12)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(fat12_entry_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fat12_entry_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fat12_entry_lock"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(fat12_entry_lock);\n\nstatic int fat12_ent_get(struct fat_entry *fatent)\n{\n\tu8 **ent12_p = fatent->u.ent12_p;\n\tint next;\n\n\tspin_lock(&fat12_entry_lock);\n\tif (fatent->entry & 1)\n\t\tnext = (*ent12_p[0] >> 4) | (*ent12_p[1] << 4);\n\telse\n\t\tnext = (*ent12_p[1] << 8) | *ent12_p[0];\n\tspin_unlock(&fat12_entry_lock);\n\n\tnext &= 0x0fff;\n\tif (next >= BAD_FAT12)\n\t\tnext = FAT_ENT_EOF;\n\treturn next;\n}"
  },
  {
    "function_name": "fat_ent_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "102-118",
    "snippet": "static int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t int offset, sector_t blocknr)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\tfatent->bhs[0] = sb_bread(sb, blocknr);\n\tif (!fatent->bhs[0]) {\n\t\tfat_msg(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\",\n\t\t       (llu)blocknr);\n\t\treturn -EIO;\n\t}\n\tfatent->nr_bhs = 1;\n\tops->ent_set_ptr(fatent, offset);\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->ent_set_ptr",
          "args": [
            "fatent",
            "offset"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"FAT read failed (blocknr %llu)\"",
            "(llu)blocknr"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "blocknr < MSDOS_SB(sb)->fat_start"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t int offset, sector_t blocknr)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\tfatent->bhs[0] = sb_bread(sb, blocknr);\n\tif (!fatent->bhs[0]) {\n\t\tfat_msg(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\",\n\t\t       (llu)blocknr);\n\t\treturn -EIO;\n\t}\n\tfatent->nr_bhs = 1;\n\tops->ent_set_ptr(fatent, offset);\n\treturn 0;\n}"
  },
  {
    "function_name": "fat12_ent_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "70-100",
    "snippet": "static int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t   int offset, sector_t blocknr)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\n\tbhs[0] = sb_bread(sb, blocknr);\n\tif (!bhs[0])\n\t\tgoto err;\n\n\tif ((offset + 1) < sb->s_blocksize)\n\t\tfatent->nr_bhs = 1;\n\telse {\n\t\t/* This entry is block boundary, it needs the next block */\n\t\tblocknr++;\n\t\tbhs[1] = sb_bread(sb, blocknr);\n\t\tif (!bhs[1])\n\t\t\tgoto err_brelse;\n\t\tfatent->nr_bhs = 2;\n\t}\n\tfat12_ent_set_ptr(fatent, offset);\n\treturn 0;\n\nerr_brelse:\n\tbrelse(bhs[0]);\nerr:\n\tfat_msg(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\", (llu)blocknr);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"FAT read failed (blocknr %llu)\"",
            "(llu)blocknr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fat_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "50-60",
          "snippet": "void fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid fat_msg(struct super_block *sb, const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sFAT-fs (%s): %pV\\n\", level, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[0]"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat12_ent_set_ptr",
          "args": [
            "fatent",
            "offset"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "fat12_ent_set_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "44-56",
          "snippet": "static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(offset >= (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\n\t} else {\n\t\tWARN_ON(offset != (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[1]->b_data;\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(offset >= (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\n\t} else {\n\t\tWARN_ON(offset != (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[1]->b_data;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "blocknr"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "blocknr < MSDOS_SB(sb)->fat_start"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int fat12_ent_bread(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t   int offset, sector_t blocknr)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\n\tWARN_ON(blocknr < MSDOS_SB(sb)->fat_start);\n\tfatent->fat_inode = MSDOS_SB(sb)->fat_inode;\n\n\tbhs[0] = sb_bread(sb, blocknr);\n\tif (!bhs[0])\n\t\tgoto err;\n\n\tif ((offset + 1) < sb->s_blocksize)\n\t\tfatent->nr_bhs = 1;\n\telse {\n\t\t/* This entry is block boundary, it needs the next block */\n\t\tblocknr++;\n\t\tbhs[1] = sb_bread(sb, blocknr);\n\t\tif (!bhs[1])\n\t\t\tgoto err_brelse;\n\t\tfatent->nr_bhs = 2;\n\t}\n\tfat12_ent_set_ptr(fatent, offset);\n\treturn 0;\n\nerr_brelse:\n\tbrelse(bhs[0]);\nerr:\n\tfat_msg(sb, KERN_ERR, \"FAT read failed (blocknr %llu)\", (llu)blocknr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "fat32_ent_set_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "64-68",
    "snippet": "static void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (4 - 1));\n\tfatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset & (4 - 1)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat32_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (4 - 1));\n\tfatent->u.ent32_p = (__le32 *)(fatent->bhs[0]->b_data + offset);\n}"
  },
  {
    "function_name": "fat16_ent_set_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "58-62",
    "snippet": "static void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (2 - 1));\n\tfatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset & (2 - 1)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat16_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tWARN_ON(offset & (2 - 1));\n\tfatent->u.ent16_p = (__le16 *)(fatent->bhs[0]->b_data + offset);\n}"
  },
  {
    "function_name": "fat12_ent_set_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "44-56",
    "snippet": "static void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(offset >= (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\n\t} else {\n\t\tWARN_ON(offset != (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[1]->b_data;\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset != (bhs[0]->b_size - 1)"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "offset >= (bhs[0]->b_size - 1)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat12_ent_set_ptr(struct fat_entry *fatent, int offset)\n{\n\tstruct buffer_head **bhs = fatent->bhs;\n\tif (fatent->nr_bhs == 1) {\n\t\tWARN_ON(offset >= (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[0]->b_data + (offset + 1);\n\t} else {\n\t\tWARN_ON(offset != (bhs[0]->b_size - 1));\n\t\tfatent->u.ent12_p[0] = bhs[0]->b_data + offset;\n\t\tfatent->u.ent12_p[1] = bhs[1]->b_data;\n\t}\n}"
  },
  {
    "function_name": "fat_ent_blocknr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "34-42",
    "snippet": "static void fat_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t    int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = (entry << sbi->fatent_shift);\n\tWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry < FAT_START_ENT || sbi->max_cluster <= entry"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t    int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = (entry << sbi->fatent_shift);\n\tWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}"
  },
  {
    "function_name": "fat12_ent_blocknr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
    "lines": "24-32",
    "snippet": "static void fat12_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t      int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = entry + (entry >> 1);\n\tWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/msdos_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry < FAT_START_ENT || sbi->max_cluster <= entry"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat12_ent_blocknr(struct super_block *sb, int entry,\n\t\t\t      int *offset, sector_t *blocknr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tint bytes = entry + (entry >> 1);\n\tWARN_ON(entry < FAT_START_ENT || sbi->max_cluster <= entry);\n\t*offset = bytes & (sb->s_blocksize - 1);\n\t*blocknr = sbi->fat_start + (bytes >> sb->s_blocksize_bits);\n}"
  }
]