[
  {
    "function_name": "ext4_ind_remove_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "1314-1557",
    "snippet": "int ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t  ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4], offsets2[4];\n\tIndirect chain[4], chain2[4];\n\tIndirect *partial, *partial2;\n\text4_lblk_t max_block;\n\t__le32 nr = 0, nr2 = 0;\n\tint n = 0, n2 = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tif (end >= max_block)\n\t\tend = max_block;\n\tif ((start >= end) || (start > max_block))\n\t\treturn 0;\n\n\tn = ext4_block_to_path(inode, start, offsets, NULL);\n\tn2 = ext4_block_to_path(inode, end, offsets2, NULL);\n\n\tBUG_ON(n > n2);\n\n\tif ((n == 1) && (n == n2)) {\n\t\t/* We're punching only within direct block range */\n\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t       i_data + offsets2[0]);\n\t\treturn 0;\n\t} else if (n2 > n) {\n\t\t/*\n\t\t * Start and end are on a different levels so we're going to\n\t\t * free partial block at start, and partial block at end of\n\t\t * the range. If there are some levels in between then\n\t\t * do_indirects label will take care of that.\n\t\t */\n\n\t\tif (n == 1) {\n\t\t\t/*\n\t\t\t * Start is at the direct block level, free\n\t\t\t * everything to the end of the level.\n\t\t\t */\n\t\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\t\tgoto end_range;\n\t\t}\n\n\n\t\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t\tif (nr) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the start of the range\n\t\t */\n\t\twhile (partial > chain) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\tpartial->p + 1,\n\t\t\t\t(__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t(chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\nend_range:\n\t\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\t\tif (nr2) {\n\t\t\tif (partial2 == chain2) {\n\t\t\t\t/*\n\t\t\t\t * Remember, end is exclusive so here we're at\n\t\t\t\t * the start of the next level we're not going\n\t\t\t\t * to free. Everything was covered by the start\n\t\t\t\t * of the range.\n\t\t\t\t */\n\t\t\t\tgoto do_indirects;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * ext4_find_shared returns Indirect structure which\n\t\t\t * points to the last element which should not be\n\t\t\t * removed by truncate. But this is end of the range\n\t\t\t * in punch_hole so we need to point to the next element\n\t\t\t */\n\t\t\tpartial2->p++;\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the end of the range\n\t\t */\n\t\twhile (partial2 > chain2) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t\tgoto do_indirects;\n\t}\n\n\t/* Punch happened within the same level (n == n2) */\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\n\t/* Free top, but only if partial2 isn't its subtree. */\n\tif (nr) {\n\t\tint level = min(partial - chain, partial2 - chain2);\n\t\tint i;\n\t\tint subtree = 1;\n\n\t\tfor (i = 0; i <= level; i++) {\n\t\t\tif (offsets[i] != offsets2[i]) {\n\t\t\t\tsubtree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!subtree) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t\t   &nr, &nr+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t\t   partial->p,\n\t\t\t\t\t\t   partial->p+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nr2) {\n\t\t/*\n\t\t * ext4_find_shared returns Indirect structure which\n\t\t * points to the last element which should not be\n\t\t * removed by truncate. But this is end of the range\n\t\t * in punch_hole so we need to point to the next element\n\t\t */\n\t\tpartial2->p++;\n\t}\n\n\twhile (partial > chain || partial2 > chain2) {\n\t\tint depth = (chain+n-1) - partial;\n\t\tint depth2 = (chain2+n2-1) - partial2;\n\n\t\tif (partial > chain && partial2 > chain2 &&\n\t\t    partial->bh->b_blocknr == partial2->bh->b_blocknr) {\n\t\t\t/*\n\t\t\t * We've converged on the same block. Clear the range,\n\t\t\t * then we're done.\n\t\t\t */\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * The start and end partial branches may not be at the same\n\t\t * level even though the punch happened within one level. So, we\n\t\t * give them a chance to arrive at the same level, then walk\n\t\t * them in step with each other until we converge on the same\n\t\t * block.\n\t\t */\n\t\tif (partial > chain && depth <= depth2) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   (__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tif (partial2 > chain2 && depth2 <= depth) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t}\n\treturn 0;\n\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_branches",
          "args": [
            "handle",
            "inode",
            "NULL",
            "&nr",
            "&nr+1",
            "3"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1090-1200",
          "snippet": "static void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial2->bh"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial2->bh",
            "\"call brelse\""
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial2->bh",
            "\"call brelse\""
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"get_write_access\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "partial - chain",
            "partial2 - chain2"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_shared",
          "args": [
            "inode",
            "n2",
            "offsets2",
            "chain2",
            "&nr2"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "871-918",
          "snippet": "static Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial2->bh",
            "\"call brelse\""
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"get_write_access\""
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_data",
          "args": [
            "handle",
            "inode",
            "NULL",
            "i_data + offsets[0]",
            "i_data + EXT4_NDIR_BLOCKS"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1005-1075",
          "snippet": "static void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "n > n2"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_block_to_path",
          "args": [
            "inode",
            "end",
            "offsets2",
            "NULL"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "72-110",
          "snippet": "static int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t  ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4], offsets2[4];\n\tIndirect chain[4], chain2[4];\n\tIndirect *partial, *partial2;\n\text4_lblk_t max_block;\n\t__le32 nr = 0, nr2 = 0;\n\tint n = 0, n2 = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tif (end >= max_block)\n\t\tend = max_block;\n\tif ((start >= end) || (start > max_block))\n\t\treturn 0;\n\n\tn = ext4_block_to_path(inode, start, offsets, NULL);\n\tn2 = ext4_block_to_path(inode, end, offsets2, NULL);\n\n\tBUG_ON(n > n2);\n\n\tif ((n == 1) && (n == n2)) {\n\t\t/* We're punching only within direct block range */\n\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t       i_data + offsets2[0]);\n\t\treturn 0;\n\t} else if (n2 > n) {\n\t\t/*\n\t\t * Start and end are on a different levels so we're going to\n\t\t * free partial block at start, and partial block at end of\n\t\t * the range. If there are some levels in between then\n\t\t * do_indirects label will take care of that.\n\t\t */\n\n\t\tif (n == 1) {\n\t\t\t/*\n\t\t\t * Start is at the direct block level, free\n\t\t\t * everything to the end of the level.\n\t\t\t */\n\t\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\t\tgoto end_range;\n\t\t}\n\n\n\t\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t\tif (nr) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the start of the range\n\t\t */\n\t\twhile (partial > chain) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\tpartial->p + 1,\n\t\t\t\t(__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t(chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\nend_range:\n\t\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\t\tif (nr2) {\n\t\t\tif (partial2 == chain2) {\n\t\t\t\t/*\n\t\t\t\t * Remember, end is exclusive so here we're at\n\t\t\t\t * the start of the next level we're not going\n\t\t\t\t * to free. Everything was covered by the start\n\t\t\t\t * of the range.\n\t\t\t\t */\n\t\t\t\tgoto do_indirects;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * ext4_find_shared returns Indirect structure which\n\t\t\t * points to the last element which should not be\n\t\t\t * removed by truncate. But this is end of the range\n\t\t\t * in punch_hole so we need to point to the next element\n\t\t\t */\n\t\t\tpartial2->p++;\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the end of the range\n\t\t */\n\t\twhile (partial2 > chain2) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t\tgoto do_indirects;\n\t}\n\n\t/* Punch happened within the same level (n == n2) */\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\n\t/* Free top, but only if partial2 isn't its subtree. */\n\tif (nr) {\n\t\tint level = min(partial - chain, partial2 - chain2);\n\t\tint i;\n\t\tint subtree = 1;\n\n\t\tfor (i = 0; i <= level; i++) {\n\t\t\tif (offsets[i] != offsets2[i]) {\n\t\t\t\tsubtree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!subtree) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t\t   &nr, &nr+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t\t   partial->p,\n\t\t\t\t\t\t   partial->p+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nr2) {\n\t\t/*\n\t\t * ext4_find_shared returns Indirect structure which\n\t\t * points to the last element which should not be\n\t\t * removed by truncate. But this is end of the range\n\t\t * in punch_hole so we need to point to the next element\n\t\t */\n\t\tpartial2->p++;\n\t}\n\n\twhile (partial > chain || partial2 > chain2) {\n\t\tint depth = (chain+n-1) - partial;\n\t\tint depth2 = (chain2+n2-1) - partial2;\n\n\t\tif (partial > chain && partial2 > chain2 &&\n\t\t    partial->bh->b_blocknr == partial2->bh->b_blocknr) {\n\t\t\t/*\n\t\t\t * We've converged on the same block. Clear the range,\n\t\t\t * then we're done.\n\t\t\t */\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * The start and end partial branches may not be at the same\n\t\t * level even though the punch happened within one level. So, we\n\t\t * give them a chance to arrive at the same level, then walk\n\t\t * them in step with each other until we converge on the same\n\t\t * block.\n\t\t */\n\t\tif (partial > chain && depth <= depth2) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   (__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tif (partial2 > chain2 && depth2 <= depth) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t}\n\treturn 0;\n\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_ind_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "1202-1302",
    "snippet": "void ext4_ind_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n = 0;\n\text4_lblk_t last_block, max_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tif (last_block != max_block) {\n\t\tn = ext4_block_to_path(inode, last_block, offsets, NULL);\n\t\tif (n == 0)\n\t\t\treturn;\n\t}\n\n\text4_es_remove_extent(inode, last_block, EXT_MAX_BLOCKS - last_block);\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext4 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\tif (last_block == max_block) {\n\t\t/*\n\t\t * It is unnecessary to free any data blocks if last_block is\n\t\t * equal to the indirect block limit.\n\t\t */\n\t\treturn;\n\t} else if (n == 1) {\t\t/* direct blocks */\n\t\text4_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text4_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_branches",
          "args": [
            "handle",
            "inode",
            "NULL",
            "&nr",
            "&nr+1",
            "3"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1090-1200",
          "snippet": "static void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"get_write_access\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_find_shared",
          "args": [
            "inode",
            "n",
            "offsets",
            "chain",
            "&nr"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "871-918",
          "snippet": "static Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_data",
          "args": [
            "handle",
            "inode",
            "NULL",
            "i_data+offsets[0]",
            "i_data + EXT4_NDIR_BLOCKS"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1005-1075",
          "snippet": "static void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode",
            "last_block",
            "EXT_MAX_BLOCKS - last_block"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_to_path",
          "args": [
            "inode",
            "last_block",
            "offsets",
            "NULL"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "72-110",
          "snippet": "static int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nvoid ext4_ind_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n = 0;\n\text4_lblk_t last_block, max_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tif (last_block != max_block) {\n\t\tn = ext4_block_to_path(inode, last_block, offsets, NULL);\n\t\tif (n == 0)\n\t\t\treturn;\n\t}\n\n\text4_es_remove_extent(inode, last_block, EXT_MAX_BLOCKS - last_block);\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext4 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\tif (last_block == max_block) {\n\t\t/*\n\t\t * It is unnecessary to free any data blocks if last_block is\n\t\t * equal to the indirect block limit.\n\t\t */\n\t\treturn;\n\t} else if (n == 1) {\t\t/* direct blocks */\n\t\text4_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text4_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n}"
  },
  {
    "function_name": "ext4_free_branches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "1090-1200",
    "snippet": "static void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_data",
          "args": [
            "handle",
            "inode",
            "parent_bh",
            "first",
            "last"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1005-1075",
          "snippet": "static void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"free data blocks\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "parent_bh"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "parent_bh"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "parent_bh",
            "\"get_write_access\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "nr",
            "1",
            "EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_restart_trans",
          "args": [
            "handle",
            "inode",
            "ext4_blocks_for_truncate(inode)"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_restart_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "160-179",
          "snippet": "int ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_extend_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "812-821",
          "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_is_aborted",
          "args": [
            "handle"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_is_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "285-290",
          "snippet": "static inline int ext4_handle_is_aborted(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn is_handle_aborted(handle);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_is_aborted(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn is_handle_aborted(handle);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_branches",
          "args": [
            "handle",
            "inode",
            "bh",
            "(__le32 *) bh->b_data",
            "(__le32 *) bh->b_data + addr_per_block",
            "depth"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_branches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1090-1200",
          "snippet": "static void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"free child branches\""
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE_BLOCK",
          "args": [
            "inode",
            "nr",
            "\"Read failure\""
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "nr"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\"",
            "(unsigned long) nr",
            "depth"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "nr",
            "1"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_branches(handle_t *handle, struct inode *inode,\n\t\t\t       struct buffer_head *parent_bh,\n\t\t\t       __le32 *first, __le32 *last, int depth)\n{\n\text4_fsblk_t nr;\n\t__le32 *p;\n\n\tif (ext4_handle_is_aborted(handle))\n\t\treturn;\n\n\tif (depth--) {\n\t\tstruct buffer_head *bh;\n\t\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\t\tp = last;\n\t\twhile (--p >= first) {\n\t\t\tnr = le32_to_cpu(*p);\n\t\t\tif (!nr)\n\t\t\t\tcontinue;\t\t/* A hole */\n\n\t\t\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb),\n\t\t\t\t\t\t   nr, 1)) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"invalid indirect mapped \"\n\t\t\t\t\t\t \"block %lu (level %d)\",\n\t\t\t\t\t\t (unsigned long) nr, depth);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Go read the buffer for the next level down */\n\t\t\tbh = sb_bread(inode->i_sb, nr);\n\n\t\t\t/*\n\t\t\t * A read failure? Report error and clear slot\n\t\t\t * (should be rare).\n\t\t\t */\n\t\t\tif (!bh) {\n\t\t\t\tEXT4_ERROR_INODE_BLOCK(inode, nr,\n\t\t\t\t\t\t       \"Read failure\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* This zaps the entire block.  Bottom up. */\n\t\t\tBUFFER_TRACE(bh, \"free child branches\");\n\t\t\text4_free_branches(handle, inode, bh,\n\t\t\t\t\t(__le32 *) bh->b_data,\n\t\t\t\t\t(__le32 *) bh->b_data + addr_per_block,\n\t\t\t\t\tdepth);\n\t\t\tbrelse(bh);\n\n\t\t\t/*\n\t\t\t * Everything below this this pointer has been\n\t\t\t * released.  Now let this top-of-subtree go.\n\t\t\t *\n\t\t\t * We want the freeing of this indirect block to be\n\t\t\t * atomic in the journal with the updating of the\n\t\t\t * bitmap block which owns it.  So make some room in\n\t\t\t * the journal.\n\t\t\t *\n\t\t\t * We zero the parent pointer *after* freeing its\n\t\t\t * pointee in the bitmaps, so if extend_transaction()\n\t\t\t * for some reason fails to put the bitmap changes and\n\t\t\t * the release into the same transaction, recovery\n\t\t\t * will merely complain about releasing a free block,\n\t\t\t * rather than leaking blocks.\n\t\t\t */\n\t\t\tif (ext4_handle_is_aborted(handle))\n\t\t\t\treturn;\n\t\t\tif (try_to_extend_transaction(handle, inode)) {\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\text4_truncate_restart_trans(handle, inode,\n\t\t\t\t\t    ext4_blocks_for_truncate(inode));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The forget flag here is critical because if\n\t\t\t * we are journaling (and not doing data\n\t\t\t * journaling), we have to make sure a revoke\n\t\t\t * record is written to prevent the journal\n\t\t\t * replay from overwriting the (former)\n\t\t\t * indirect block if it gets reallocated as a\n\t\t\t * data block.  This must happen in the same\n\t\t\t * transaction where the data blocks are\n\t\t\t * actually freed.\n\t\t\t */\n\t\t\text4_free_blocks(handle, inode, NULL, nr, 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA|\n\t\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\n\t\t\tif (parent_bh) {\n\t\t\t\t/*\n\t\t\t\t * The block which we have just freed is\n\t\t\t\t * pointed to by an indirect block: journal it\n\t\t\t\t */\n\t\t\t\tBUFFER_TRACE(parent_bh, \"get_write_access\");\n\t\t\t\tif (!ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t   parent_bh)){\n\t\t\t\t\t*p = 0;\n\t\t\t\t\tBUFFER_TRACE(parent_bh,\n\t\t\t\t\t\"call ext4_handle_dirty_metadata\");\n\t\t\t\t\text4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t   inode,\n\t\t\t\t\t\t\t\t   parent_bh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* We have reached the bottom of the tree. */\n\t\tBUFFER_TRACE(parent_bh, \"free data blocks\");\n\t\text4_free_data(handle, inode, parent_bh, first, last);\n\t}\n}"
  },
  {
    "function_name": "ext4_free_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "1005-1075",
    "snippet": "static void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\"",
            "(unsigned long long) this_bh->b_blocknr"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "this_bh"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "this_bh"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "this_bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_blocks",
          "args": [
            "handle",
            "inode",
            "this_bh",
            "block_to_free",
            "count",
            "block_to_free_p",
            "p"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "931-984",
          "snippet": "static int ext4_clear_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     ext4_fsblk_t block_to_free,\n\t\t\t     unsigned long count, __le32 *first,\n\t\t\t     __le32 *last)\n{\n\t__le32 *p;\n\tint\tflags = EXT4_FREE_BLOCKS_VALIDATED;\n\tint\terr;\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n\telse if (ext4_should_journal_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET;\n\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), block_to_free,\n\t\t\t\t   count)) {\n\t\tEXT4_ERROR_INODE(inode, \"attempt to clear invalid \"\n\t\t\t\t \"blocks %llu len %lu\",\n\t\t\t\t (unsigned long long) block_to_free, count);\n\t\treturn 1;\n\t}\n\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\terr = ext4_truncate_restart_trans(handle, inode,\n\t\t\t\t\text4_blocks_for_truncate(inode));\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (p = first; p < last; p++)\n\t\t*p = 0;\n\n\text4_free_blocks(handle, inode, NULL, block_to_free, count, flags);\n\treturn 0;\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_clear_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     ext4_fsblk_t block_to_free,\n\t\t\t     unsigned long count, __le32 *first,\n\t\t\t     __le32 *last)\n{\n\t__le32 *p;\n\tint\tflags = EXT4_FREE_BLOCKS_VALIDATED;\n\tint\terr;\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n\telse if (ext4_should_journal_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET;\n\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), block_to_free,\n\t\t\t\t   count)) {\n\t\tEXT4_ERROR_INODE(inode, \"attempt to clear invalid \"\n\t\t\t\t \"blocks %llu len %lu\",\n\t\t\t\t (unsigned long long) block_to_free, count);\n\t\treturn 1;\n\t}\n\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\terr = ext4_truncate_restart_trans(handle, inode,\n\t\t\t\t\text4_blocks_for_truncate(inode));\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (p = first; p < last; p++)\n\t\t*p = 0;\n\n\text4_free_blocks(handle, inode, NULL, block_to_free, count, flags);\n\treturn 0;\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "this_bh"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "this_bh",
            "\"get_write_access\""
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic void ext4_free_data(handle_t *handle, struct inode *inode,\n\t\t\t   struct buffer_head *this_bh,\n\t\t\t   __le32 *first, __le32 *last)\n{\n\text4_fsblk_t block_to_free = 0;    /* Starting block # of a run */\n\tunsigned long count = 0;\t    /* Number of blocks in the run */\n\t__le32 *block_to_free_p = NULL;\t    /* Pointer into inode/ind\n\t\t\t\t\t       corresponding to\n\t\t\t\t\t       block_to_free */\n\text4_fsblk_t nr;\t\t    /* Current block # */\n\t__le32 *p;\t\t\t    /* Pointer into inode/ind\n\t\t\t\t\t       for current block */\n\tint err = 0;\n\n\tif (this_bh) {\t\t\t\t/* For indirect block */\n\t\tBUFFER_TRACE(this_bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, this_bh);\n\t\t/* Important: if we can't update the indirect pointers\n\t\t * to the blocks, we can't free them. */\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tfor (p = first; p < last; p++) {\n\t\tnr = le32_to_cpu(*p);\n\t\tif (nr) {\n\t\t\t/* accumulate blocks to free if they're contiguous */\n\t\t\tif (count == 0) {\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t} else if (nr == block_to_free + count) {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\terr = ext4_clear_blocks(handle, inode, this_bh,\n\t\t\t\t\t\t        block_to_free, count,\n\t\t\t\t\t\t        block_to_free_p, p);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t\tblock_to_free = nr;\n\t\t\t\tblock_to_free_p = p;\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!err && count > 0)\n\t\terr = ext4_clear_blocks(handle, inode, this_bh, block_to_free,\n\t\t\t\t\tcount, block_to_free_p, p);\n\tif (err < 0)\n\t\t/* fatal error */\n\t\treturn;\n\n\tif (this_bh) {\n\t\tBUFFER_TRACE(this_bh, \"call ext4_handle_dirty_metadata\");\n\n\t\t/*\n\t\t * The buffer head should have an attached journal head at this\n\t\t * point. However, if the data is corrupted and an indirect\n\t\t * block pointed to itself, it would have been detached when\n\t\t * the block was cleared. Check for this instead of OOPSing.\n\t\t */\n\t\tif ((EXT4_JOURNAL(inode) == NULL) || bh2jh(this_bh))\n\t\t\text4_handle_dirty_metadata(handle, inode, this_bh);\n\t\telse\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"circular indirect block detected at \"\n\t\t\t\t\t \"block %llu\",\n\t\t\t\t(unsigned long long) this_bh->b_blocknr);\n\t}\n}"
  },
  {
    "function_name": "ext4_clear_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "931-984",
    "snippet": "static int ext4_clear_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     ext4_fsblk_t block_to_free,\n\t\t\t     unsigned long count, __le32 *first,\n\t\t\t     __le32 *last)\n{\n\t__le32 *p;\n\tint\tflags = EXT4_FREE_BLOCKS_VALIDATED;\n\tint\terr;\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n\telse if (ext4_should_journal_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET;\n\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), block_to_free,\n\t\t\t\t   count)) {\n\t\tEXT4_ERROR_INODE(inode, \"attempt to clear invalid \"\n\t\t\t\t \"blocks %llu len %lu\",\n\t\t\t\t (unsigned long long) block_to_free, count);\n\t\treturn 1;\n\t}\n\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\terr = ext4_truncate_restart_trans(handle, inode,\n\t\t\t\t\text4_blocks_for_truncate(inode));\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (p = first; p < last; p++)\n\t\t*p = 0;\n\n\text4_free_blocks(handle, inode, NULL, block_to_free, count, flags);\n\treturn 0;\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "block_to_free",
            "count",
            "flags"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"retaking write access\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_truncate_restart_trans",
          "args": [
            "handle",
            "inode",
            "ext4_blocks_for_truncate(inode)"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_restart_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "160-179",
          "snippet": "int ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_extend_transaction",
          "args": [
            "handle",
            "inode"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "812-821",
          "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"attempt to clear invalid \"\n\t\t\t\t \"blocks %llu len %lu\"",
            "(unsigned long long) block_to_free",
            "count"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "block_to_free",
            "count"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_clear_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     struct buffer_head *bh,\n\t\t\t     ext4_fsblk_t block_to_free,\n\t\t\t     unsigned long count, __le32 *first,\n\t\t\t     __le32 *last)\n{\n\t__le32 *p;\n\tint\tflags = EXT4_FREE_BLOCKS_VALIDATED;\n\tint\terr;\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET | EXT4_FREE_BLOCKS_METADATA;\n\telse if (ext4_should_journal_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_FORGET;\n\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), block_to_free,\n\t\t\t\t   count)) {\n\t\tEXT4_ERROR_INODE(inode, \"attempt to clear invalid \"\n\t\t\t\t \"blocks %llu len %lu\",\n\t\t\t\t (unsigned long long) block_to_free, count);\n\t\treturn 1;\n\t}\n\n\tif (try_to_extend_transaction(handle, inode)) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t\terr = ext4_mark_inode_dirty(handle, inode);\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\terr = ext4_truncate_restart_trans(handle, inode,\n\t\t\t\t\text4_blocks_for_truncate(inode));\n\t\tif (unlikely(err))\n\t\t\tgoto out_err;\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"retaking write access\");\n\t\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (p = first; p < last; p++)\n\t\t*p = 0;\n\n\text4_free_blocks(handle, inode, NULL, block_to_free, count, flags);\n\treturn 0;\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_find_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "871-918",
    "snippet": "static Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_zeroes",
          "args": [
            "(__le32 *) p->bh->b_data",
            "p->p"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "all_zeroes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "828-834",
          "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_branch",
          "args": [
            "inode",
            "k",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "142-186",
          "snippet": "static Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_find_shared(struct inode *inode, int depth,\n\t\t\t\t  ext4_lblk_t offsets[4], Indirect chain[4],\n\t\t\t\t  __le32 *top)\n{\n\tIndirect *partial, *p;\n\tint k, err;\n\n\t*top = 0;\n\t/* Make k index the deepest non-null offset + 1 */\n\tfor (k = depth; k > 1 && !offsets[k-1]; k--)\n\t\t;\n\tpartial = ext4_get_branch(inode, k, offsets, chain, &err);\n\t/* Writer: pointers */\n\tif (!partial)\n\t\tpartial = chain + k-1;\n\t/*\n\t * If the branch acquired continuation since we've looked at it -\n\t * fine, it should all survive and (new) top doesn't belong to us.\n\t */\n\tif (!partial->key && *partial->p)\n\t\t/* Writer: end */\n\t\tgoto no_top;\n\tfor (p = partial; (p > chain) && all_zeroes((__le32 *) p->bh->b_data, p->p); p--)\n\t\t;\n\t/*\n\t * OK, we've found the last block that must survive. The rest of our\n\t * branch should be detached before unlocking. However, if that rest\n\t * of branch is all ours and does not grow immediately from the inode\n\t * it's easier to cheat and just decrement partial->p.\n\t */\n\tif (p == chain + k - 1 && p > chain) {\n\t\tp->p--;\n\t} else {\n\t\t*top = *p->p;\n\t\t/* Nope, don't do this in ext4.  Must leave the tree intact */\n#if 0\n\t\t*p->p = 0;\n#endif\n\t}\n\t/* Writer: end */\n\n\twhile (partial > p) {\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nno_top:\n\treturn partial;\n}"
  },
  {
    "function_name": "all_zeroes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "828-834",
    "snippet": "static inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic inline int all_zeroes(__le32 *p, __le32 *q)\n{\n\twhile (p < q)\n\t\tif (*p++)\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "try_to_extend_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "812-821",
    "snippet": "static int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "ext4_blocks_for_truncate(inode)"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_has_enough_credits",
          "args": [
            "handle",
            "EXT4_RESERVE_TRANS_BLOCKS+1"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_has_enough_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "292-297",
          "snippet": "static inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int try_to_extend_transaction(handle_t *handle, struct inode *inode)\n{\n\tif (!ext4_handle_valid(handle))\n\t\treturn 0;\n\tif (ext4_handle_has_enough_credits(handle, EXT4_RESERVE_TRANS_BLOCKS+1))\n\t\treturn 0;\n\tif (!ext4_journal_extend(handle, ext4_blocks_for_truncate(inode)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_ind_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "790-798",
    "snippet": "int ext4_ind_trans_blocks(struct inode *inode, int nrblocks)\n{\n\t/*\n\t * With N contiguous data blocks, we need at most\n\t * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,\n\t * 2 dindirect blocks, and 1 tindirect block\n\t */\n\treturn DIV_ROUND_UP(nrblocks, EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "nrblocks",
            "EXT4_ADDR_PER_BLOCK(inode->i_sb)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_trans_blocks(struct inode *inode, int nrblocks)\n{\n\t/*\n\t * With N contiguous data blocks, we need at most\n\t * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,\n\t * 2 dindirect blocks, and 1 tindirect block\n\t */\n\treturn DIV_ROUND_UP(nrblocks, EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;\n}"
  },
  {
    "function_name": "ext4_ind_calc_metadata_amount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "764-784",
    "snippet": "int ext4_ind_calc_metadata_amount(struct inode *inode, sector_t lblock)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tsector_t dind_mask = ~((sector_t)EXT4_ADDR_PER_BLOCK(inode->i_sb) - 1);\n\tint blk_bits;\n\n\tif (lblock < EXT4_NDIR_BLOCKS)\n\t\treturn 0;\n\n\tlblock -= EXT4_NDIR_BLOCKS;\n\n\tif (ei->i_da_metadata_calc_len &&\n\t    (lblock & dind_mask) == ei->i_da_metadata_calc_last_lblock) {\n\t\tei->i_da_metadata_calc_len++;\n\t\treturn 0;\n\t}\n\tei->i_da_metadata_calc_last_lblock = lblock & dind_mask;\n\tei->i_da_metadata_calc_len = 1;\n\tblk_bits = order_base_2(lblock);\n\treturn (blk_bits / EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb)) + 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "lblock"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_calc_metadata_amount(struct inode *inode, sector_t lblock)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tsector_t dind_mask = ~((sector_t)EXT4_ADDR_PER_BLOCK(inode->i_sb) - 1);\n\tint blk_bits;\n\n\tif (lblock < EXT4_NDIR_BLOCKS)\n\t\treturn 0;\n\n\tlblock -= EXT4_NDIR_BLOCKS;\n\n\tif (ei->i_da_metadata_calc_len &&\n\t    (lblock & dind_mask) == ei->i_da_metadata_calc_last_lblock) {\n\t\tei->i_da_metadata_calc_len++;\n\t\treturn 0;\n\t}\n\tei->i_da_metadata_calc_last_lblock = lblock & dind_mask;\n\tei->i_da_metadata_calc_len = 1;\n\tblk_bits = order_base_2(lblock);\n\treturn (blk_bits / EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb)) + 1;\n}"
  },
  {
    "function_name": "ext4_ind_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "645-758",
    "snippet": "ssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "end"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "2"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(rw & WRITE) && ret < 0"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "ext4_get_block"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_do_io",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "ext4_get_block",
            "NULL",
            "DIO_LOCKING"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "dax_do_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "192-226",
          "snippet": "ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_done",
          "args": [
            "inode"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1955-1959",
          "snippet": "void inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "inode->i_sb->s_bdev",
            "iter",
            "offset",
            "ext4_get_block",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__blockdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "1304-1324",
          "snippet": "ssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DIOREAD_LOCK"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_ind_map_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "513-632",
    "snippet": "int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_ind_map_blocks_exit",
          "args": [
            "inode",
            "flags",
            "map",
            "err"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "partial->bh"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "partial->bh",
            "\"call brelse\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "chain[depth-1].key"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "371-382",
          "snippet": "static inline void ext4_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int datasync)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int datasync)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_splice_branch",
          "args": [
            "handle",
            "&ar",
            "partial",
            "indirect_blks"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_splice_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "411-483",
          "snippet": "static int ext4_splice_branch(handle_t *handle,\n\t\t\t      struct ext4_allocation_request *ar,\n\t\t\t      Indirect *where, int num)\n{\n\tint i;\n\tint err = 0;\n\text4_fsblk_t current_block;\n\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && ar->len > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < ar->len; i++)\n\t\t\t*(where->p + i) = cpu_to_le32(current_block++);\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t */\n\t\text4_mark_inode_dirty(handle, ar->inode);\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\t/*\n\t\t * branch[i].bh is newly allocated, so there is no\n\t\t * need to revoke the block, which is why we don't\n\t\t * need to set EXT4_FREE_BLOCKS_METADATA.\n\t\t */\n\t\text4_free_blocks(handle, ar->inode, where[i].bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\text4_free_blocks(handle, ar->inode, NULL, le32_to_cpu(where[num].key),\n\t\t\t ar->len, 0);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_splice_branch(handle_t *handle,\n\t\t\t      struct ext4_allocation_request *ar,\n\t\t\t      Indirect *where, int num)\n{\n\tint i;\n\tint err = 0;\n\text4_fsblk_t current_block;\n\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && ar->len > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < ar->len; i++)\n\t\t\t*(where->p + i) = cpu_to_le32(current_block++);\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t */\n\t\text4_mark_inode_dirty(handle, ar->inode);\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\t/*\n\t\t * branch[i].bh is newly allocated, so there is no\n\t\t * need to revoke the block, which is why we don't\n\t\t * need to set EXT4_FREE_BLOCKS_METADATA.\n\t\t */\n\t\text4_free_blocks(handle, ar->inode, where[i].bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\text4_free_blocks(handle, ar->inode, NULL, le32_to_cpu(where[num].key),\n\t\t\t ar->len, 0);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_branch",
          "args": [
            "handle",
            "&ar",
            "indirect_blks",
            "offsets + (partial - chain)",
            "partial"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "321-394",
          "snippet": "static int ext4_alloc_branch(handle_t *handle,\n\t\t\t     struct ext4_allocation_request *ar,\n\t\t\t     int indirect_blks, ext4_lblk_t *offsets,\n\t\t\t     Indirect *branch)\n{\n\tstruct buffer_head *\t\tbh;\n\text4_fsblk_t\t\t\tb, new_blocks[4];\n\t__le32\t\t\t\t*p;\n\tint\t\t\t\ti, j, err, len = 1;\n\n\tfor (i = 0; i <= indirect_blks; i++) {\n\t\tif (i == indirect_blks) {\n\t\t\tnew_blocks[i] = ext4_mb_new_blocks(handle, ar, &err);\n\t\t} else\n\t\t\tar->goal = new_blocks[i] = ext4_new_meta_blocks(handle,\n\t\t\t\t\tar->inode, ar->goal,\n\t\t\t\t\tar->flags & EXT4_MB_DELALLOC_RESERVED,\n\t\t\t\t\tNULL, &err);\n\t\tif (err) {\n\t\t\ti--;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[i].key = cpu_to_le32(new_blocks[i]);\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tbh = branch[i].bh = sb_getblk(ar->inode->i_sb, new_blocks[i-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\tp = branch[i].p = (__le32 *) bh->b_data + offsets[i];\n\t\tb = new_blocks[i];\n\n\t\tif (i == indirect_blks)\n\t\t\tlen = ar->len;\n\t\tfor (j = 0; j < len; j++)\n\t\t\t*p++ = cpu_to_le32(b++);\n\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\treturn 0;\nfailed:\n\tfor (; i >= 0; i--) {\n\t\t/*\n\t\t * We want to ext4_forget() only freshly allocated indirect\n\t\t * blocks.  Buffer for new_blocks[i-1] is at branch[i].bh and\n\t\t * buffer at branch[0].bh is indirect block / inode already\n\t\t * existing before ext4_alloc_branch() was called.\n\t\t */\n\t\tif (i > 0 && i != indirect_blks && branch[i].bh)\n\t\t\text4_forget(handle, 1, ar->inode, branch[i].bh,\n\t\t\t\t    branch[i].bh->b_blocknr);\n\t\text4_free_blocks(handle, ar->inode, NULL, new_blocks[i],\n\t\t\t\t (i == indirect_blks) ? ar->len : 1, 0);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_alloc_branch(handle_t *handle,\n\t\t\t     struct ext4_allocation_request *ar,\n\t\t\t     int indirect_blks, ext4_lblk_t *offsets,\n\t\t\t     Indirect *branch)\n{\n\tstruct buffer_head *\t\tbh;\n\text4_fsblk_t\t\t\tb, new_blocks[4];\n\t__le32\t\t\t\t*p;\n\tint\t\t\t\ti, j, err, len = 1;\n\n\tfor (i = 0; i <= indirect_blks; i++) {\n\t\tif (i == indirect_blks) {\n\t\t\tnew_blocks[i] = ext4_mb_new_blocks(handle, ar, &err);\n\t\t} else\n\t\t\tar->goal = new_blocks[i] = ext4_new_meta_blocks(handle,\n\t\t\t\t\tar->inode, ar->goal,\n\t\t\t\t\tar->flags & EXT4_MB_DELALLOC_RESERVED,\n\t\t\t\t\tNULL, &err);\n\t\tif (err) {\n\t\t\ti--;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[i].key = cpu_to_le32(new_blocks[i]);\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tbh = branch[i].bh = sb_getblk(ar->inode->i_sb, new_blocks[i-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\tp = branch[i].p = (__le32 *) bh->b_data + offsets[i];\n\t\tb = new_blocks[i];\n\n\t\tif (i == indirect_blks)\n\t\t\tlen = ar->len;\n\t\tfor (j = 0; j < len; j++)\n\t\t\t*p++ = cpu_to_le32(b++);\n\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\treturn 0;\nfailed:\n\tfor (; i >= 0; i--) {\n\t\t/*\n\t\t * We want to ext4_forget() only freshly allocated indirect\n\t\t * blocks.  Buffer for new_blocks[i-1] is at branch[i].bh and\n\t\t * buffer at branch[0].bh is indirect block / inode already\n\t\t * existing before ext4_alloc_branch() was called.\n\t\t */\n\t\tif (i > 0 && i != indirect_blks && branch[i].bh)\n\t\t\text4_forget(handle, 1, ar->inode, branch[i].bh,\n\t\t\t\t    branch[i].bh->b_blocknr);\n\t\text4_free_blocks(handle, ar->inode, NULL, new_blocks[i],\n\t\t\t\t (i == indirect_blks) ? ar->len : 1, 0);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blks_to_allocate",
          "args": [
            "partial",
            "indirect_blks",
            "map->m_len",
            "blocks_to_boundary"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blks_to_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "268-292",
          "snippet": "static int ext4_blks_to_allocate(Indirect *branch, int k, unsigned int blks,\n\t\t\t\t int blocks_to_boundary)\n{\n\tunsigned int count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_blks_to_allocate(Indirect *branch, int k, unsigned int blks,\n\t\t\t\t int blocks_to_boundary)\n{\n\tunsigned int count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_goal",
          "args": [
            "inode",
            "map->m_lblk",
            "partial"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "242-254",
          "snippet": "static ext4_fsblk_t ext4_find_goal(struct inode *inode, ext4_lblk_t block,\n\t\t\t\t   Indirect *partial)\n{\n\text4_fsblk_t goal;\n\n\t/*\n\t * XXX need to get goal block from mballoc's data structures\n\t */\n\n\tgoal = ext4_find_near(inode, partial);\n\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\treturn goal;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic ext4_fsblk_t ext4_find_goal(struct inode *inode, ext4_lblk_t block,\n\t\t\t\t   Indirect *partial)\n{\n\text4_fsblk_t goal;\n\n\t/*\n\t * XXX need to get goal block from mballoc's data structures\n\t */\n\n\tgoal = ext4_find_near(inode, partial);\n\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\treturn goal;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ar",
            "0",
            "sizeof(ar)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\""
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_RO_COMPAT_BIGALLOC"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_branch",
          "args": [
            "inode",
            "depth",
            "offsets",
            "chain",
            "&err"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "142-186",
          "snippet": "static Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_to_path",
          "args": [
            "inode",
            "map->m_lblk",
            "offsets",
            "&blocks_to_boundary"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "72-110",
          "snippet": "static int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_ind_map_blocks_enter",
          "args": [
            "inode",
            "map->m_lblk",
            "map->m_len",
            "flags"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_splice_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "411-483",
    "snippet": "static int ext4_splice_branch(handle_t *handle,\n\t\t\t      struct ext4_allocation_request *ar,\n\t\t\t      Indirect *where, int num)\n{\n\tint i;\n\tint err = 0;\n\text4_fsblk_t current_block;\n\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && ar->len > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < ar->len; i++)\n\t\t\t*(where->p + i) = cpu_to_le32(current_block++);\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t */\n\t\text4_mark_inode_dirty(handle, ar->inode);\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\t/*\n\t\t * branch[i].bh is newly allocated, so there is no\n\t\t * need to revoke the block, which is why we don't\n\t\t * need to set EXT4_FREE_BLOCKS_METADATA.\n\t\t */\n\t\text4_free_blocks(handle, ar->inode, where[i].bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\text4_free_blocks(handle, ar->inode, NULL, le32_to_cpu(where[num].key),\n\t\t\t ar->len, 0);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "ar->inode",
            "NULL",
            "le32_to_cpu(where[num].key)",
            "ar->len",
            "0"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "where[num].key"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"splicing direct\\n\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "ar->inode"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "ar->inode",
            "where->bh"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "where->bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "5",
            "\"splicing indirect only\\n\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "current_block++"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "where->bh"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "where->bh",
            "\"get_write_access\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_splice_branch(handle_t *handle,\n\t\t\t      struct ext4_allocation_request *ar,\n\t\t\t      Indirect *where, int num)\n{\n\tint i;\n\tint err = 0;\n\text4_fsblk_t current_block;\n\n\t/*\n\t * If we're splicing into a [td]indirect block (as opposed to the\n\t * inode) then we need to get write access to the [td]indirect block\n\t * before the splice.\n\t */\n\tif (where->bh) {\n\t\tBUFFER_TRACE(where->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\t/* That's it */\n\n\t*where->p = where->key;\n\n\t/*\n\t * Update the host buffer_head or inode to point to more just allocated\n\t * direct blocks blocks\n\t */\n\tif (num == 0 && ar->len > 1) {\n\t\tcurrent_block = le32_to_cpu(where->key) + 1;\n\t\tfor (i = 1; i < ar->len; i++)\n\t\t\t*(where->p + i) = cpu_to_le32(current_block++);\n\t}\n\n\t/* We are done with atomic stuff, now do the rest of housekeeping */\n\t/* had we spliced it onto indirect block? */\n\tif (where->bh) {\n\t\t/*\n\t\t * If we spliced it onto an indirect block, we haven't\n\t\t * altered the inode.  Note however that if it is being spliced\n\t\t * onto an indirect block at the very end of the file (the\n\t\t * file is growing) then we *will* alter the inode to reflect\n\t\t * the new i_size.  But that is not done here - it is done in\n\t\t * generic_commit_write->__mark_inode_dirty->ext4_dirty_inode.\n\t\t */\n\t\tjbd_debug(5, \"splicing indirect only\\n\");\n\t\tBUFFER_TRACE(where->bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, where->bh);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t} else {\n\t\t/*\n\t\t * OK, we spliced it into the inode itself on a direct block.\n\t\t */\n\t\text4_mark_inode_dirty(handle, ar->inode);\n\t\tjbd_debug(5, \"splicing direct\\n\");\n\t}\n\treturn err;\n\nerr_out:\n\tfor (i = 1; i <= num; i++) {\n\t\t/*\n\t\t * branch[i].bh is newly allocated, so there is no\n\t\t * need to revoke the block, which is why we don't\n\t\t * need to set EXT4_FREE_BLOCKS_METADATA.\n\t\t */\n\t\text4_free_blocks(handle, ar->inode, where[i].bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t}\n\text4_free_blocks(handle, ar->inode, NULL, le32_to_cpu(where[num].key),\n\t\t\t ar->len, 0);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_alloc_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "321-394",
    "snippet": "static int ext4_alloc_branch(handle_t *handle,\n\t\t\t     struct ext4_allocation_request *ar,\n\t\t\t     int indirect_blks, ext4_lblk_t *offsets,\n\t\t\t     Indirect *branch)\n{\n\tstruct buffer_head *\t\tbh;\n\text4_fsblk_t\t\t\tb, new_blocks[4];\n\t__le32\t\t\t\t*p;\n\tint\t\t\t\ti, j, err, len = 1;\n\n\tfor (i = 0; i <= indirect_blks; i++) {\n\t\tif (i == indirect_blks) {\n\t\t\tnew_blocks[i] = ext4_mb_new_blocks(handle, ar, &err);\n\t\t} else\n\t\t\tar->goal = new_blocks[i] = ext4_new_meta_blocks(handle,\n\t\t\t\t\tar->inode, ar->goal,\n\t\t\t\t\tar->flags & EXT4_MB_DELALLOC_RESERVED,\n\t\t\t\t\tNULL, &err);\n\t\tif (err) {\n\t\t\ti--;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[i].key = cpu_to_le32(new_blocks[i]);\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tbh = branch[i].bh = sb_getblk(ar->inode->i_sb, new_blocks[i-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\tp = branch[i].p = (__le32 *) bh->b_data + offsets[i];\n\t\tb = new_blocks[i];\n\n\t\tif (i == indirect_blks)\n\t\t\tlen = ar->len;\n\t\tfor (j = 0; j < len; j++)\n\t\t\t*p++ = cpu_to_le32(b++);\n\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\treturn 0;\nfailed:\n\tfor (; i >= 0; i--) {\n\t\t/*\n\t\t * We want to ext4_forget() only freshly allocated indirect\n\t\t * blocks.  Buffer for new_blocks[i-1] is at branch[i].bh and\n\t\t * buffer at branch[0].bh is indirect block / inode already\n\t\t * existing before ext4_alloc_branch() was called.\n\t\t */\n\t\tif (i > 0 && i != indirect_blks && branch[i].bh)\n\t\t\text4_forget(handle, 1, ar->inode, branch[i].bh,\n\t\t\t\t    branch[i].bh->b_blocknr);\n\t\text4_free_blocks(handle, ar->inode, NULL, new_blocks[i],\n\t\t\t\t (i == indirect_blks) ? ar->len : 1, 0);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "ar->inode",
            "NULL",
            "new_blocks[i]",
            "(i == indirect_blks) ? ar->len : 1",
            "0"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_forget",
          "args": [
            "handle",
            "1",
            "ar->inode",
            "branch[i].bh",
            "branch[i].bh->b_blocknr"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "ar->inode",
            "bh"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"marking uptodate\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "b++"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "bh->b_size"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call get_create_access\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "ar->inode->i_sb",
            "new_blocks[i-1]"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_blocks[i]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_new_meta_blocks",
          "args": [
            "handle",
            "ar->inode",
            "ar->goal",
            "ar->flags & EXT4_MB_DELALLOC_RESERVED",
            "NULL",
            "&err"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_new_meta_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "622-650",
          "snippet": "ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_new_blocks",
          "args": [
            "handle",
            "ar",
            "&err"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4390-4531",
          "snippet": "ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_ac_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_ac_cachep;\n\next4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_alloc_branch(handle_t *handle,\n\t\t\t     struct ext4_allocation_request *ar,\n\t\t\t     int indirect_blks, ext4_lblk_t *offsets,\n\t\t\t     Indirect *branch)\n{\n\tstruct buffer_head *\t\tbh;\n\text4_fsblk_t\t\t\tb, new_blocks[4];\n\t__le32\t\t\t\t*p;\n\tint\t\t\t\ti, j, err, len = 1;\n\n\tfor (i = 0; i <= indirect_blks; i++) {\n\t\tif (i == indirect_blks) {\n\t\t\tnew_blocks[i] = ext4_mb_new_blocks(handle, ar, &err);\n\t\t} else\n\t\t\tar->goal = new_blocks[i] = ext4_new_meta_blocks(handle,\n\t\t\t\t\tar->inode, ar->goal,\n\t\t\t\t\tar->flags & EXT4_MB_DELALLOC_RESERVED,\n\t\t\t\t\tNULL, &err);\n\t\tif (err) {\n\t\t\ti--;\n\t\t\tgoto failed;\n\t\t}\n\t\tbranch[i].key = cpu_to_le32(new_blocks[i]);\n\t\tif (i == 0)\n\t\t\tcontinue;\n\n\t\tbh = branch[i].bh = sb_getblk(ar->inode->i_sb, new_blocks[i-1]);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\tp = branch[i].p = (__le32 *) bh->b_data + offsets[i];\n\t\tb = new_blocks[i];\n\n\t\tif (i == indirect_blks)\n\t\t\tlen = ar->len;\n\t\tfor (j = 0; j < len; j++)\n\t\t\t*p++ = cpu_to_le32(b++);\n\n\t\tBUFFER_TRACE(bh, \"marking uptodate\");\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, ar->inode, bh);\n\t\tif (err)\n\t\t\tgoto failed;\n\t}\n\treturn 0;\nfailed:\n\tfor (; i >= 0; i--) {\n\t\t/*\n\t\t * We want to ext4_forget() only freshly allocated indirect\n\t\t * blocks.  Buffer for new_blocks[i-1] is at branch[i].bh and\n\t\t * buffer at branch[0].bh is indirect block / inode already\n\t\t * existing before ext4_alloc_branch() was called.\n\t\t */\n\t\tif (i > 0 && i != indirect_blks && branch[i].bh)\n\t\t\text4_forget(handle, 1, ar->inode, branch[i].bh,\n\t\t\t\t    branch[i].bh->b_blocknr);\n\t\text4_free_blocks(handle, ar->inode, NULL, new_blocks[i],\n\t\t\t\t (i == indirect_blks) ? ar->len : 1, 0);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_blks_to_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "268-292",
    "snippet": "static int ext4_blks_to_allocate(Indirect *branch, int k, unsigned int blks,\n\t\t\t\t int blocks_to_boundary)\n{\n\tunsigned int count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*(branch[0].p + count)"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_blks_to_allocate(Indirect *branch, int k, unsigned int blks,\n\t\t\t\t int blocks_to_boundary)\n{\n\tunsigned int count = 0;\n\n\t/*\n\t * Simple case, [t,d]Indirect block(s) has not allocated yet\n\t * then it's clear blocks on that path have not allocated\n\t */\n\tif (k > 0) {\n\t\t/* right now we don't handle cross boundary allocation */\n\t\tif (blks < blocks_to_boundary + 1)\n\t\t\tcount += blks;\n\t\telse\n\t\t\tcount += blocks_to_boundary + 1;\n\t\treturn count;\n\t}\n\n\tcount++;\n\twhile (count < blks && count <= blocks_to_boundary &&\n\t\tle32_to_cpu(*(branch[0].p + count)) == 0) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ext4_find_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "242-254",
    "snippet": "static ext4_fsblk_t ext4_find_goal(struct inode *inode, ext4_lblk_t block,\n\t\t\t\t   Indirect *partial)\n{\n\text4_fsblk_t goal;\n\n\t/*\n\t * XXX need to get goal block from mballoc's data structures\n\t */\n\n\tgoal = ext4_find_near(inode, partial);\n\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\treturn goal;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_find_near",
          "args": [
            "inode",
            "partial"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_near",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "208-229",
          "snippet": "static ext4_fsblk_t ext4_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\treturn ext4_inode_to_goal_block(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic ext4_fsblk_t ext4_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\treturn ext4_inode_to_goal_block(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic ext4_fsblk_t ext4_find_goal(struct inode *inode, ext4_lblk_t block,\n\t\t\t\t   Indirect *partial)\n{\n\text4_fsblk_t goal;\n\n\t/*\n\t * XXX need to get goal block from mballoc's data structures\n\t */\n\n\tgoal = ext4_find_near(inode, partial);\n\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\treturn goal;\n}"
  },
  {
    "function_name": "ext4_find_near",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "208-229",
    "snippet": "static ext4_fsblk_t ext4_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\treturn ext4_inode_to_goal_block(inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_inode_to_goal_block",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_to_goal_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "843-882",
          "snippet": "ext4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_group_t block_group;\n\text4_grpblk_t colour;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));\n\text4_fsblk_t bg_start;\n\text4_fsblk_t last_block;\n\n\tblock_group = ei->i_block_group;\n\tif (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) {\n\t\t/*\n\t\t * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\n\t\t * block groups per flexgroup, reserve the first block\n\t\t * group for directories and special files.  Regular\n\t\t * files will start at the second block group.  This\n\t\t * tends to speed up directory access and improves\n\t\t * fsck times.\n\t\t */\n\t\tblock_group &= ~(flex_size-1);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tblock_group++;\n\t}\n\tbg_start = ext4_group_first_block_no(inode->i_sb, block_group);\n\tlast_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;\n\n\t/*\n\t * If we are doing delayed allocation, we don't need take\n\t * colour into account.\n\t */\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\treturn bg_start;\n\n\tif (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)\n\t\tcolour = (current->pid % 16) *\n\t\t\t(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\telse\n\t\tcolour = (current->pid % 16) * ((last_block - bg_start) / 16);\n\treturn bg_start + colour;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\next4_fsblk_t ext4_inode_to_goal_block(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\text4_group_t block_group;\n\text4_grpblk_t colour;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(inode->i_sb));\n\text4_fsblk_t bg_start;\n\text4_fsblk_t last_block;\n\n\tblock_group = ei->i_block_group;\n\tif (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) {\n\t\t/*\n\t\t * If there are at least EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME\n\t\t * block groups per flexgroup, reserve the first block\n\t\t * group for directories and special files.  Regular\n\t\t * files will start at the second block group.  This\n\t\t * tends to speed up directory access and improves\n\t\t * fsck times.\n\t\t */\n\t\tblock_group &= ~(flex_size-1);\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\tblock_group++;\n\t}\n\tbg_start = ext4_group_first_block_no(inode->i_sb, block_group);\n\tlast_block = ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es) - 1;\n\n\t/*\n\t * If we are doing delayed allocation, we don't need take\n\t * colour into account.\n\t */\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\treturn bg_start;\n\n\tif (bg_start + EXT4_BLOCKS_PER_GROUP(inode->i_sb) <= last_block)\n\t\tcolour = (current->pid % 16) *\n\t\t\t(EXT4_BLOCKS_PER_GROUP(inode->i_sb) / 16);\n\telse\n\t\tcolour = (current->pid % 16) * ((last_block - bg_start) / 16);\n\treturn bg_start + colour;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic ext4_fsblk_t ext4_find_near(struct inode *inode, Indirect *ind)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *start = ind->bh ? (__le32 *) ind->bh->b_data : ei->i_data;\n\t__le32 *p;\n\n\t/* Try to find previous block */\n\tfor (p = ind->p - 1; p >= start; p--) {\n\t\tif (*p)\n\t\t\treturn le32_to_cpu(*p);\n\t}\n\n\t/* No such thing, so let's try location of indirect block */\n\tif (ind->bh)\n\t\treturn ind->bh->b_blocknr;\n\n\t/*\n\t * It is going to be referred to from the inode itself? OK, just put it\n\t * into the same cylinder group then.\n\t */\n\treturn ext4_inode_to_goal_block(inode);\n}"
  },
  {
    "function_name": "ext4_get_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "142-186",
    "snippet": "static Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_chain",
          "args": [
            "++p",
            "bh",
            "(__le32 *)bh->b_data + *++offsets"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "add_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "35-39",
          "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_check_indirect_blockref",
          "args": [
            "inode",
            "bh"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "le32_to_cpu(p->key)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "p->key"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic Indirect *ext4_get_branch(struct inode *inode, int depth,\n\t\t\t\t ext4_lblk_t  *offsets,\n\t\t\t\t Indirect chain[4], int *err)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tIndirect *p = chain;\n\tstruct buffer_head *bh;\n\tint ret = -EIO;\n\n\t*err = 0;\n\t/* i_data is not going away, no lock needed */\n\tadd_chain(chain, NULL, EXT4_I(inode)->i_data + *offsets);\n\tif (!p->key)\n\t\tgoto no_block;\n\twhile (--depth) {\n\t\tbh = sb_getblk(sb, le32_to_cpu(p->key));\n\t\tif (unlikely(!bh)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failure;\n\t\t}\n\n\t\tif (!bh_uptodate_or_lock(bh)) {\n\t\t\tif (bh_submit_read(bh) < 0) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t\t/* validate block references */\n\t\t\tif (ext4_check_indirect_blockref(inode, bh)) {\n\t\t\t\tput_bh(bh);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tadd_chain(++p, bh, (__le32 *)bh->b_data + *++offsets);\n\t\t/* Reader: end */\n\t\tif (!p->key)\n\t\t\tgoto no_block;\n\t}\n\treturn NULL;\n\nfailure:\n\t*err = ret;\nno_block:\n\treturn p;\n}"
  },
  {
    "function_name": "ext4_block_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "72-110",
    "snippet": "static int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"block %lu > max in inode %lu\"",
            "i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks",
            "inode->i_ino"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK_BITS",
          "args": [
            "inode->i_sb"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ADDR_PER_BLOCK",
          "args": [
            "inode->i_sb"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic int ext4_block_to_path(struct inode *inode,\n\t\t\t      ext4_lblk_t i_block,\n\t\t\t      ext4_lblk_t offsets[4], int *boundary)\n{\n\tint ptrs = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\tint ptrs_bits = EXT4_ADDR_PER_BLOCK_BITS(inode->i_sb);\n\tconst long direct_blocks = EXT4_NDIR_BLOCKS,\n\t\tindirect_blocks = ptrs,\n\t\tdouble_blocks = (1 << (ptrs_bits * 2));\n\tint n = 0;\n\tint final = 0;\n\n\tif (i_block < direct_blocks) {\n\t\toffsets[n++] = i_block;\n\t\tfinal = direct_blocks;\n\t} else if ((i_block -= direct_blocks) < indirect_blocks) {\n\t\toffsets[n++] = EXT4_IND_BLOCK;\n\t\toffsets[n++] = i_block;\n\t\tfinal = ptrs;\n\t} else if ((i_block -= indirect_blocks) < double_blocks) {\n\t\toffsets[n++] = EXT4_DIND_BLOCK;\n\t\toffsets[n++] = i_block >> ptrs_bits;\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else if (((i_block -= double_blocks) >> (ptrs_bits * 2)) < ptrs) {\n\t\toffsets[n++] = EXT4_TIND_BLOCK;\n\t\toffsets[n++] = i_block >> (ptrs_bits * 2);\n\t\toffsets[n++] = (i_block >> ptrs_bits) & (ptrs - 1);\n\t\toffsets[n++] = i_block & (ptrs - 1);\n\t\tfinal = ptrs;\n\t} else {\n\t\text4_warning(inode->i_sb, \"block %lu > max in inode %lu\",\n\t\t\t     i_block + direct_blocks +\n\t\t\t     indirect_blocks + double_blocks, inode->i_ino);\n\t}\n\tif (boundary)\n\t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n\treturn n;\n}"
  },
  {
    "function_name": "add_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
    "lines": "35-39",
    "snippet": "static inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/aio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nstatic inline void add_chain(Indirect *p, struct buffer_head *bh, __le32 *v)\n{\n\tp->key = *(p->p = v);\n\tp->bh = bh;\n}"
  }
]