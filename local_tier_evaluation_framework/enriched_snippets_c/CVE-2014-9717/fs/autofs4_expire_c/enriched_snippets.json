[
  {
    "function_name": "autofs4_expire_multi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "593-602",
    "snippet": "int autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\tstruct autofs_sb_info *sbi, int __user *arg)\n{\n\tint do_now = 0;\n\n\tif (arg && get_user(do_now, arg))\n\t\treturn -EFAULT;\n\n\treturn autofs4_do_expire_multi(sb, mnt, sbi, do_now);\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_do_expire_multi",
          "args": [
            "sb",
            "mnt",
            "sbi",
            "do_now"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_do_expire_multi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "561-589",
          "snippet": "int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nint autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "do_now",
            "arg"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nint autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\tstruct autofs_sb_info *sbi, int __user *arg)\n{\n\tint do_now = 0;\n\n\tif (arg && get_user(do_now, arg))\n\t\treturn -EFAULT;\n\n\treturn autofs4_do_expire_multi(sb, mnt, sbi, do_now);\n}"
  },
  {
    "function_name": "autofs4_do_expire_multi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "561-589",
    "snippet": "int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long now;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&ino->expire_complete"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_wait",
          "args": [
            "sbi",
            "dentry",
            "NFY_EXPIRE"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_expire_indirect",
          "args": [
            "sb",
            "mnt",
            "sbi",
            "when"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "426-488",
          "snippet": "struct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstruct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_expire_direct",
          "args": [
            "sb",
            "mnt",
            "sbi",
            "when"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_direct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "296-337",
          "snippet": "struct dentry *autofs4_expire_direct(struct super_block *sb,\n\t\t\t\t     struct vfsmount *mnt,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = dget(sb->s_root);\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(root);\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\tgoto out;\n\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\t\tino->flags |= AUTOFS_INF_EXPIRING;\n\t\t\tsmp_mb();\n\t\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\t\tinit_completion(&ino->expire_complete);\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn root;\n\t\t}\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t}\nout:\n\tspin_unlock(&sbi->fs_lock);\n\tdput(root);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstruct dentry *autofs4_expire_direct(struct super_block *sb,\n\t\t\t\t     struct vfsmount *mnt,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = dget(sb->s_root);\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(root);\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\tgoto out;\n\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\t\tino->flags |= AUTOFS_INF_EXPIRING;\n\t\t\tsmp_mb();\n\t\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\t\tinit_completion(&ino->expire_complete);\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn root;\n\t\t}\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t}\nout:\n\tspin_unlock(&sbi->fs_lock);\n\tdput(root);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_type_trigger",
          "args": [
            "sbi->type"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nint autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,\n\t\t\t    struct autofs_sb_info *sbi, int when)\n{\n\tstruct dentry *dentry;\n\tint ret = -EAGAIN;\n\n\tif (autofs_type_trigger(sbi->type))\n\t\tdentry = autofs4_expire_direct(sb, mnt, sbi, when);\n\telse\n\t\tdentry = autofs4_expire_indirect(sb, mnt, sbi, when);\n\n\tif (dentry) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t\t/* This is synchronous because it makes the daemon a\n                   little easier */\n\t\tret = autofs4_wait(sbi, dentry, NFY_EXPIRE);\n\n\t\tspin_lock(&sbi->fs_lock);\n\t\t/* avoid rapid-fire expire attempts if expiry fails */\n\t\tino->last_used = now;\n\t\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\t\tcomplete_all(&ino->expire_complete);\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tdput(dentry);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "autofs4_expire_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "524-559",
    "snippet": "int autofs4_expire_run(struct super_block *sb,\n\t\t      struct vfsmount *mnt,\n\t\t      struct autofs_sb_info *sbi,\n\t\t      struct autofs_packet_expire __user *pkt_p)\n{\n\tstruct autofs_packet_expire pkt;\n\tstruct autofs_info *ino;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tmemset(&pkt,0,sizeof pkt);\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = autofs_ptype_expire;\n\n\tif ((dentry = autofs4_expire_indirect(sb, mnt, sbi, 0)) == NULL)\n\t\treturn -EAGAIN;\n\n\tpkt.len = dentry->d_name.len;\n\tmemcpy(pkt.name, dentry->d_name.name, pkt.len);\n\tpkt.name[pkt.len] = '\\0';\n\tdput(dentry);\n\n\tif ( copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)) )\n\t\tret = -EFAULT;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(dentry);\n\t/* avoid rapid-fire expire attempts if expiry fails */\n\tino->last_used = now;\n\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\tcomplete_all(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long now;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&ino->expire_complete"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "pkt_p",
            "&pkt",
            "sizeof(struct autofs_packet_expire)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pkt.name",
            "dentry->d_name.name",
            "pkt.len"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_expire_indirect",
          "args": [
            "sb",
            "mnt",
            "sbi",
            "0"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_expire_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "426-488",
          "snippet": "struct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstruct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pkt",
            "0",
            "sizeof pkt"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nint autofs4_expire_run(struct super_block *sb,\n\t\t      struct vfsmount *mnt,\n\t\t      struct autofs_sb_info *sbi,\n\t\t      struct autofs_packet_expire __user *pkt_p)\n{\n\tstruct autofs_packet_expire pkt;\n\tstruct autofs_info *ino;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tmemset(&pkt,0,sizeof pkt);\n\n\tpkt.hdr.proto_version = sbi->version;\n\tpkt.hdr.type = autofs_ptype_expire;\n\n\tif ((dentry = autofs4_expire_indirect(sb, mnt, sbi, 0)) == NULL)\n\t\treturn -EAGAIN;\n\n\tpkt.len = dentry->d_name.len;\n\tmemcpy(pkt.name, dentry->d_name.name, pkt.len);\n\tpkt.name[pkt.len] = '\\0';\n\tdput(dentry);\n\n\tif ( copy_to_user(pkt_p, &pkt, sizeof(struct autofs_packet_expire)) )\n\t\tret = -EFAULT;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(dentry);\n\t/* avoid rapid-fire expire attempts if expiry fails */\n\tino->last_used = now;\n\tino->flags &= ~AUTOFS_INF_EXPIRING;\n\tcomplete_all(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "autofs4_expire_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "490-521",
    "snippet": "int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"expire done status=%d\"",
            "status"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ino->expire_complete"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_wait",
          "args": [
            "sbi",
            "dentry",
            "NFY_NONE"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_wait_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/waitq.c",
          "lines": "539-564",
          "snippet": "int autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/file.h>",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/file.h>\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\n{\n\tstruct autofs_wait_queue *wq, **wql;\n\n\tmutex_lock(&sbi->wq_mutex);\n\tfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\n\t\tif (wq->wait_queue_token == wait_queue_token)\n\t\t\tbreak;\n\t}\n\n\tif (!wq) {\n\t\tmutex_unlock(&sbi->wq_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t*wql = wq->next;\t/* Unlink from chain */\n\tkfree(wq->name.name);\n\twq->name.name = NULL;\t/* Do not wait on this queue */\n\twq->status = status;\n\twake_up_interruptible(&wq->queue);\n\tif (!--wq->wait_ctr)\n\t\tkfree(wq);\n\tmutex_unlock(&sbi->wq_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"waiting for expire %p name=%pd\"",
            "dentry",
            "dentry"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "dentry->d_sb"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nint autofs4_expire_wait(struct dentry *dentry, int rcu_walk)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tint status;\n\n\t/* Block on any pending expire */\n\tif (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))\n\t\treturn 0;\n\tif (rcu_walk)\n\t\treturn -ECHILD;\n\n\tspin_lock(&sbi->fs_lock);\n\tif (ino->flags & AUTOFS_INF_EXPIRING) {\n\t\tspin_unlock(&sbi->fs_lock);\n\n\t\tDPRINTK(\"waiting for expire %p name=%pd\", dentry, dentry);\n\n\t\tstatus = autofs4_wait(sbi, dentry, NFY_NONE);\n\t\twait_for_completion(&ino->expire_complete);\n\n\t\tDPRINTK(\"expire done status=%d\", status);\n\n\t\tif (d_unhashed(dentry))\n\t\t\treturn -EAGAIN;\n\n\t\treturn status;\n\t}\n\tspin_unlock(&sbi->fs_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_expire_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "426-488",
    "snippet": "struct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long now;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&expired->d_parent->d_subdirs",
            "&expired->d_child"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&expired->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&expired->d_parent->d_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ino->expire_complete"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"returning %p %pd\"",
            "expired",
            "expired"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "expired"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_expire",
          "args": [
            "expired",
            "mnt",
            "timeout",
            "how"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "should_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "344-419",
          "snippet": "static struct dentry *should_expire(struct dentry *dentry,\n\t\t\t\t    struct vfsmount *mnt,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    int how)\n{\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tint exp_leaves = how & AUTOFS_EXP_LEAVES;\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tunsigned int ino_count;\n\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\treturn NULL;\n\n\t/*\n\t * Case 1: (i) indirect mount or top level pseudo direct mount\n\t *\t   (autofs-4.1).\n\t *\t   (ii) indirect mount with offset mount, check the \"/\"\n\t *\t   offset (autofs-5.0+).\n\t */\n\tif (d_mountpoint(dentry)) {\n\t\tDPRINTK(\"checking mountpoint %p %pd\", dentry, dentry);\n\n\t\t/* Can we umount this guy */\n\t\tif (autofs4_mount_busy(mnt, dentry))\n\t\t\treturn NULL;\n\n\t\t/* Can we expire this guy */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tDPRINTK(\"checking symlink %p %pd\", dentry, dentry);\n\t\t/*\n\t\t * A symlink can't be \"busy\" in the usual sense so\n\t\t * just check last used for expire timeout.\n\t\t */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (simple_empty(dentry))\n\t\treturn NULL;\n\n\t/* Case 2: tree mount, expire iff entire tree is not busy */\n\tif (!exp_leaves) {\n\t\t/* Path walk currently on this dentry? */\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\tif (!autofs4_tree_busy(mnt, dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t/*\n\t * Case 3: pseudo direct mount, expire individual leaves\n\t *\t   (autofs-4.1).\n\t */\n\t} else {\n\t\t/* Path walk currently on this dentry? */\n\t\tstruct dentry *expired;\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\texpired = autofs4_check_leaves(mnt, dentry, timeout, do_now);\n\t\tif (expired) {\n\t\t\tif (expired == dentry)\n\t\t\t\tdput(dentry);\n\t\t\treturn expired;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *should_expire(struct dentry *dentry,\n\t\t\t\t    struct vfsmount *mnt,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    int how)\n{\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tint exp_leaves = how & AUTOFS_EXP_LEAVES;\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tunsigned int ino_count;\n\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\treturn NULL;\n\n\t/*\n\t * Case 1: (i) indirect mount or top level pseudo direct mount\n\t *\t   (autofs-4.1).\n\t *\t   (ii) indirect mount with offset mount, check the \"/\"\n\t *\t   offset (autofs-5.0+).\n\t */\n\tif (d_mountpoint(dentry)) {\n\t\tDPRINTK(\"checking mountpoint %p %pd\", dentry, dentry);\n\n\t\t/* Can we umount this guy */\n\t\tif (autofs4_mount_busy(mnt, dentry))\n\t\t\treturn NULL;\n\n\t\t/* Can we expire this guy */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tDPRINTK(\"checking symlink %p %pd\", dentry, dentry);\n\t\t/*\n\t\t * A symlink can't be \"busy\" in the usual sense so\n\t\t * just check last used for expire timeout.\n\t\t */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (simple_empty(dentry))\n\t\treturn NULL;\n\n\t/* Case 2: tree mount, expire iff entire tree is not busy */\n\tif (!exp_leaves) {\n\t\t/* Path walk currently on this dentry? */\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\tif (!autofs4_tree_busy(mnt, dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t/*\n\t * Case 3: pseudo direct mount, expire individual leaves\n\t *\t   (autofs-4.1).\n\t */\n\t} else {\n\t\t/* Path walk currently on this dentry? */\n\t\tstruct dentry *expired;\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\texpired = autofs4_check_leaves(mnt, dentry, timeout, do_now);\n\t\tif (expired) {\n\t\t\tif (expired == dentry)\n\t\t\t\tdput(dentry);\n\t\t\treturn expired;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "expired"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_positive_subdir",
          "args": [
            "dentry",
            "root"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_positive_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "76-118",
          "snippet": "static struct dentry *get_next_positive_subdir(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *q;\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&root->d_lock);\n\n\tif (prev)\n\t\tnext = prev->d_child.next;\n\telse {\n\t\tprev = dget_dlock(root);\n\t\tnext = prev->d_subdirs.next;\n\t}\n\ncont:\n\tif (next == &root->d_subdirs) {\n\t\tspin_unlock(&root->d_lock);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\tdput(prev);\n\t\treturn NULL;\n\t}\n\n\tq = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Already gone or negative dentry (under construction) - try next */\n\tif (!d_count(q) || !simple_positive(q)) {\n\t\tspin_unlock(&q->d_lock);\n\t\tnext = q->d_child.next;\n\t\tgoto cont;\n\t}\n\tdget_dlock(q);\n\tspin_unlock(&q->d_lock);\n\tspin_unlock(&root->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn q;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *get_next_positive_subdir(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *q;\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&root->d_lock);\n\n\tif (prev)\n\t\tnext = prev->d_child.next;\n\telse {\n\t\tprev = dget_dlock(root);\n\t\tnext = prev->d_subdirs.next;\n\t}\n\ncont:\n\tif (next == &root->d_subdirs) {\n\t\tspin_unlock(&root->d_lock);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\tdput(prev);\n\t\treturn NULL;\n\t}\n\n\tq = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Already gone or negative dentry (under construction) - try next */\n\tif (!d_count(q) || !simple_positive(q)) {\n\t\tspin_unlock(&q->d_lock);\n\t\tnext = q->d_child.next;\n\t\tgoto cont;\n\t}\n\tdget_dlock(q);\n\tspin_unlock(&q->d_lock);\n\tspin_unlock(&root->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn q;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstruct dentry *autofs4_expire_indirect(struct super_block *sb,\n\t\t\t\t       struct vfsmount *mnt,\n\t\t\t\t       struct autofs_sb_info *sbi,\n\t\t\t\t       int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = sb->s_root;\n\tstruct dentry *dentry;\n\tstruct dentry *expired;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tdentry = NULL;\n\twhile ((dentry = get_next_positive_subdir(dentry, root))) {\n\t\tspin_lock(&sbi->fs_lock);\n\t\tino = autofs4_dentry_ino(dentry);\n\t\tif (ino->flags & AUTOFS_INF_NO_RCU)\n\t\t\texpired = NULL;\n\t\telse\n\t\t\texpired = should_expire(dentry, mnt, timeout, how);\n\t\tif (!expired) {\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tino = autofs4_dentry_ino(expired);\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (should_expire(expired, mnt, timeout, how)) {\n\t\t\tif (expired != dentry)\n\t\t\t\tdput(dentry);\n\t\t\tgoto found;\n\t\t}\n\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\tif (expired != dentry)\n\t\t\tdput(expired);\n\t\tspin_unlock(&sbi->fs_lock);\n\t}\n\treturn NULL;\n\nfound:\n\tDPRINTK(\"returning %p %pd\", expired, expired);\n\tino->flags |= AUTOFS_INF_EXPIRING;\n\tsmp_mb();\n\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\tinit_completion(&ino->expire_complete);\n\tspin_unlock(&sbi->fs_lock);\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&expired->d_parent->d_lock);\n\tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n\tspin_unlock(&expired->d_lock);\n\tspin_unlock(&expired->d_parent->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\treturn expired;\n}"
  },
  {
    "function_name": "should_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "344-419",
    "snippet": "static struct dentry *should_expire(struct dentry *dentry,\n\t\t\t\t    struct vfsmount *mnt,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    int how)\n{\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tint exp_leaves = how & AUTOFS_EXP_LEAVES;\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tunsigned int ino_count;\n\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\treturn NULL;\n\n\t/*\n\t * Case 1: (i) indirect mount or top level pseudo direct mount\n\t *\t   (autofs-4.1).\n\t *\t   (ii) indirect mount with offset mount, check the \"/\"\n\t *\t   offset (autofs-5.0+).\n\t */\n\tif (d_mountpoint(dentry)) {\n\t\tDPRINTK(\"checking mountpoint %p %pd\", dentry, dentry);\n\n\t\t/* Can we umount this guy */\n\t\tif (autofs4_mount_busy(mnt, dentry))\n\t\t\treturn NULL;\n\n\t\t/* Can we expire this guy */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tDPRINTK(\"checking symlink %p %pd\", dentry, dentry);\n\t\t/*\n\t\t * A symlink can't be \"busy\" in the usual sense so\n\t\t * just check last used for expire timeout.\n\t\t */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (simple_empty(dentry))\n\t\treturn NULL;\n\n\t/* Case 2: tree mount, expire iff entire tree is not busy */\n\tif (!exp_leaves) {\n\t\t/* Path walk currently on this dentry? */\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\tif (!autofs4_tree_busy(mnt, dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t/*\n\t * Case 3: pseudo direct mount, expire individual leaves\n\t *\t   (autofs-4.1).\n\t */\n\t} else {\n\t\t/* Path walk currently on this dentry? */\n\t\tstruct dentry *expired;\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\texpired = autofs4_check_leaves(mnt, dentry, timeout, do_now);\n\t\tif (expired) {\n\t\t\tif (expired == dentry)\n\t\t\t\tdput(dentry);\n\t\t\treturn expired;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_check_leaves",
          "args": [
            "mnt",
            "dentry",
            "timeout",
            "do_now"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_check_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "269-293",
          "snippet": "static struct dentry *autofs4_check_leaves(struct vfsmount *mnt,\n\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t   unsigned long timeout,\n\t\t\t\t\t   int do_now)\n{\n\tstruct dentry *p;\n\n\tDPRINTK(\"parent %p %pd\", parent, parent);\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, parent))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\tif (d_mountpoint(p)) {\n\t\t\t/* Can we umount this guy */\n\t\t\tif (autofs4_mount_busy(mnt, p))\n\t\t\t\tcontinue;\n\n\t\t\t/* Can we expire this guy */\n\t\t\tif (autofs4_can_expire(p, timeout, do_now))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *autofs4_check_leaves(struct vfsmount *mnt,\n\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t   unsigned long timeout,\n\t\t\t\t\t   int do_now)\n{\n\tstruct dentry *p;\n\n\tDPRINTK(\"parent %p %pd\", parent, parent);\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, parent))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\tif (d_mountpoint(p)) {\n\t\t\t/* Can we umount this guy */\n\t\t\tif (autofs4_mount_busy(mnt, p))\n\t\t\t\tcontinue;\n\n\t\t\t/* Can we expire this guy */\n\t\t\tif (autofs4_can_expire(p, timeout, do_now))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "dentry"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ino->count"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_tree_busy",
          "args": [
            "mnt",
            "dentry",
            "timeout",
            "do_now"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_tree_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "214-267",
          "snippet": "static int autofs4_tree_busy(struct vfsmount *mnt,\n\t       \t\t     struct dentry *top,\n\t\t\t     unsigned long timeout,\n\t\t\t     int do_now)\n{\n\tstruct autofs_info *top_ino = autofs4_dentry_ino(top);\n\tstruct dentry *p;\n\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* Negative dentry - give up */\n\tif (!simple_positive(top))\n\t\treturn 1;\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, top))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\t/*\n\t\t * Is someone visiting anywhere in the subtree ?\n\t\t * If there's no mount we need to check the usage\n\t\t * count for the autofs dentry.\n\t\t * If the fs is busy update the expiry counter.\n\t\t */\n\t\tif (d_mountpoint(p)) {\n\t\t\tif (autofs4_mount_busy(mnt, p)) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct autofs_info *ino = autofs4_dentry_ino(p);\n\t\t\tunsigned int ino_count = atomic_read(&ino->count);\n\n\t\t\t/* allow for dget above and top is already dgot */\n\t\t\tif (p == top)\n\t\t\t\tino_count += 2;\n\t\t\telse\n\t\t\t\tino_count++;\n\n\t\t\tif (d_count(p) > ino_count) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Timeout of a tree mount is ultimately determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_tree_busy(struct vfsmount *mnt,\n\t       \t\t     struct dentry *top,\n\t\t\t     unsigned long timeout,\n\t\t\t     int do_now)\n{\n\tstruct autofs_info *top_ino = autofs4_dentry_ino(top);\n\tstruct dentry *p;\n\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* Negative dentry - give up */\n\tif (!simple_positive(top))\n\t\treturn 1;\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, top))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\t/*\n\t\t * Is someone visiting anywhere in the subtree ?\n\t\t * If there's no mount we need to check the usage\n\t\t * count for the autofs dentry.\n\t\t * If the fs is busy update the expiry counter.\n\t\t */\n\t\tif (d_mountpoint(p)) {\n\t\t\tif (autofs4_mount_busy(mnt, p)) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct autofs_info *ino = autofs4_dentry_ino(p);\n\t\t\tunsigned int ino_count = atomic_read(&ino->count);\n\n\t\t\t/* allow for dget above and top is already dgot */\n\t\t\tif (p == top)\n\t\t\t\tino_count += 2;\n\t\t\telse\n\t\t\t\tino_count++;\n\n\t\t\tif (d_count(p) > ino_count) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Timeout of a tree mount is ultimately determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ino->count"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_empty",
          "args": [
            "dentry"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "simple_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "284-302",
          "snippet": "int simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint simple_empty(struct dentry *dentry)\n{\n\tstruct dentry *child;\n\tint ret = 0;\n\n\tspin_lock(&dentry->d_lock);\n\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\tif (simple_positive(child)) {\n\t\t\tspin_unlock(&child->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&child->d_lock);\n\t}\n\tret = 1;\nout:\n\tspin_unlock(&dentry->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_can_expire",
          "args": [
            "dentry",
            "timeout",
            "do_now"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_can_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "20-35",
          "snippet": "static inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstatic inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"checking symlink %p %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_mount_busy",
          "args": [
            "mnt",
            "dentry"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "38-71",
          "snippet": "static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"checking mountpoint %p %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *should_expire(struct dentry *dentry,\n\t\t\t\t    struct vfsmount *mnt,\n\t\t\t\t    unsigned long timeout,\n\t\t\t\t    int how)\n{\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tint exp_leaves = how & AUTOFS_EXP_LEAVES;\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\tunsigned int ino_count;\n\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\treturn NULL;\n\n\t/*\n\t * Case 1: (i) indirect mount or top level pseudo direct mount\n\t *\t   (autofs-4.1).\n\t *\t   (ii) indirect mount with offset mount, check the \"/\"\n\t *\t   offset (autofs-5.0+).\n\t */\n\tif (d_mountpoint(dentry)) {\n\t\tDPRINTK(\"checking mountpoint %p %pd\", dentry, dentry);\n\n\t\t/* Can we umount this guy */\n\t\tif (autofs4_mount_busy(mnt, dentry))\n\t\t\treturn NULL;\n\n\t\t/* Can we expire this guy */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (dentry->d_inode && d_is_symlink(dentry)) {\n\t\tDPRINTK(\"checking symlink %p %pd\", dentry, dentry);\n\t\t/*\n\t\t * A symlink can't be \"busy\" in the usual sense so\n\t\t * just check last used for expire timeout.\n\t\t */\n\t\tif (autofs4_can_expire(dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t\treturn NULL;\n\t}\n\n\tif (simple_empty(dentry))\n\t\treturn NULL;\n\n\t/* Case 2: tree mount, expire iff entire tree is not busy */\n\tif (!exp_leaves) {\n\t\t/* Path walk currently on this dentry? */\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\tif (!autofs4_tree_busy(mnt, dentry, timeout, do_now))\n\t\t\treturn dentry;\n\t/*\n\t * Case 3: pseudo direct mount, expire individual leaves\n\t *\t   (autofs-4.1).\n\t */\n\t} else {\n\t\t/* Path walk currently on this dentry? */\n\t\tstruct dentry *expired;\n\t\tino_count = atomic_read(&ino->count) + 1;\n\t\tif (d_count(dentry) > ino_count)\n\t\t\treturn NULL;\n\n\t\texpired = autofs4_check_leaves(mnt, dentry, timeout, do_now);\n\t\tif (expired) {\n\t\t\tif (expired == dentry)\n\t\t\t\tdput(dentry);\n\t\t\treturn expired;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_expire_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "296-337",
    "snippet": "struct dentry *autofs4_expire_direct(struct super_block *sb,\n\t\t\t\t     struct vfsmount *mnt,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = dget(sb->s_root);\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(root);\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\tgoto out;\n\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\t\tino->flags |= AUTOFS_INF_EXPIRING;\n\t\t\tsmp_mb();\n\t\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\t\tinit_completion(&ino->expire_complete);\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn root;\n\t\t}\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t}\nout:\n\tspin_unlock(&sbi->fs_lock);\n\tdput(root);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long now;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ino->expire_complete"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_direct_busy",
          "args": [
            "mnt",
            "root",
            "timeout",
            "do_now"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_direct_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "189-209",
          "snippet": "static int autofs4_direct_busy(struct vfsmount *mnt,\n\t\t\t\tstruct dentry *top,\n\t\t\t\tunsigned long timeout,\n\t\t\t\tint do_now)\n{\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* If it's busy update the expiry counters */\n\tif (!may_umount_tree(mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tif (ino)\n\t\t\tino->last_used = jiffies;\n\t\treturn 1;\n\t}\n\n\t/* Timeout of a direct mount is determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_direct_busy(struct vfsmount *mnt,\n\t\t\t\tstruct dentry *top,\n\t\t\t\tunsigned long timeout,\n\t\t\t\tint do_now)\n{\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* If it's busy update the expiry counters */\n\tif (!may_umount_tree(mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tif (ino)\n\t\t\tino->last_used = jiffies;\n\t\treturn 1;\n\t}\n\n\t/* Timeout of a direct mount is determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->fs_lock"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "root"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstruct dentry *autofs4_expire_direct(struct super_block *sb,\n\t\t\t\t     struct vfsmount *mnt,\n\t\t\t\t     struct autofs_sb_info *sbi,\n\t\t\t\t     int how)\n{\n\tunsigned long timeout;\n\tstruct dentry *root = dget(sb->s_root);\n\tint do_now = how & AUTOFS_EXP_IMMEDIATE;\n\tstruct autofs_info *ino;\n\n\tif (!root)\n\t\treturn NULL;\n\n\tnow = jiffies;\n\ttimeout = sbi->exp_timeout;\n\n\tspin_lock(&sbi->fs_lock);\n\tino = autofs4_dentry_ino(root);\n\t/* No point expiring a pending mount */\n\tif (ino->flags & AUTOFS_INF_PENDING)\n\t\tgoto out;\n\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\tino->flags |= AUTOFS_INF_NO_RCU;\n\t\tspin_unlock(&sbi->fs_lock);\n\t\tsynchronize_rcu();\n\t\tspin_lock(&sbi->fs_lock);\n\t\tif (!autofs4_direct_busy(mnt, root, timeout, do_now)) {\n\t\t\tino->flags |= AUTOFS_INF_EXPIRING;\n\t\t\tsmp_mb();\n\t\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t\t\tinit_completion(&ino->expire_complete);\n\t\t\tspin_unlock(&sbi->fs_lock);\n\t\t\treturn root;\n\t\t}\n\t\tino->flags &= ~AUTOFS_INF_NO_RCU;\n\t}\nout:\n\tspin_unlock(&sbi->fs_lock);\n\tdput(root);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_check_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "269-293",
    "snippet": "static struct dentry *autofs4_check_leaves(struct vfsmount *mnt,\n\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t   unsigned long timeout,\n\t\t\t\t\t   int do_now)\n{\n\tstruct dentry *p;\n\n\tDPRINTK(\"parent %p %pd\", parent, parent);\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, parent))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\tif (d_mountpoint(p)) {\n\t\t\t/* Can we umount this guy */\n\t\t\tif (autofs4_mount_busy(mnt, p))\n\t\t\t\tcontinue;\n\n\t\t\t/* Can we expire this guy */\n\t\t\tif (autofs4_can_expire(p, timeout, do_now))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_can_expire",
          "args": [
            "p",
            "timeout",
            "do_now"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_can_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "20-35",
          "snippet": "static inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstatic inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_mount_busy",
          "args": [
            "mnt",
            "p"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "38-71",
          "snippet": "static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "p"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry %p %pd\"",
            "p",
            "p"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_positive_dentry",
          "args": [
            "p",
            "parent"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_positive_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "123-181",
          "snippet": "static struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"parent %p %pd\"",
            "parent",
            "parent"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *autofs4_check_leaves(struct vfsmount *mnt,\n\t\t\t\t\t   struct dentry *parent,\n\t\t\t\t\t   unsigned long timeout,\n\t\t\t\t\t   int do_now)\n{\n\tstruct dentry *p;\n\n\tDPRINTK(\"parent %p %pd\", parent, parent);\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, parent))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\tif (d_mountpoint(p)) {\n\t\t\t/* Can we umount this guy */\n\t\t\tif (autofs4_mount_busy(mnt, p))\n\t\t\t\tcontinue;\n\n\t\t\t/* Can we expire this guy */\n\t\t\tif (autofs4_can_expire(p, timeout, do_now))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "autofs4_tree_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "214-267",
    "snippet": "static int autofs4_tree_busy(struct vfsmount *mnt,\n\t       \t\t     struct dentry *top,\n\t\t\t     unsigned long timeout,\n\t\t\t     int do_now)\n{\n\tstruct autofs_info *top_ino = autofs4_dentry_ino(top);\n\tstruct dentry *p;\n\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* Negative dentry - give up */\n\tif (!simple_positive(top))\n\t\treturn 1;\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, top))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\t/*\n\t\t * Is someone visiting anywhere in the subtree ?\n\t\t * If there's no mount we need to check the usage\n\t\t * count for the autofs dentry.\n\t\t * If the fs is busy update the expiry counter.\n\t\t */\n\t\tif (d_mountpoint(p)) {\n\t\t\tif (autofs4_mount_busy(mnt, p)) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct autofs_info *ino = autofs4_dentry_ino(p);\n\t\t\tunsigned int ino_count = atomic_read(&ino->count);\n\n\t\t\t/* allow for dget above and top is already dgot */\n\t\t\tif (p == top)\n\t\t\t\tino_count += 2;\n\t\t\telse\n\t\t\t\tino_count++;\n\n\t\t\tif (d_count(p) > ino_count) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Timeout of a tree mount is ultimately determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_can_expire",
          "args": [
            "top",
            "timeout",
            "do_now"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_can_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "20-35",
          "snippet": "static inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstatic inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "p"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "p"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ino->count"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "p"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_mount_busy",
          "args": [
            "mnt",
            "p"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_mount_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "38-71",
          "snippet": "static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "p"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry %p %pd\"",
            "p",
            "p"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_positive_dentry",
          "args": [
            "p",
            "top"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_positive_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "123-181",
          "snippet": "static struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "top"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "simple_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "241-244",
          "snippet": "static inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"top %p %pd\"",
            "top",
            "top"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_tree_busy(struct vfsmount *mnt,\n\t       \t\t     struct dentry *top,\n\t\t\t     unsigned long timeout,\n\t\t\t     int do_now)\n{\n\tstruct autofs_info *top_ino = autofs4_dentry_ino(top);\n\tstruct dentry *p;\n\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* Negative dentry - give up */\n\tif (!simple_positive(top))\n\t\treturn 1;\n\n\tp = NULL;\n\twhile ((p = get_next_positive_dentry(p, top))) {\n\t\tDPRINTK(\"dentry %p %pd\", p, p);\n\n\t\t/*\n\t\t * Is someone visiting anywhere in the subtree ?\n\t\t * If there's no mount we need to check the usage\n\t\t * count for the autofs dentry.\n\t\t * If the fs is busy update the expiry counter.\n\t\t */\n\t\tif (d_mountpoint(p)) {\n\t\t\tif (autofs4_mount_busy(mnt, p)) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct autofs_info *ino = autofs4_dentry_ino(p);\n\t\t\tunsigned int ino_count = atomic_read(&ino->count);\n\n\t\t\t/* allow for dget above and top is already dgot */\n\t\t\tif (p == top)\n\t\t\t\tino_count += 2;\n\t\t\telse\n\t\t\t\tino_count++;\n\n\t\t\tif (d_count(p) > ino_count) {\n\t\t\t\ttop_ino->last_used = jiffies;\n\t\t\t\tdput(p);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Timeout of a tree mount is ultimately determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "autofs4_direct_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "189-209",
    "snippet": "static int autofs4_direct_busy(struct vfsmount *mnt,\n\t\t\t\tstruct dentry *top,\n\t\t\t\tunsigned long timeout,\n\t\t\t\tint do_now)\n{\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* If it's busy update the expiry counters */\n\tif (!may_umount_tree(mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tif (ino)\n\t\t\tino->last_used = jiffies;\n\t\treturn 1;\n\t}\n\n\t/* Timeout of a direct mount is determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autofs4_can_expire",
          "args": [
            "top",
            "timeout",
            "do_now"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_can_expire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
          "lines": "20-35",
          "snippet": "static inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"autofs_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long now;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstatic inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "top"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_umount_tree",
          "args": [
            "mnt"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "may_umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1267-1287",
          "snippet": "int may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"top %p %pd\"",
            "top",
            "top"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_direct_busy(struct vfsmount *mnt,\n\t\t\t\tstruct dentry *top,\n\t\t\t\tunsigned long timeout,\n\t\t\t\tint do_now)\n{\n\tDPRINTK(\"top %p %pd\", top, top);\n\n\t/* If it's busy update the expiry counters */\n\tif (!may_umount_tree(mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tif (ino)\n\t\t\tino->last_used = jiffies;\n\t\treturn 1;\n\t}\n\n\t/* Timeout of a direct mount is determined by its top dentry */\n\tif (!autofs4_can_expire(top, timeout, do_now))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_next_positive_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "123-181",
    "snippet": "static struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "prev"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "ret"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_set_subclass",
          "args": [
            "&ret->d_lock.dep_map",
            "0",
            "_RET_IP_"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "ret"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "simple_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "241-244",
          "snippet": "static inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&ret->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structdentry",
            "d_child"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->d_lock"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "root"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "root->d_sb"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *get_next_positive_dentry(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *p, *ret;\n\n\tif (prev == NULL)\n\t\treturn dget(root);\n\n\tspin_lock(&sbi->lookup_lock);\nrelock:\n\tp = prev;\n\tspin_lock(&p->d_lock);\nagain:\n\tnext = p->d_subdirs.next;\n\tif (next == &p->d_subdirs) {\n\t\twhile (1) {\n\t\t\tstruct dentry *parent;\n\n\t\t\tif (p == root) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tspin_unlock(&sbi->lookup_lock);\n\t\t\t\tdput(prev);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tparent = p->d_parent;\n\t\t\tif (!spin_trylock(&parent->d_lock)) {\n\t\t\t\tspin_unlock(&p->d_lock);\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tnext = p->d_child.next;\n\t\t\tp = parent;\n\t\t\tif (next != &parent->d_subdirs)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tret = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Negative dentry - try next */\n\tif (!simple_positive(ret)) {\n\t\tspin_unlock(&p->d_lock);\n\t\tlock_set_subclass(&ret->d_lock.dep_map, 0, _RET_IP_);\n\t\tp = ret;\n\t\tgoto again;\n\t}\n\tdget_dlock(ret);\n\tspin_unlock(&ret->d_lock);\n\tspin_unlock(&p->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "get_next_positive_subdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "76-118",
    "snippet": "static struct dentry *get_next_positive_subdir(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *q;\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&root->d_lock);\n\n\tif (prev)\n\t\tnext = prev->d_child.next;\n\telse {\n\t\tprev = dget_dlock(root);\n\t\tnext = prev->d_subdirs.next;\n\t}\n\ncont:\n\tif (next == &root->d_subdirs) {\n\t\tspin_unlock(&root->d_lock);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\tdput(prev);\n\t\treturn NULL;\n\t}\n\n\tq = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Already gone or negative dentry (under construction) - try next */\n\tif (!d_count(q) || !simple_positive(q)) {\n\t\tspin_unlock(&q->d_lock);\n\t\tnext = q->d_child.next;\n\t\tgoto cont;\n\t}\n\tdget_dlock(q);\n\tspin_unlock(&q->d_lock);\n\tspin_unlock(&root->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn q;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "prev"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->lookup_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_dlock",
          "args": [
            "q"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "767-770",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "q"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "simple_positive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "241-244",
          "snippet": "static inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int is_autofs4_dentry(struct dentry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint is_autofs4_dentry(struct dentry *);\n\nstatic inline int simple_positive(struct dentry *dentry)\n{\n\treturn dentry->d_inode && !d_unhashed(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "q"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&q->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structdentry",
            "d_child"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->d_lock"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "root->d_sb"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic struct dentry *get_next_positive_subdir(struct dentry *prev,\n\t\t\t\t\t\tstruct dentry *root)\n{\n\tstruct autofs_sb_info *sbi = autofs4_sbi(root->d_sb);\n\tstruct list_head *next;\n\tstruct dentry *q;\n\n\tspin_lock(&sbi->lookup_lock);\n\tspin_lock(&root->d_lock);\n\n\tif (prev)\n\t\tnext = prev->d_child.next;\n\telse {\n\t\tprev = dget_dlock(root);\n\t\tnext = prev->d_subdirs.next;\n\t}\n\ncont:\n\tif (next == &root->d_subdirs) {\n\t\tspin_unlock(&root->d_lock);\n\t\tspin_unlock(&sbi->lookup_lock);\n\t\tdput(prev);\n\t\treturn NULL;\n\t}\n\n\tq = list_entry(next, struct dentry, d_child);\n\n\tspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\n\t/* Already gone or negative dentry (under construction) - try next */\n\tif (!d_count(q) || !simple_positive(q)) {\n\t\tspin_unlock(&q->d_lock);\n\t\tnext = q->d_child.next;\n\t\tgoto cont;\n\t}\n\tdget_dlock(q);\n\tspin_unlock(&q->d_lock);\n\tspin_unlock(&root->d_lock);\n\tspin_unlock(&sbi->lookup_lock);\n\n\tdput(prev);\n\n\treturn q;\n}"
  },
  {
    "function_name": "autofs4_mount_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "38-71",
    "snippet": "static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"returning = %d\"",
            "status"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "top"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "may_umount_tree",
          "args": [
            "path.mnt"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "may_umount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1267-1287",
          "snippet": "int may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tlock_mount_hash();\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tunlock_mount_hash();\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autofs_type_indirect",
          "args": [
            "sbi->type"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_sbi",
          "args": [
            "path.dentry->d_sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "132-135",
          "snippet": "static inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int autofs4_fill_super(struct super_block *, void *, int);",
            "struct autofs_info *autofs4_new_ino(struct autofs_sb_info *);",
            "void autofs4_catatonic_mode(struct autofs_sb_info *);",
            "extern void autofs4_kill_sb(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nint autofs4_fill_super(struct super_block *, void *, int);\nstruct autofs_info *autofs4_new_ino(struct autofs_sb_info *);\nvoid autofs4_catatonic_mode(struct autofs_sb_info *);\nextern void autofs4_kill_sb(struct super_block *);\n\nstatic inline struct autofs_sb_info *autofs4_sbi(struct super_block *sb)\n{\n\treturn (struct autofs_sb_info *)(sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_autofs4_dentry",
          "args": [
            "path.dentry"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "is_autofs4_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/root.c",
          "lines": "840-845",
          "snippet": "int is_autofs4_dentry(struct dentry *dentry)\n{\n\treturn dentry && dentry->d_inode &&\n\t\tdentry->d_op == &autofs4_dentry_operations &&\n\t\tdentry->d_fsdata != NULL;\n}",
          "includes": [
            "#include \"autofs_i.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/compat.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);",
            "static int autofs4_dir_unlink(struct inode *,struct dentry *);",
            "static int autofs4_dir_rmdir(struct inode *,struct dentry *);",
            "static struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);",
            "static int autofs4_d_manage(struct dentry *, bool);",
            "static void autofs4_dentry_release(struct dentry *);",
            "const struct dentry_operations autofs4_dentry_operations = {\n\t.d_automount\t= autofs4_d_automount,\n\t.d_manage\t= autofs4_d_manage,\n\t.d_release\t= autofs4_dentry_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"autofs_i.h\"\n#include <linux/mutex.h>\n#include <linux/compat.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nstatic int autofs4_dir_symlink(struct inode *,struct dentry *,const char *);\nstatic int autofs4_dir_unlink(struct inode *,struct dentry *);\nstatic int autofs4_dir_rmdir(struct inode *,struct dentry *);\nstatic struct dentry *autofs4_lookup(struct inode *,struct dentry *, unsigned int);\nstatic int autofs4_d_manage(struct dentry *, bool);\nstatic void autofs4_dentry_release(struct dentry *);\nconst struct dentry_operations autofs4_dentry_operations = {\n\t.d_automount\t= autofs4_d_automount,\n\t.d_manage\t= autofs4_d_manage,\n\t.d_release\t= autofs4_dentry_release,\n};\n\nint is_autofs4_dentry(struct dentry *dentry)\n{\n\treturn dentry && dentry->d_inode &&\n\t\tdentry->d_op == &autofs4_dentry_operations &&\n\t\tdentry->d_fsdata != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "follow_down_one",
          "args": [
            "&path"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "follow_down_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1110-1123",
          "snippet": "int follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint follow_down_one(struct path *path)\n{\n\tstruct vfsmount *mounted;\n\n\tmounted = lookup_mnt(path);\n\tif (mounted) {\n\t\tdput(path->dentry);\n\t\tmntput(path->mnt);\n\t\tpath->mnt = mounted;\n\t\tpath->dentry = dget(mounted->mnt_root);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&path"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTK",
          "args": [
            "\"dentry %p %pd\"",
            "dentry",
            "dentry"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct dentry *top = dentry;\n\tstruct path path = {.mnt = mnt, .dentry = dentry};\n\tint status = 1;\n\n\tDPRINTK(\"dentry %p %pd\", dentry, dentry);\n\n\tpath_get(&path);\n\n\tif (!follow_down_one(&path))\n\t\tgoto done;\n\n\tif (is_autofs4_dentry(path.dentry)) {\n\t\tstruct autofs_sb_info *sbi = autofs4_sbi(path.dentry->d_sb);\n\n\t\t/* This is an autofs submount, we can't expire it */\n\t\tif (autofs_type_indirect(sbi->type))\n\t\t\tgoto done;\n\t}\n\n\t/* Update the expiry counter if fs is busy */\n\tif (!may_umount_tree(path.mnt)) {\n\t\tstruct autofs_info *ino = autofs4_dentry_ino(top);\n\t\tino->last_used = jiffies;\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\ndone:\n\tDPRINTK(\"returning = %d\", status);\n\tpath_put(&path);\n\treturn status;\n}"
  },
  {
    "function_name": "autofs4_can_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/expire.c",
    "lines": "20-35",
    "snippet": "static inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"autofs_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long now;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "ino->last_used + timeout",
            "now"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autofs4_dentry_ino",
          "args": [
            "dentry"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "autofs4_dentry_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/autofs4/autofs_i.h",
          "lines": "137-140",
          "snippet": "static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/current.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/list.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/auto_dev-ioctl.h>",
            "#include <linux/auto_fs4.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void autofs4_free_ino(struct autofs_info *);",
            "int is_autofs4_dentry(struct dentry *);",
            "void autofs4_clean_ino(struct autofs_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/current.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/auto_dev-ioctl.h>\n#include <linux/auto_fs4.h>\n\nvoid autofs4_free_ino(struct autofs_info *);\nint is_autofs4_dentry(struct dentry *);\nvoid autofs4_clean_ino(struct autofs_info *);\n\nstatic inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)\n{\n\treturn (struct autofs_info *)(dentry->d_fsdata);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"autofs_i.h\"\n\nstatic unsigned long now;\n\nstatic inline int autofs4_can_expire(struct dentry *dentry,\n\t\t\t\t\tunsigned long timeout, int do_now)\n{\n\tstruct autofs_info *ino = autofs4_dentry_ino(dentry);\n\n\t/* dentry in the process of being deleted */\n\tif (ino == NULL)\n\t\treturn 0;\n\n\tif (!do_now) {\n\t\t/* Too young to die */\n\t\tif (!timeout || time_after(ino->last_used + timeout, now))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
  }
]