[
  {
    "function_name": "afs_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "351-380",
    "snippet": "static int afs_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tstruct afs_writeback *wb = (struct afs_writeback *) page_private(page);\n\tstruct afs_vnode *vnode = AFS_FS_I(page->mapping->host);\n\n\t_enter(\"{{%x:%u}[%lu],%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index, page->flags,\n\t       gfp_flags);\n\n\t/* deny if page is being written to the cache and the caller hasn't\n\t * elected to wait */\n#ifdef CONFIG_AFS_FSCACHE\n\tif (!fscache_maybe_release_page(vnode->cache, page, gfp_flags)) {\n\t\t_leave(\" = F [cache busy]\");\n\t\treturn 0;\n\t}\n#endif\n\n\tif (PagePrivate(page)) {\n\t\tif (wb) {\n\t\t\tset_page_private(page, 0);\n\t\t\tafs_put_writeback(wb);\n\t\t}\n\t\tClearPagePrivate(page);\n\t}\n\n\t/* indicate that the page can be released */\n\t_leave(\" = T\");\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static int afs_releasepage(struct page *page, gfp_t gfp_flags);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = T\""
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_writeback",
          "args": [
            "wb"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "68-82",
          "snippet": "void afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nvoid afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_maybe_release_page",
          "args": [
            "vnode->cache",
            "page",
            "gfp_flags"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_maybe_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "63-137",
          "snippet": "bool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nbool __fscache_maybe_release_page(struct fscache_cookie *cookie,\n\t\t\t\t  struct page *page,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct page *xpage;\n\tvoid *val;\n\n\t_enter(\"%p,%p,%x\", cookie, page, gfp);\n\ntry_again:\n\trcu_read_lock();\n\tval = radix_tree_lookup(&cookie->stores, page->index);\n\tif (!val) {\n\t\trcu_read_unlock();\n\t\tfscache_stat(&fscache_n_store_vmscan_not_storing);\n\t\t__fscache_uncache_page(cookie, page);\n\t\treturn true;\n\t}\n\n\t/* see if the page is actually undergoing storage - if so we can't get\n\t * rid of it till the cache has finished with it */\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\trcu_read_unlock();\n\t\tgoto page_busy;\n\t}\n\n\t/* the page is pending storage, so we attempt to cancel the store and\n\t * discard the store request so that the page can be reclaimed */\n\tspin_lock(&cookie->stores_lock);\n\trcu_read_unlock();\n\n\tif (radix_tree_tag_get(&cookie->stores, page->index,\n\t\t\t       FSCACHE_COOKIE_STORING_TAG)) {\n\t\t/* the page started to undergo storage whilst we were looking,\n\t\t * so now we can only wait or return */\n\t\tspin_unlock(&cookie->stores_lock);\n\t\tgoto page_busy;\n\t}\n\n\txpage = radix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\n\tif (xpage) {\n\t\tfscache_stat(&fscache_n_store_vmscan_cancelled);\n\t\tfscache_stat(&fscache_n_store_radix_deletes);\n\t\tASSERTCMP(xpage, ==, page);\n\t} else {\n\t\tfscache_stat(&fscache_n_store_vmscan_gone);\n\t}\n\n\twake_up_bit(&cookie->flags, 0);\n\tif (xpage)\n\t\tpage_cache_release(xpage);\n\t__fscache_uncache_page(cookie, page);\n\treturn true;\n\npage_busy:\n\t/* We will wait here if we're allowed to, but that could deadlock the\n\t * allocator as the work threads writing to the cache may all end up\n\t * sleeping on memory allocation, so we may need to impose a timeout\n\t * too. */\n\tif (!(gfp & __GFP_WAIT) || !(gfp & __GFP_FS)) {\n\t\tfscache_stat(&fscache_n_store_vmscan_busy);\n\t\treturn false;\n\t}\n\n\tfscache_stat(&fscache_n_store_vmscan_wait);\n\tif (!release_page_wait_timeout(cookie, page))\n\t\t_debug(\"fscache writeout timeout page: %p{%lx}\",\n\t\t\tpage, page->index);\n\n\tgfp &= ~__GFP_WAIT;\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{{%x:%u}[%lu],%lx},%x\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "page->index",
            "page->flags",
            "gfp_flags"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_releasepage(struct page *page, gfp_t gfp_flags);\nstatic int afs_launder_page(struct page *page);\n\nstatic int afs_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tstruct afs_writeback *wb = (struct afs_writeback *) page_private(page);\n\tstruct afs_vnode *vnode = AFS_FS_I(page->mapping->host);\n\n\t_enter(\"{{%x:%u}[%lu],%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, page->index, page->flags,\n\t       gfp_flags);\n\n\t/* deny if page is being written to the cache and the caller hasn't\n\t * elected to wait */\n#ifdef CONFIG_AFS_FSCACHE\n\tif (!fscache_maybe_release_page(vnode->cache, page, gfp_flags)) {\n\t\t_leave(\" = F [cache busy]\");\n\t\treturn 0;\n\t}\n#endif\n\n\tif (PagePrivate(page)) {\n\t\tif (wb) {\n\t\t\tset_page_private(page, 0);\n\t\t\tafs_put_writeback(wb);\n\t\t}\n\t\tClearPagePrivate(page);\n\t}\n\n\t/* indicate that the page can be released */\n\t_leave(\" = T\");\n\treturn 1;\n}"
  },
  {
    "function_name": "afs_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "314-345",
    "snippet": "static void afs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t       unsigned int length)\n{\n\tstruct afs_writeback *wb = (struct afs_writeback *) page_private(page);\n\n\t_enter(\"{%lu},%u,%u\", page->index, offset, length);\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* we clean up only if the entire page is being invalidated */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE) {\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page)) {\n\t\t\tstruct afs_vnode *vnode = AFS_FS_I(page->mapping->host);\n\t\t\tfscache_wait_on_page_write(vnode->cache, page);\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t}\n#endif\n\n\t\tif (PagePrivate(page)) {\n\t\t\tif (wb && !PageWriteback(page)) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tafs_put_writeback(wb);\n\t\t\t}\n\n\t\t\tif (!page_private(page))\n\t\t\t\tClearPagePrivate(page);\n\t\t}\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static void afs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t       unsigned int length);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_writeback",
          "args": [
            "wb"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/write.c",
          "lines": "68-82",
          "snippet": "void afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n\nvoid afs_put_writeback(struct afs_writeback *wb)\n{\n\tstruct afs_vnode *vnode = wb->vnode;\n\n\t_enter(\"{%d}\", wb->usage);\n\n\tspin_lock(&vnode->writeback_lock);\n\tif (--wb->usage == 0)\n\t\tafs_unlink_writeback(wb);\n\telse\n\t\twb = NULL;\n\tspin_unlock(&vnode->writeback_lock);\n\tif (wb)\n\t\tafs_free_writeback(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "vnode->cache",
            "page"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_wait_on_page_write",
          "args": [
            "vnode->cache",
            "page"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "__v9fs_fscache_wait_on_page_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "408-414",
          "snippet": "void __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid __v9fs_fscache_wait_on_page_write(struct inode *inode, struct page *page)\n{\n\tconst struct v9fs_inode *v9inode = V9FS_I(inode);\n\tp9_debug(P9_DEBUG_FSC, \"inode %p page %p\\n\", inode, page);\n\tif (PageFsCache(page))\n\t\tfscache_wait_on_page_write(v9inode->fscache, page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu},%u,%u\"",
            "page->index",
            "offset",
            "length"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic void afs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t       unsigned int length);\nstatic int afs_launder_page(struct page *page);\n\nstatic void afs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t       unsigned int length)\n{\n\tstruct afs_writeback *wb = (struct afs_writeback *) page_private(page);\n\n\t_enter(\"{%lu},%u,%u\", page->index, offset, length);\n\n\tBUG_ON(!PageLocked(page));\n\n\t/* we clean up only if the entire page is being invalidated */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE) {\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page)) {\n\t\t\tstruct afs_vnode *vnode = AFS_FS_I(page->mapping->host);\n\t\t\tfscache_wait_on_page_write(vnode->cache, page);\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t}\n#endif\n\n\t\tif (PagePrivate(page)) {\n\t\t\tif (wb && !PageWriteback(page)) {\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\tafs_put_writeback(wb);\n\t\t\t}\n\n\t\t\tif (!page_private(page))\n\t\t\t\tClearPagePrivate(page);\n\t\t}\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_launder_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "302-307",
    "snippet": "static int afs_launder_page(struct page *page)\n{\n\t_enter(\"{%lu}\", page->index);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu}\"",
            "page->index"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nstatic int afs_launder_page(struct page *page)\n{\n\t_enter(\"{%lu}\", page->index);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "242-297",
    "snippet": "static int afs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages)\n{\n\tstruct key *key = file->private_data;\n\tstruct afs_vnode *vnode;\n\tint ret = 0;\n\n\t_enter(\"{%d},{%lu},,%d\",\n\t       key_serial(key), mapping->host->i_ino, nr_pages);\n\n\tASSERT(key != NULL);\n\n\tvnode = AFS_FS_I(mapping->host);\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* attempt to read as many of the pages as possible */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_pages(vnode->cache,\n\t\t\t\t\t  mapping,\n\t\t\t\t\t  pages,\n\t\t\t\t\t  &nr_pages,\n\t\t\t\t\t  afs_file_readpage_read_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n#else\n\tret = -ENOBUFS;\n#endif\n\n\tswitch (ret) {\n\t\t/* all pages are being read from the cache */\n\tcase 0:\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(nr_pages != 0);\n\t\t_leave(\" = 0 [reading all]\");\n\t\treturn 0;\n\n\t\t/* there were pages that couldn't be read from the cache */\n\tcase -ENODATA:\n\tcase -ENOBUFS:\n\t\tbreak;\n\n\t\t/* other error */\n\tdefault:\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* load the missing pages from the network */\n\tret = read_cache_pages(mapping, pages, afs_page_filler, key);\n\n\t_leave(\" = %d [netting]\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [netting]\"",
            "ret"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cache_pages",
          "args": [
            "mapping",
            "pages",
            "afs_page_filler",
            "key"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [reading all]\""
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_pages != 0"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_pages",
          "args": [
            "vnode->cache",
            "mapping",
            "pages",
            "&nr_pages",
            "afs_file_readpage_read_complete",
            "NULL",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "532-642",
          "snippet": "int __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_pages(struct fscache_cookie *cookie,\n\t\t\t\t  struct address_space *mapping,\n\t\t\t\t  struct list_head *pages,\n\t\t\t\t  unsigned *nr_pages,\n\t\t\t\t  fscache_rw_complete_t end_io_func,\n\t\t\t\t  void *context,\n\t\t\t\t  gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,,%d,,,\", cookie, *nr_pages);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(*nr_pages, >, 0);\n\tASSERT(!list_empty(pages));\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, mapping, end_io_func, context);\n\tif (!op)\n\t\treturn -ENOMEM;\n\tatomic_set(&op->n_pages, *nr_pages);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_pages);\n\t\tret = object->cache->ops->allocate_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_pages);\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_pages);\n\t\tret = object->cache->ops->read_or_alloc_pages(\n\t\t\top, pages, nr_pages, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_pages);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "mapping->host"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key != NULL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%d},{%lu},,%d\"",
            "key_serial(key)",
            "mapping->host->i_ino",
            "nr_pages"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpages(struct file *filp, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages);\n\nstatic int afs_readpages(struct file *file, struct address_space *mapping,\n\t\t\t struct list_head *pages, unsigned nr_pages)\n{\n\tstruct key *key = file->private_data;\n\tstruct afs_vnode *vnode;\n\tint ret = 0;\n\n\t_enter(\"{%d},{%lu},,%d\",\n\t       key_serial(key), mapping->host->i_ino, nr_pages);\n\n\tASSERT(key != NULL);\n\n\tvnode = AFS_FS_I(mapping->host);\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* attempt to read as many of the pages as possible */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_pages(vnode->cache,\n\t\t\t\t\t  mapping,\n\t\t\t\t\t  pages,\n\t\t\t\t\t  &nr_pages,\n\t\t\t\t\t  afs_file_readpage_read_complete,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n#else\n\tret = -ENOBUFS;\n#endif\n\n\tswitch (ret) {\n\t\t/* all pages are being read from the cache */\n\tcase 0:\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(nr_pages != 0);\n\t\t_leave(\" = 0 [reading all]\");\n\t\treturn 0;\n\n\t\t/* there were pages that couldn't be read from the cache */\n\tcase -ENODATA:\n\tcase -ENOBUFS:\n\t\tbreak;\n\n\t\t/* other error */\n\tdefault:\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t/* load the missing pages from the network */\n\tret = read_cache_pages(mapping, pages, afs_page_filler, key);\n\n\t_leave(\" = %d [netting]\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "217-237",
    "snippet": "static int afs_readpage(struct file *file, struct page *page)\n{\n\tstruct key *key;\n\tint ret;\n\n\tif (file) {\n\t\tkey = file->private_data;\n\t\tASSERT(key != NULL);\n\t\tret = afs_page_filler(key, page);\n\t} else {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tkey = afs_request_key(AFS_FS_S(inode->i_sb)->volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\tret = PTR_ERR(key);\n\t\t} else {\n\t\t\tret = afs_page_filler(key, page);\n\t\t\tkey_put(key);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_page_filler",
          "args": [
            "key",
            "page"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "afs_page_filler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
          "lines": "127-211",
          "snippet": "int afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_readpage(struct file *file, struct page *page);",
            "static int afs_launder_page(struct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nint afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "AFS_FS_S(inode->i_sb)->volume->cell"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_S",
          "args": [
            "inode->i_sb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_S",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "176-179",
          "snippet": "static inline struct afs_super_info *AFS_FS_S(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nstatic inline struct afs_super_info *AFS_FS_S(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key != NULL"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nstatic int afs_readpage(struct file *file, struct page *page)\n{\n\tstruct key *key;\n\tint ret;\n\n\tif (file) {\n\t\tkey = file->private_data;\n\t\tASSERT(key != NULL);\n\t\tret = afs_page_filler(key, page);\n\t} else {\n\t\tstruct inode *inode = page->mapping->host;\n\t\tkey = afs_request_key(AFS_FS_S(inode->i_sb)->volume->cell);\n\t\tif (IS_ERR(key)) {\n\t\t\tret = PTR_ERR(key);\n\t\t} else {\n\t\t\tret = afs_page_filler(key, page);\n\t\t\tkey_put(key);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_page_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "127-211",
    "snippet": "int afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageFsCache(page)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_uncache_page",
          "args": [
            "vnode->cache",
            "page"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_uncache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "1058-1102",
          "snippet": "void __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nvoid __fscache_uncache_page(struct fscache_cookie *cookie, struct page *page)\n{\n\tstruct fscache_object *object;\n\n\t_enter(\",%p\", page);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tfscache_stat(&fscache_n_uncaches);\n\n\t/* cache withdrawal may beat us to it */\n\tif (!PageFsCache(page))\n\t\tgoto done;\n\n\t/* get the object */\n\tspin_lock(&cookie->lock);\n\n\tif (hlist_empty(&cookie->backing_objects)) {\n\t\tClearPageFsCache(page);\n\t\tgoto done_unlock;\n\t}\n\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\t/* there might now be stuff on disk we could read */\n\tclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\n\n\t/* only invoke the cache backend if we managed to mark the page\n\t * uncached here; this deals with synchronisation vs withdrawal */\n\tif (TestClearPageFsCache(page) &&\n\t    object->cache->ops->uncache_page) {\n\t\t/* the cache backend releases the cookie lock */\n\t\tfscache_stat(&fscache_n_cop_uncache_page);\n\t\tobject->cache->ops->uncache_page(object, page);\n\t\tfscache_stat_d(&fscache_n_cop_uncache_page);\n\t\tgoto done;\n\t}\n\ndone_unlock:\n\tspin_unlock(&cookie->lock);\ndone:\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_write_page",
          "args": [
            "vnode->cache",
            "page",
            "GFP_KERNEL"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "922-1052",
          "snippet": "int __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_write_page(struct fscache_cookie *cookie,\n\t\t\t struct page *page,\n\t\t\t gfp_t gfp)\n{\n\tstruct fscache_storage *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%x,\", cookie, (u32) page->flags);\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERT(PageFsCache(page));\n\n\tfscache_stat(&fscache_n_stores);\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\top = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\n\tif (!op)\n\t\tgoto nomem;\n\n\tfscache_operation_init(&op->op, fscache_write_op,\n\t\t\t       fscache_release_write_op);\n\top->op.flags = FSCACHE_OP_ASYNC |\n\t\t(1 << FSCACHE_OP_WAITING) |\n\t\t(1 << FSCACHE_OP_UNUSE_COOKIE);\n\n\tret = radix_tree_maybe_preload(gfp & ~__GFP_HIGHMEM);\n\tif (ret < 0)\n\t\tgoto nomem_free;\n\n\tret = -ENOBUFS;\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\tif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\n\t\tgoto nobufs;\n\n\t/* add the page to the pending-storage radix tree on the backing\n\t * object */\n\tspin_lock(&object->lock);\n\tspin_lock(&cookie->stores_lock);\n\n\t_debug(\"store limit %llx\", (unsigned long long) object->store_limit);\n\n\tret = radix_tree_insert(&cookie->stores, page->index, page);\n\tif (ret < 0) {\n\t\tif (ret == -EEXIST)\n\t\t\tgoto already_queued;\n\t\t_debug(\"insert failed %d\", ret);\n\t\tgoto nobufs_unlock_obj;\n\t}\n\n\tradix_tree_tag_set(&cookie->stores, page->index,\n\t\t\t   FSCACHE_COOKIE_PENDING_TAG);\n\tpage_cache_get(page);\n\n\t/* we only want one writer at a time, but we do need to queue new\n\t * writers after exclusive ops */\n\tif (test_and_set_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags))\n\t\tgoto already_pending;\n\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\n\top->op.debug_id\t= atomic_inc_return(&fscache_op_debug_id);\n\top->store_limit = object->store_limit;\n\n\t__fscache_use_cookie(cookie);\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto submit_failed;\n\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tfscache_stat(&fscache_n_store_ops);\n\tfscache_stat(&fscache_n_stores_ok);\n\n\t/* the work queue now carries its own ref on the object */\n\tfscache_put_operation(&op->op);\n\t_leave(\" = 0\");\n\treturn 0;\n\nalready_queued:\n\tfscache_stat(&fscache_n_stores_again);\nalready_pending:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tfscache_stat(&fscache_n_stores_ok);\n\t_leave(\" = 0\");\n\treturn 0;\n\nsubmit_failed:\n\tspin_lock(&cookie->stores_lock);\n\tradix_tree_delete(&cookie->stores, page->index);\n\tspin_unlock(&cookie->stores_lock);\n\twake_cookie = __fscache_unuse_cookie(cookie);\n\tpage_cache_release(page);\n\tret = -ENOBUFS;\n\tgoto nobufs;\n\nnobufs_unlock_obj:\n\tspin_unlock(&cookie->stores_lock);\n\tspin_unlock(&object->lock);\nnobufs:\n\tspin_unlock(&cookie->lock);\n\tradix_tree_preload_end();\n\tkfree(op);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tfscache_stat(&fscache_n_stores_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n\nnomem_free:\n\tkfree(op);\nnomem:\n\tfscache_stat(&fscache_n_stores_oom);\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageFsCache(page)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageFsCache",
          "args": [
            "page"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_fetch_data",
          "args": [
            "vnode",
            "key",
            "offset",
            "len",
            "page"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_fetch_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "395-445",
          "snippet": "int afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_fetch_data(struct afs_vnode *vnode, struct key *key,\n\t\t\t off_t offset, size_t length, struct page *page)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key));\n\n\t/* this op will fetch the status */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\t/* merge in AFS status fetches and clear outstanding callback on this\n\t * vnode */\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_fetch_data(server, key, vnode, offset, length,\n\t\t\t\t\tpage, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "i_size_read(inode) - offset",
            "PAGE_SIZE"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_read_or_alloc_page",
          "args": [
            "vnode->cache",
            "page",
            "afs_file_readpage_read_complete",
            "NULL",
            "GFP_KERNEL"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_read_or_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/page.c",
          "lines": "399-511",
          "snippet": "int __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fscache-cache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/buffer_head.h>\n#include <linux/fscache-cache.h>\n#include <linux/module.h>\n\nint __fscache_read_or_alloc_page(struct fscache_cookie *cookie,\n\t\t\t\t struct page *page,\n\t\t\t\t fscache_rw_complete_t end_io_func,\n\t\t\t\t void *context,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct fscache_retrieval *op;\n\tstruct fscache_object *object;\n\tbool wake_cookie = false;\n\tint ret;\n\n\t_enter(\"%p,%p,,,\", cookie, page);\n\n\tfscache_stat(&fscache_n_retrievals);\n\n\tif (hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs;\n\n\tif (test_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags)) {\n\t\t_leave(\" = -ENOBUFS [invalidating]\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tASSERTCMP(cookie->def->type, !=, FSCACHE_COOKIE_TYPE_INDEX);\n\tASSERTCMP(page, !=, NULL);\n\n\tif (fscache_wait_for_deferred_lookup(cookie) < 0)\n\t\treturn -ERESTARTSYS;\n\n\top = fscache_alloc_retrieval(cookie, page->mapping,\n\t\t\t\t     end_io_func, context);\n\tif (!op) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&op->n_pages, 1);\n\n\tspin_lock(&cookie->lock);\n\n\tif (!fscache_cookie_enabled(cookie) ||\n\t    hlist_empty(&cookie->backing_objects))\n\t\tgoto nobufs_unlock;\n\tobject = hlist_entry(cookie->backing_objects.first,\n\t\t\t     struct fscache_object, cookie_link);\n\n\tASSERT(test_bit(FSCACHE_OBJECT_IS_LOOKED_UP, &object->flags));\n\n\t__fscache_use_cookie(cookie);\n\tatomic_inc(&object->n_reads);\n\t__set_bit(FSCACHE_OP_DEC_READ_CNT, &op->op.flags);\n\n\tif (fscache_submit_op(object, &op->op) < 0)\n\t\tgoto nobufs_unlock_dec;\n\tspin_unlock(&cookie->lock);\n\n\tfscache_stat(&fscache_n_retrieval_ops);\n\n\t/* pin the netfs read context in case we need to do the actual netfs\n\t * read because we've encountered a cache read failure */\n\tfscache_get_context(object->cookie, op->context);\n\n\t/* we wait for the operation to become active, and then process it\n\t * *here*, in this thread, and not in the thread pool */\n\tret = fscache_wait_for_operation_activation(\n\t\tobject, &op->op,\n\t\t__fscache_stat(&fscache_n_retrieval_op_waits),\n\t\t__fscache_stat(&fscache_n_retrievals_object_dead),\n\t\tfscache_do_cancel_retrieval);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* ask the cache to honour the operation */\n\tif (test_bit(FSCACHE_COOKIE_NO_DATA_YET, &object->cookie->flags)) {\n\t\tfscache_stat(&fscache_n_cop_allocate_page);\n\t\tret = object->cache->ops->allocate_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_allocate_page);\n\t\tif (ret == 0)\n\t\t\tret = -ENODATA;\n\t} else {\n\t\tfscache_stat(&fscache_n_cop_read_or_alloc_page);\n\t\tret = object->cache->ops->read_or_alloc_page(op, page, gfp);\n\t\tfscache_stat_d(&fscache_n_cop_read_or_alloc_page);\n\t}\n\nerror:\n\tif (ret == -ENOMEM)\n\t\tfscache_stat(&fscache_n_retrievals_nomem);\n\telse if (ret == -ERESTARTSYS)\n\t\tfscache_stat(&fscache_n_retrievals_intr);\n\telse if (ret == -ENODATA)\n\t\tfscache_stat(&fscache_n_retrievals_nodata);\n\telse if (ret < 0)\n\t\tfscache_stat(&fscache_n_retrievals_nobufs);\n\telse\n\t\tfscache_stat(&fscache_n_retrievals_ok);\n\n\tfscache_put_retrieval(op);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnobufs_unlock_dec:\n\tatomic_dec(&object->n_reads);\n\twake_cookie = __fscache_unuse_cookie(cookie);\nnobufs_unlock:\n\tspin_unlock(&cookie->lock);\n\tif (wake_cookie)\n\t\t__fscache_wake_unused_cookie(cookie);\n\tkfree(op);\nnobufs:\n\tfscache_stat(&fscache_n_retrievals_nobufs);\n\t_leave(\" = -ENOBUFS\");\n\treturn -ENOBUFS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x},{%lu},{%lu}\"",
            "key_serial(key)",
            "inode->i_ino",
            "page->index"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nint afs_page_filler(void *data, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key = data;\n\tsize_t len;\n\toff_t offset;\n\tint ret;\n\n\t_enter(\"{%x},{%lu},{%lu}\", key_serial(key), inode->i_ino, page->index);\n\n\tBUG_ON(!PageLocked(page));\n\n\tret = -ESTALE;\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto error;\n\n\t/* is it cached? */\n#ifdef CONFIG_AFS_FSCACHE\n\tret = fscache_read_or_alloc_page(vnode->cache,\n\t\t\t\t\t page,\n\t\t\t\t\t afs_file_readpage_read_complete,\n\t\t\t\t\t NULL,\n\t\t\t\t\t GFP_KERNEL);\n#else\n\tret = -ENOBUFS;\n#endif\n\tswitch (ret) {\n\t\t/* read BIO submitted (page in cache) */\n\tcase 0:\n\t\tbreak;\n\n\t\t/* page not yet cached */\n\tcase -ENODATA:\n\t\t_debug(\"cache said ENODATA\");\n\t\tgoto go_on;\n\n\t\t/* page will not be cached */\n\tcase -ENOBUFS:\n\t\t_debug(\"cache said ENOBUFS\");\n\tdefault:\n\tgo_on:\n\t\toffset = page->index << PAGE_CACHE_SHIFT;\n\t\tlen = min_t(size_t, i_size_read(inode) - offset, PAGE_SIZE);\n\n\t\t/* read the contents of the file from the server into the\n\t\t * page */\n\t\tret = afs_vnode_fetch_data(vnode, key, offset, len, page);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\t_debug(\"got NOENT from server\"\n\t\t\t\t       \" - marking file deleted and stale\");\n\t\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\t\tret = -ESTALE;\n\t\t\t}\n\n#ifdef CONFIG_AFS_FSCACHE\n\t\t\tfscache_uncache_page(vnode->cache, page);\n#endif\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t\tgoto error;\n\t\t}\n\n\t\tSetPageUptodate(page);\n\n\t\t/* send the page to the cache */\n#ifdef CONFIG_AFS_FSCACHE\n\t\tif (PageFsCache(page) &&\n\t\t    fscache_write_page(vnode->cache, page, GFP_KERNEL) != 0) {\n\t\t\tfscache_uncache_page(vnode->cache, page);\n\t\t\tBUG_ON(PageFsCache(page));\n\t\t}\n#endif\n\t\tunlock_page(page);\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror:\n\tSetPageError(page);\n\tunlock_page(page);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_file_readpage_read_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "110-121",
    "snippet": "static void afs_file_readpage_read_complete(struct page *page,\n\t\t\t\t\t    void *data,\n\t\t\t\t\t    int error)\n{\n\t_enter(\"%p,%p,%d\", page, data, error);\n\n\t/* if the read completes with an error, we just unlock the page and let\n\t * the VM reissue the readpage */\n\tif (!error)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readpage(struct file *file, struct page *page);",
      "static int afs_launder_page(struct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p,%p,%d\"",
            "page",
            "data",
            "error"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readpage(struct file *file, struct page *page);\nstatic int afs_launder_page(struct page *page);\n\nstatic void afs_file_readpage_read_complete(struct page *page,\n\t\t\t\t\t    void *data,\n\t\t\t\t\t    int error)\n{\n\t_enter(\"%p,%p,%d\", page, data, error);\n\n\t/* if the read completes with an error, we just unlock the page and let\n\t * the VM reissue the readpage */\n\tif (!error)\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "afs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "95-104",
    "snippet": "int afs_release(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey_put(file->private_data);\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "file->private_data"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_release(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey_put(file->private_data);\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
    "lines": "67-90",
    "snippet": "int afs_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = key;\n\t_leave(\" = 0\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [val]\"",
            "ret"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_validate",
          "args": [
            "vnode",
            "key"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "afs_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "313-372",
          "snippet": "int afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "vnode->volume->cell"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},\"",
            "vnode->fid.vid",
            "vnode->fid.vnode"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = key;\n\t_leave(\" = 0\");\n\treturn 0;\n}"
  }
]