[
  {
    "function_name": "ffs2_thread_should_wake(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "837-883",
    "snippet": "nt jffs2_thread_should_wake(struct jffs2_sb_info *c)\n{\n\tint ret = 0;\n\tuint32_t dirty;\n\tint nr_very_dirty = 0;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list))\n\t\treturn 1;\n\n\tif (c->unchecked_size) {\n\t\tjffs2_dbg(1, \"jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\\n\",\n\t\t\t  c->unchecked_size, c->checked_ino);\n\t\treturn 1;\n\t}\n\n\t/* dirty_size contains blocks on erase_pending_list\n\t * those blocks are counted in c->nr_erasing_blocks.\n\t * If one block is actually erased, it is not longer counted as dirty_space\n\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t * with c->nr_erasing_blocks * c->sector_size again.\n\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t */\n\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\n\t\t\t(dirty > c->nospc_dirty_size))\n\t\tret = 1;\n\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_very_dirty++;\n\t\tif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\n\t\t\tret = 1;\n\t\t\t/* In debug mode, actually go through and count them all */\n\t\t\tD1(continue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",\n\t\t  __func__, c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t  c->dirty_size, nr_very_dirty, ret ? \"yes\" : \"no\");\n\n\treturn ret;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",",
            "_func__,",
            "->nr_free_blocks,",
            "->nr_erasing_blocks,",
            "->dirty_size,",
            "r_very_dirty,",
            "et ? \"yes\" : \"no\")"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "ontinue)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each_entry(",
          "args": [
            "eb,",
            "c->very_dirty_list,",
            "ist)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\\n\",",
            "->unchecked_size,",
            "->checked_ino)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erase_pending_list)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erase_complete_list)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_thread_should_wake(struct jffs2_sb_info *c)\n{\n\tint ret = 0;\n\tuint32_t dirty;\n\tint nr_very_dirty = 0;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list))\n\t\treturn 1;\n\n\tif (c->unchecked_size) {\n\t\tjffs2_dbg(1, \"jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\\n\",\n\t\t\t  c->unchecked_size, c->checked_ino);\n\t\treturn 1;\n\t}\n\n\t/* dirty_size contains blocks on erase_pending_list\n\t * those blocks are counted in c->nr_erasing_blocks.\n\t * If one block is actually erased, it is not longer counted as dirty_space\n\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t * with c->nr_erasing_blocks * c->sector_size again.\n\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t */\n\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\n\t\t\t(dirty > c->nospc_dirty_size))\n\t\tret = 1;\n\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_very_dirty++;\n\t\tif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\n\t\t\tret = 1;\n\t\t\t/* In debug mode, actually go through and count them all */\n\t\t\tD1(continue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",\n\t\t  __func__, c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t  c->dirty_size, nr_very_dirty, ret ? \"yes\" : \"no\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_mark_node_obsolete(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "579-835",
    "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->erase_free_sem)"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_del_ino_cache(",
          "args": [
            ",",
            "c)"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_del_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "457-485",
          "snippet": "oid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\n{\n\tstruct jffs2_inode_cache **prev;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tBUG_ON(old->xref);\n#endif\n\tdbg_inocache(\"del %p (ino #%u)\\n\", old, old->ino);\n\tspin_lock(&c->inocache_lock);\n\n\tprev = &c->inocache_list[old->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < old->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tif ((*prev) == old) {\n\t\t*prev = old->next;\n\t}\n\n\t/* Free it now unless it's in READING or CLEARING state, which\n\t   are the transitions upon read_inode() and clear_inode(). The\n\t   rest of the time we know nobody else is looking at it, and\n\t   if it's held by read_inode() or clear_inode() they'll free it\n\t   for themselves. */\n\tif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\n\t\tjffs2_free_inode_cache(old);\n\n\tspin_unlock(&c->inocache_lock);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\n{\n\tstruct jffs2_inode_cache **prev;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\tBUG_ON(old->xref);\n#endif\n\tdbg_inocache(\"del %p (ino #%u)\\n\", old, old->ino);\n\tspin_lock(&c->inocache_lock);\n\n\tprev = &c->inocache_list[old->ino % c->inocache_hashsize];\n\n\twhile ((*prev) && (*prev)->ino < old->ino) {\n\t\tprev = &(*prev)->next;\n\t}\n\tif ((*prev) == old) {\n\t\t*prev = old->next;\n\t}\n\n\t/* Free it now unless it's in READING or CLEARING state, which\n\t   are the transitions upon read_inode() and clear_inode(). The\n\t   rest of the time we know nobody else is looking at it, and\n\t   if it's held by read_inode() or clear_inode() they'll free it\n\t   for themselves. */\n\tif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\n\t\tjffs2_free_inode_cache(old);\n\n\tspin_unlock(&c->inocache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_release_xattr_ref(",
          "args": [
            ",",
            "struct jffs2_xattr_ref *)ic)"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_release_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1326-1341",
          "snippet": "oid jffs2_release_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tstruct jffs2_xattr_ref *tmp, **ptmp;\n\n\tif (ref->node != (void *)ref)\n\t\treturn;\n\n\tfor (tmp=c->xref_dead_list, ptmp=&c->xref_dead_list; tmp; ptmp=&tmp->next, tmp=tmp->next) {\n\t\tif (ref == tmp) {\n\t\t\t*ptmp = tmp->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tjffs2_free_xattr_ref(ref);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_release_xattr_ref(struct jffs2_sb_info *c, struct jffs2_xattr_ref *ref)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tstruct jffs2_xattr_ref *tmp, **ptmp;\n\n\tif (ref->node != (void *)ref)\n\t\treturn;\n\n\tfor (tmp=c->xref_dead_list, ptmp=&c->xref_dead_list; tmp; ptmp=&tmp->next, tmp=tmp->next) {\n\t\tif (ref == tmp) {\n\t\t\t*ptmp = tmp->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tjffs2_free_xattr_ref(ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_release_xattr_datum(",
          "args": [
            ",",
            "struct jffs2_xattr_datum *)ic)"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_release_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "1316-1324",
          "snippet": "oid jffs2_release_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tif (atomic_read(&xd->refcnt) || xd->node != (void *)xd)\n\t\treturn;\n\n\tlist_del(&xd->xindex);\n\tjffs2_free_xattr_datum(xd);\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_release_xattr_datum(struct jffs2_sb_info *c, struct jffs2_xattr_datum *xd)\n{\n\t/* must be called under spin_lock(&c->erase_completion_lock) */\n\tif (atomic_read(&xd->refcnt) || xd->node != (void *)xd)\n\t\treturn;\n\n\tlist_del(&xd->xindex);\n\tjffs2_free_xattr_datum(xd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_raw_ref_to_ic(",
          "args": [
            "ef)"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_raw_ref_to_ic(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "119-127",
          "snippet": "tatic inline struct jffs2_inode_cache *jffs2_raw_ref_to_ic(struct jffs2_raw_node_ref *raw)\n{\n\twhile(raw->next_in_ino)\n\t\traw = raw->next_in_ino;\n\n\t/* NB. This can be a jffs2_xattr_datum or jffs2_xattr_ref and\n\t   not actually a jffs2_inode_cache. Check ->class */\n\treturn ((struct jffs2_inode_cache *)raw);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_inode_cache *jffs2_raw_ref_to_ic(struct jffs2_raw_node_ref *raw)\n{\n\twhile(raw->next_in_ino)\n\t\traw = raw->next_in_ino;\n\n\t/* NB. This can be a jffs2_xattr_datum or jffs2_xattr_ref and\n\t   not actually a jffs2_inode_cache. Check ->class */\n\treturn ((struct jffs2_inode_cache *)raw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",",
            "ef_offset(ref),",
            "etlen)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Write error in obliterating obsoleted node at 0x%08x: %d\\n\",",
            "ef_offset(ref),",
            "et)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_write(",
          "args": [
            ",",
            "ef_offset(ref),",
            "izeof(n),",
            "retlen,",
            "char *)&n)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "e16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            ".nodetype)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",",
            "ef_offset(ref),",
            "e16_to_cpu(n.nodetype))"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            ".nodetype)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            ".nodetype)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",",
            "e32_to_cpu(n.totlen),",
            "reed_len)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            ".totlen)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "reed_len)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(n.totlen))"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            ".totlen)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Short read from obsoleted node at 0x%08x: %zd\\n\",",
            "ef_offset(ref),",
            "etlen)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Read error reading from obsoleted node at 0x%08x: %d\\n\",",
            "ef_offset(ref),",
            "et)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "ef_offset(ref),",
            "izeof(n),",
            "retlen,",
            "char *)&n)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "obliterating obsoleted node at 0x%08x\\n\",",
            "ef_offset(ref))"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_is_readonly(",
          "args": [
            ")"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_can_mark_obsolete(",
          "args": [
            ")"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->used_size)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->very_dirty_list)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "...and adding to very_dirty_list\\n\")"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "jeb->list)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",",
            "eb->offset)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERYDIRTY(",
          "args": [
            ",",
            "eb->dirty_size - addedsize)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERYDIRTY(",
          "args": [
            ",",
            "eb->dirty_size)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->dirty_list)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "...and adding to dirty_list\\n\")"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "jeb->list)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",",
            "eb->offset)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDIRTY(",
          "args": [
            "eb->dirty_size - addedsize)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDIRTY(",
          "args": [
            "eb->dirty_size)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Not moving gcblock 0x%08x to dirty_list\\n\",",
            "eb->offset)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Done OK\\n\")"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->erasable_list)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "...and adding to erasable_list\\n\")"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_garbage_collect_trigger(",
          "args": [
            ")"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->erase_pending_list)"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "...and adding to erase_pending_list\\n\")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->erasable_pending_wbuf_list)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "...and adding to erasable_pending_wbuf_list\\n\")"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_wbuf_dirty(",
          "args": [
            ")"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "jeb->list)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",",
            "eb->offset)"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",",
            "eb->offset)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",",
            "eb->offset)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "309-384",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_sanity_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_sanity_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "27-49",
          "snippet": "id\n__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_eraseblock *jeb)\n{\n\tif (unlikely(jeb && jeb->used_size + jeb->dirty_size +\n\t\t\tjeb->free_size + jeb->wasted_size +\n\t\t\tjeb->unchecked_size != c->sector_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting for block at 0x%08x is screwed.\\n\", jeb->offset);\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tjeb->free_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->wasted_size, jeb->unchecked_size, c->sector_size);\n\t\tBUG();\n\t}\n\n\tif (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size\n\t\t\t\t+ c->wasted_size + c->unchecked_size != c->flash_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting superblock info is screwed.\\n\");\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tc->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,\n\t\t\tc->wasted_size, c->unchecked_size, c->flash_size);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_eraseblock *jeb)\n{\n\tif (unlikely(jeb && jeb->used_size + jeb->dirty_size +\n\t\t\tjeb->free_size + jeb->wasted_size +\n\t\t\tjeb->unchecked_size != c->sector_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting for block at 0x%08x is screwed.\\n\", jeb->offset);\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tjeb->free_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->wasted_size, jeb->unchecked_size, c->sector_size);\n\t\tBUG();\n\t}\n\n\tif (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size\n\t\t\t\t+ c->wasted_size + c->unchecked_size != c->flash_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting superblock info is screwed.\\n\");\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tc->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,\n\t\t\tc->wasted_size, c->unchecked_size, c->flash_size);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Wasting\\n\")"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Converting %d bytes of wasted space to dirty in block at %08x\\n\",",
            "eb->wasted_size,",
            "eb->offset)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Leaving block at %08x on the bad_used_list\\n\",",
            "eb->offset)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_list(",
          "args": [
            "jeb->list,",
            "c->bad_used_list)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "n_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "565-577",
          "snippet": "tatic inline int on_list(struct list_head *obj, struct list_head *head)\n{\n\tstruct list_head *this;\n\n\tlist_for_each(this, head) {\n\t\tif (this == obj) {\n\t\t\tjffs2_dbg(1, \"%p is on list at %p\\n\", obj, head);\n\t\t\treturn 1;\n\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int on_list(struct list_head *obj, struct list_head *head)\n{\n\tstruct list_head *this;\n\n\tlist_for_each(this, head) {\n\t\tif (this == obj) {\n\t\t\tjffs2_dbg(1, \"%p is on list at %p\\n\", obj, head);\n\t\t\treturn 1;\n\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Dirtying\\n\")"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDIRTY(",
          "args": [
            "eb->wasted_size + freed_len)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Obsoleting node at 0x%08x of len %#x: \",",
            "ef_offset(ref),",
            "reed_len)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "f (unlikely(jeb->used_size < freed_len)) \n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",",
            "reed_len,",
            "locknr,",
            "ef->flash_offset,",
            "eb->used_size)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "nlikely(jeb->used_size < freed_len))"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_thread_should_wake(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "837-883",
          "snippet": "nt jffs2_thread_should_wake(struct jffs2_sb_info *c)\n{\n\tint ret = 0;\n\tuint32_t dirty;\n\tint nr_very_dirty = 0;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list))\n\t\treturn 1;\n\n\tif (c->unchecked_size) {\n\t\tjffs2_dbg(1, \"jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\\n\",\n\t\t\t  c->unchecked_size, c->checked_ino);\n\t\treturn 1;\n\t}\n\n\t/* dirty_size contains blocks on erase_pending_list\n\t * those blocks are counted in c->nr_erasing_blocks.\n\t * If one block is actually erased, it is not longer counted as dirty_space\n\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t * with c->nr_erasing_blocks * c->sector_size again.\n\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t */\n\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\n\t\t\t(dirty > c->nospc_dirty_size))\n\t\tret = 1;\n\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_very_dirty++;\n\t\tif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\n\t\t\tret = 1;\n\t\t\t/* In debug mode, actually go through and count them all */\n\t\t\tD1(continue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",\n\t\t  __func__, c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t  c->dirty_size, nr_very_dirty, ret ? \"yes\" : \"no\");\n\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_thread_should_wake(struct jffs2_sb_info *c)\n{\n\tint ret = 0;\n\tuint32_t dirty;\n\tint nr_very_dirty = 0;\n\tstruct jffs2_eraseblock *jeb;\n\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list))\n\t\treturn 1;\n\n\tif (c->unchecked_size) {\n\t\tjffs2_dbg(1, \"jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\\n\",\n\t\t\t  c->unchecked_size, c->checked_ino);\n\t\treturn 1;\n\t}\n\n\t/* dirty_size contains blocks on erase_pending_list\n\t * those blocks are counted in c->nr_erasing_blocks.\n\t * If one block is actually erased, it is not longer counted as dirty_space\n\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t * with c->nr_erasing_blocks * c->sector_size again.\n\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t */\n\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\n\t\t\t(dirty > c->nospc_dirty_size))\n\t\tret = 1;\n\n\tlist_for_each_entry(jeb, &c->very_dirty_list, list) {\n\t\tnr_very_dirty++;\n\t\tif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\n\t\t\tret = 1;\n\t\t\t/* In debug mode, actually go through and count them all */\n\t\t\tD1(continue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\\n\",\n\t\t  __func__, c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t  c->dirty_size, nr_very_dirty, ret ? \"yes\" : \"no\");\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "eb->used_size < freed_len)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Obsoleting previously unchecked node at 0x%08x of len %x\\n\",",
            "ef_offset(ref),",
            "reed_len)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "f (unlikely(jeb->unchecked_size < freed_len)) \n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",",
            "reed_len,",
            "locknr,",
            "ef->flash_offset,",
            "eb->used_size)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "eb->unchecked_size < freed_len)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_flags(",
          "args": [
            "ef)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_totlen(",
          "args": [
            ",",
            "eb,",
            "ef)"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "_jffs2_ref_totlen(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "718-755",
          "snippet": "int32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t    struct jffs2_raw_node_ref *ref)\n{\n\tuint32_t ret;\n\n\tret = __ref_totlen(c, jeb, ref);\n\n#ifdef TEST_TOTLEN\n\tif (unlikely(ret != ref->__totlen)) {\n\t\tif (!jeb)\n\t\t\tjeb = &c->blocks[ref->flash_offset / c->sector_size];\n\n\t\tpr_crit(\"Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\\n\",\n\t\t\tref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\n\t\t\tret, ref->__totlen);\n\t\tif (ref_next(ref)) {\n\t\t\tpr_crit(\"next %p (0x%08x-0x%08x)\\n\",\n\t\t\t\tref_next(ref), ref_offset(ref_next(ref)),\n\t\t\t\tref_offset(ref_next(ref)) + ref->__totlen);\n\t\t} else \n\t\t\tpr_crit(\"No next ref. jeb->last_node is %p\\n\",\n\t\t\t\tjeb->last_node);\n\n\t\tpr_crit(\"jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\\n\",\n\t\t\tjeb->wasted_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->free_size);\n\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\n\t\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n#endif\n\n\t\tWARN_ON(1);\n\n\t\tret = ref->__totlen;\n\t}\n#endif /* TEST_TOTLEN */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "c->erase_free_sem)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_is_readonly(",
          "args": [
            ")"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_can_mark_obsolete(",
          "args": [
            ")"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "raw node at 0x%08x is off the end of device!\\n\",",
            "ef->flash_offset)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): called with already obsolete node at 0x%08x\\n\",",
            "_func__,",
            "ef_offset(ref))"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "ef)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_obsolete(",
          "args": [
            "ef)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\")"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "ref)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
  },
  {
    "function_name": "n_list(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "565-577",
    "snippet": "tatic inline int on_list(struct list_head *obj, struct list_head *head)\n{\n\tstruct list_head *this;\n\n\tlist_for_each(this, head) {\n\t\tif (this == obj) {\n\t\t\tjffs2_dbg(1, \"%p is on list at %p\\n\", obj, head);\n\t\t\treturn 1;\n\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%p is on list at %p\\n\",",
            "bj,",
            "ead)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each(",
          "args": [
            "his,",
            "ead)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int on_list(struct list_head *obj, struct list_head *head)\n{\n\tstruct list_head *this;\n\n\tlist_for_each(this, head) {\n\t\tif (this == obj) {\n\t\t\tjffs2_dbg(1, \"%p is on list at %p\\n\", obj, head);\n\t\t\treturn 1;\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_complete_reservation(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "556-563",
    "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_garbage_collect_trigger(",
          "args": [
            ")"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_complete_reservation()\\n\")"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
  },
  {
    "function_name": "ffs2_add_physical_node_ref(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "500-553",
    "snippet": "truct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "309-384",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_sanity_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_sanity_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "27-49",
          "snippet": "id\n__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_eraseblock *jeb)\n{\n\tif (unlikely(jeb && jeb->used_size + jeb->dirty_size +\n\t\t\tjeb->free_size + jeb->wasted_size +\n\t\t\tjeb->unchecked_size != c->sector_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting for block at 0x%08x is screwed.\\n\", jeb->offset);\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tjeb->free_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->wasted_size, jeb->unchecked_size, c->sector_size);\n\t\tBUG();\n\t}\n\n\tif (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size\n\t\t\t\t+ c->wasted_size + c->unchecked_size != c->flash_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting superblock info is screwed.\\n\");\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tc->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,\n\t\t\tc->wasted_size, c->unchecked_size, c->flash_size);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_sanity_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t     struct jffs2_eraseblock *jeb)\n{\n\tif (unlikely(jeb && jeb->used_size + jeb->dirty_size +\n\t\t\tjeb->free_size + jeb->wasted_size +\n\t\t\tjeb->unchecked_size != c->sector_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting for block at 0x%08x is screwed.\\n\", jeb->offset);\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tjeb->free_size, jeb->dirty_size, jeb->used_size,\n\t\t\tjeb->wasted_size, jeb->unchecked_size, c->sector_size);\n\t\tBUG();\n\t}\n\n\tif (unlikely(c->used_size + c->dirty_size + c->free_size + c->erasing_size + c->bad_size\n\t\t\t\t+ c->wasted_size + c->unchecked_size != c->flash_size)) {\n\t\tJFFS2_ERROR(\"eeep, space accounting superblock info is screwed.\\n\");\n\t\tJFFS2_ERROR(\"free %#08x + dirty %#08x + used %#08x + erasing %#08x + bad %#08x + wasted %#08x + unchecked %#08x != total %#08x.\\n\",\n\t\t\tc->free_size, c->dirty_size, c->used_size, c->erasing_size, c->bad_size,\n\t\t\tc->wasted_size, c->unchecked_size, c->flash_size);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->clean_list)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flush_wbuf_pad(",
          "args": [
            ")"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_wbuf_dirty(",
          "args": [
            ")"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->used_size)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDIRTY(",
          "args": [
            "eb->wasted_size)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs,",
            "en,",
            "c)"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EINVAL)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_cont(",
          "args": [
            ", expected at %08x\\n\",",
            "eb->offset + (c->sector_size - jeb->free_size))"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "No nextblock\")"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "nextblock 0x%08x\",",
            "->nextblock->offset)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "argh. node added in wrong place at 0x%08x(%d)\\n\",",
            "fs & ~3,",
            "fs & 3)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Node at 0x%x(%d), size 0x%x\\n\",",
            "_func__,",
            "fs & ~3,",
            "fs & 3,",
            "en)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}"
  },
  {
    "function_name": "ffs2_do_reserve_space(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "354-486",
    "snippet": "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Giving 0x%x bytes at 0x%x\\n\",",
            "_func__,",
            "len,",
            "eb->offset + (c->sector_size - jeb->free_size))"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "eb->first_node)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",",
            "eb->offset,",
            "eb->free_size)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_find_nextblock(",
          "args": [
            ")"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_find_nextblock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "280-351",
          "snippet": "tatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\n{\n\tstruct list_head *next;\n\n\t/* Take the next block off the 'free' list */\n\n\tif (list_empty(&c->free_list)) {\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_list)) {\n\t\t\tstruct jffs2_eraseblock *ejeb;\n\n\t\t\tejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move_tail(&ejeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\tjffs2_dbg(1, \"%s(): Triggering erase of erasable block at 0x%08x\\n\",\n\t\t\t\t  __func__, ejeb->offset);\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t  __func__);\n\t\t\t/* c->nextblock is NULL, no update to c->nextblock allowed */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t/* Have another go. It'll be on the erasable_list now */\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks) {\n\t\t\t/* Ouch. We're in GC, or we wouldn't have got here.\n\t\t\t   And there's no space left. At all. */\n\t\t\tpr_crit(\"Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",\n\t\t\t\tc->nr_erasing_blocks, c->nr_free_blocks,\n\t\t\t\tlist_empty(&c->erasable_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erasing_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erase_pending_list) ? \"yes\" : \"no\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* Don't wait for it; just erase one right now */\n\t\tjffs2_erase_pending_blocks(c, 1);\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t/* An erase may have failed, decreasing the\n\t\t   amount of free space available. So we must\n\t\t   restart from the beginning */\n\t\treturn -EAGAIN;\n\t}\n\n\tnext = c->free_list.next;\n\tlist_del(next);\n\tc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\n\tc->nr_free_blocks--;\n\n\tjffs2_sum_reset_collected(c->summary); /* reset collected summary */\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\n\t\tc->wbuf_ofs = 0xffffffff;\n#endif\n\n\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t  __func__, c->nextblock->offset);\n\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\n{\n\tstruct list_head *next;\n\n\t/* Take the next block off the 'free' list */\n\n\tif (list_empty(&c->free_list)) {\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_list)) {\n\t\t\tstruct jffs2_eraseblock *ejeb;\n\n\t\t\tejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move_tail(&ejeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\tjffs2_dbg(1, \"%s(): Triggering erase of erasable block at 0x%08x\\n\",\n\t\t\t\t  __func__, ejeb->offset);\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t  __func__);\n\t\t\t/* c->nextblock is NULL, no update to c->nextblock allowed */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t/* Have another go. It'll be on the erasable_list now */\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks) {\n\t\t\t/* Ouch. We're in GC, or we wouldn't have got here.\n\t\t\t   And there's no space left. At all. */\n\t\t\tpr_crit(\"Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",\n\t\t\t\tc->nr_erasing_blocks, c->nr_free_blocks,\n\t\t\t\tlist_empty(&c->erasable_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erasing_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erase_pending_list) ? \"yes\" : \"no\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* Don't wait for it; just erase one right now */\n\t\tjffs2_erase_pending_blocks(c, 1);\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t/* An erase may have failed, decreasing the\n\t\t   amount of free space available. So we must\n\t\t   restart from the beginning */\n\t\treturn -EAGAIN;\n\t}\n\n\tnext = c->free_list.next;\n\tlist_del(next);\n\tc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\n\tc->nr_free_blocks--;\n\n\tjffs2_sum_reset_collected(c->summary); /* reset collected summary */\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\n\t\tc->wbuf_ofs = 0xffffffff;\n#endif\n\n\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t  __func__, c->nextblock->offset);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_close_nextblock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_close_nextblock(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "243-276",
          "snippet": "tatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\n\tif (c->nextblock == NULL) {\n\t\tjffs2_dbg(1, \"%s(): Erase block at 0x%08x has already been placed in a list\\n\",\n\t\t\t  __func__, jeb->offset);\n\t\treturn;\n\t}\n\t/* Check, if we have a dirty block now, or if it was dirty already */\n\tif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t}\n\tc->nextblock = NULL;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\n\tif (c->nextblock == NULL) {\n\t\tjffs2_dbg(1, \"%s(): Erase block at 0x%08x has already been placed in a list\\n\",\n\t\t\t  __func__, jeb->offset);\n\t\treturn;\n\t}\n\t/* Check, if we have a dirty block now, or if it was dirty already */\n\tif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t}\n\tc->nextblock = NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "jeb->offset + c->sector_size - waste) | REF_OBSOLETE,",
            "aste,",
            "ULL)"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "eb,",
            ")"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flush_wbuf_pad(",
          "args": [
            ")"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Flushing write buffer\\n\",",
            "_func__)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_wbuf_dirty(",
          "args": [
            ")"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "umsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_is_disabled(",
          "args": [
            "->summary)"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_is_disabled(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "224-227",
          "snippet": "nt jffs2_sum_is_disabled(struct jffs2_summary *s)\n{\n\treturn (s->sum_size == JFFS2_SUMMARY_NOSUM_SIZE);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_is_disabled(struct jffs2_summary *s)\n{\n\treturn (s->sum_size == JFFS2_SUMMARY_NOSUM_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_write_sumnode(",
          "args": [
            ")"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_write_sumnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "846-874",
          "snippet": "nt jffs2_sum_write_sumnode(struct jffs2_sb_info *c)\n\t__must_hold(&c->erase_completion_block)\n{\n\tint datasize, infosize, padsize;\n\tstruct jffs2_eraseblock *jeb;\n\tint ret = 0;\n\n\tdbg_summary(\"called\\n\");\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjeb = c->nextblock;\n\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\tif (!c->summary->sum_num || !c->summary->sum_list_head) {\n\t\tJFFS2_WARNING(\"Empty summary info!!!\\n\");\n\t\tBUG();\n\t}\n\n\tdatasize = c->summary->sum_size + sizeof(struct jffs2_sum_marker);\n\tinfosize = sizeof(struct jffs2_raw_summary) + datasize;\n\tpadsize = jeb->free_size - infosize;\n\tinfosize += padsize;\n\tdatasize += padsize;\n\n\tret = jffs2_sum_write_data(c, jeb, infosize, datasize, padsize);\n\tspin_lock(&c->erase_completion_lock);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_write_sumnode(struct jffs2_sb_info *c)\n\t__must_hold(&c->erase_completion_block)\n{\n\tint datasize, infosize, padsize;\n\tstruct jffs2_eraseblock *jeb;\n\tint ret = 0;\n\n\tdbg_summary(\"called\\n\");\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjeb = c->nextblock;\n\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\tif (!c->summary->sum_num || !c->summary->sum_list_head) {\n\t\tJFFS2_WARNING(\"Empty summary info!!!\\n\");\n\t\tBUG();\n\t}\n\n\tdatasize = c->summary->sum_size + sizeof(struct jffs2_sum_marker);\n\tinfosize = sizeof(struct jffs2_raw_summary) + datasize;\n\tpadsize = jeb->free_size - infosize;\n\tinfosize += padsize;\n\tdatasize += padsize;\n\n\tret = jffs2_sum_write_data(c, jeb, infosize, datasize, padsize);\n\tspin_lock(&c->erase_completion_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_summary(",
          "args": [
            "generating summary for 0x%08x.\\n\",",
            "eb->offset)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "insize)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bg_summary(",
          "args": [
            "minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",",
            "insize,",
            "eb->free_size,",
            "->summary->sum_size,",
            "umsize)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "umsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_find_nextblock(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "280-351",
    "snippet": "tatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\n{\n\tstruct list_head *next;\n\n\t/* Take the next block off the 'free' list */\n\n\tif (list_empty(&c->free_list)) {\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_list)) {\n\t\t\tstruct jffs2_eraseblock *ejeb;\n\n\t\t\tejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move_tail(&ejeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\tjffs2_dbg(1, \"%s(): Triggering erase of erasable block at 0x%08x\\n\",\n\t\t\t\t  __func__, ejeb->offset);\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t  __func__);\n\t\t\t/* c->nextblock is NULL, no update to c->nextblock allowed */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t/* Have another go. It'll be on the erasable_list now */\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks) {\n\t\t\t/* Ouch. We're in GC, or we wouldn't have got here.\n\t\t\t   And there's no space left. At all. */\n\t\t\tpr_crit(\"Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",\n\t\t\t\tc->nr_erasing_blocks, c->nr_free_blocks,\n\t\t\t\tlist_empty(&c->erasable_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erasing_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erase_pending_list) ? \"yes\" : \"no\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* Don't wait for it; just erase one right now */\n\t\tjffs2_erase_pending_blocks(c, 1);\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t/* An erase may have failed, decreasing the\n\t\t   amount of free space available. So we must\n\t\t   restart from the beginning */\n\t\treturn -EAGAIN;\n\t}\n\n\tnext = c->free_list.next;\n\tlist_del(next);\n\tc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\n\tc->nr_free_blocks--;\n\n\tjffs2_sum_reset_collected(c->summary); /* reset collected summary */\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\n\t\tc->wbuf_ofs = 0xffffffff;\n#endif\n\n\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t  __func__, c->nextblock->offset);\n\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): new nextblock = 0x%08x\\n\",",
            "_func__,",
            "->nextblock->offset)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_reset_collected(",
          "args": [
            "->summary)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_reset_collected(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "210-215",
          "snippet": "oid jffs2_sum_reset_collected(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_sum_reset_collected(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_entry(",
          "args": [
            "ext,",
            "truct ffs2_eraseblock,",
            "ist)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "ext)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_erase_pending_blocks(",
          "args": [
            ",",
            ")"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",",
            "->nr_erasing_blocks,",
            "->nr_free_blocks,",
            "ist_empty(&c->erasable_list) ? \"yes\" : \"no\",",
            "ist_empty(&c->erasing_list) ? \"yes\" : \"no\",",
            "ist_empty(&c->erase_pending_list) ? \"yes\" : \"no\")"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erase_pending_list)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erasing_list)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erasable_list)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flush_wbuf_pad(",
          "args": [
            ")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Flushing write buffer\\n\",",
            "_func__)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erasable_pending_wbuf_list)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Triggering erase of erasable block at 0x%08x\\n\",",
            "_func__,",
            "jeb->offset)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_garbage_collect_trigger(",
          "args": [
            ")"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_move_tail(",
          "args": [
            "ejeb->list,",
            "c->erase_pending_list)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_entry(",
          "args": [
            "->erasable_list.next,",
            "truct ffs2_eraseblock,",
            "ist)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erasable_list)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->free_list)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\n{\n\tstruct list_head *next;\n\n\t/* Take the next block off the 'free' list */\n\n\tif (list_empty(&c->free_list)) {\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_list)) {\n\t\t\tstruct jffs2_eraseblock *ejeb;\n\n\t\t\tejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move_tail(&ejeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\tjffs2_dbg(1, \"%s(): Triggering erase of erasable block at 0x%08x\\n\",\n\t\t\t\t  __func__, ejeb->offset);\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks &&\n\t\t\t!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t  __func__);\n\t\t\t/* c->nextblock is NULL, no update to c->nextblock allowed */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t/* Have another go. It'll be on the erasable_list now */\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!c->nr_erasing_blocks) {\n\t\t\t/* Ouch. We're in GC, or we wouldn't have got here.\n\t\t\t   And there's no space left. At all. */\n\t\t\tpr_crit(\"Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\\n\",\n\t\t\t\tc->nr_erasing_blocks, c->nr_free_blocks,\n\t\t\t\tlist_empty(&c->erasable_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erasing_list) ? \"yes\" : \"no\",\n\t\t\t\tlist_empty(&c->erase_pending_list) ? \"yes\" : \"no\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* Don't wait for it; just erase one right now */\n\t\tjffs2_erase_pending_blocks(c, 1);\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t/* An erase may have failed, decreasing the\n\t\t   amount of free space available. So we must\n\t\t   restart from the beginning */\n\t\treturn -EAGAIN;\n\t}\n\n\tnext = c->free_list.next;\n\tlist_del(next);\n\tc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\n\tc->nr_free_blocks--;\n\n\tjffs2_sum_reset_collected(c->summary); /* reset collected summary */\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t/* adjust write buffer offset, else we get a non contiguous write bug */\n\tif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\n\t\tc->wbuf_ofs = 0xffffffff;\n#endif\n\n\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t  __func__, c->nextblock->offset);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_close_nextblock(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "243-276",
    "snippet": "tatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\n\tif (c->nextblock == NULL) {\n\t\tjffs2_dbg(1, \"%s(): Erase block at 0x%08x has already been placed in a list\\n\",\n\t\t\t  __func__, jeb->offset);\n\t\treturn;\n\t}\n\t/* Check, if we have a dirty block now, or if it was dirty already */\n\tif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t}\n\tc->nextblock = NULL;\n\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->clean_list)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->used_size)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->dirty_list)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->used_size)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add_tail(",
          "args": [
            "jeb->list,",
            "c->very_dirty_list)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->used_size)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERYDIRTY(",
          "args": [
            ",",
            "eb->dirty_size)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SDIRTY",
          "args": [
            "eb->wasted_size + jeb->dirty_size)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Erase block at 0x%08x has already been placed in a list\\n\",",
            "_func__,",
            "eb->offset)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\n\tif (c->nextblock == NULL) {\n\t\tjffs2_dbg(1, \"%s(): Erase block at 0x%08x has already been placed in a list\\n\",\n\t\t\t  __func__, jeb->offset);\n\t\treturn;\n\t}\n\t/* Check, if we have a dirty block now, or if it was dirty already */\n\tif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t\t  jeb->used_size);\n\t\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t}\n\tc->nextblock = NULL;\n\n}"
  },
  {
    "function_name": "ffs2_reserve_space_gc(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "212-238",
    "snippet": "nt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "->nextblock,",
            ")"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ond_resched(",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): looping, ret is %d\\n\",",
            "_func__,",
            "et)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_do_reserve_space(",
          "args": [
            ",",
            "insize,",
            "en,",
            "umsize)"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_do_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "354-486",
          "snippet": "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Requested 0x%x bytes\\n\",",
            "_func__,",
            "insize)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "insize)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_reserve_space(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "74-210",
    "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "->nextblock,",
            ")"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): ret is %d\\n\",",
            "_func__,",
            "et)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_do_reserve_space(",
          "args": [
            ",",
            "insize,",
            "en,",
            "umsize)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_do_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "354-486",
          "snippet": "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize)\n{\n\tstruct jffs2_eraseblock *jeb = c->nextblock;\n\tuint32_t reserved_size;\t\t\t\t/* for summary information at the end of the jeb */\n\tint ret;\n\n restart:\n\treserved_size = 0;\n\n\tif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\n\t\t\t\t\t\t\t/* NOSUM_SIZE means not to generate summary */\n\n\t\tif (jeb) {\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t\tdbg_summary(\"minsize=%d , jeb->free=%d ,\"\n\t\t\t\t\t\t\"summary->size=%d , sumsize=%d\\n\",\n\t\t\t\t\t\tminsize, jeb->free_size,\n\t\t\t\t\t\tc->summary->sum_size, sumsize);\n\t\t}\n\n\t\t/* Is there enough space for writing out the current node, or we have to\n\t\t   write out summary information now, close this jeb and select new nextblock? */\n\t\tif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\n\t\t\t\t\tJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\n\n\t\t\t/* Has summary been disabled for this jeb? */\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t/* Writing out the collected summary information */\n\t\t\tdbg_summary(\"generating summary for 0x%08x.\\n\", jeb->offset);\n\t\t\tret = jffs2_sum_write_sumnode(c);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (jffs2_sum_is_disabled(c->summary)) {\n\t\t\t\t/* jffs2_write_sumnode() couldn't write out the summary information\n\t\t\t\t   diabling summary for this jeb and free the collected information\n\t\t\t\t */\n\t\t\t\tsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t\t/* keep always valid value in reserved_size */\n\t\t\treserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\n\t\t}\n\t} else {\n\t\tif (jeb && minsize > jeb->free_size) {\n\t\t\tuint32_t waste;\n\n\t\t\t/* Skip the end of this block and file it as having some dirty space */\n\t\t\t/* If there's a pending write to it, flush now */\n\n\t\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tjffs2_dbg(1, \"%s(): Flushing write buffer\\n\",\n\t\t\t\t\t  __func__);\n\t\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tjeb = c->nextblock;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\t\t/* Just lock it again and continue. Nothing much can change because\n\t\t\t   we hold c->alloc_sem anyway. In fact, it's not entirely clear why\n\t\t\t   we hold c->erase_completion_lock in the majority of this function...\n\t\t\t   but that's a question for another (more caffeine-rich) day. */\n\t\t\tspin_lock(&c->erase_completion_lock);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\twaste = jeb->free_size;\n\t\t\tjffs2_link_node_ref(c, jeb,\n\t\t\t\t\t    (jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\n\t\t\t\t\t    waste, NULL);\n\t\t\t/* FIXME: that made it count as dirty. Convert to wasted */\n\t\t\tjeb->dirty_size -= waste;\n\t\t\tc->dirty_size -= waste;\n\t\t\tjeb->wasted_size += waste;\n\t\t\tc->wasted_size += waste;\n\n\t\t\tjffs2_close_nextblock(c, jeb);\n\t\t\tjeb = NULL;\n\t\t}\n\t}\n\n\tif (!jeb) {\n\n\t\tret = jffs2_find_nextblock(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tjeb = c->nextblock;\n\n\t\tif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\n\t\t\tpr_warn(\"Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\\n\",\n\t\t\t\tjeb->offset, jeb->free_size);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\t/* OK, jeb (==c->nextblock) is now pointing at a block which definitely has\n\t   enough space */\n\t*len = jeb->free_size - reserved_size;\n\n\tif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\n\t    !jeb->first_node->next_in_ino) {\n\t\t/* Only node in it beforehand was a CLEANMARKER node (we think).\n\t\t   So mark it obsolete now that there's going to be another node\n\t\t   in the block. This will reduce used_size to zero but We've\n\t\t   already set c->nextblock so that jffs2_mark_node_obsolete()\n\t\t   won't try to refile it to the dirty_list.\n\t\t*/\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_mark_node_obsolete(c, jeb->first_node);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tjffs2_dbg(1, \"%s(): Giving 0x%x bytes at 0x%x\\n\",\n\t\t  __func__,\n\t\t  *len, jeb->offset + (c->sector_size - jeb->free_size));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignal_pending(",
          "args": [
            "urrent)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ond_resched(",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emove_wait_queue(",
          "args": [
            "c->erase_wait,",
            "wait)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chedule(",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s waiting for erase to complete\\n\",",
            "_func__)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dd_wait_queue(",
          "args": [
            "c->erase_wait,",
            "wait)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_current_state(",
          "args": [
            "ASK_UNINTERRUPTIBLE)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECLARE_WAITQUEUE(",
          "args": [
            "ait,",
            "urrent)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erase_complete_list)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "c->erase_pending_list)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_garbage_collect_pass(",
          "args": [
            ")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",",
            "->nr_free_blocks,",
            "->nr_erasing_blocks,",
            "->free_size,",
            "->dirty_size,",
            "->wasted_size,",
            "->used_size,",
            "->erasing_size,",
            "->bad_size,",
            "->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,",
            "->flash_size)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",",
            "vail,",
            "locksneeded * c->sector_size)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",",
            "_func__)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",",
            "irty,",
            "->unchecked_size,",
            "->sector_size)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",",
            "_func__)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_rp_can_write(",
          "args": [
            ")"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_rp_can_write(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "24-50",
          "snippet": "tatic int jffs2_rp_can_write(struct jffs2_sb_info *c)\n{\n\tuint32_t avail;\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tavail = c->dirty_size + c->free_size + c->unchecked_size +\n\t\tc->erasing_size - c->resv_blocks_write * c->sector_size\n\t\t- c->nospc_dirty_size;\n\n\tif (avail < 2 * opts->rp_size)\n\t\tjffs2_dbg(1, \"rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",\n\t\t\t  opts->rp_size, c->dirty_size, c->free_size,\n\t\t\t  c->erasing_size, c->unchecked_size,\n\t\t\t  c->nr_erasing_blocks, avail, c->nospc_dirty_size);\n\n\tif (avail > opts->rp_size)\n\t\treturn 1;\n\n\t/* Always allow root */\n\tif (capable(CAP_SYS_RESOURCE))\n\t\treturn 1;\n\n\tjffs2_dbg(1, \"forbid writing\\n\");\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_rp_can_write(struct jffs2_sb_info *c)\n{\n\tuint32_t avail;\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tavail = c->dirty_size + c->free_size + c->unchecked_size +\n\t\tc->erasing_size - c->resv_blocks_write * c->sector_size\n\t\t- c->nospc_dirty_size;\n\n\tif (avail < 2 * opts->rp_size)\n\t\tjffs2_dbg(1, \"rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",\n\t\t\t  opts->rp_size, c->dirty_size, c->free_size,\n\t\t\t  c->erasing_size, c->unchecked_size,\n\t\t\t  c->nr_erasing_blocks, avail, c->nospc_dirty_size);\n\n\tif (avail > opts->rp_size)\n\t\treturn 1;\n\n\t/* Always allow root */\n\tif (capable(CAP_SYS_RESOURCE))\n\t\treturn 1;\n\n\tjffs2_dbg(1, \"forbid writing\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): alloc sem got\\n\",",
            "_func__)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Requested 0x%x bytes\\n\",",
            "_func__,",
            "insize)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "insize)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_rp_can_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
    "lines": "24-50",
    "snippet": "tatic int jffs2_rp_can_write(struct jffs2_sb_info *c)\n{\n\tuint32_t avail;\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tavail = c->dirty_size + c->free_size + c->unchecked_size +\n\t\tc->erasing_size - c->resv_blocks_write * c->sector_size\n\t\t- c->nospc_dirty_size;\n\n\tif (avail < 2 * opts->rp_size)\n\t\tjffs2_dbg(1, \"rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",\n\t\t\t  opts->rp_size, c->dirty_size, c->free_size,\n\t\t\t  c->erasing_size, c->unchecked_size,\n\t\t\t  c->nr_erasing_blocks, avail, c->nospc_dirty_size);\n\n\tif (avail > opts->rp_size)\n\t\treturn 1;\n\n\t/* Always allow root */\n\tif (capable(CAP_SYS_RESOURCE))\n\t\treturn 1;\n\n\tjffs2_dbg(1, \"forbid writing\\n\");\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/sched.h> /* For cond_resched() */\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "forbid writing\\n\")"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apable(",
          "args": [
            "AP_SYS_RESOURCE)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",",
            "pts->rp_size,",
            "->dirty_size,",
            "->free_size,",
            "->erasing_size,",
            "->unchecked_size,",
            "->nr_erasing_blocks,",
            "vail,",
            "->nospc_dirty_size)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_rp_can_write(struct jffs2_sb_info *c)\n{\n\tuint32_t avail;\n\tstruct jffs2_mount_opts *opts = &c->mount_opts;\n\n\tavail = c->dirty_size + c->free_size + c->unchecked_size +\n\t\tc->erasing_size - c->resv_blocks_write * c->sector_size\n\t\t- c->nospc_dirty_size;\n\n\tif (avail < 2 * opts->rp_size)\n\t\tjffs2_dbg(1, \"rpsize %u, dirty_size %u, free_size %u, \"\n\t\t\t  \"erasing_size %u, unchecked_size %u, \"\n\t\t\t  \"nr_erasing_blocks %u, avail %u, resrv %u\\n\",\n\t\t\t  opts->rp_size, c->dirty_size, c->free_size,\n\t\t\t  c->erasing_size, c->unchecked_size,\n\t\t\t  c->nr_erasing_blocks, avail, c->nospc_dirty_size);\n\n\tif (avail > opts->rp_size)\n\t\treturn 1;\n\n\t/* Always allow root */\n\tif (capable(CAP_SYS_RESOURCE))\n\t\treturn 1;\n\n\tjffs2_dbg(1, \"forbid writing\\n\");\n\treturn 0;\n}"
  }
]