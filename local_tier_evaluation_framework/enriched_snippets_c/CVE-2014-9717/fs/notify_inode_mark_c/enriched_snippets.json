[
  {
    "function_name": "fsnotify_unmount_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "171-247",
    "snippet": "void fsnotify_unmount_inodes(struct list_head *list)\n{\n\tstruct inode *inode, *next_i, *need_iput = NULL;\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next_i, list, i_sb_list) {\n\t\tstruct inode *need_iput_tmp;\n\n\t\t/*\n\t\t * We cannot __iget() an inode in state I_FREEING,\n\t\t * I_WILL_FREE, or I_NEW which is fine because by that point\n\t\t * the inode cannot have any associated watches.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If i_count is zero, the inode cannot have any watches and\n\t\t * doing an __iget/iput with MS_ACTIVE clear would actually\n\t\t * evict all inodes with zero i_count from icache which is\n\t\t * unnecessarily violent and may in fact be illegal to do.\n\t\t */\n\t\tif (!atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_iput_tmp = need_iput;\n\t\tneed_iput = NULL;\n\n\t\t/* In case fsnotify_inode_delete() drops a reference. */\n\t\tif (inode != need_iput_tmp)\n\t\t\t__iget(inode);\n\t\telse\n\t\t\tneed_iput_tmp = NULL;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\t/* In case the dropping of a reference would nuke next_i. */\n\t\twhile (&next_i->i_sb_list != list) {\n\t\t\tspin_lock(&next_i->i_lock);\n\t\t\tif (!(next_i->i_state & (I_FREEING | I_WILL_FREE)) &&\n\t\t\t\t\t\tatomic_read(&next_i->i_count)) {\n\t\t\t\t__iget(next_i);\n\t\t\t\tneed_iput = next_i;\n\t\t\t\tspin_unlock(&next_i->i_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&next_i->i_lock);\n\t\t\tnext_i = list_entry(next_i->i_sb_list.next,\n\t\t\t\t\t\tstruct inode, i_sb_list);\n\t\t}\n\n\t\t/*\n\t\t * We can safely drop inode_sb_list_lock here because either\n\t\t * we actually hold references on both inode and next_i or\n\t\t * end of list.  Also no new inodes will be added since the\n\t\t * umount has begun.\n\t\t */\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\tif (need_iput_tmp)\n\t\t\tiput(need_iput_tmp);\n\n\t\t/* for each watch, send FS_UNMOUNT and then remove it */\n\t\tfsnotify(inode, FS_UNMOUNT, inode, FSNOTIFY_EVENT_INODE, NULL, 0);\n\n\t\tfsnotify_inode_delete(inode);\n\n\t\tiput(inode);\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_inode_delete",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_inode_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "34-37",
          "snippet": "void __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify",
          "args": [
            "inode",
            "FS_UNMOUNT",
            "inode",
            "FSNOTIFY_EVENT_INODE",
            "NULL",
            "0"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "191-284",
          "snippet": "int fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next_i->i_sb_list.next",
            "structinode",
            "i_sb_list"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "next_i"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&next_i->i_count"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "inode",
            "next_i",
            "list",
            "i_sb_list"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_unmount_inodes(struct list_head *list)\n{\n\tstruct inode *inode, *next_i, *need_iput = NULL;\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next_i, list, i_sb_list) {\n\t\tstruct inode *need_iput_tmp;\n\n\t\t/*\n\t\t * We cannot __iget() an inode in state I_FREEING,\n\t\t * I_WILL_FREE, or I_NEW which is fine because by that point\n\t\t * the inode cannot have any associated watches.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If i_count is zero, the inode cannot have any watches and\n\t\t * doing an __iget/iput with MS_ACTIVE clear would actually\n\t\t * evict all inodes with zero i_count from icache which is\n\t\t * unnecessarily violent and may in fact be illegal to do.\n\t\t */\n\t\tif (!atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tneed_iput_tmp = need_iput;\n\t\tneed_iput = NULL;\n\n\t\t/* In case fsnotify_inode_delete() drops a reference. */\n\t\tif (inode != need_iput_tmp)\n\t\t\t__iget(inode);\n\t\telse\n\t\t\tneed_iput_tmp = NULL;\n\t\tspin_unlock(&inode->i_lock);\n\n\t\t/* In case the dropping of a reference would nuke next_i. */\n\t\twhile (&next_i->i_sb_list != list) {\n\t\t\tspin_lock(&next_i->i_lock);\n\t\t\tif (!(next_i->i_state & (I_FREEING | I_WILL_FREE)) &&\n\t\t\t\t\t\tatomic_read(&next_i->i_count)) {\n\t\t\t\t__iget(next_i);\n\t\t\t\tneed_iput = next_i;\n\t\t\t\tspin_unlock(&next_i->i_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&next_i->i_lock);\n\t\t\tnext_i = list_entry(next_i->i_sb_list.next,\n\t\t\t\t\t\tstruct inode, i_sb_list);\n\t\t}\n\n\t\t/*\n\t\t * We can safely drop inode_sb_list_lock here because either\n\t\t * we actually hold references on both inode and next_i or\n\t\t * end of list.  Also no new inodes will be added since the\n\t\t * umount has begun.\n\t\t */\n\t\tspin_unlock(&inode_sb_list_lock);\n\n\t\tif (need_iput_tmp)\n\t\t\tiput(need_iput_tmp);\n\n\t\t/* for each watch, send FS_UNMOUNT and then remove it */\n\t\tfsnotify(inode, FS_UNMOUNT, inode, FSNOTIFY_EVENT_INODE, NULL, 0);\n\n\t\tfsnotify_inode_delete(inode);\n\n\t\tiput(inode);\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n}"
  },
  {
    "function_name": "fsnotify_add_inode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "143-162",
    "snippet": "int fsnotify_add_inode_mark(struct fsnotify_mark *mark,\n\t\t\t    struct fsnotify_group *group, struct inode *inode,\n\t\t\t    int allow_dups)\n{\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_INODE;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\tmark->inode = inode;\n\tret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,\n\t\t\t\t     allow_dups);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_mask",
          "args": [
            "&inode->i_fsnotify_marks"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "114-122",
          "snippet": "u32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nu32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_list",
          "args": [
            "&inode->i_fsnotify_marks",
            "mark",
            "allow_dups"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_mark_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "281-311",
          "snippet": "int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,\n\t\t\t   int allow_dups)\n{\n\tstruct fsnotify_mark *lmark, *last = NULL;\n\tint cmp;\n\n\t/* is mark the first mark? */\n\tif (hlist_empty(head)) {\n\t\thlist_add_head_rcu(&mark->obj_list, head);\n\t\treturn 0;\n\t}\n\n\t/* should mark be in the middle of the current list? */\n\thlist_for_each_entry(lmark, head, obj_list) {\n\t\tlast = lmark;\n\n\t\tif ((lmark->group == mark->group) && !allow_dups)\n\t\t\treturn -EEXIST;\n\n\t\tcmp = fsnotify_compare_groups(lmark->group, mark->group);\n\t\tif (cmp >= 0) {\n\t\t\thlist_add_before_rcu(&mark->obj_list, &lmark->obj_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(last == NULL);\n\t/* mark should be the last entry.  last is the current last entry */\n\thlist_add_behind_rcu(&mark->obj_list, &last->obj_list);\n\treturn 0;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,\n\t\t\t   int allow_dups)\n{\n\tstruct fsnotify_mark *lmark, *last = NULL;\n\tint cmp;\n\n\t/* is mark the first mark? */\n\tif (hlist_empty(head)) {\n\t\thlist_add_head_rcu(&mark->obj_list, head);\n\t\treturn 0;\n\t}\n\n\t/* should mark be in the middle of the current list? */\n\thlist_for_each_entry(lmark, head, obj_list) {\n\t\tlast = lmark;\n\n\t\tif ((lmark->group == mark->group) && !allow_dups)\n\t\t\treturn -EEXIST;\n\n\t\tcmp = fsnotify_compare_groups(lmark->group, mark->group);\n\t\tif (cmp >= 0) {\n\t\t\thlist_add_before_rcu(&mark->obj_list, &lmark->obj_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(last == NULL);\n\t/* mark should be the last entry.  last is the current last entry */\n\thlist_add_behind_rcu(&mark->obj_list, &last->obj_list);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mark->lock"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&group->mark_mutex)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_inode_mark(struct fsnotify_mark *mark,\n\t\t\t    struct fsnotify_group *group, struct inode *inode,\n\t\t\t    int allow_dups)\n{\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_INODE;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\tmark->inode = inode;\n\tret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,\n\t\t\t\t     allow_dups);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fsnotify_set_inode_mark_mask_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "115-134",
    "snippet": "void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,\n\t\t\t\t\t __u32 mask)\n{\n\tstruct inode *inode;\n\n\tassert_spin_locked(&mark->lock);\n\n\tif (mask &&\n\t    mark->inode &&\n\t    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {\n\t\tmark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;\n\t\tinode = igrab(mark->inode);\n\t\t/*\n\t\t * we shouldn't be able to get here if the inode wasn't\n\t\t * already safely held in memory.  But bug in case it\n\t\t * ever is wrong.\n\t\t */\n\t\tBUG_ON(!inode);\n\t}\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "mark->inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mark->lock"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,\n\t\t\t\t\t __u32 mask)\n{\n\tstruct inode *inode;\n\n\tassert_spin_locked(&mark->lock);\n\n\tif (mask &&\n\t    mark->inode &&\n\t    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {\n\t\tmark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;\n\t\tinode = igrab(mark->inode);\n\t\t/*\n\t\t * we shouldn't be able to get here if the inode wasn't\n\t\t * already safely held in memory.  But bug in case it\n\t\t * ever is wrong.\n\t\t */\n\t\tBUG_ON(!inode);\n\t}\n}"
  },
  {
    "function_name": "fsnotify_find_inode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "99-109",
    "snippet": "struct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_find_mark",
          "args": [
            "&inode->i_fsnotify_marks",
            "group"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_find_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "394-406",
          "snippet": "struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,\n\t\t\t\t\t struct fsnotify_group *group)\n{\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list) {\n\t\tif (mark->group == group) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\treturn mark;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,\n\t\t\t\t\t struct fsnotify_group *group)\n{\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list) {\n\t\tif (mark->group == group) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\treturn mark;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_inode_mark(struct fsnotify_group *group,\n\t\t\t\t\t       struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\n\tspin_lock(&inode->i_lock);\n\tmark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tspin_unlock(&inode->i_lock);\n\n\treturn mark;\n}"
  },
  {
    "function_name": "fsnotify_clear_inode_marks_by_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "90-93",
    "snippet": "void fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_INODE);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_clear_marks_by_group_flags",
          "args": [
            "group",
            "FSNOTIFY_MARK_FLAG_INODE"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_clear_marks_by_group_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "411-425",
          "snippet": "void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_inode_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group_flags(group, FSNOTIFY_MARK_FLAG_INODE);\n}"
  },
  {
    "function_name": "fsnotify_clear_marks_by_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "70-85",
    "snippet": "void fsnotify_clear_marks_by_inode(struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry_safe(mark, n, &inode->i_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_marks",
          "args": [
            "&free_list"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_marks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "210-225",
          "snippet": "void fsnotify_destroy_marks(struct list_head *to_free)\n{\n\tstruct fsnotify_mark *mark, *lmark;\n\tstruct fsnotify_group *group;\n\n\tlist_for_each_entry_safe(mark, lmark, to_free, free_list) {\n\t\tspin_lock(&mark->lock);\n\t\tfsnotify_get_group(mark->group);\n\t\tgroup = mark->group;\n\t\tspin_unlock(&mark->lock);\n\n\t\tfsnotify_destroy_mark(mark, group);\n\t\tfsnotify_put_mark(mark);\n\t\tfsnotify_put_group(group);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_marks(struct list_head *to_free)\n{\n\tstruct fsnotify_mark *mark, *lmark;\n\tstruct fsnotify_group *group;\n\n\tlist_for_each_entry_safe(mark, lmark, to_free, free_list) {\n\t\tspin_lock(&mark->lock);\n\t\tfsnotify_get_group(mark->group);\n\t\tgroup = mark->group;\n\t\tspin_unlock(&mark->lock);\n\n\t\tfsnotify_destroy_mark(mark, group);\n\t\tfsnotify_put_mark(mark);\n\t\tfsnotify_put_group(group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "mark"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mark->obj_list"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mark->free_list",
            "&free_list"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_safe",
          "args": [
            "mark",
            "n",
            "&inode->i_fsnotify_marks",
            "obj_list"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "free_list"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_inode(struct inode *inode)\n{\n\tstruct fsnotify_mark *mark;\n\tstruct hlist_node *n;\n\tLIST_HEAD(free_list);\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry_safe(mark, n, &inode->i_fsnotify_marks, obj_list) {\n\t\tlist_add(&mark->free_list, &free_list);\n\t\thlist_del_init_rcu(&mark->obj_list);\n\t\tfsnotify_get_mark(mark);\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tfsnotify_destroy_marks(&free_list);\n}"
  },
  {
    "function_name": "fsnotify_destroy_inode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "46-65",
    "snippet": "void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)\n{\n\tstruct inode *inode = mark->inode;\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->inode = NULL;\n\n\t/*\n\t * this mark is now off the inode->i_fsnotify_marks list and we\n\t * hold the inode->i_lock, so this is the perfect time to update the\n\t * inode->i_fsnotify_mask\n\t */\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_mask",
          "args": [
            "&inode->i_fsnotify_marks"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "114-122",
          "snippet": "u32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nu32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init_rcu",
          "args": [
            "&mark->obj_list"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mark->lock"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&mark->group->mark_mutex)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&mark->group->mark_mutex"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)\n{\n\tstruct inode *inode = mark->inode;\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->inode = NULL;\n\n\t/*\n\t * this mark is now off the inode->i_fsnotify_marks list and we\n\t * hold the inode->i_lock, so this is the perfect time to update the\n\t * inode->i_fsnotify_mask\n\t */\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "fsnotify_recalc_inode_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
    "lines": "37-44",
    "snippet": "void fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fsnotify_update_child_dentry_flags",
          "args": [
            "inode"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_update_child_dentry_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "52-87",
          "snippet": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_recalc_mask",
          "args": [
            "&inode->i_fsnotify_marks"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_recalc_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "114-122",
          "snippet": "u32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nu32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_recalc_inode_mask(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\t__fsnotify_update_child_dentry_flags(inode);\n}"
  }
]