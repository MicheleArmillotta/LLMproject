[
  {
    "function_name": "squashfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/namei.c",
    "lines": "139-245",
    "snippet": "static struct dentry *squashfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tstruct inode *inode = NULL;\n\tstruct squashfs_sb_info *msblk = dir->i_sb->s_fs_info;\n\tstruct squashfs_dir_header dirh;\n\tstruct squashfs_dir_entry *dire;\n\tu64 block = squashfs_i(dir)->start + msblk->directory_table;\n\tint offset = squashfs_i(dir)->offset;\n\tint err, length;\n\tunsigned int dir_count, size;\n\n\tTRACE(\"Entered squashfs_lookup [%llx:%x]\\n\", block, offset);\n\n\tdire = kmalloc(sizeof(*dire) + SQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n\tif (dire == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_entry\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (len > SQUASHFS_NAME_LEN) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto failed;\n\t}\n\n\tlength = get_dir_index_using_name(dir->i_sb, &block, &offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_start,\n\t\t\t\tsquashfs_i(dir)->dir_idx_offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_cnt, name, len);\n\n\twhile (length < i_size_read(dir)) {\n\t\t/*\n\t\t * Read directory header.\n\t\t */\n\t\terr = squashfs_read_metadata(dir->i_sb, &dirh, &block,\n\t\t\t\t&offset, sizeof(dirh));\n\t\tif (err < 0)\n\t\t\tgoto read_failure;\n\n\t\tlength += sizeof(dirh);\n\n\t\tdir_count = le32_to_cpu(dirh.count) + 1;\n\n\t\tif (dir_count > SQUASHFS_DIR_COUNT)\n\t\t\tgoto data_error;\n\n\t\twhile (dir_count--) {\n\t\t\t/*\n\t\t\t * Read directory entry.\n\t\t\t */\n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire, &block,\n\t\t\t\t\t&offset, sizeof(*dire));\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tsize = le16_to_cpu(dire->size) + 1;\n\n\t\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\t\tgoto data_error;\n\n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire->name,\n\t\t\t\t\t&block, &offset, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tlength += sizeof(*dire) + size;\n\n\t\t\tif (name[0] < dire->name[0])\n\t\t\t\tgoto exit_lookup;\n\n\t\t\tif (len == size && !strncmp(name, dire->name, len)) {\n\t\t\t\tunsigned int blk, off, ino_num;\n\t\t\t\tlong long ino;\n\t\t\t\tblk = le32_to_cpu(dirh.start_block);\n\t\t\t\toff = le16_to_cpu(dire->offset);\n\t\t\t\tino_num = le32_to_cpu(dirh.inode_number) +\n\t\t\t\t\t(short) le16_to_cpu(dire->inode_number);\n\t\t\t\tino = SQUASHFS_MKINODE(blk, off);\n\n\t\t\t\tTRACE(\"calling squashfs_iget for directory \"\n\t\t\t\t\t\"entry %s, inode  %x:%x, %d\\n\", name,\n\t\t\t\t\tblk, off, ino_num);\n\n\t\t\t\tinode = squashfs_iget(dir->i_sb, ino, ino_num);\n\t\t\t\tgoto exit_lookup;\n\t\t\t}\n\t\t}\n\t}\n\nexit_lookup:\n\tkfree(dire);\n\treturn d_splice_alias(inode, dentry);\n\ndata_error:\n\terr = -EIO;\n\nread_failure:\n\tERROR(\"Unable to read directory block [%llx:%x]\\n\",\n\t\tsquashfs_i(dir)->start + msblk->directory_table,\n\t\tsquashfs_i(dir)->offset);\nfailed:\n\tkfree(dire);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dire"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read directory block [%llx:%x]\\n\"",
            "squashfs_i(dir)->start + msblk->directory_table",
            "squashfs_i(dir)->offset"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "dir"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dire"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_iget",
          "args": [
            "dir->i_sb",
            "ino",
            "ino_num"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
          "lines": "84-105",
          "snippet": "struct inode *squashfs_iget(struct super_block *sb, long long ino,\n\t\t\t\tunsigned int ino_number)\n{\n\tstruct inode *inode = iget_locked(sb, ino_number);\n\tint err;\n\n\tTRACE(\"Entered squashfs_iget\\n\");\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = squashfs_read_inode(inode, ino);\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct inode *squashfs_iget(struct super_block *sb, long long ino,\n\t\t\t\tunsigned int ino_number)\n{\n\tstruct inode *inode = iget_locked(sb, ino_number);\n\tint err;\n\n\tTRACE(\"Entered squashfs_iget\\n\");\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = squashfs_read_inode(inode, ino);\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"calling squashfs_iget for directory \"\n\t\t\t\t\t\"entry %s, inode  %x:%x, %d\\n\"",
            "name",
            "blk",
            "off",
            "ino_num"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_MKINODE",
          "args": [
            "blk",
            "off"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dire->inode_number"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dirh.inode_number"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "dire->name",
            "len"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "dir->i_sb",
            "dire->name",
            "&block",
            "&offset",
            "size"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "dir"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dir_index_using_name",
          "args": [
            "dir->i_sb",
            "&block",
            "&offset",
            "squashfs_i(dir)->dir_idx_start",
            "squashfs_i(dir)->dir_idx_offset",
            "squashfs_i(dir)->dir_idx_cnt",
            "name",
            "len"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "get_dir_index_using_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/namei.c",
          "lines": "76-136",
          "snippet": "static int get_dir_index_using_name(struct super_block *sb,\n\t\t\tu64 *next_block, int *next_offset, u64 index_start,\n\t\t\tint index_offset, int i_count, const char *name,\n\t\t\tint len)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint i, length = 0, err;\n\tunsigned int size;\n\tstruct squashfs_dir_index *index;\n\tchar *str;\n\n\tTRACE(\"Entered get_dir_index_using_name, i_count %d\\n\", i_count);\n\n\tindex = kmalloc(sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2, GFP_KERNEL);\n\tif (index == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_index\\n\");\n\t\tgoto out;\n\t}\n\n\tstr = &index->name[SQUASHFS_NAME_LEN + 1];\n\tstrncpy(str, name, len);\n\tstr[len] = '\\0';\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, index, &index_start,\n\t\t\t\t\t&index_offset, sizeof(*index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\n\t\tsize = le32_to_cpu(index->size) + 1;\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, index->name, &index_start,\n\t\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex->name[size] = '\\0';\n\n\t\tif (strcmp(index->name, str) > 0)\n\t\t\tbreak;\n\n\t\tlength = le32_to_cpu(index->index);\n\t\t*next_block = le32_to_cpu(index->start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\tkfree(index);\n\nout:\n\t/*\n\t * Return index (f_pos) of the looked up metadata block.  Translate\n\t * from internal f_pos to external f_pos which is offset by 3 because\n\t * we invent \".\" and \"..\" entries which are not actually stored in the\n\t * directory.\n\t */\n\treturn length + 3;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/dcache.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int get_dir_index_using_name(struct super_block *sb,\n\t\t\tu64 *next_block, int *next_offset, u64 index_start,\n\t\t\tint index_offset, int i_count, const char *name,\n\t\t\tint len)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint i, length = 0, err;\n\tunsigned int size;\n\tstruct squashfs_dir_index *index;\n\tchar *str;\n\n\tTRACE(\"Entered get_dir_index_using_name, i_count %d\\n\", i_count);\n\n\tindex = kmalloc(sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2, GFP_KERNEL);\n\tif (index == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_index\\n\");\n\t\tgoto out;\n\t}\n\n\tstr = &index->name[SQUASHFS_NAME_LEN + 1];\n\tstrncpy(str, name, len);\n\tstr[len] = '\\0';\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, index, &index_start,\n\t\t\t\t\t&index_offset, sizeof(*index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\n\t\tsize = le32_to_cpu(index->size) + 1;\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, index->name, &index_start,\n\t\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex->name[size] = '\\0';\n\n\t\tif (strcmp(index->name, str) > 0)\n\t\t\tbreak;\n\n\t\tlength = le32_to_cpu(index->index);\n\t\t*next_block = le32_to_cpu(index->start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\tkfree(index);\n\nout:\n\t/*\n\t * Return index (f_pos) of the looked up metadata block.  Translate\n\t * from internal f_pos to external f_pos which is offset by 3 because\n\t * we invent \".\" and \"..\" entries which are not actually stored in the\n\t * directory.\n\t */\n\treturn length + 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate squashfs_dir_entry\\n\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*dire) + SQUASHFS_NAME_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_lookup [%llx:%x]\\n\"",
            "block",
            "offset"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct dentry *squashfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\tstruct inode *inode = NULL;\n\tstruct squashfs_sb_info *msblk = dir->i_sb->s_fs_info;\n\tstruct squashfs_dir_header dirh;\n\tstruct squashfs_dir_entry *dire;\n\tu64 block = squashfs_i(dir)->start + msblk->directory_table;\n\tint offset = squashfs_i(dir)->offset;\n\tint err, length;\n\tunsigned int dir_count, size;\n\n\tTRACE(\"Entered squashfs_lookup [%llx:%x]\\n\", block, offset);\n\n\tdire = kmalloc(sizeof(*dire) + SQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n\tif (dire == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_entry\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (len > SQUASHFS_NAME_LEN) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto failed;\n\t}\n\n\tlength = get_dir_index_using_name(dir->i_sb, &block, &offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_start,\n\t\t\t\tsquashfs_i(dir)->dir_idx_offset,\n\t\t\t\tsquashfs_i(dir)->dir_idx_cnt, name, len);\n\n\twhile (length < i_size_read(dir)) {\n\t\t/*\n\t\t * Read directory header.\n\t\t */\n\t\terr = squashfs_read_metadata(dir->i_sb, &dirh, &block,\n\t\t\t\t&offset, sizeof(dirh));\n\t\tif (err < 0)\n\t\t\tgoto read_failure;\n\n\t\tlength += sizeof(dirh);\n\n\t\tdir_count = le32_to_cpu(dirh.count) + 1;\n\n\t\tif (dir_count > SQUASHFS_DIR_COUNT)\n\t\t\tgoto data_error;\n\n\t\twhile (dir_count--) {\n\t\t\t/*\n\t\t\t * Read directory entry.\n\t\t\t */\n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire, &block,\n\t\t\t\t\t&offset, sizeof(*dire));\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tsize = le16_to_cpu(dire->size) + 1;\n\n\t\t\t/* size should never be larger than SQUASHFS_NAME_LEN */\n\t\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\t\tgoto data_error;\n\n\t\t\terr = squashfs_read_metadata(dir->i_sb, dire->name,\n\t\t\t\t\t&block, &offset, size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto read_failure;\n\n\t\t\tlength += sizeof(*dire) + size;\n\n\t\t\tif (name[0] < dire->name[0])\n\t\t\t\tgoto exit_lookup;\n\n\t\t\tif (len == size && !strncmp(name, dire->name, len)) {\n\t\t\t\tunsigned int blk, off, ino_num;\n\t\t\t\tlong long ino;\n\t\t\t\tblk = le32_to_cpu(dirh.start_block);\n\t\t\t\toff = le16_to_cpu(dire->offset);\n\t\t\t\tino_num = le32_to_cpu(dirh.inode_number) +\n\t\t\t\t\t(short) le16_to_cpu(dire->inode_number);\n\t\t\t\tino = SQUASHFS_MKINODE(blk, off);\n\n\t\t\t\tTRACE(\"calling squashfs_iget for directory \"\n\t\t\t\t\t\"entry %s, inode  %x:%x, %d\\n\", name,\n\t\t\t\t\tblk, off, ino_num);\n\n\t\t\t\tinode = squashfs_iget(dir->i_sb, ino, ino_num);\n\t\t\t\tgoto exit_lookup;\n\t\t\t}\n\t\t}\n\t}\n\nexit_lookup:\n\tkfree(dire);\n\treturn d_splice_alias(inode, dentry);\n\ndata_error:\n\terr = -EIO;\n\nread_failure:\n\tERROR(\"Unable to read directory block [%llx:%x]\\n\",\n\t\tsquashfs_i(dir)->start + msblk->directory_table,\n\t\tsquashfs_i(dir)->offset);\nfailed:\n\tkfree(dire);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "get_dir_index_using_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/namei.c",
    "lines": "76-136",
    "snippet": "static int get_dir_index_using_name(struct super_block *sb,\n\t\t\tu64 *next_block, int *next_offset, u64 index_start,\n\t\t\tint index_offset, int i_count, const char *name,\n\t\t\tint len)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint i, length = 0, err;\n\tunsigned int size;\n\tstruct squashfs_dir_index *index;\n\tchar *str;\n\n\tTRACE(\"Entered get_dir_index_using_name, i_count %d\\n\", i_count);\n\n\tindex = kmalloc(sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2, GFP_KERNEL);\n\tif (index == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_index\\n\");\n\t\tgoto out;\n\t}\n\n\tstr = &index->name[SQUASHFS_NAME_LEN + 1];\n\tstrncpy(str, name, len);\n\tstr[len] = '\\0';\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, index, &index_start,\n\t\t\t\t\t&index_offset, sizeof(*index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\n\t\tsize = le32_to_cpu(index->size) + 1;\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, index->name, &index_start,\n\t\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex->name[size] = '\\0';\n\n\t\tif (strcmp(index->name, str) > 0)\n\t\t\tbreak;\n\n\t\tlength = le32_to_cpu(index->index);\n\t\t*next_block = le32_to_cpu(index->start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\tkfree(index);\n\nout:\n\t/*\n\t * Return index (f_pos) of the looked up metadata block.  Translate\n\t * from internal f_pos to external f_pos which is offset by 3 because\n\t * we invent \".\" and \"..\" entries which are not actually stored in the\n\t * directory.\n\t */\n\treturn length + 3;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/dcache.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "index"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "index->start_block"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "index->name",
            "str"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "index->name",
            "&index_start",
            "&index_offset",
            "size"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "str",
            "name",
            "len"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate squashfs_dir_index\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2",
            "GFP_KERNEL"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered get_dir_index_using_name, i_count %d\\n\"",
            "i_count"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/dcache.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int get_dir_index_using_name(struct super_block *sb,\n\t\t\tu64 *next_block, int *next_offset, u64 index_start,\n\t\t\tint index_offset, int i_count, const char *name,\n\t\t\tint len)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint i, length = 0, err;\n\tunsigned int size;\n\tstruct squashfs_dir_index *index;\n\tchar *str;\n\n\tTRACE(\"Entered get_dir_index_using_name, i_count %d\\n\", i_count);\n\n\tindex = kmalloc(sizeof(*index) + SQUASHFS_NAME_LEN * 2 + 2, GFP_KERNEL);\n\tif (index == NULL) {\n\t\tERROR(\"Failed to allocate squashfs_dir_index\\n\");\n\t\tgoto out;\n\t}\n\n\tstr = &index->name[SQUASHFS_NAME_LEN + 1];\n\tstrncpy(str, name, len);\n\tstr[len] = '\\0';\n\n\tfor (i = 0; i < i_count; i++) {\n\t\terr = squashfs_read_metadata(sb, index, &index_start,\n\t\t\t\t\t&index_offset, sizeof(*index));\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\n\t\tsize = le32_to_cpu(index->size) + 1;\n\t\tif (size > SQUASHFS_NAME_LEN)\n\t\t\tbreak;\n\n\t\terr = squashfs_read_metadata(sb, index->name, &index_start,\n\t\t\t\t\t&index_offset, size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tindex->name[size] = '\\0';\n\n\t\tif (strcmp(index->name, str) > 0)\n\t\t\tbreak;\n\n\t\tlength = le32_to_cpu(index->index);\n\t\t*next_block = le32_to_cpu(index->start_block) +\n\t\t\t\t\tmsblk->directory_table;\n\t}\n\n\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n\tkfree(index);\n\nout:\n\t/*\n\t * Return index (f_pos) of the looked up metadata block.  Translate\n\t * from internal f_pos to external f_pos which is offset by 3 because\n\t * we invent \".\" and \"..\" entries which are not actually stored in the\n\t * directory.\n\t */\n\treturn length + 3;\n}"
  }
]