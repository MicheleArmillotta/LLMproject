[
  {
    "function_name": "nfs_destroy_readpagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "433-436",
    "snippet": "void nfs_destroy_readpagecache(void)\n{\n\tkmem_cache_destroy(nfs_rdata_cachep);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs_rdata_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs_rdata_cachep"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *nfs_rdata_cachep;\n\nvoid nfs_destroy_readpagecache(void)\n{\n\tkmem_cache_destroy(nfs_rdata_cachep);\n}"
  },
  {
    "function_name": "nfs_init_readpagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "421-431",
    "snippet": "int __init nfs_init_readpagecache(void)\n{\n\tnfs_rdata_cachep = kmem_cache_create(\"nfs_read_data\",\n\t\t\t\t\t     sizeof(struct nfs_pgio_header),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_rdata_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs_rdata_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs_read_data\"",
            "sizeof(struct nfs_pgio_header)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *nfs_rdata_cachep;\n\nint __init nfs_init_readpagecache(void)\n{\n\tnfs_rdata_cachep = kmem_cache_create(\"nfs_read_data\",\n\t\t\t\t\t     sizeof(struct nfs_pgio_header),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_rdata_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "365-419",
    "snippet": "int nfs_readpages(struct file *filp, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs_readdesc desc = {\n\t\t.pgio = &pgio,\n\t};\n\tstruct inode *inode = mapping->host;\n\tunsigned long npages;\n\tint ret = -ESTALE;\n\n\tdprintk(\"NFS: nfs_readpages (%s/%Lu %d)\\n\",\n\t\t\tinode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(inode),\n\t\t\tnr_pages);\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGES);\n\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tif (filp == NULL) {\n\t\tdesc.ctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (desc.ctx == NULL)\n\t\t\treturn -EBADF;\n\t} else\n\t\tdesc.ctx = get_nfs_open_context(nfs_file_open_context(filp));\n\n\t/* attempt to read as many of the pages as possible from the cache\n\t * - this returns -ENOBUFS immediately if the cookie is negative\n\t */\n\tret = nfs_readpages_from_fscache(desc.ctx, inode, mapping,\n\t\t\t\t\t pages, &nr_pages);\n\tif (ret == 0)\n\t\tgoto read_complete; /* all pages were read */\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\n\tret = read_cache_pages(mapping, pages, readpage_async_filler, &desc);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\tnpages = (pgm->pg_bytes_written + PAGE_CACHE_SIZE - 1) >>\n\t\t PAGE_CACHE_SHIFT;\n\tnfs_add_stats(inode, NFSIOS_READPAGES, npages);\nread_complete:\n\tput_nfs_open_context(desc.ctx);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;",
      "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "desc.ctx"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_READPAGES",
            "npages"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pgio.pg_mirror_count != 1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_complete",
          "args": [
            "&pgio"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1244-1254",
          "snippet": "void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cache_pages",
          "args": [
            "mapping",
            "pages",
            "readpage_async_filler",
            "&desc"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_read",
          "args": [
            "&pgio",
            "inode",
            "false",
            "&nfs_async_read_completion_ops"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "55-68",
          "snippet": "void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_read_ops;",
            "static const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_rw_ops nfs_rw_read_ops;\nstatic const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};\n\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readpages_from_fscache",
          "args": [
            "desc.ctx",
            "inode",
            "mapping",
            "pages",
            "&nr_pages"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_readpages_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "366-411",
          "snippet": "int __nfs_readpages_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct address_space *mapping,\n\t\t\t\t struct list_head *pages,\n\t\t\t\t unsigned *nr_pages)\n{\n\tunsigned npages = *nr_pages;\n\tint ret;\n\n\tdfprintk(FSCACHE, \"NFS: nfs_getpages_from_fscache (0x%p/%u/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), npages, inode);\n\n\tret = fscache_read_or_alloc_pages(nfs_i_fscache(inode),\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  nfs_readpage_from_fscache_complete,\n\t\t\t\t\t  ctx,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tif (*nr_pages < npages)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK,\n\t\t\t\t      npages);\n\tif (*nr_pages > 0)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL,\n\t\t\t\t      *nr_pages);\n\n\tswitch (ret) {\n\tcase 0: /* read submitted to the cache for all pages */\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: submitted\\n\");\n\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* some pages aren't cached and can't be */\n\tcase -ENODATA: /* some pages aren't cached */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: no page: %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: ret  %d\\n\", ret);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint __nfs_readpages_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct address_space *mapping,\n\t\t\t\t struct list_head *pages,\n\t\t\t\t unsigned *nr_pages)\n{\n\tunsigned npages = *nr_pages;\n\tint ret;\n\n\tdfprintk(FSCACHE, \"NFS: nfs_getpages_from_fscache (0x%p/%u/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), npages, inode);\n\n\tret = fscache_read_or_alloc_pages(nfs_i_fscache(inode),\n\t\t\t\t\t  mapping, pages, nr_pages,\n\t\t\t\t\t  nfs_readpage_from_fscache_complete,\n\t\t\t\t\t  ctx,\n\t\t\t\t\t  mapping_gfp_mask(mapping));\n\tif (*nr_pages < npages)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK,\n\t\t\t\t      npages);\n\tif (*nr_pages > 0)\n\t\tnfs_add_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL,\n\t\t\t\t      *nr_pages);\n\n\tswitch (ret) {\n\tcase 0: /* read submitted to the cache for all pages */\n\t\tBUG_ON(!list_empty(pages));\n\t\tBUG_ON(*nr_pages != 0);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: submitted\\n\");\n\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* some pages aren't cached and can't be */\n\tcase -ENODATA: /* some pages aren't cached */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: no page: %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS: nfs_getpages_from_fscache: ret  %d\\n\", ret);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs_open_context",
          "args": [
            "nfs_file_open_context(filp)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "803-808",
          "snippet": "struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "filp"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_find_open_context",
          "args": [
            "inode",
            "NULL",
            "FMODE_READ"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_find_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "865-881",
          "snippet": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tbreak;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tbreak;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_STALE",
          "args": [
            "inode"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSREADPAGES"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: nfs_readpages (%s/%Lu %d)\\n\"",
            "inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(inode)",
            "nr_pages"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "inode"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};\n\nint nfs_readpages(struct file *filp, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\tstruct nfs_readdesc desc = {\n\t\t.pgio = &pgio,\n\t};\n\tstruct inode *inode = mapping->host;\n\tunsigned long npages;\n\tint ret = -ESTALE;\n\n\tdprintk(\"NFS: nfs_readpages (%s/%Lu %d)\\n\",\n\t\t\tinode->i_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(inode),\n\t\t\tnr_pages);\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGES);\n\n\tif (NFS_STALE(inode))\n\t\tgoto out;\n\n\tif (filp == NULL) {\n\t\tdesc.ctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (desc.ctx == NULL)\n\t\t\treturn -EBADF;\n\t} else\n\t\tdesc.ctx = get_nfs_open_context(nfs_file_open_context(filp));\n\n\t/* attempt to read as many of the pages as possible from the cache\n\t * - this returns -ENOBUFS immediately if the cookie is negative\n\t */\n\tret = nfs_readpages_from_fscache(desc.ctx, inode, mapping,\n\t\t\t\t\t pages, &nr_pages);\n\tif (ret == 0)\n\t\tgoto read_complete; /* all pages were read */\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\n\tret = read_cache_pages(mapping, pages, readpage_async_filler, &desc);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\tnpages = (pgm->pg_bytes_written + PAGE_CACHE_SIZE - 1) >>\n\t\t PAGE_CACHE_SHIFT;\n\tnfs_add_stats(inode, NFSIOS_READPAGES, npages);\nread_complete:\n\tput_nfs_open_context(desc.ctx);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "readpage_async_filler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "335-363",
    "snippet": "static int\nreadpage_async_filler(void *data, struct page *page)\n{\n\tstruct nfs_readdesc *desc = (struct nfs_readdesc *)data;\n\tstruct nfs_page *new;\n\tunsigned int len;\n\tint error;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\n\tnew = nfs_create_request(desc->ctx, page, NULL, 0, len);\n\tif (IS_ERR(new))\n\t\tgoto out_error;\n\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tif (!nfs_pageio_add_request(desc->pgio, new)) {\n\t\terror = desc->pgio->pg_error;\n\t\tgoto out_unlock;\n\t}\n\treturn 0;\nout_error:\n\terror = PTR_ERR(new);\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_add_request",
          "args": [
            "desc->pgio",
            "new"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_add_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1138-1183",
          "snippet": "int nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_create_request",
          "args": [
            "desc->ctx",
            "page",
            "NULL",
            "0",
            "len"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "351-388",
          "snippet": "struct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_return_empty_page",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_return_empty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "46-53",
          "snippet": "static\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic int\nreadpage_async_filler(void *data, struct page *page)\n{\n\tstruct nfs_readdesc *desc = (struct nfs_readdesc *)data;\n\tstruct nfs_page *new;\n\tunsigned int len;\n\tint error;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\n\tnew = nfs_create_request(desc->ctx, page, NULL, 0, len);\n\tif (IS_ERR(new))\n\t\tgoto out_error;\n\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\tif (!nfs_pageio_add_request(desc->pgio, new)) {\n\t\terror = desc->pgio->pg_error;\n\t\tgoto out_unlock;\n\t}\n\treturn 0;\nout_error:\n\terror = PTR_ERR(new);\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "278-328",
    "snippet": "int nfs_readpage(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint\t\terror;\n\n\tdprintk(\"NFS: nfs_readpage (%p %ld@%lu)\\n\",\n\t\tpage, PAGE_CACHE_SIZE, page_file_index(page));\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\n\tnfs_inc_stats(inode, NFSIOS_READPAGES);\n\n\t/*\n\t * Try to flush any pending writes to the file..\n\t *\n\t * NOTE! Because we own the page lock, there cannot\n\t * be any new pending writes generated at this point\n\t * for this page (other pages can be written to).\n\t */\n\terror = nfs_wb_page(inode, page);\n\tif (error)\n\t\tgoto out_unlock;\n\tif (PageUptodate(page))\n\t\tgoto out_unlock;\n\n\terror = -ESTALE;\n\tif (NFS_STALE(inode))\n\t\tgoto out_unlock;\n\n\tif (file == NULL) {\n\t\terror = -EBADF;\n\t\tctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (ctx == NULL)\n\t\t\tgoto out_unlock;\n\t} else\n\t\tctx = get_nfs_open_context(nfs_file_open_context(file));\n\n\tif (!IS_SYNC(inode)) {\n\t\terror = nfs_readpage_from_fscache(ctx, inode, page);\n\t\tif (error == 0)\n\t\t\tgoto out;\n\t}\n\n\terror = nfs_readpage_async(ctx, inode, page);\n\nout:\n\tput_nfs_open_context(ctx);\n\treturn error;\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "ctx"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readpage_async",
          "args": [
            "ctx",
            "inode",
            "page"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "85-116",
          "snippet": "int nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;",
            "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};\n\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readpage_from_fscache",
          "args": [
            "ctx",
            "inode",
            "page"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_readpage_from_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "327-361",
          "snippet": "int __nfs_readpage_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\tstruct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache(fsc:%p/p:%p(i:%lx f:%lx)/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, inode);\n\n\tret = fscache_read_or_alloc_page(nfs_i_fscache(inode),\n\t\t\t\t\t page,\n\t\t\t\t\t nfs_readpage_from_fscache_complete,\n\t\t\t\t\t ctx,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\tcase 0: /* read BIO submitted (page in fscache) */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache: BIO submitted\\n\");\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK);\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* inode not in cache */\n\tcase -ENODATA: /* page not in cache */\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE, \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint __nfs_readpage_from_fscache(struct nfs_open_context *ctx,\n\t\t\t\tstruct inode *inode, struct page *page)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_from_fscache(fsc:%p/p:%p(i:%lx f:%lx)/0x%p)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, inode);\n\n\tret = fscache_read_or_alloc_page(nfs_i_fscache(inode),\n\t\t\t\t\t page,\n\t\t\t\t\t nfs_readpage_from_fscache_complete,\n\t\t\t\t\t ctx,\n\t\t\t\t\t GFP_KERNEL);\n\n\tswitch (ret) {\n\tcase 0: /* read BIO submitted (page in fscache) */\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache: BIO submitted\\n\");\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_OK);\n\t\treturn ret;\n\n\tcase -ENOBUFS: /* inode not in cache */\n\tcase -ENODATA: /* page not in cache */\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t\tdfprintk(FSCACHE,\n\t\t\t \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\treturn 1;\n\n\tdefault:\n\t\tdfprintk(FSCACHE, \"NFS:    readpage_from_fscache %d\\n\", ret);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_READ_FAIL);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nfs_open_context",
          "args": [
            "nfs_file_open_context(file)"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "803-808",
          "snippet": "struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_find_open_context",
          "args": [
            "inode",
            "NULL",
            "FMODE_READ"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_find_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "865-881",
          "snippet": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tbreak;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nstruct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & (FMODE_READ|FMODE_WRITE)) != mode)\n\t\t\tcontinue;\n\t\tctx = get_nfs_open_context(pos);\n\t\tbreak;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_STALE",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_wb_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1893-1925",
          "snippet": "int nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_READPAGES"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: nfs_readpage (%p %ld@%lu)\\n\"",
            "page",
            "PAGE_CACHE_SIZE",
            "page_file_index(page)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_index",
          "args": [
            "page"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nint nfs_readpage(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint\t\terror;\n\n\tdprintk(\"NFS: nfs_readpage (%p %ld@%lu)\\n\",\n\t\tpage, PAGE_CACHE_SIZE, page_file_index(page));\n\tnfs_inc_stats(inode, NFSIOS_VFSREADPAGE);\n\tnfs_inc_stats(inode, NFSIOS_READPAGES);\n\n\t/*\n\t * Try to flush any pending writes to the file..\n\t *\n\t * NOTE! Because we own the page lock, there cannot\n\t * be any new pending writes generated at this point\n\t * for this page (other pages can be written to).\n\t */\n\terror = nfs_wb_page(inode, page);\n\tif (error)\n\t\tgoto out_unlock;\n\tif (PageUptodate(page))\n\t\tgoto out_unlock;\n\n\terror = -ESTALE;\n\tif (NFS_STALE(inode))\n\t\tgoto out_unlock;\n\n\tif (file == NULL) {\n\t\terror = -EBADF;\n\t\tctx = nfs_find_open_context(inode, NULL, FMODE_READ);\n\t\tif (ctx == NULL)\n\t\t\tgoto out_unlock;\n\t} else\n\t\tctx = get_nfs_open_context(nfs_file_open_context(file));\n\n\tif (!IS_SYNC(inode)) {\n\t\terror = nfs_readpage_from_fscache(ctx, inode, page);\n\t\tif (error == 0)\n\t\t\tgoto out;\n\t}\n\n\terror = nfs_readpage_async(ctx, inode, page);\n\nout:\n\tput_nfs_open_context(ctx);\n\treturn error;\nout_unlock:\n\tunlock_page(page);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs_readpage_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "254-270",
    "snippet": "static void nfs_readpage_result(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tif (hdr->res.eof) {\n\t\tloff_t bound;\n\n\t\tbound = hdr->args.offset + hdr->res.count;\n\t\tspin_lock(&hdr->lock);\n\t\tif (bound < hdr->io_start + hdr->good_bytes) {\n\t\t\tset_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\t\tclear_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\t\thdr->good_bytes = bound - hdr->io_start;\n\t\t}\n\t\tspin_unlock(&hdr->lock);\n\t} else if (hdr->res.count != hdr->args.count)\n\t\tnfs_readpage_retry(task, hdr);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readpage_retry",
          "args": [
            "task",
            "hdr"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage_retry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "233-252",
          "snippet": "static void nfs_readpage_retry(struct rpc_task *task,\n\t\t\t       struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res  *resp = &hdr->res;\n\n\t/* This is a short read! */\n\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);\n\t/* Has the server at least made some progress? */\n\tif (resp->count == 0) {\n\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\treturn;\n\t}\n\t/* Yes, so retry the read at the end of the hdr */\n\thdr->mds_offset += resp->count;\n\targp->offset += resp->count;\n\targp->pgbase += resp->count;\n\targp->count -= resp->count;\n\trpc_restart_call_prepare(task);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_retry(struct rpc_task *task,\n\t\t\t       struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res  *resp = &hdr->res;\n\n\t/* This is a short read! */\n\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);\n\t/* Has the server at least made some progress? */\n\tif (resp->count == 0) {\n\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\treturn;\n\t}\n\t/* Yes, so retry the read at the end of the hdr */\n\thdr->mds_offset += resp->count;\n\targp->offset += resp->count;\n\targp->pgbase += resp->count;\n\targp->count -= resp->count;\n\trpc_restart_call_prepare(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&hdr->lock"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_IOHDR_ERROR",
            "&hdr->flags"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_IOHDR_EOF",
            "&hdr->flags"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&hdr->lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_result(struct rpc_task *task,\n\t\t\t\tstruct nfs_pgio_header *hdr)\n{\n\tif (hdr->res.eof) {\n\t\tloff_t bound;\n\n\t\tbound = hdr->args.offset + hdr->res.count;\n\t\tspin_lock(&hdr->lock);\n\t\tif (bound < hdr->io_start + hdr->good_bytes) {\n\t\t\tset_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\t\tclear_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\t\thdr->good_bytes = bound - hdr->io_start;\n\t\t}\n\t\tspin_unlock(&hdr->lock);\n\t} else if (hdr->res.count != hdr->args.count)\n\t\tnfs_readpage_retry(task, hdr);\n}"
  },
  {
    "function_name": "nfs_readpage_retry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "233-252",
    "snippet": "static void nfs_readpage_retry(struct rpc_task *task,\n\t\t\t       struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res  *resp = &hdr->res;\n\n\t/* This is a short read! */\n\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);\n\t/* Has the server at least made some progress? */\n\tif (resp->count == 0) {\n\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\treturn;\n\t}\n\t/* Yes, so retry the read at the end of the hdr */\n\thdr->mds_offset += resp->count;\n\targp->offset += resp->count;\n\targp->pgbase += resp->count;\n\targp->count -= resp->count;\n\trpc_restart_call_prepare(task);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_set_pgio_error",
          "args": [
            "hdr",
            "-EIO",
            "argp->offset"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_pgio_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "77-87",
          "snippet": "void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)\n{\n\tspin_lock(&hdr->lock);\n\tif (pos < hdr->io_start + hdr->good_bytes) {\n\t\tset_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\tclear_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\thdr->good_bytes = pos - hdr->io_start;\n\t\thdr->error = error;\n\t}\n\tspin_unlock(&hdr->lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)\n{\n\tspin_lock(&hdr->lock);\n\tif (pos < hdr->io_start + hdr->good_bytes) {\n\t\tset_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\tclear_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\thdr->good_bytes = pos - hdr->io_start;\n\t\thdr->error = error;\n\t}\n\tspin_unlock(&hdr->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "hdr->inode",
            "NFSIOS_SHORTREAD"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_retry(struct rpc_task *task,\n\t\t\t       struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res  *resp = &hdr->res;\n\n\t/* This is a short read! */\n\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);\n\t/* Has the server at least made some progress? */\n\tif (resp->count == 0) {\n\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\treturn;\n\t}\n\t/* Yes, so retry the read at the end of the hdr */\n\thdr->mds_offset += resp->count;\n\targp->offset += resp->count;\n\targp->pgbase += resp->count;\n\targp->count -= resp->count;\n\trpc_restart_call_prepare(task);\n}"
  },
  {
    "function_name": "nfs_readpage_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "216-231",
    "snippet": "static int nfs_readpage_done(struct rpc_task *task,\n\t\t\t     struct nfs_pgio_header *hdr,\n\t\t\t     struct inode *inode)\n{\n\tint status = NFS_PROTO(inode)->read_done(task, hdr);\n\tif (status != 0)\n\t\treturn status;\n\n\tnfs_add_stats(inode, NFSIOS_SERVERREADBYTES, hdr->res.count);\n\n\tif (task->tk_status == -ESTALE) {\n\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\tnfs_mark_for_revalidate(inode);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_INO_STALE",
            "&NFS_I(inode)->flags"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_SERVERREADBYTES",
            "hdr->res.count"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "hdr"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic int nfs_readpage_done(struct rpc_task *task,\n\t\t\t     struct nfs_pgio_header *hdr,\n\t\t\t     struct inode *inode)\n{\n\tint status = NFS_PROTO(inode)->read_done(task, hdr);\n\tif (status != 0)\n\t\treturn status;\n\n\tnfs_add_stats(inode, NFSIOS_SERVERREADBYTES, hdr->res.count);\n\n\tif (task->tk_status == -ESTALE) {\n\t\tset_bit(NFS_INO_STALE, &NFS_I(inode)->flags);\n\t\tnfs_mark_for_revalidate(inode);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_async_read_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "195-205",
    "snippet": "static void\nnfs_async_read_error(struct list_head *head)\n{\n\tstruct nfs_page\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_readpage_release(req);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_readpage_release",
          "args": [
            "req"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "118-133",
          "snippet": "static void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "head->next"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void\nnfs_async_read_error(struct list_head *head)\n{\n\tstruct nfs_page\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_readpage_release(req);\n\t}\n}"
  },
  {
    "function_name": "nfs_initiate_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "183-193",
    "snippet": "static void nfs_initiate_read(struct nfs_pgio_header *hdr,\n\t\t\t      struct rpc_message *msg,\n\t\t\t      const struct nfs_rpc_ops *rpc_ops,\n\t\t\t      struct rpc_task_setup *task_setup_data, int how)\n{\n\tstruct inode *inode = hdr->inode;\n\tint swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;\n\n\ttask_setup_data->flags |= swap_flags;\n\trpc_ops->read_setup(hdr, msg);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_ops->read_setup",
          "args": [
            "hdr",
            "msg"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SWAPFILE",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_initiate_read(struct nfs_pgio_header *hdr,\n\t\t\t      struct rpc_message *msg,\n\t\t\t      const struct nfs_rpc_ops *rpc_ops,\n\t\t\t      struct rpc_task_setup *task_setup_data, int how)\n{\n\tstruct inode *inode = hdr->inode;\n\tint swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;\n\n\ttask_setup_data->flags |= swap_flags;\n\trpc_ops->read_setup(hdr, msg);\n}"
  },
  {
    "function_name": "nfs_read_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "141-181",
    "snippet": "static void nfs_read_completion(struct nfs_pgio_header *hdr)\n{\n\tunsigned long bytes = 0;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\tgoto out;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\t\tstruct page *page = req->wb_page;\n\t\tunsigned long start = req->wb_pgbase;\n\t\tunsigned long end = req->wb_pgbase + req->wb_bytes;\n\n\t\tif (test_bit(NFS_IOHDR_EOF, &hdr->flags)) {\n\t\t\t/* note: regions of the page not covered by a\n\t\t\t * request are zeroed in nfs_readpage_async /\n\t\t\t * readpage_async_filler */\n\t\t\tif (bytes > hdr->good_bytes) {\n\t\t\t\t/* nothing in this request was good, so zero\n\t\t\t\t * the full extent of the request */\n\t\t\t\tzero_user_segment(page, start, end);\n\n\t\t\t} else if (hdr->good_bytes - bytes < req->wb_bytes) {\n\t\t\t\t/* part of this request has good bytes, but\n\t\t\t\t * not all. zero the bad bytes */\n\t\t\t\tstart += hdr->good_bytes - bytes;\n\t\t\t\tWARN_ON(start < req->wb_pgbase);\n\t\t\t\tzero_user_segment(page, start, end);\n\t\t\t}\n\t\t}\n\t\tbytes += req->wb_bytes;\n\t\tif (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {\n\t\t\tif (bytes <= hdr->good_bytes)\n\t\t\t\tnfs_page_group_set_uptodate(req);\n\t\t} else\n\t\t\tnfs_page_group_set_uptodate(req);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_readpage_release(req);\n\t}\nout:\n\thdr->release(hdr);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->release",
          "args": [
            "hdr"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_readpage_release",
          "args": [
            "req"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_readpage_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "118-133",
          "snippet": "static void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_set_uptodate",
          "args": [
            "req"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_set_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "135-139",
          "snippet": "static void nfs_page_group_set_uptodate(struct nfs_page *req)\n{\n\tif (nfs_page_group_sync_on_bit(req, PG_UPTODATE))\n\t\tSetPageUptodate(req->wb_page);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_page_group_set_uptodate(struct nfs_page *req)\n{\n\tif (nfs_page_group_sync_on_bit(req, PG_UPTODATE))\n\t\tSetPageUptodate(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_ERROR",
            "&hdr->flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "start",
            "end"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start < req->wb_pgbase"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "start",
            "end"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "hdr->pages.next"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&hdr->pages"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_read_completion(struct nfs_pgio_header *hdr)\n{\n\tunsigned long bytes = 0;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\tgoto out;\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\t\tstruct page *page = req->wb_page;\n\t\tunsigned long start = req->wb_pgbase;\n\t\tunsigned long end = req->wb_pgbase + req->wb_bytes;\n\n\t\tif (test_bit(NFS_IOHDR_EOF, &hdr->flags)) {\n\t\t\t/* note: regions of the page not covered by a\n\t\t\t * request are zeroed in nfs_readpage_async /\n\t\t\t * readpage_async_filler */\n\t\t\tif (bytes > hdr->good_bytes) {\n\t\t\t\t/* nothing in this request was good, so zero\n\t\t\t\t * the full extent of the request */\n\t\t\t\tzero_user_segment(page, start, end);\n\n\t\t\t} else if (hdr->good_bytes - bytes < req->wb_bytes) {\n\t\t\t\t/* part of this request has good bytes, but\n\t\t\t\t * not all. zero the bad bytes */\n\t\t\t\tstart += hdr->good_bytes - bytes;\n\t\t\t\tWARN_ON(start < req->wb_pgbase);\n\t\t\t\tzero_user_segment(page, start, end);\n\t\t\t}\n\t\t}\n\t\tbytes += req->wb_bytes;\n\t\tif (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {\n\t\t\tif (bytes <= hdr->good_bytes)\n\t\t\t\tnfs_page_group_set_uptodate(req);\n\t\t} else\n\t\t\tnfs_page_group_set_uptodate(req);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_readpage_release(req);\n\t}\nout:\n\thdr->release(hdr);\n}"
  },
  {
    "function_name": "nfs_page_group_set_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "135-139",
    "snippet": "static void nfs_page_group_set_uptodate(struct nfs_page *req)\n{\n\tif (nfs_page_group_sync_on_bit(req, PG_UPTODATE))\n\t\tSetPageUptodate(req->wb_page);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "req->wb_page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_sync_on_bit",
          "args": [
            "req",
            "PG_UPTODATE"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_sync_on_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "255-264",
          "snippet": "bool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_page_group_set_uptodate(struct nfs_page *req)\n{\n\tif (nfs_page_group_sync_on_bit(req, PG_UPTODATE))\n\t\tSetPageUptodate(req->wb_page);\n}"
  },
  {
    "function_name": "nfs_readpage_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "118-133",
    "snippet": "static void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "req->wb_page"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_readpage_to_fscache",
          "args": [
            "d_inode",
            "req->wb_page",
            "0"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs_readpage_to_fscache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "417-439",
          "snippet": "void __nfs_readpage_to_fscache(struct inode *inode, struct page *page, int sync)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_to_fscache(fsc:%p/p:%p(i:%lx f:%lx)/%d)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, sync);\n\n\tret = fscache_write_page(nfs_i_fscache(inode), page, GFP_KERNEL);\n\tdfprintk(FSCACHE,\n\t\t \"NFS:     readpage_to_fscache: p:%p(i:%lu f:%lx) ret %d\\n\",\n\t\t page, page->index, page->flags, ret);\n\n\tif (ret != 0) {\n\t\tfscache_uncache_page(nfs_i_fscache(inode), page);\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t} else {\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_OK);\n\t}\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nvoid __nfs_readpage_to_fscache(struct inode *inode, struct page *page, int sync)\n{\n\tint ret;\n\n\tdfprintk(FSCACHE,\n\t\t \"NFS: readpage_to_fscache(fsc:%p/p:%p(i:%lx f:%lx)/%d)\\n\",\n\t\t nfs_i_fscache(inode), page, page->index, page->flags, sync);\n\n\tret = fscache_write_page(nfs_i_fscache(inode), page, GFP_KERNEL);\n\tdfprintk(FSCACHE,\n\t\t \"NFS:     readpage_to_fscache: p:%p(i:%lu f:%lx) ret %d\\n\",\n\t\t page, page->index, page->flags, ret);\n\n\tif (ret != 0) {\n\t\tfscache_uncache_page(nfs_i_fscache(inode), page);\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_FAIL);\n\t\tnfs_inc_fscache_stats(inode, NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t} else {\n\t\tnfs_inc_fscache_stats(inode,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_WRITTEN_OK);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "req->wb_page"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_sync_on_bit",
          "args": [
            "req",
            "PG_UNLOCKPAGE"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_sync_on_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "255-264",
          "snippet": "bool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: read done (%s/%llu %d@%lld)\\n\"",
            "d_inode->i_sb->s_id",
            "(unsigned long long)NFS_FILEID(d_inode)",
            "req->wb_bytes",
            "(long long)req_offset(req)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "d_inode"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic void nfs_readpage_release(struct nfs_page *req)\n{\n\tstruct inode *d_inode = req->wb_context->dentry->d_inode;\n\n\tdprintk(\"NFS: read done (%s/%llu %d@%lld)\\n\", d_inode->i_sb->s_id,\n\t\t(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,\n\t\t(long long)req_offset(req));\n\n\tif (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {\n\t\tif (PageUptodate(req->wb_page))\n\t\t\tnfs_readpage_to_fscache(d_inode, req->wb_page, 0);\n\n\t\tunlock_page(req->wb_page);\n\t}\n\tnfs_release_request(req);\n}"
  },
  {
    "function_name": "nfs_readpage_async",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "85-116",
    "snippet": "int nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;",
      "static const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pgio.pg_mirror_count != 1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_complete",
          "args": [
            "&pgio"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1244-1254",
          "snippet": "void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_add_request",
          "args": [
            "&pgio",
            "new"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_add_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1138-1183",
          "snippet": "int nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_read",
          "args": [
            "&pgio",
            "inode",
            "false",
            "&nfs_async_read_completion_ops"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "55-68",
          "snippet": "void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_read_ops;",
            "static const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_rw_ops nfs_rw_read_ops;\nstatic const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};\n\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_create_request",
          "args": [
            "ctx",
            "page",
            "NULL",
            "0",
            "len"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "351-388",
          "snippet": "struct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_return_empty_page",
          "args": [
            "page"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_return_empty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
          "lines": "46-53",
          "snippet": "static\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops;\nstatic const struct nfs_pgio_completion_ops nfs_async_read_completion_ops = {\n\t.error_cleanup = nfs_async_read_error,\n\t.completion = nfs_read_completion,\n};\n\nint nfs_readpage_async(struct nfs_open_context *ctx, struct inode *inode,\n\t\t       struct page *page)\n{\n\tstruct nfs_page\t*new;\n\tunsigned int len;\n\tstruct nfs_pageio_descriptor pgio;\n\tstruct nfs_pgio_mirror *pgm;\n\n\tlen = nfs_page_length(page);\n\tif (len == 0)\n\t\treturn nfs_return_empty_page(page);\n\tnew = nfs_create_request(ctx, page, NULL, 0, len);\n\tif (IS_ERR(new)) {\n\t\tunlock_page(page);\n\t\treturn PTR_ERR(new);\n\t}\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\n\tnfs_pageio_init_read(&pgio, inode, false,\n\t\t\t     &nfs_async_read_completion_ops);\n\tnfs_pageio_add_request(&pgio, new);\n\tnfs_pageio_complete(&pgio);\n\n\t/* It doesn't make sense to do mirrored reads! */\n\tWARN_ON_ONCE(pgio.pg_mirror_count != 1);\n\n\tpgm = &pgio.pg_mirrors[0];\n\tNFS_I(inode)->read_io += pgm->pg_bytes_written;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_pageio_reset_read_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "71-82",
    "snippet": "void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "pgio->pg_inode"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pgio->pg_mirror_count != 1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nvoid nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\t/* read path should never have more than one mirror */\n\tWARN_ON_ONCE(pgio->pg_mirror_count != 1);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->rsize;\n}"
  },
  {
    "function_name": "nfs_pageio_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "55-68",
    "snippet": "void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_rw_ops nfs_rw_read_ops;",
      "static const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_init",
          "args": [
            "pgio",
            "inode",
            "pg_ops",
            "compl_ops",
            "&nfs_rw_read_ops",
            "server->rsize",
            "0"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "718-759",
          "snippet": "void nfs_pageio_init(struct nfs_pageio_descriptor *desc,\n\t\t     struct inode *inode,\n\t\t     const struct nfs_pageio_ops *pg_ops,\n\t\t     const struct nfs_pgio_completion_ops *compl_ops,\n\t\t     const struct nfs_rw_ops *rw_ops,\n\t\t     size_t bsize,\n\t\t     int io_flags)\n{\n\tstruct nfs_pgio_mirror *new;\n\tint i;\n\n\tdesc->pg_moreio = 0;\n\tdesc->pg_inode = inode;\n\tdesc->pg_ops = pg_ops;\n\tdesc->pg_completion_ops = compl_ops;\n\tdesc->pg_rw_ops = rw_ops;\n\tdesc->pg_ioflags = io_flags;\n\tdesc->pg_error = 0;\n\tdesc->pg_lseg = NULL;\n\tdesc->pg_dreq = NULL;\n\tdesc->pg_layout_private = NULL;\n\tdesc->pg_bsize = bsize;\n\n\tdesc->pg_mirror_count = 1;\n\tdesc->pg_mirror_idx = 0;\n\n\tif (pg_ops->pg_get_mirror_count) {\n\t\t/* until we have a request, we don't have an lseg and no\n\t\t * idea how many mirrors there will be */\n\t\tnew = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,\n\t\t\t      sizeof(struct nfs_pgio_mirror), GFP_KERNEL);\n\t\tdesc->pg_mirrors_dynamic = new;\n\t\tdesc->pg_mirrors = new;\n\n\t\tfor (i = 0; i < NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)\n\t\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[i], bsize);\n\t} else {\n\t\tdesc->pg_mirrors_dynamic = NULL;\n\t\tdesc->pg_mirrors = desc->pg_mirrors_static;\n\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[0], bsize);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_init(struct nfs_pageio_descriptor *desc,\n\t\t     struct inode *inode,\n\t\t     const struct nfs_pageio_ops *pg_ops,\n\t\t     const struct nfs_pgio_completion_ops *compl_ops,\n\t\t     const struct nfs_rw_ops *rw_ops,\n\t\t     size_t bsize,\n\t\t     int io_flags)\n{\n\tstruct nfs_pgio_mirror *new;\n\tint i;\n\n\tdesc->pg_moreio = 0;\n\tdesc->pg_inode = inode;\n\tdesc->pg_ops = pg_ops;\n\tdesc->pg_completion_ops = compl_ops;\n\tdesc->pg_rw_ops = rw_ops;\n\tdesc->pg_ioflags = io_flags;\n\tdesc->pg_error = 0;\n\tdesc->pg_lseg = NULL;\n\tdesc->pg_dreq = NULL;\n\tdesc->pg_layout_private = NULL;\n\tdesc->pg_bsize = bsize;\n\n\tdesc->pg_mirror_count = 1;\n\tdesc->pg_mirror_idx = 0;\n\n\tif (pg_ops->pg_get_mirror_count) {\n\t\t/* until we have a request, we don't have an lseg and no\n\t\t * idea how many mirrors there will be */\n\t\tnew = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,\n\t\t\t      sizeof(struct nfs_pgio_mirror), GFP_KERNEL);\n\t\tdesc->pg_mirrors_dynamic = new;\n\t\tdesc->pg_mirrors = new;\n\n\t\tfor (i = 0; i < NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)\n\t\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[i], bsize);\n\t} else {\n\t\tdesc->pg_mirrors_dynamic = NULL;\n\t\tdesc->pg_mirrors = desc->pg_mirrors_static;\n\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[0], bsize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic const struct nfs_rw_ops nfs_rw_read_ops;\nstatic const struct nfs_rw_ops nfs_rw_read_ops = {\n\t.rw_mode\t\t= FMODE_READ,\n\t.rw_alloc_header\t= nfs_readhdr_alloc,\n\t.rw_free_header\t\t= nfs_readhdr_free,\n\t.rw_done\t\t= nfs_readpage_done,\n\t.rw_result\t\t= nfs_readpage_result,\n\t.rw_initiate\t\t= nfs_initiate_read,\n};\n\nvoid nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,\n\t\t\t      struct inode *inode, bool force_mds,\n\t\t\t      const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_read_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_read_ops,\n\t\t\tserver->rsize, 0);\n}"
  },
  {
    "function_name": "nfs_return_empty_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "46-53",
    "snippet": "static\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic\nint nfs_return_empty_page(struct page *page)\n{\n\tzero_user(page, 0, PAGE_CACHE_SIZE);\n\tSetPageUptodate(page);\n\tunlock_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_readhdr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "41-44",
    "snippet": "static void nfs_readhdr_free(struct nfs_pgio_header *rhdr)\n{\n\tkmem_cache_free(nfs_rdata_cachep, rhdr);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs_rdata_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs_rdata_cachep",
            "rhdr"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *nfs_rdata_cachep;\n\nstatic void nfs_readhdr_free(struct nfs_pgio_header *rhdr)\n{\n\tkmem_cache_free(nfs_rdata_cachep, rhdr);\n}"
  },
  {
    "function_name": "nfs_readhdr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/read.c",
    "lines": "36-39",
    "snippet": "static struct nfs_pgio_header *nfs_readhdr_alloc(void)\n{\n\treturn kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"nfs4_fs.h\"",
      "#include <linux/module.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs_rdata_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "nfs_rdata_cachep",
            "GFP_KERNEL"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"nfs4_fs.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *nfs_rdata_cachep;\n\nstatic struct nfs_pgio_header *nfs_readhdr_alloc(void)\n{\n\treturn kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);\n}"
  }
]