[
  {
    "function_name": "cifs_dir_needs_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "1011-1015",
    "snippet": "static bool\ncifs_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->srch_inf.endOfSearch && !cfile->invalidHandle;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\ncifs_dir_needs_close(struct cifsFileInfo *cfile)\n{\n\treturn !cfile->srch_inf.endOfSearch && !cfile->invalidHandle;\n}"
  },
  {
    "function_name": "cifs_wp_retry_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "1005-1009",
    "snippet": "static unsigned int\ncifs_wp_retry_size(struct inode *inode)\n{\n\treturn CIFS_SB(inode->i_sb)->wsize;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_wp_retry_size(struct inode *inode)\n{\n\treturn CIFS_SB(inode->i_sb)->wsize;\n}"
  },
  {
    "function_name": "cifs_is_read_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "999-1003",
    "snippet": "static bool\ncifs_is_read_op(__u32 oplock)\n{\n\treturn oplock == OPLOCK_READ;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\ncifs_is_read_op(__u32 oplock)\n{\n\treturn oplock == OPLOCK_READ;\n}"
  },
  {
    "function_name": "cifs_query_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "948-997",
    "snippet": "static int\ncifs_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, char **target_path,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, full_path);\n\n\t/* Check for unix extensions */\n\tif (cap_unix(tcon->ses)) {\n\t\trc = CIFSSMBUnixQuerySymLink(xid, tcon, full_path, target_path,\n\t\t\t\t\t     cifs_sb->local_nls);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = cifs_unix_dfs_readlink(xid, tcon, full_path,\n\t\t\t\t\t\t    target_path,\n\t\t\t\t\t\t    cifs_sb->local_nls);\n\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.create_options = OPEN_REPARSE_POINT;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = CIFSSMBQuerySymLink(xid, tcon, fid.netfid, target_path,\n\t\t\t\t cifs_sb->local_nls);\n\tif (rc)\n\t\tgoto out_close;\n\n\tconvert_delimiter(*target_path, '/');\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tif (!rc)\n\t\tcifs_dbg(FYI, \"%s: target path: %s\\n\", __func__, *target_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: target path: %s\\n\"",
            "__func__",
            "*target_path"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "*target_path",
            "'/'"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQuerySymLink",
          "args": [
            "xid",
            "tcon",
            "fid.netfid",
            "target_path",
            "cifs_sb->local_nls"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQuerySymLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3138-3259",
          "snippet": "int\nCIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid, char **symlinkinfo,\n\t\t    const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\tbool is_unicode;\n\tunsigned int sub_len;\n\tchar *sub_start;\n\tstruct reparse_symlink_data *reparse_buf;\n\tstruct reparse_posix_data *posix_buf;\n\t__u32 data_offset, data_count;\n\tchar *end_of_smb;\n\n\tcifs_dbg(FYI, \"In Windows reparse style QueryLink for fid %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryReparseLinkInfo = %d\\n\", rc);\n\t\tgoto qreparse_out;\n\t}\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t/* BB also check enough total bytes returned */\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto qreparse_out;\n\t}\n\tif (!data_count || (data_count > 2048)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Invalid return data count on get reparse info ioctl\\n\");\n\t\tgoto qreparse_out;\n\t}\n\tend_of_smb = 2 + get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\treparse_buf = (struct reparse_symlink_data *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\tif ((char *)reparse_buf >= end_of_smb) {\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (reparse_buf->ReparseTag == cpu_to_le32(IO_REPARSE_TAG_NFS)) {\n\t\tcifs_dbg(FYI, \"NFS style reparse tag\\n\");\n\t\tposix_buf =  (struct reparse_posix_data *)reparse_buf;\n\n\t\tif (posix_buf->InodeType != cpu_to_le64(NFS_SPECFILE_LNK)) {\n\t\t\tcifs_dbg(FYI, \"unsupported file type 0x%llx\\n\",\n\t\t\t\t le64_to_cpu(posix_buf->InodeType));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tis_unicode = true;\n\t\tsub_len = le16_to_cpu(reparse_buf->ReparseDataLength);\n\t\tif (posix_buf->PathBuffer + sub_len > end_of_smb) {\n\t\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\t*symlinkinfo = cifs_strndup_from_utf16(posix_buf->PathBuffer,\n\t\t\t\tsub_len, is_unicode, nls_codepage);\n\t\tgoto qreparse_out;\n\t} else if (reparse_buf->ReparseTag !=\n\t\t\tcpu_to_le32(IO_REPARSE_TAG_SYMLINK)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto qreparse_out;\n\t}\n\n\t/* Reparse tag is NTFS symlink */\n\tsub_start = le16_to_cpu(reparse_buf->SubstituteNameOffset) +\n\t\t\t\treparse_buf->PathBuffer;\n\tsub_len = le16_to_cpu(reparse_buf->SubstituteNameLength);\n\tif (sub_start + sub_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\n\t/* BB FIXME investigate remapping reserved chars here */\n\t*symlinkinfo = cifs_strndup_from_utf16(sub_start, sub_len, is_unicode,\n\t\t\t\t\t       nls_codepage);\n\tif (!*symlinkinfo)\n\t\trc = -ENOMEM;\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid, char **symlinkinfo,\n\t\t    const struct nls_table *nls_codepage)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\tbool is_unicode;\n\tunsigned int sub_len;\n\tchar *sub_start;\n\tstruct reparse_symlink_data *reparse_buf;\n\tstruct reparse_posix_data *posix_buf;\n\t__u32 data_offset, data_count;\n\tchar *end_of_smb;\n\n\tcifs_dbg(FYI, \"In Windows reparse style QueryLink for fid %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->TotalParameterCount = 0 ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le32(2);\n\t/* BB find exact data count max from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le32(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_GET_REPARSE_POINT);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\tpSMB->ByteCount = 0;\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryReparseLinkInfo = %d\\n\", rc);\n\t\tgoto qreparse_out;\n\t}\n\n\tdata_offset = le32_to_cpu(pSMBr->DataOffset);\n\tdata_count = le32_to_cpu(pSMBr->DataCount);\n\tif (get_bcc(&pSMBr->hdr) < 2 || data_offset > 512) {\n\t\t/* BB also check enough total bytes returned */\n\t\trc = -EIO;\t/* bad smb */\n\t\tgoto qreparse_out;\n\t}\n\tif (!data_count || (data_count > 2048)) {\n\t\trc = -EIO;\n\t\tcifs_dbg(FYI, \"Invalid return data count on get reparse info ioctl\\n\");\n\t\tgoto qreparse_out;\n\t}\n\tend_of_smb = 2 + get_bcc(&pSMBr->hdr) + (char *)&pSMBr->ByteCount;\n\treparse_buf = (struct reparse_symlink_data *)\n\t\t\t\t((char *)&pSMBr->hdr.Protocol + data_offset);\n\tif ((char *)reparse_buf >= end_of_smb) {\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (reparse_buf->ReparseTag == cpu_to_le32(IO_REPARSE_TAG_NFS)) {\n\t\tcifs_dbg(FYI, \"NFS style reparse tag\\n\");\n\t\tposix_buf =  (struct reparse_posix_data *)reparse_buf;\n\n\t\tif (posix_buf->InodeType != cpu_to_le64(NFS_SPECFILE_LNK)) {\n\t\t\tcifs_dbg(FYI, \"unsupported file type 0x%llx\\n\",\n\t\t\t\t le64_to_cpu(posix_buf->InodeType));\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\tis_unicode = true;\n\t\tsub_len = le16_to_cpu(reparse_buf->ReparseDataLength);\n\t\tif (posix_buf->PathBuffer + sub_len > end_of_smb) {\n\t\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto qreparse_out;\n\t\t}\n\t\t*symlinkinfo = cifs_strndup_from_utf16(posix_buf->PathBuffer,\n\t\t\t\tsub_len, is_unicode, nls_codepage);\n\t\tgoto qreparse_out;\n\t} else if (reparse_buf->ReparseTag !=\n\t\t\tcpu_to_le32(IO_REPARSE_TAG_SYMLINK)) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto qreparse_out;\n\t}\n\n\t/* Reparse tag is NTFS symlink */\n\tsub_start = le16_to_cpu(reparse_buf->SubstituteNameOffset) +\n\t\t\t\treparse_buf->PathBuffer;\n\tsub_len = le16_to_cpu(reparse_buf->SubstituteNameLength);\n\tif (sub_start + sub_len > end_of_smb) {\n\t\tcifs_dbg(FYI, \"reparse buf beyond SMB\\n\");\n\t\trc = -EIO;\n\t\tgoto qreparse_out;\n\t}\n\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\tis_unicode = true;\n\telse\n\t\tis_unicode = false;\n\n\t/* BB FIXME investigate remapping reserved chars here */\n\t*symlinkinfo = cifs_strndup_from_utf16(sub_start, sub_len, is_unicode,\n\t\t\t\t\t       nls_codepage);\n\tif (!*symlinkinfo)\n\t\trc = -ENOMEM;\nqreparse_out:\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_unix_dfs_readlink",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "target_path",
            "cifs_sb->local_nls"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_unix_dfs_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "921-946",
          "snippet": "static int\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const unsigned char *searchName, char **symlinkinfo,\n\t\t       const struct nls_table *nls_codepage)\n{\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\n\trc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage,\n\t\t\t  &num_referrals, &referrals, 0);\n\n\tif (!rc && num_referrals > 0) {\n\t\t*symlinkinfo = kstrndup(referrals->node_name,\n\t\t\t\t\tstrlen(referrals->node_name),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!*symlinkinfo)\n\t\t\trc = -ENOMEM;\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\t}\n\treturn rc;\n#else /* No DFS support */\n\treturn -EREMOTE;\n#endif\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const unsigned char *searchName, char **symlinkinfo,\n\t\t       const struct nls_table *nls_codepage)\n{\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\n\trc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage,\n\t\t\t  &num_referrals, &referrals, 0);\n\n\tif (!rc && num_referrals > 0) {\n\t\t*symlinkinfo = kstrndup(referrals->node_name,\n\t\t\t\t\tstrlen(referrals->node_name),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!*symlinkinfo)\n\t\t\trc = -ENOMEM;\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\t}\n\treturn rc;\n#else /* No DFS support */\n\treturn -EREMOTE;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixQuerySymLink",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "target_path",
            "cifs_sb->local_nls"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixQuerySymLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3034-3126",
          "snippet": "int\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcifs_dbg(FYI, \"In QPathSymLinkInfo (Unix) for path %s\\n\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifs_strtoUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySymLinkInfo = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_utf16(data_start,\n\t\t\t\t\tcount, is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixQuerySymLink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tconst unsigned char *searchName, char **symlinkinfo,\n\t\t\tconst struct nls_table *nls_codepage)\n{\n/* SMB_QUERY_FILE_UNIX_LINK */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\tchar *data_start;\n\n\tcifs_dbg(FYI, \"In QPathSymLinkInfo (Unix) for path %s\\n\", searchName);\n\nquerySymLinkRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifs_strtoUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t\tPATH_MAX, nls_codepage);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_LINK);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QuerySymLinkInfo = %d\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\tbool is_unicode;\n\t\t\tu16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\n\t\t\tdata_start = ((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t\t   le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tis_unicode = true;\n\t\t\telse\n\t\t\t\tis_unicode = false;\n\n\t\t\t/* BB FIXME investigate remapping reserved chars here */\n\t\t\t*symlinkinfo = cifs_strndup_from_utf16(data_start,\n\t\t\t\t\tcount, is_unicode, nls_codepage);\n\t\t\tif (!*symlinkinfo)\n\t\t\t\trc = -ENOMEM;\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto querySymLinkRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: path: %s\\n\"",
            "__func__",
            "full_path"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *full_path, char **target_path,\n\t\t   struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tint oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\n\tcifs_dbg(FYI, \"%s: path: %s\\n\", __func__, full_path);\n\n\t/* Check for unix extensions */\n\tif (cap_unix(tcon->ses)) {\n\t\trc = CIFSSMBUnixQuerySymLink(xid, tcon, full_path, target_path,\n\t\t\t\t\t     cifs_sb->local_nls);\n\t\tif (rc == -EREMOTE)\n\t\t\trc = cifs_unix_dfs_readlink(xid, tcon, full_path,\n\t\t\t\t\t\t    target_path,\n\t\t\t\t\t\t    cifs_sb->local_nls);\n\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\toparms.create_options = OPEN_REPARSE_POINT;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\trc = CIFSSMBQuerySymLink(xid, tcon, fid.netfid, target_path,\n\t\t\t\t cifs_sb->local_nls);\n\tif (rc)\n\t\tgoto out_close;\n\n\tconvert_delimiter(*target_path, '/');\nout_close:\n\tCIFSSMBClose(xid, tcon, fid.netfid);\nout:\n\tif (!rc)\n\t\tcifs_dbg(FYI, \"%s: target path: %s\\n\", __func__, *target_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_unix_dfs_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "921-946",
    "snippet": "static int\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const unsigned char *searchName, char **symlinkinfo,\n\t\t       const struct nls_table *nls_codepage)\n{\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\n\trc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage,\n\t\t\t  &num_referrals, &referrals, 0);\n\n\tif (!rc && num_referrals > 0) {\n\t\t*symlinkinfo = kstrndup(referrals->node_name,\n\t\t\t\t\tstrlen(referrals->node_name),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!*symlinkinfo)\n\t\t\trc = -ENOMEM;\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\t}\n\treturn rc;\n#else /* No DFS support */\n\treturn -EREMOTE;\n#endif\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_dfs_info_array",
          "args": [
            "referrals",
            "num_referrals"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "free_dfs_info_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1387-1398",
          "snippet": "static inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "referrals->node_name",
            "strlen(referrals->node_name)",
            "GFP_KERNEL"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "referrals->node_name"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dfs_path",
          "args": [
            "xid",
            "tcon->ses",
            "searchName",
            "nls_codepage",
            "&num_referrals",
            "&referrals",
            "0"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "get_dfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2768-2807",
          "snippet": "int\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_unix_dfs_readlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const unsigned char *searchName, char **symlinkinfo,\n\t\t       const struct nls_table *nls_codepage)\n{\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\n\trc = get_dfs_path(xid, tcon->ses, searchName, nls_codepage,\n\t\t\t  &num_referrals, &referrals, 0);\n\n\tif (!rc && num_referrals > 0) {\n\t\t*symlinkinfo = kstrndup(referrals->node_name,\n\t\t\t\t\tstrlen(referrals->node_name),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!*symlinkinfo)\n\t\t\trc = -ENOMEM;\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\t}\n\treturn rc;\n#else /* No DFS support */\n\treturn -EREMOTE;\n#endif\n}"
  },
  {
    "function_name": "cifs_mand_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "912-919",
    "snippet": "static int\ncifs_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\treturn CIFSSMBLock(xid, tlink_tcon(cfile->tlink), cfile->fid.netfid,\n\t\t\t   current->tgid, length, offset, unlock, lock,\n\t\t\t   (__u8)type, wait, 0);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBLock",
          "args": [
            "xid",
            "tlink_tcon(cfile->tlink)",
            "cfile->fid.netfid",
            "current->tgid",
            "length",
            "offset",
            "unlock",
            "lock",
            "(__u8)type",
            "wait",
            "0"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2306-2375",
          "snippet": "int\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "cfile->tlink"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_mand_lock(const unsigned int xid, struct cifsFileInfo *cfile, __u64 offset,\n\t       __u64 length, __u32 type, int lock, int unlock, bool wait)\n{\n\treturn CIFSSMBLock(xid, tlink_tcon(cfile->tlink), cfile->fid.netfid,\n\t\t\t   current->tgid, length, offset, unlock, lock,\n\t\t\t   (__u8)type, wait, 0);\n}"
  },
  {
    "function_name": "cifs_queryfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "880-910",
    "snippet": "static int\ncifs_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct kstatfs *buf)\n{\n\tint rc = -EOPNOTSUPP;\n\n\tbuf->f_type = CIFS_MAGIC_NUMBER;\n\n\t/*\n\t * We could add a second check for a QFS Unix capability bit\n\t */\n\tif ((tcon->ses->capabilities & CAP_UNIX) &&\n\t    (CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))\n\t\trc = CIFSSMBQFSPosixInfo(xid, tcon, buf);\n\n\t/*\n\t * Only need to call the old QFSInfo if failed on newer one,\n\t * e.g. by OS/2.\n\t **/\n\tif (rc && (tcon->ses->capabilities & CAP_NT_SMBS))\n\t\trc = CIFSSMBQFSInfo(xid, tcon, buf);\n\n\t/*\n\t * Some old Windows servers also do not support level 103, retry with\n\t * older level one if old server failed the previous call or we\n\t * bypassed it because we detected that this was an older LANMAN sess\n\t */\n\tif (rc)\n\t\trc = SMBOldQFSInfo(xid, tcon, buf);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SMBOldQFSInfo",
          "args": [
            "xid",
            "tcon",
            "buf"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "SMBOldQFSInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4981-5059",
          "snippet": "int\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"OldQFSInfo\\n\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcifs_dbg(FYI, \"qfsinf resp BCC: %d  Offset %d\\n\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBOldQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t      struct kstatfs *FSData)\n{\n/* level 0x01 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ALLOC_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"OldQFSInfo\\n\");\noldQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;     /* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_ALLOCATION);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 18)\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tcifs_dbg(FYI, \"qfsinf resp BCC: %d  Offset %d\\n\",\n\t\t\t\t get_bcc(&pSMBr->hdr), data_offset);\n\n\t\t\tresponse_data = (FILE_SYSTEM_ALLOC_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) + data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\tle16_to_cpu(response_data->BytesPerSector) *\n\t\t\t\tle32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t       le32_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t\tle32_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto oldQFSInfoRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQFSInfo",
          "args": [
            "xid",
            "tcon",
            "buf"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5061-5139",
          "snippet": "int\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSInfo\\n\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct kstatfs *FSData)\n{\n/* level 0x103 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSInfo\\n\");\nQFSInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_SIZE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t    le32_to_cpu(response_data->BytesPerSector) *\n\t\t\t    le32_to_cpu(response_data->\n\t\t\t\t\tSectorsPerAllocationUnit);\n\t\t\tFSData->f_blocks =\n\t\t\t    le64_to_cpu(response_data->TotalAllocationUnits);\n\t\t\tFSData->f_bfree = FSData->f_bavail =\n\t\t\t    le64_to_cpu(response_data->FreeAllocationUnits);\n\t\t\tcifs_dbg(FYI, \"Blocks: %lld  Free: %lld Block size %ld\\n\",\n\t\t\t\t (unsigned long long)FSData->f_blocks,\n\t\t\t\t (unsigned long long)FSData->f_bfree,\n\t\t\t\t FSData->f_bsize);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSInfoRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQFSPosixInfo",
          "args": [
            "xid",
            "tcon",
            "buf"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSPosixInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5426-5510",
          "snippet": "int\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSPosixInfo\\n\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSPosixInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct kstatfs *FSData)\n{\n/* level 0x201  SMB_QUERY_CIFS_POSIX_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_POSIX_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSPosixInfo\\n\");\nQFSPosixRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(100);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(struct\n\t\t\tsmb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_POSIX_FS_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSUnixInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_POSIX_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tFSData->f_bsize =\n\t\t\t\t\tle32_to_cpu(response_data->BlockSize);\n\t\t\tFSData->f_blocks =\n\t\t\t\t\tle64_to_cpu(response_data->TotalBlocks);\n\t\t\tFSData->f_bfree =\n\t\t\t    le64_to_cpu(response_data->BlocksAvail);\n\t\t\tif (response_data->UserBlocksAvail == cpu_to_le64(-1)) {\n\t\t\t\tFSData->f_bavail = FSData->f_bfree;\n\t\t\t} else {\n\t\t\t\tFSData->f_bavail =\n\t\t\t\t    le64_to_cpu(response_data->UserBlocksAvail);\n\t\t\t}\n\t\t\tif (response_data->TotalFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_files =\n\t\t\t\t     le64_to_cpu(response_data->TotalFileNodes);\n\t\t\tif (response_data->FreeFileNodes != cpu_to_le64(-1))\n\t\t\t\tFSData->f_ffree =\n\t\t\t\t      le64_to_cpu(response_data->FreeFileNodes);\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSPosixRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct kstatfs *buf)\n{\n\tint rc = -EOPNOTSUPP;\n\n\tbuf->f_type = CIFS_MAGIC_NUMBER;\n\n\t/*\n\t * We could add a second check for a QFS Unix capability bit\n\t */\n\tif ((tcon->ses->capabilities & CAP_UNIX) &&\n\t    (CIFS_POSIX_EXTENSIONS & le64_to_cpu(tcon->fsUnixInfo.Capability)))\n\t\trc = CIFSSMBQFSPosixInfo(xid, tcon, buf);\n\n\t/*\n\t * Only need to call the old QFSInfo if failed on newer one,\n\t * e.g. by OS/2.\n\t **/\n\tif (rc && (tcon->ses->capabilities & CAP_NT_SMBS))\n\t\trc = CIFSSMBQFSInfo(xid, tcon, buf);\n\n\t/*\n\t * Some old Windows servers also do not support level 103, retry with\n\t * older level one if old server failed the previous call or we\n\t * bypassed it because we detected that this was an older LANMAN sess\n\t */\n\tif (rc)\n\t\trc = SMBOldQFSInfo(xid, tcon, buf);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_oplock_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "871-878",
    "snippet": "static int\ncifs_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\n\t\t     struct cifsInodeInfo *cinode)\n{\n\treturn CIFSSMBLock(0, tcon, fid->netfid, current->tgid, 0, 0, 0, 0,\n\t\t\t   LOCKING_ANDX_OPLOCK_RELEASE, false,\n\t\t\t   CIFS_CACHE_READ(cinode) ? 1 : 0);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBLock",
          "args": [
            "0",
            "tcon",
            "fid->netfid",
            "current->tgid",
            "0",
            "0",
            "0",
            "0",
            "LOCKING_ANDX_OPLOCK_RELEASE",
            "false",
            "CIFS_CACHE_READ(cinode) ? 1 : 0"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2306-2375",
          "snippet": "int\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBLock(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const __u16 smb_file_id, const __u32 netpid, const __u64 len,\n\t    const __u64 offset, const __u32 numUnlock,\n\t    const __u32 numLock, const __u8 lockType,\n\t    const bool waitFlag, const __u8 oplock_level)\n{\n\tint rc = 0;\n\tLOCK_REQ *pSMB = NULL;\n/*\tLOCK_RSP *pSMBr = NULL; */ /* No response data other than rc to parse */\n\tint bytes_returned;\n\tint flags = 0;\n\t__u16 count;\n\n\tcifs_dbg(FYI, \"CIFSSMBLock timeout %d numLock %d\\n\",\n\t\t (int)waitFlag, numLock);\n\trc = small_smb_init(SMB_COM_LOCKING_ANDX, 8, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (lockType == LOCKING_ANDX_OPLOCK_RELEASE) {\n\t\t/* no response expected */\n\t\tflags = CIFS_ASYNC_OP | CIFS_OBREAK_OP;\n\t\tpSMB->Timeout = 0;\n\t} else if (waitFlag) {\n\t\tflags = CIFS_BLOCKING_OP; /* blocking operation, no timeout */\n\t\tpSMB->Timeout = cpu_to_le32(-1);/* blocking - do not time out */\n\t} else {\n\t\tpSMB->Timeout = 0;\n\t}\n\n\tpSMB->NumberOfLocks = cpu_to_le16(numLock);\n\tpSMB->NumberOfUnlocks = cpu_to_le16(numUnlock);\n\tpSMB->LockType = lockType;\n\tpSMB->OplockLevel = oplock_level;\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = smb_file_id; /* netfid stays le */\n\n\tif ((numLock != 0) || (numUnlock != 0)) {\n\t\tpSMB->Locks[0].Pid = cpu_to_le16(netpid);\n\t\t/* BB where to store pid high? */\n\t\tpSMB->Locks[0].LengthLow = cpu_to_le32((u32)len);\n\t\tpSMB->Locks[0].LengthHigh = cpu_to_le32((u32)(len>>32));\n\t\tpSMB->Locks[0].OffsetLow = cpu_to_le32((u32)offset);\n\t\tpSMB->Locks[0].OffsetHigh = cpu_to_le32((u32)(offset>>32));\n\t\tcount = sizeof(LOCKING_ANDX_RANGE);\n\t} else {\n\t\t/* oplock break */\n\t\tcount = 0;\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\tif (waitFlag) {\n\t\trc = SendReceiveBlockingLock(xid, tcon, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMB, &bytes_returned);\n\t\tcifs_small_buf_release(pSMB);\n\t} else {\n\t\trc = SendReceiveNoRsp(xid, tcon->ses, (char *)pSMB, flags);\n\t\t/* SMB buffer freed by function above */\n\t}\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Lock = %d\\n\", rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,\n\t\t     struct cifsInodeInfo *cinode)\n{\n\treturn CIFSSMBLock(0, tcon, fid->netfid, current->tgid, 0, 0, 0, 0,\n\t\t\t   LOCKING_ANDX_OPLOCK_RELEASE, false,\n\t\t\t   CIFS_CACHE_READ(cinode) ? 1 : 0);\n}"
  },
  {
    "function_name": "cifs_close_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "864-869",
    "snippet": "static int\ncifs_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn CIFSFindClose(xid, tcon, fid->netfid);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSFindClose",
          "args": [
            "xid",
            "tcon",
            "fid->netfid"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSFindClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4635-4665",
          "snippet": "int\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcifs_dbg(FYI, \"In CIFSSMBFindClose\\n\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in FindClose = %d\\n\", rc);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSFindClose(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const __u16 searchHandle)\n{\n\tint rc = 0;\n\tFINDCLOSE_REQ *pSMB = NULL;\n\n\tcifs_dbg(FYI, \"In CIFSSMBFindClose\\n\");\n\trc = small_smb_init(SMB_COM_FIND_CLOSE2, 1, tcon, (void **)&pSMB);\n\n\t/* no sense returning error if session restarted\n\t\tas file handle has been closed */\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = searchHandle;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in FindClose = %d\\n\", rc);\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fclose);\n\n\t/* Since session is dead, search handle closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_close_dir(const unsigned int xid, struct cifs_tcon *tcon,\n\t       struct cifs_fid *fid)\n{\n\treturn CIFSFindClose(xid, tcon, fid->netfid);\n}"
  },
  {
    "function_name": "cifs_query_dir_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "856-862",
    "snippet": "static int\ncifs_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn CIFSFindNext(xid, tcon, fid->netfid, search_flags, srch_inf);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSFindNext",
          "args": [
            "xid",
            "tcon",
            "fid->netfid",
            "search_flags",
            "srch_inf"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSFindNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4500-4633",
          "snippet": "int CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, __u16 search_flags,\n\t\t struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In FindNext\\n\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcifs_dbg(FYI, \"FindNext returned = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cifs_dbg(FYI, \"fnxt2 entries in buf %d index_of_last %d\\n\",\n    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint CIFSFindNext(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u16 searchHandle, __u16 search_flags,\n\t\t struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In FindNext\\n\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcifs_dbg(FYI, \"FindNext returned = %d\\n\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cifs_dbg(FYI, \"fnxt2 entries in buf %d index_of_last %d\\n\",\n    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_query_dir_next(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    struct cifs_fid *fid, __u16 search_flags,\n\t\t    struct cifs_search_info *srch_inf)\n{\n\treturn CIFSFindNext(xid, tcon, fid->netfid, search_flags, srch_inf);\n}"
  },
  {
    "function_name": "cifs_query_dir_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "846-854",
    "snippet": "static int\ncifs_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\treturn CIFSFindFirst(xid, tcon, path, cifs_sb,\n\t\t\t     &fid->netfid, search_flags, srch_inf, true);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSFindFirst",
          "args": [
            "xid",
            "tcon",
            "path",
            "cifs_sb",
            "&fid->netfid",
            "search_flags",
            "srch_inf",
            "true"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSFindFirst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4345-4498",
          "snippet": "int\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSFindFirst(const unsigned int xid, struct cifs_tcon *tcon,\n\t      const char *searchName, struct cifs_sb_info *cifs_sb,\n\t      __u16 *pnetfid, __u16 search_flags,\n\t      struct cifs_search_info *psrch_inf, bool msearch)\n{\n/* level 257 SMB_ */\n\tTRANSACTION2_FFIRST_REQ *pSMB = NULL;\n\tTRANSACTION2_FFIRST_RSP *pSMBr = NULL;\n\tT2_FFIRST_RSP_PARMS *parms;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tint name_len, remap;\n\t__u16 params, byte_count;\n\tstruct nls_table *nls_codepage;\n\n\tcifs_dbg(FYI, \"In FindFirst for %s\\n\", searchName);\n\nfindFirstRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tnls_codepage = cifs_sb->local_nls;\n\tremap = cifs_remap(cifs_sb);\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, searchName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\t/* We can not add the asterik earlier in case\n\t\tit got remapped to 0xF03A as if it were part of the\n\t\tdirectory name instead of a wildcard */\n\t\tname_len *= 2;\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tpSMB->FileName[name_len+2] = '*';\n\t\t\tpSMB->FileName[name_len+3] = 0;\n\t\t\tname_len += 4; /* now the trailing null */\n\t\t\t/* null terminate just in case */\n\t\t\tpSMB->FileName[name_len] = 0;\n\t\t\tpSMB->FileName[name_len+1] = 0;\n\t\t\tname_len += 2;\n\t\t}\n\t} else {\t/* BB add check for overrun of SMB buf BB */\n\t\tname_len = strnlen(searchName, PATH_MAX);\n/* BB fix here and in unicode clause above ie\n\t\tif (name_len > buffersize-header)\n\t\t\tfree buffer exit; BB */\n\t\tstrncpy(pSMB->FileName, searchName, name_len);\n\t\tif (msearch) {\n\t\t\tpSMB->FileName[name_len] = CIFS_DIR_SEP(cifs_sb);\n\t\t\tpSMB->FileName[name_len+1] = '*';\n\t\t\tpSMB->FileName[name_len+2] = 0;\n\t\t\tname_len += 3;\n\t\t}\n\t}\n\n\tparams = 12 + name_len /* includes null */ ;\n\tpSMB->TotalDataCount = 0;\t/* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(10);\n\tpSMB->MaxDataCount = cpu_to_le16(CIFSMaxBufSize & 0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_ffirst_req, SearchAttributes)\n\t\t- 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\t/* one byte, no need to make endian neutral */\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_FIRST);\n\tpSMB->SearchAttributes =\n\t    cpu_to_le16(ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM |\n\t\t\tATTR_DIRECTORY);\n\tpSMB->SearchCount = cpu_to_le16(CIFSMaxBufSize/sizeof(FILE_UNIX_INFO));\n\tpSMB->SearchFlags = cpu_to_le16(search_flags);\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\n\t/* BB what should we set StorageType to? Does it matter? BB */\n\tpSMB->SearchStorageType = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_ffirst);\n\n\tif (rc) {/* BB add logic to retry regular search if Unix search\n\t\t\trejected unexpectedly by server */\n\t\t/* BB Add code to handle unsupported level rc */\n\t\tcifs_dbg(FYI, \"Error in FindFirst = %d\\n\", rc);\n\n\t\tcifs_buf_release(pSMB);\n\n\t\t/* BB eventually could optimize out free and realloc of buf */\n\t\t/*    for this case */\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto findFirstRetry;\n\t} else { /* decode response */\n\t\t/* BB remember to free buffer if error BB */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMBr;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tpsrch_inf->srch_entries_start =\n\t\t\t\t(char *) &pSMBr->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tparms = (T2_FFIRST_RSP_PARMS *)((char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset));\n\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry = 2 /* skip . and .. */ +\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (CIFSMaxBufSize < lnoff) {\n\t\t\t\tcifs_dbg(VFS, \"ignoring corrupt resume name\\n\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\tpsrch_inf->last_entry = psrch_inf->srch_entries_start +\n\t\t\t\t\t\t\tlnoff;\n\n\t\t\tif (pnetfid)\n\t\t\t\t*pnetfid = parms->SearchHandle;\n\t\t} else {\n\t\t\tcifs_buf_release(pSMB);\n\t\t}\n\t}\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     const char *path, struct cifs_sb_info *cifs_sb,\n\t\t     struct cifs_fid *fid, __u16 search_flags,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\treturn CIFSFindFirst(xid, tcon, path, cifs_sb,\n\t\t\t     &fid->netfid, search_flags, srch_inf, true);\n}"
  },
  {
    "function_name": "cifs_set_compression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "839-844",
    "snippet": "static int\ncifs_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn CIFSSMB_set_compression(xid, tcon, cfile->fid.netfid);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMB_set_compression",
          "args": [
            "xid",
            "tcon",
            "cfile->fid.netfid"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMB_set_compression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3261-3312",
          "snippet": "int\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_compr_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcifs_dbg(FYI, \"Set compression for %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\tpSMB->TotalParameterCount = 0;\n\tpSMB->TotalDataCount = cpu_to_le32(2);\n\tpSMB->MaxParameterCount = 0;\n\tpSMB->MaxDataCount = 0;\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = cpu_to_le32(2);\n\tpSMB->DataOffset =\n\t\tcpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4);  /* 84 */\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = 0;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_SET_COMPRESSION);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\t/* 3 byte pad, followed by 2 byte compress state */\n\tpSMB->ByteCount = cpu_to_le16(5);\n\tinc_rfc1001_len(pSMB, 5);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetCompression = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMB_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    __u16 fid)\n{\n\tint rc = 0;\n\tint bytes_returned;\n\tstruct smb_com_transaction_compr_ioctl_req *pSMB;\n\tstruct smb_com_transaction_ioctl_rsp *pSMBr;\n\n\tcifs_dbg(FYI, \"Set compression for %u\\n\", fid);\n\trc = smb_init(SMB_COM_NT_TRANSACT, 23, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->compression_state = cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\tpSMB->TotalParameterCount = 0;\n\tpSMB->TotalDataCount = cpu_to_le32(2);\n\tpSMB->MaxParameterCount = 0;\n\tpSMB->MaxDataCount = 0;\n\tpSMB->MaxSetupCount = 4;\n\tpSMB->Reserved = 0;\n\tpSMB->ParameterOffset = 0;\n\tpSMB->DataCount = cpu_to_le32(2);\n\tpSMB->DataOffset =\n\t\tcpu_to_le32(offsetof(struct smb_com_transaction_compr_ioctl_req,\n\t\t\t\tcompression_state) - 4);  /* 84 */\n\tpSMB->SetupCount = 4;\n\tpSMB->SubCommand = cpu_to_le16(NT_TRANSACT_IOCTL);\n\tpSMB->ParameterCount = 0;\n\tpSMB->FunctionCode = cpu_to_le32(FSCTL_SET_COMPRESSION);\n\tpSMB->IsFsctl = 1; /* FSCTL */\n\tpSMB->IsRootFlag = 0;\n\tpSMB->Fid = fid; /* file handle always le */\n\t/* 3 byte pad, followed by 2 byte compress state */\n\tpSMB->ByteCount = cpu_to_le16(5);\n\tinc_rfc1001_len(pSMB, 5);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in SetCompression = %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\t/*\n\t * Note: On -EAGAIN error only caller can retry on handle based calls\n\t * since file handle passed in no longer valid.\n\t */\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   struct cifsFileInfo *cfile)\n{\n\treturn CIFSSMB_set_compression(xid, tcon, cfile->fid.netfid);\n}"
  },
  {
    "function_name": "smb_set_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "764-837",
    "snippet": "static int\nsmb_set_file_info(struct inode *inode, const char *full_path,\n\t\t  FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\t__u32 netpid;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\n\t/* if the file is already open for write, just use that fileid */\n\topen_file = find_writable_file(cinode, true);\n\tif (open_file) {\n\t\tfid.netfid = open_file->fid.netfid;\n\t\tnetpid = open_file->pid;\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tgoto set_via_filehandle;\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\ttlink = NULL;\n\t\tgoto out;\n\t}\n\ttcon = tlink_tcon(tlink);\n\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, buf, cifs_sb->local_nls,\n\t\t\t\tcifs_remap(cifs_sb));\n\tif (rc == 0) {\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\t\tgoto out;\n\t} else if (rc != -EOPNOTSUPP && rc != -EINVAL) {\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = SYNCHRONIZE | FILE_WRITE_ATTRIBUTES;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tcifs_dbg(FYI, \"calling SetFileInfo since SetPathInfo for times not supported by this server\\n\");\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0) {\n\t\tif (rc == -EIO)\n\t\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnetpid = current->tgid;\n\nset_via_filehandle:\n\trc = CIFSSMBSetFileInfo(xid, tcon, buf, fid.netfid, netpid);\n\tif (!rc)\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\n\tif (open_file == NULL)\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\telse\n\t\tcifsFileInfo_put(open_file);\nout:\n\tif (tlink != NULL)\n\t\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifsFileInfo_put",
          "args": [
            "open_file"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "cifsFileInfo_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "358-436",
          "snippet": "void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nvoid cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tstruct inode *inode = cifs_file->dentry->d_inode;\n\tstruct cifs_tcon *tcon = tlink_tcon(cifs_file->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifsLockInfo *li, *tmp;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\tbool oplock_break_cancelled;\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (--cifs_file->count > 0) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn;\n\t}\n\n\tif (server->ops->get_lease_key)\n\t\tserver->ops->get_lease_key(inode, &fid);\n\n\t/* store open in pending opens to make sure we don't miss lease break */\n\tcifs_add_pending_open_locked(&fid, cifs_file->tlink, &open);\n\n\t/* remove it from the lists */\n\tlist_del(&cifs_file->flist);\n\tlist_del(&cifs_file->tlist);\n\n\tif (list_empty(&cifsi->openFileList)) {\n\t\tcifs_dbg(FYI, \"closing last open instance for inode %p\\n\",\n\t\t\t cifs_file->dentry->d_inode);\n\t\t/*\n\t\t * In strict cache mode we need invalidate mapping on the last\n\t\t * close  because it may cause a error when we open this file\n\t\t * again and get at least level II oplock.\n\t\t */\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\n\t\t\tset_bit(CIFS_INO_INVALID_MAPPING, &cifsi->flags);\n\t\tcifs_set_oplock_level(cifsi, 0);\n\t}\n\tspin_unlock(&cifs_file_list_lock);\n\n\toplock_break_cancelled = cancel_work_sync(&cifs_file->oplock_break);\n\n\tif (!tcon->need_reconnect && !cifs_file->invalidHandle) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\t\tunsigned int xid;\n\n\t\txid = get_xid();\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &cifs_file->fid);\n\t\t_free_xid(xid);\n\t}\n\n\tif (oplock_break_cancelled)\n\t\tcifs_done_oplock_break(cifsi);\n\n\tcifs_del_pending_open(&open);\n\n\t/*\n\t * Delete any outstanding lock records. We'll lose them when the file\n\t * is closed anyway.\n\t */\n\tdown_write(&cifsi->lock_sem);\n\tlist_for_each_entry_safe(li, tmp, &cifs_file->llist->locks, llist) {\n\t\tlist_del(&li->llist);\n\t\tcifs_del_lock_waiters(li);\n\t\tkfree(li);\n\t}\n\tlist_del(&cifs_file->llist->llist);\n\tkfree(cifs_file->llist);\n\tup_write(&cifsi->lock_sem);\n\n\tcifs_put_tlink(cifs_file->tlink);\n\tdput(cifs_file->dentry);\n\tcifs_sb_deactive(sb);\n\tkfree(cifs_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf->Attributes"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetFileInfo",
          "args": [
            "xid",
            "tcon",
            "buf",
            "fid.netfid",
            "netpid"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5693-5755",
          "snippet": "int\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const FILE_BASIC_INFO *data, __u16 fid, __u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Times (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"calling SetFileInfo since SetPathInfo for times not supported by this server\\n\""
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBSetPathInfo",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "buf",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5813-5890",
          "snippet": "int\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writable_file",
          "args": [
            "cinode",
            "true"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "find_writable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "1753-1831",
          "snippet": "struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstruct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,\n\t\t\t\t\tbool fsuid_only)\n{\n\tstruct cifsFileInfo *open_file, *inv_file = NULL;\n\tstruct cifs_sb_info *cifs_sb;\n\tbool any_available = false;\n\tint rc;\n\tunsigned int refind = 0;\n\n\t/* Having a null inode here (because mapping->host was set to zero by\n\tthe VFS or MM) should not happen but we had reports of on oops (due to\n\tit being zero) during stress testcases so we need to check for it */\n\n\tif (cifs_inode == NULL) {\n\t\tcifs_dbg(VFS, \"Null inode passed to cifs_writeable_file\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tcifs_sb = CIFS_SB(cifs_inode->vfs_inode.i_sb);\n\n\t/* only filter by fsuid on multiuser mounts */\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\tfsuid_only = false;\n\n\tspin_lock(&cifs_file_list_lock);\nrefind_writable:\n\tif (refind > MAX_REOPEN_ATT) {\n\t\tspin_unlock(&cifs_file_list_lock);\n\t\treturn NULL;\n\t}\n\tlist_for_each_entry(open_file, &cifs_inode->openFileList, flist) {\n\t\tif (!any_available && open_file->pid != current->tgid)\n\t\t\tcontinue;\n\t\tif (fsuid_only && !uid_eq(open_file->uid, current_fsuid()))\n\t\t\tcontinue;\n\t\tif (OPEN_FMODE(open_file->f_flags) & FMODE_WRITE) {\n\t\t\tif (!open_file->invalidHandle) {\n\t\t\t\t/* found a good writable file */\n\t\t\t\tcifsFileInfo_get_locked(open_file);\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\treturn open_file;\n\t\t\t} else {\n\t\t\t\tif (!inv_file)\n\t\t\t\t\tinv_file = open_file;\n\t\t\t}\n\t\t}\n\t}\n\t/* couldn't find useable FH with same pid, try any available */\n\tif (!any_available) {\n\t\tany_available = true;\n\t\tgoto refind_writable;\n\t}\n\n\tif (inv_file) {\n\t\tany_available = false;\n\t\tcifsFileInfo_get_locked(inv_file);\n\t}\n\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (inv_file) {\n\t\trc = cifs_reopen_file(inv_file, false);\n\t\tif (!rc)\n\t\t\treturn inv_file;\n\t\telse {\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_move_tail(&inv_file->flist,\n\t\t\t\t\t&cifs_inode->openFileList);\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tcifsFileInfo_put(inv_file);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\t++refind;\n\t\t\tgoto refind_writable;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsmb_set_file_info(struct inode *inode, const char *full_path,\n\t\t  FILE_BASIC_INFO *buf, const unsigned int xid)\n{\n\tint oplock = 0;\n\tint rc;\n\t__u32 netpid;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tstruct cifsFileInfo *open_file;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct tcon_link *tlink = NULL;\n\tstruct cifs_tcon *tcon;\n\n\t/* if the file is already open for write, just use that fileid */\n\topen_file = find_writable_file(cinode, true);\n\tif (open_file) {\n\t\tfid.netfid = open_file->fid.netfid;\n\t\tnetpid = open_file->pid;\n\t\ttcon = tlink_tcon(open_file->tlink);\n\t\tgoto set_via_filehandle;\n\t}\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\ttlink = NULL;\n\t\tgoto out;\n\t}\n\ttcon = tlink_tcon(tlink);\n\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, buf, cifs_sb->local_nls,\n\t\t\t\tcifs_remap(cifs_sb));\n\tif (rc == 0) {\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\t\tgoto out;\n\t} else if (rc != -EOPNOTSUPP && rc != -EINVAL) {\n\t\tgoto out;\n\t}\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = SYNCHRONIZE | FILE_WRITE_ATTRIBUTES;\n\toparms.create_options = CREATE_NOT_DIR;\n\toparms.disposition = FILE_OPEN;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tcifs_dbg(FYI, \"calling SetFileInfo since SetPathInfo for times not supported by this server\\n\");\n\trc = CIFS_open(xid, &oparms, &oplock, NULL);\n\tif (rc != 0) {\n\t\tif (rc == -EIO)\n\t\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnetpid = current->tgid;\n\nset_via_filehandle:\n\trc = CIFSSMBSetFileInfo(xid, tcon, buf, fid.netfid, netpid);\n\tif (!rc)\n\t\tcinode->cifsAttrs = le32_to_cpu(buf->Attributes);\n\n\tif (open_file == NULL)\n\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\telse\n\t\tcifsFileInfo_put(open_file);\nout:\n\tif (tlink != NULL)\n\t\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_sync_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "754-762",
    "snippet": "static int\ncifs_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBWrite2(xid, parms, written, iov, nr_segs);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBWrite2",
          "args": [
            "xid",
            "parms",
            "written",
            "iov",
            "nr_segs"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBWrite2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2160-2262",
          "snippet": "int\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcifs_dbg(FYI, \"write2 at %lld %d bytes\\n\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error Write2 = %d\\n\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBWrite2(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t      unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = -EACCES;\n\tWRITE_REQ *pSMB = NULL;\n\tint wct;\n\tint smb_hdr_len;\n\tint resp_buf_type = 0;\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\t*nbytes = 0;\n\n\tcifs_dbg(FYI, \"write2 at %lld %d bytes\\n\", (long long)offset, count);\n\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES) {\n\t\twct = 14;\n\t} else {\n\t\twct = 12;\n\t\tif ((offset >> 32) > 0) {\n\t\t\t/* can not handle big offset for old srv */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\trc = small_smb_init(SMB_COM_WRITE_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;\t/* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 14)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\tpSMB->Reserved = 0xFFFFFFFF;\n\tpSMB->WriteMode = 0;\n\tpSMB->Remaining = 0;\n\n\tpSMB->DataOffset =\n\t    cpu_to_le16(offsetof(struct smb_com_write_req, Data) - 4);\n\n\tpSMB->DataLengthLow = cpu_to_le16(count & 0xFFFF);\n\tpSMB->DataLengthHigh = cpu_to_le16(count >> 16);\n\t/* header + 1 byte pad */\n\tsmb_hdr_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 1;\n\tif (wct == 14)\n\t\tinc_rfc1001_len(pSMB, count + 1);\n\telse /* wct == 12 */\n\t\tinc_rfc1001_len(pSMB, count + 5); /* smb data starts later */\n\tif (wct == 14)\n\t\tpSMB->ByteCount = cpu_to_le16(count + 1);\n\telse /* wct == 12 */ /* bigger pad, smaller smb hdr, keep offset ok */ {\n\t\tstruct smb_com_writex_req *pSMBW =\n\t\t\t\t(struct smb_com_writex_req *)pSMB;\n\t\tpSMBW->ByteCount = cpu_to_le16(count + 5);\n\t}\n\tiov[0].iov_base = pSMB;\n\tif (wct == 14)\n\t\tiov[0].iov_len = smb_hdr_len + 4;\n\telse /* wct == 12 pad bigger by four bytes */\n\t\tiov[0].iov_len = smb_hdr_len + 8;\n\n\n\trc = SendReceive2(xid, tcon->ses, iov, n_vec + 1, &resp_buf_type, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_writes);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error Write2 = %d\\n\", rc);\n\t} else if (resp_buf_type == 0) {\n\t\t/* presumably this can not happen, but best to be safe */\n\t\trc = -EIO;\n\t} else {\n\t\tWRITE_RSP *pSMBr = (WRITE_RSP *)iov[0].iov_base;\n\t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n\t\t*nbytes = (*nbytes) << 16;\n\t\t*nbytes += le16_to_cpu(pSMBr->Count);\n\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned by the\n\t\t * server is greater than bytes requested by the client. OS/2\n\t\t * servers are known to set incorrect CountHigh values.\n\t\t */\n\t\tif (*nbytes > count)\n\t\t\t*nbytes &= 0xFFFF;\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_sync_write(const unsigned int xid, struct cifs_fid *pfid,\n\t\tstruct cifs_io_parms *parms, unsigned int *written,\n\t\tstruct kvec *iov, unsigned long nr_segs)\n{\n\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBWrite2(xid, parms, written, iov, nr_segs);\n}"
  },
  {
    "function_name": "cifs_sync_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "745-752",
    "snippet": "static int\ncifs_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBRead(xid, parms, bytes_read, buf, buf_type);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBRead",
          "args": [
            "xid",
            "parms",
            "bytes_read",
            "buf",
            "buf_type"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1645-1751",
          "snippet": "int\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBRead(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t    unsigned int *nbytes, char **buf, int *pbuf_type)\n{\n\tint rc = -EACCES;\n\tREAD_REQ *pSMB = NULL;\n\tREAD_RSP *pSMBr = NULL;\n\tchar *pReadData = NULL;\n\tint wct;\n\tint resp_buf_type = 0;\n\tstruct kvec iov[1];\n\t__u32 pid = io_parms->pid;\n\t__u16 netfid = io_parms->netfid;\n\t__u64 offset = io_parms->offset;\n\tstruct cifs_tcon *tcon = io_parms->tcon;\n\tunsigned int count = io_parms->length;\n\n\tcifs_dbg(FYI, \"Reading %d bytes on fid %d\\n\", count, netfid);\n\tif (tcon->ses->capabilities & CAP_LARGE_FILES)\n\t\twct = 12;\n\telse {\n\t\twct = 10; /* old style read */\n\t\tif ((offset >> 32) > 0)  {\n\t\t\t/* can not handle this big offset for old */\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t*nbytes = 0;\n\trc = small_smb_init(SMB_COM_READ_ANDX, wct, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid >> 16));\n\n\t/* tcon and ses pointer are checked in smb_init */\n\tif (tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\tpSMB->Fid = netfid;\n\tpSMB->OffsetLow = cpu_to_le32(offset & 0xFFFFFFFF);\n\tif (wct == 12)\n\t\tpSMB->OffsetHigh = cpu_to_le32(offset >> 32);\n\n\tpSMB->Remaining = 0;\n\tpSMB->MaxCount = cpu_to_le16(count & 0xFFFF);\n\tpSMB->MaxCountHigh = cpu_to_le32(count >> 16);\n\tif (wct == 12)\n\t\tpSMB->ByteCount = 0;  /* no need to do le conversion since 0 */\n\telse {\n\t\t/* old style read */\n\t\tstruct smb_com_readx_req *pSMBW =\n\t\t\t(struct smb_com_readx_req *)pSMB;\n\t\tpSMBW->ByteCount = 0;\n\t}\n\n\tiov[0].iov_base = (char *)pSMB;\n\tiov[0].iov_len = be32_to_cpu(pSMB->hdr.smb_buf_length) + 4;\n\trc = SendReceive2(xid, tcon->ses, iov, 1 /* num iovecs */,\n\t\t\t &resp_buf_type, CIFS_LOG_ERROR);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_reads);\n\tpSMBr = (READ_RSP *)iov[0].iov_base;\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\tint data_length = le16_to_cpu(pSMBr->DataLengthHigh);\n\t\tdata_length = data_length << 16;\n\t\tdata_length += le16_to_cpu(pSMBr->DataLength);\n\t\t*nbytes = data_length;\n\n\t\t/*check that DataLength would not go beyond end of SMB */\n\t\tif ((data_length > CIFSMaxBufSize)\n\t\t\t\t|| (data_length > count)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t data_length, count);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t} else {\n\t\t\tpReadData = (char *) (&pSMBr->hdr.Protocol) +\n\t\t\t\t\tle16_to_cpu(pSMBr->DataOffset);\n/*\t\t\tif (rc = copy_to_user(buf, pReadData, data_length)) {\n\t\t\t\tcifs_dbg(VFS, \"Faulting on read rc = %d\\n\",rc);\n\t\t\t\trc = -EFAULT;\n\t\t\t}*/ /* can not use copy_to_user when using page cache*/\n\t\t\tif (*buf)\n\t\t\t\tmemcpy(*buf, pReadData, data_length);\n\t\t}\n\t}\n\n/*\tcifs_small_buf_release(pSMB); */ /* Freed earlier now in SendReceive2 */\n\tif (*buf) {\n\t\tfree_rsp_buf(resp_buf_type, iov[0].iov_base);\n\t} else if (resp_buf_type != CIFS_NO_BUFFER) {\n\t\t/* return buffer to caller to free */\n\t\t*buf = iov[0].iov_base;\n\t\tif (resp_buf_type == CIFS_SMALL_BUFFER)\n\t\t\t*pbuf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buf_type == CIFS_LARGE_BUFFER)\n\t\t\t*pbuf_type = CIFS_LARGE_BUFFER;\n\t} /* else no valid buffer on return - leave as null */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_sync_read(const unsigned int xid, struct cifs_fid *pfid,\n\t       struct cifs_io_parms *parms, unsigned int *bytes_read,\n\t       char **buf, int *buf_type)\n{\n\tparms->netfid = pfid->netfid;\n\treturn CIFSSMBRead(xid, parms, bytes_read, buf, buf_type);\n}"
  },
  {
    "function_name": "cifs_flush_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "738-743",
    "snippet": "static int\ncifs_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn CIFSSMBFlush(xid, tcon, fid->netfid);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBFlush",
          "args": [
            "xid",
            "tcon",
            "fid->netfid"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBFlush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2543-2562",
          "snippet": "int\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBFlush\\n\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in Flush = %d\\n\", rc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBFlush(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tFLUSH_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBFlush\\n\");\n\n\trc = small_smb_init(SMB_COM_FLUSH, 1, tcon, (void **) &pSMB);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_flushes);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"Send error in Flush = %d\\n\", rc);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_flush_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\treturn CIFSSMBFlush(xid, tcon, fid->netfid);\n}"
  },
  {
    "function_name": "cifs_close_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "731-736",
    "snippet": "static void\ncifs_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tCIFSSMBClose(xid, tcon, fid->netfid);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid->netfid"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_close_file(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tstruct cifs_fid *fid)\n{\n\tCIFSSMBClose(xid, tcon, fid->netfid);\n}"
  },
  {
    "function_name": "cifs_set_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "722-729",
    "snippet": "static void\ncifs_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tcfile->fid.netfid = fid->netfid;\n\tcifs_set_oplock_level(cinode, oplock);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_set_oplock_level",
          "args": [
            "cinode",
            "oplock"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_oplock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "533-547",
          "snippet": "void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)\n{\n\tstruct cifsInodeInfo *cinode = CIFS_I(cfile->dentry->d_inode);\n\tcfile->fid.netfid = fid->netfid;\n\tcifs_set_oplock_level(cinode, oplock);\n\tcinode->can_cache_brlcks = CIFS_CACHE_WRITE(cinode);\n}"
  },
  {
    "function_name": "cifs_open_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "707-720",
    "snippet": "static int\ncifs_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\n\t       __u32 *oplock, FILE_ALL_INFO *buf)\n{\n\tif (!(oparms->tcon->ses->capabilities & CAP_NT_SMBS))\n\t\treturn SMBLegacyOpen(xid, oparms->tcon, oparms->path,\n\t\t\t\t     oparms->disposition,\n\t\t\t\t     oparms->desired_access,\n\t\t\t\t     oparms->create_options,\n\t\t\t\t     &oparms->fid->netfid, oplock, buf,\n\t\t\t\t     oparms->cifs_sb->local_nls,\n\t\t\t\t     cifs_remap(oparms->cifs_sb));\n\treturn CIFS_open(xid, oparms, oplock, buf);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "oparms",
            "oplock",
            "buf"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMBLegacyOpen",
          "args": [
            "xid",
            "oparms->tcon",
            "oparms->path",
            "oparms->disposition",
            "oparms->desired_access",
            "oparms->create_options",
            "&oparms->fid->netfid",
            "oplock",
            "buf",
            "oparms->cifs_sb->local_nls",
            "cifs_remap(oparms->cifs_sb)"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "SMBLegacyOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1164-1269",
          "snippet": "int\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBLegacyOpen(const unsigned int xid, struct cifs_tcon *tcon,\n\t    const char *fileName, const int openDisposition,\n\t    const int access_flags, const int create_options, __u16 *netfid,\n\t    int *pOplock, FILE_ALL_INFO *pfile_info,\n\t    const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = -EACCES;\n\tOPENX_REQ *pSMB = NULL;\n\tOPENX_RSP *pSMBr = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\nOldOpenRetry:\n\trc = smb_init(SMB_COM_OPEN_ANDX, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->AndXCommand = 0xFF;       /* none */\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tcount = 1;      /* account for one byte pad to word boundary */\n\t\tname_len =\n\t\t   cifsConvertToUTF16((__le16 *) (pSMB->fileName + 1),\n\t\t\t\t      fileName, PATH_MAX, nls_codepage, remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {                /* BB improve check for buffer overruns BB */\n\t\tcount = 0;      /* no pad */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->fileName, fileName, name_len);\n\t}\n\tif (*pOplock & REQ_OPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_OPLOCK);\n\telse if (*pOplock & REQ_BATCHOPLOCK)\n\t\tpSMB->OpenFlags = cpu_to_le16(REQ_BATCHOPLOCK);\n\n\tpSMB->OpenFlags |= cpu_to_le16(REQ_MORE_INFO);\n\tpSMB->Mode = cpu_to_le16(access_flags_to_smbopen_mode(access_flags));\n\tpSMB->Mode |= cpu_to_le16(0x40); /* deny none */\n\t/* set file as system file if special file such\n\t   as fifo and server expecting SFU style and\n\t   no Unix extensions */\n\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\tpSMB->FileAttributes = cpu_to_le16(ATTR_SYSTEM);\n\telse /* BB FIXME BB */\n\t\tpSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\tpSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);\n\n\t/* BB FIXME BB */\n/*\tpSMB->CreateOptions = cpu_to_le32(create_options &\n\t\t\t\t\t\t CREATE_OPTIONS_MASK); */\n\t/* BB FIXME END BB */\n\n\tpSMB->Sattr = cpu_to_le16(ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIRECTORY);\n\tpSMB->OpenFunction = cpu_to_le16(convert_disposition(openDisposition));\n\tcount += name_len;\n\tinc_rfc1001_len(pSMB, count);\n\n\tpSMB->ByteCount = cpu_to_le16(count);\n\t/* long_op set to 1 to allow for oplock break timeouts */\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *)pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t} else {\n\t/* BB verify if wct == 15 */\n\n/*\t\t*pOplock = pSMBr->OplockLevel; */ /* BB take from action field*/\n\n\t\t*netfid = pSMBr->Fid;   /* cifs fid stays in le */\n\t\t/* Let caller know file was created so we can set the mode. */\n\t\t/* Do we care about the CreateAction in any other cases? */\n\t/* BB FIXME BB */\n/*\t\tif (cpu_to_le32(FILE_CREATE) == pSMBr->CreateAction)\n\t\t\t*pOplock |= CIFS_CREATE_ACTION; */\n\t/* BB FIXME END */\n\n\t\tif (pfile_info) {\n\t\t\tpfile_info->CreationTime = 0; /* BB convert CreateTime*/\n\t\t\tpfile_info->LastAccessTime = 0; /* BB fixme */\n\t\t\tpfile_info->LastWriteTime = 0; /* BB fixme */\n\t\t\tpfile_info->ChangeTime = 0;  /* BB fixme */\n\t\t\tpfile_info->Attributes =\n\t\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->FileAttributes));\n\t\t\t/* the file_info buf is endian converted by caller */\n\t\t\tpfile_info->AllocationSize =\n\t\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->EndOfFile));\n\t\t\tpfile_info->EndOfFile = pfile_info->AllocationSize;\n\t\t\tpfile_info->NumberOfLinks = cpu_to_le32(1);\n\t\t\tpfile_info->DeletePending = 0;\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto OldOpenRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "oparms->cifs_sb"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_open_file(const unsigned int xid, struct cifs_open_parms *oparms,\n\t       __u32 *oplock, FILE_ALL_INFO *buf)\n{\n\tif (!(oparms->tcon->ses->capabilities & CAP_NT_SMBS))\n\t\treturn SMBLegacyOpen(xid, oparms->tcon, oparms->path,\n\t\t\t\t     oparms->disposition,\n\t\t\t\t     oparms->desired_access,\n\t\t\t\t     oparms->create_options,\n\t\t\t\t     &oparms->fid->netfid, oplock, buf,\n\t\t\t\t     oparms->cifs_sb->local_nls,\n\t\t\t\t     cifs_remap(oparms->cifs_sb));\n\treturn CIFS_open(xid, oparms, oplock, buf);\n}"
  },
  {
    "function_name": "cifs_mkdir_setinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "687-705",
    "snippet": "static void\ncifs_mkdir_setinfo(struct inode *inode, const char *full_path,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO info;\n\tstruct cifsInodeInfo *cifsInode;\n\tu32 dosattrs;\n\tint rc;\n\n\tmemset(&info, 0, sizeof(info));\n\tcifsInode = CIFS_I(inode);\n\tdosattrs = cifsInode->cifsAttrs|ATTR_READONLY;\n\tinfo.Attributes = cpu_to_le32(dosattrs);\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, &info, cifs_sb->local_nls,\n\t\t\t\tcifs_remap(cifs_sb));\n\tif (rc == 0)\n\t\tcifsInode->cifsAttrs = dosattrs;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBSetPathInfo",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "&info",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBSetPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5813-5890",
          "snippet": "int\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t   const char *fileName, const FILE_BASIC_INFO *data,\n\t\t   const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tchar *data_offset;\n\t__u16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"In SetTimes\\n\");\n\nSetTimesRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, fileName,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(fileName, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, fileName, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset = (char *) (&pSMB->hdr.Protocol) + offset;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tif (tcon->ses->capabilities & CAP_INFOLEVEL_PASSTHRU)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO2);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_BASIC_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tmemcpy(data_offset, data, sizeof(FILE_BASIC_INFO));\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (times) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto SetTimesRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dosattrs"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "inode"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_mkdir_setinfo(struct inode *inode, const char *full_path,\n\t\t   struct cifs_sb_info *cifs_sb, struct cifs_tcon *tcon,\n\t\t   const unsigned int xid)\n{\n\tFILE_BASIC_INFO info;\n\tstruct cifsInodeInfo *cifsInode;\n\tu32 dosattrs;\n\tint rc;\n\n\tmemset(&info, 0, sizeof(info));\n\tcifsInode = CIFS_I(inode);\n\tdosattrs = cifsInode->cifsAttrs|ATTR_READONLY;\n\tinfo.Attributes = cpu_to_le32(dosattrs);\n\trc = CIFSSMBSetPathInfo(xid, tcon, full_path, &info, cifs_sb->local_nls,\n\t\t\t\tcifs_remap(cifs_sb));\n\tif (rc == 0)\n\t\tcifsInode->cifsAttrs = dosattrs;\n}"
  },
  {
    "function_name": "cifs_print_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "649-685",
    "snippet": "static void\ncifs_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tseq_printf(m, \" Oplocks breaks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_oplock_brks));\n\tseq_printf(m, \"\\nReads:  %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_reads),\n\t\t   (long long)(tcon->bytes_read));\n\tseq_printf(m, \"\\nWrites: %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_writes),\n\t\t   (long long)(tcon->bytes_written));\n\tseq_printf(m, \"\\nFlushes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_flushes));\n\tseq_printf(m, \"\\nLocks: %d HardLinks: %d Symlinks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_locks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_hardlinks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_symlinks));\n\tseq_printf(m, \"\\nOpens: %d Closes: %d Deletes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_opens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_closes),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_deletes));\n\tseq_printf(m, \"\\nPosix Opens: %d Posix Mkdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixopens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixmkdirs));\n\tseq_printf(m, \"\\nMkdirs: %d Rmdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_mkdirs),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_rmdirs));\n\tseq_printf(m, \"\\nRenames: %d T2 Renames %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_renames),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_t2renames));\n\tseq_printf(m, \"\\nFindFirst: %d FNext %d FClose %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_ffirst),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fnext),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fclose));\n#endif\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nFindFirst: %d FNext %d FClose %d\"",
            "atomic_read(&tcon->stats.cifs_stats.num_ffirst)",
            "atomic_read(&tcon->stats.cifs_stats.num_fnext)",
            "atomic_read(&tcon->stats.cifs_stats.num_fclose)"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_fclose"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_fnext"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_ffirst"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_t2renames"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_renames"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_rmdirs"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_mkdirs"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_posixmkdirs"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_posixopens"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_deletes"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_closes"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_opens"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_symlinks"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_hardlinks"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_locks"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_flushes"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_writes"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_reads"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tcon->stats.cifs_stats.num_oplock_brks"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_print_stats(struct seq_file *m, struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tseq_printf(m, \" Oplocks breaks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_oplock_brks));\n\tseq_printf(m, \"\\nReads:  %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_reads),\n\t\t   (long long)(tcon->bytes_read));\n\tseq_printf(m, \"\\nWrites: %d Bytes: %llu\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_writes),\n\t\t   (long long)(tcon->bytes_written));\n\tseq_printf(m, \"\\nFlushes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_flushes));\n\tseq_printf(m, \"\\nLocks: %d HardLinks: %d Symlinks: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_locks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_hardlinks),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_symlinks));\n\tseq_printf(m, \"\\nOpens: %d Closes: %d Deletes: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_opens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_closes),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_deletes));\n\tseq_printf(m, \"\\nPosix Opens: %d Posix Mkdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixopens),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_posixmkdirs));\n\tseq_printf(m, \"\\nMkdirs: %d Rmdirs: %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_mkdirs),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_rmdirs));\n\tseq_printf(m, \"\\nRenames: %d T2 Renames %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_renames),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_t2renames));\n\tseq_printf(m, \"\\nFindFirst: %d FNext %d FClose %d\",\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_ffirst),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fnext),\n\t\t   atomic_read(&tcon->stats.cifs_stats.num_fclose));\n#endif\n}"
  },
  {
    "function_name": "cifs_clear_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "621-647",
    "snippet": "static void\ncifs_clear_stats(struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tatomic_set(&tcon->stats.cifs_stats.num_writes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_reads, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_flushes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_oplock_brks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_opens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixopens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixmkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_closes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_deletes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_mkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_rmdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_t2renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_ffirst, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fnext, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fclose, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_hardlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_symlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_locks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_get, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_set, 0);\n#endif\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_acl_set",
            "0"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_acl_get",
            "0"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_locks",
            "0"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_symlinks",
            "0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_hardlinks",
            "0"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_fclose",
            "0"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_fnext",
            "0"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_ffirst",
            "0"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_t2renames",
            "0"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_renames",
            "0"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_rmdirs",
            "0"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_mkdirs",
            "0"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_deletes",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_closes",
            "0"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_posixmkdirs",
            "0"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_posixopens",
            "0"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_opens",
            "0"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_oplock_brks",
            "0"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_flushes",
            "0"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_reads",
            "0"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&tcon->stats.cifs_stats.num_writes",
            "0"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_clear_stats(struct cifs_tcon *tcon)\n{\n#ifdef CONFIG_CIFS_STATS\n\tatomic_set(&tcon->stats.cifs_stats.num_writes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_reads, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_flushes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_oplock_brks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_opens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixopens, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_posixmkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_closes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_deletes, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_mkdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_rmdirs, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_t2renames, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_ffirst, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fnext, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_fclose, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_hardlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_symlinks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_locks, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_get, 0);\n\tatomic_set(&tcon->stats.cifs_stats.num_acl_set, 0);\n#endif\n}"
  },
  {
    "function_name": "cifs_query_file_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "614-619",
    "snippet": "static int\ncifs_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_fid *fid, FILE_ALL_INFO *data)\n{\n\treturn CIFSSMBQFileInfo(xid, tcon, fid->netfid, data);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBQFileInfo",
          "args": [
            "xid",
            "tcon",
            "fid->netfid",
            "data"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4024-4090",
          "snippet": "int\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_ALL_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2 /* level */ + 2 /* fid */;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->t2.ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFileInfo = %d\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (pFindData) {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, sizeof(FILE_ALL_INFO));\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QFileInfoRetry;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_query_file_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_fid *fid, FILE_ALL_INFO *data)\n{\n\treturn CIFSSMBQFileInfo(xid, tcon, fid->netfid, data);\n}"
  },
  {
    "function_name": "cifs_get_srv_inum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "593-612",
    "snippet": "static int\ncifs_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t  u64 *uniqueid, FILE_ALL_INFO *data)\n{\n\t/*\n\t * We can not use the IndexNumber field by default from Windows or\n\t * Samba (in ALL_INFO buf) but we can request it explicitly. The SNIA\n\t * CIFS spec claims that this value is unique within the scope of a\n\t * share, and the windows docs hint that it's actually unique\n\t * per-machine.\n\t *\n\t * There may be higher info levels that work but are there Windows\n\t * server or network appliances for which IndexNumber field is not\n\t * guaranteed unique?\n\t */\n\treturn CIFSGetSrvInodeNumber(xid, tcon, full_path, uniqueid,\n\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t     cifs_remap(cifs_sb));\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSGetSrvInodeNumber",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "uniqueid",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSGetSrvInodeNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4667-4758",
          "snippet": "int\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *search_name, __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetSrvInodeNum for %s\\n\", search_name);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in QueryInternalInfo\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in QryIntrnlInf\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSGetSrvInodeNumber(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t      const char *search_name, __u64 *inode_number,\n\t\t      const struct nls_table *nls_codepage, int remap)\n{\n\tint rc = 0;\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint name_len, bytes_returned;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In GetSrvInodeNum for %s\\n\", search_name);\n\tif (tcon == NULL)\n\t\treturn -ENODEV;\n\nGetInodeNumberRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */  + 4 /* rsrvd */  + name_len /* incl null */ ;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max data count below from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_INTERNAL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"error %d in QueryInternalInfo\\n\", rc);\n\t} else {\n\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\t\t/* BB also check enough total bytes returned */\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 2)\n\t\t\t/* If rc should we check for EOPNOSUPP and\n\t\t\tdisable the srvino flag? or in caller? */\n\t\t\trc = -EIO;      /* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\t__u16 count = le16_to_cpu(pSMBr->t2.DataCount);\n\t\t\tstruct file_internal_info *pfinfo;\n\t\t\t/* BB Do we need a cast or hash here ? */\n\t\t\tif (count < 8) {\n\t\t\t\tcifs_dbg(FYI, \"Illegal size ret in QryIntrnlInf\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto GetInodeNumOut;\n\t\t\t}\n\t\t\tpfinfo = (struct file_internal_info *)\n\t\t\t\t(data_offset + (char *) &pSMBr->hdr.Protocol);\n\t\t\t*inode_number = le64_to_cpu(pfinfo->UniqueId);\n\t\t}\n\t}\nGetInodeNumOut:\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto GetInodeNumberRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_get_srv_inum(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t  u64 *uniqueid, FILE_ALL_INFO *data)\n{\n\t/*\n\t * We can not use the IndexNumber field by default from Windows or\n\t * Samba (in ALL_INFO buf) but we can request it explicitly. The SNIA\n\t * CIFS spec claims that this value is unique within the scope of a\n\t * share, and the windows docs hint that it's actually unique\n\t * per-machine.\n\t *\n\t * There may be higher info levels that work but are there Windows\n\t * server or network appliances for which IndexNumber field is not\n\t * guaranteed unique?\n\t */\n\treturn CIFSGetSrvInodeNumber(xid, tcon, full_path, uniqueid,\n\t\t\t\t     cifs_sb->local_nls,\n\t\t\t\t     cifs_remap(cifs_sb));\n}"
  },
  {
    "function_name": "cifs_query_path_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "543-591",
    "snippet": "static int\ncifs_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t     FILE_ALL_INFO *data, bool *adjustTZ, bool *symlink)\n{\n\tint rc;\n\n\t*symlink = false;\n\n\t/* could do find first instead but this returns more info */\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, data, 0 /* not legacy */,\n\t\t\t      cifs_sb->local_nls, cifs_remap(cifs_sb));\n\t/*\n\t * BB optimize code so we do not make the above call when server claims\n\t * no NT SMB support and the above call failed at least once - set flag\n\t * in tcon or mount.\n\t */\n\tif ((rc == -EOPNOTSUPP) || (rc == -EINVAL)) {\n\t\trc = SMBQueryInformation(xid, tcon, full_path, data,\n\t\t\t\t\t cifs_sb->local_nls,\n\t\t\t\t\t cifs_remap(cifs_sb));\n\t\t*adjustTZ = true;\n\t}\n\n\tif (!rc && (le32_to_cpu(data->Attributes) & ATTR_REPARSE)) {\n\t\tint tmprc;\n\t\tint oplock = 0;\n\t\tstruct cifs_fid fid;\n\t\tstruct cifs_open_parms oparms;\n\n\t\toparms.tcon = tcon;\n\t\toparms.cifs_sb = cifs_sb;\n\t\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\t\toparms.create_options = 0;\n\t\toparms.disposition = FILE_OPEN;\n\t\toparms.path = full_path;\n\t\toparms.fid = &fid;\n\t\toparms.reconnect = false;\n\n\t\t/* Need to check if this is a symbolic link or not */\n\t\ttmprc = CIFS_open(xid, &oparms, &oplock, NULL);\n\t\tif (tmprc == -EOPNOTSUPP)\n\t\t\t*symlink = true;\n\t\telse if (tmprc == 0)\n\t\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid.netfid"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "NULL"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "1271-1391",
          "snippet": "int\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFS_open(const unsigned int xid, struct cifs_open_parms *oparms, int *oplock,\n\t  FILE_ALL_INFO *buf)\n{\n\tint rc = -EACCES;\n\tOPEN_REQ *req = NULL;\n\tOPEN_RSP *rsp = NULL;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 count;\n\tstruct cifs_sb_info *cifs_sb = oparms->cifs_sb;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tint remap = cifs_remap(cifs_sb);\n\tconst struct nls_table *nls = cifs_sb->local_nls;\n\tint create_options = oparms->create_options;\n\tint desired_access = oparms->desired_access;\n\tint disposition = oparms->disposition;\n\tconst char *path = oparms->path;\n\nopenRetry:\n\trc = smb_init(SMB_COM_NT_CREATE_ANDX, 24, tcon, (void **)&req,\n\t\t      (void **)&rsp);\n\tif (rc)\n\t\treturn rc;\n\n\t/* no commands go after this */\n\treq->AndXCommand = 0xFF;\n\n\tif (req->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\t/* account for one byte pad to word boundary */\n\t\tcount = 1;\n\t\tname_len = cifsConvertToUTF16((__le16 *)(req->fileName + 1),\n\t\t\t\t\t      path, PATH_MAX, nls, remap);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\tname_len *= 2;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t} else {\n\t\t/* BB improve check for buffer overruns BB */\n\t\t/* no pad */\n\t\tcount = 0;\n\t\tname_len = strnlen(path, PATH_MAX);\n\t\t/* trailing null */\n\t\tname_len++;\n\t\treq->NameLength = cpu_to_le16(name_len);\n\t\tstrncpy(req->fileName, path, name_len);\n\t}\n\n\tif (*oplock & REQ_OPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_OPLOCK);\n\telse if (*oplock & REQ_BATCHOPLOCK)\n\t\treq->OpenFlags = cpu_to_le32(REQ_BATCHOPLOCK);\n\n\treq->DesiredAccess = cpu_to_le32(desired_access);\n\treq->AllocationSize = 0;\n\n\t/*\n\t * Set file as system file if special file such as fifo and server\n\t * expecting SFU style and no Unix extensions.\n\t */\n\tif (create_options & CREATE_OPTION_SPECIAL)\n\t\treq->FileAttributes = cpu_to_le32(ATTR_SYSTEM);\n\telse\n\t\treq->FileAttributes = cpu_to_le32(ATTR_NORMAL);\n\n\t/*\n\t * XP does not handle ATTR_POSIX_SEMANTICS but it helps speed up case\n\t * sensitive checks for other servers such as Samba.\n\t */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);\n\n\tif (create_options & CREATE_OPTION_READONLY)\n\t\treq->FileAttributes |= cpu_to_le32(ATTR_READONLY);\n\n\treq->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);\n\treq->CreateDisposition = cpu_to_le32(disposition);\n\treq->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);\n\n\t/* BB Expirement with various impersonation levels and verify */\n\treq->ImpersonationLevel = cpu_to_le32(SECURITY_IMPERSONATION);\n\treq->SecurityFlags = SECURITY_CONTEXT_TRACKING|SECURITY_EFFECTIVE_ONLY;\n\n\tcount += name_len;\n\tinc_rfc1001_len(req, count);\n\n\treq->ByteCount = cpu_to_le16(count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *)req,\n\t\t\t (struct smb_hdr *)rsp, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_opens);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Error in Open = %d\\n\", rc);\n\t\tcifs_buf_release(req);\n\t\tif (rc == -EAGAIN)\n\t\t\tgoto openRetry;\n\t\treturn rc;\n\t}\n\n\t/* 1 byte no need to le_to_cpu */\n\t*oplock = rsp->OplockLevel;\n\t/* cifs fid stays in le */\n\toparms->fid->netfid = rsp->Fid;\n\n\t/* Let caller know file was created so we can set the mode. */\n\t/* Do we care about the CreateAction in any other cases? */\n\tif (cpu_to_le32(FILE_CREATE) == rsp->CreateAction)\n\t\t*oplock |= CIFS_CREATE_ACTION;\n\n\tif (buf) {\n\t\t/* copy from CreationTime to Attributes */\n\t\tmemcpy((char *)buf, (char *)&rsp->CreationTime, 36);\n\t\t/* the file_info buf is endian converted by caller */\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndOfFile;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tcifs_buf_release(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "data->Attributes"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SMBQueryInformation",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "data",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "SMBQueryInformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3956-4022",
          "snippet": "int\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQPathInfo",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "data",
            "0/* not legacy */",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4092-4191",
          "snippet": "int\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_query_path_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     struct cifs_sb_info *cifs_sb, const char *full_path,\n\t\t     FILE_ALL_INFO *data, bool *adjustTZ, bool *symlink)\n{\n\tint rc;\n\n\t*symlink = false;\n\n\t/* could do find first instead but this returns more info */\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, data, 0 /* not legacy */,\n\t\t\t      cifs_sb->local_nls, cifs_remap(cifs_sb));\n\t/*\n\t * BB optimize code so we do not make the above call when server claims\n\t * no NT SMB support and the above call failed at least once - set flag\n\t * in tcon or mount.\n\t */\n\tif ((rc == -EOPNOTSUPP) || (rc == -EINVAL)) {\n\t\trc = SMBQueryInformation(xid, tcon, full_path, data,\n\t\t\t\t\t cifs_sb->local_nls,\n\t\t\t\t\t cifs_remap(cifs_sb));\n\t\t*adjustTZ = true;\n\t}\n\n\tif (!rc && (le32_to_cpu(data->Attributes) & ATTR_REPARSE)) {\n\t\tint tmprc;\n\t\tint oplock = 0;\n\t\tstruct cifs_fid fid;\n\t\tstruct cifs_open_parms oparms;\n\n\t\toparms.tcon = tcon;\n\t\toparms.cifs_sb = cifs_sb;\n\t\toparms.desired_access = FILE_READ_ATTRIBUTES;\n\t\toparms.create_options = 0;\n\t\toparms.disposition = FILE_OPEN;\n\t\toparms.path = full_path;\n\t\toparms.fid = &fid;\n\t\toparms.reconnect = false;\n\n\t\t/* Need to check if this is a symbolic link or not */\n\t\ttmprc = CIFS_open(xid, &oparms, &oplock, NULL);\n\t\tif (tmprc == -EOPNOTSUPP)\n\t\t\t*symlink = true;\n\t\telse if (tmprc == 0)\n\t\t\tCIFSSMBClose(xid, tcon, fid.netfid);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_is_path_accessible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "521-541",
    "snippet": "static int\ncifs_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *file_info;\n\n\tfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (file_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, file_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_remap(cifs_sb));\n\n\tif (rc == -EOPNOTSUPP || rc == -EINVAL)\n\t\trc = SMBQueryInformation(xid, tcon, full_path, file_info,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(file_info);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "file_info"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMBQueryInformation",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "file_info",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "SMBQueryInformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "3956-4022",
          "snippet": "int\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMBQueryInformation(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t    const char *search_name, FILE_ALL_INFO *data,\n\t\t    const struct nls_table *nls_codepage, int remap)\n{\n\tQUERY_INFORMATION_REQ *pSMB;\n\tQUERY_INFORMATION_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\n\tcifs_dbg(FYI, \"In SMBQPath path %s\\n\", search_name);\nQInfRetry:\n\trc = smb_init(SMB_COM_QUERY_INFORMATION, 0, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t\tcifsConvertToUTF16((__le16 *) pSMB->FileName,\n\t\t\t\t\t   search_name, PATH_MAX, nls_codepage,\n\t\t\t\t\t   remap);\n\t\tname_len++;     /* trailing null */\n\t\tname_len *= 2;\n\t} else {\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;     /* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\tpSMB->BufferFormat = 0x04;\n\tname_len++; /* account for buffer type byte */\n\tinc_rfc1001_len(pSMB, (__u16)name_len);\n\tpSMB->ByteCount = cpu_to_le16(name_len);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QueryInfo = %d\\n\", rc);\n\t} else if (data) {\n\t\tstruct timespec ts;\n\t\t__u32 time = le32_to_cpu(pSMBr->last_write_time);\n\n\t\t/* decode response */\n\t\t/* BB FIXME - add time zone adjustment BB */\n\t\tmemset(data, 0, sizeof(FILE_ALL_INFO));\n\t\tts.tv_nsec = 0;\n\t\tts.tv_sec = time;\n\t\t/* decode time fields */\n\t\tdata->ChangeTime = cpu_to_le64(cifs_UnixTimeToNT(ts));\n\t\tdata->LastWriteTime = data->ChangeTime;\n\t\tdata->LastAccessTime = 0;\n\t\tdata->AllocationSize =\n\t\t\tcpu_to_le64(le32_to_cpu(pSMBr->size));\n\t\tdata->EndOfFile = data->AllocationSize;\n\t\tdata->Attributes =\n\t\t\tcpu_to_le32(le16_to_cpu(pSMBr->attr));\n\t} else\n\t\trc = -EIO; /* bad buffer passed in */\n\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QInfRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_remap",
          "args": [
            "cifs_sb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "65-77",
          "snippet": "int cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_remap(struct cifs_sb_info *cifs_sb)\n{\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\treturn map_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQPathInfo",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "file_info",
            "0/* not legacy */",
            "cifs_sb->local_nls",
            "cifs_remap(cifs_sb)"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "4092-4191",
          "snippet": "int\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t const char *search_name, FILE_ALL_INFO *data,\n\t\t int legacy /* old style infolevel */,\n\t\t const struct nls_table *nls_codepage, int remap)\n{\n\t/* level 263 SMB_QUERY_FILE_ALL_INFO */\n\tTRANSACTION2_QPI_REQ *pSMB = NULL;\n\tTRANSACTION2_QPI_RSP *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\tint name_len;\n\t__u16 params, byte_count;\n\n\t/* cifs_dbg(FYI, \"In QPathInfo path %s\\n\", search_name); */\nQPathInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, search_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(search_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, search_name, name_len);\n\t}\n\n\tparams = 2 /* level */ + 4 /* reserved */ + name_len /* includes NUL */;\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(4000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\tstruct smb_com_transaction2_qpi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_PATH_INFORMATION);\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tif (legacy)\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_INFO_STANDARD);\n\telse\n\t\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_ALL_INFO);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QPathInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc) /* BB add auto retry on EOPNOTSUPP? */\n\t\t\trc = -EIO;\n\t\telse if (!legacy && get_bcc(&pSMBr->hdr) < 40)\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse if (legacy && get_bcc(&pSMBr->hdr) < 24)\n\t\t\trc = -EIO;  /* 24 or 26 expected but we do not read\n\t\t\t\t\tlast field */\n\t\telse if (data) {\n\t\t\tint size;\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\n\t\t\t/*\n\t\t\t * On legacy responses we do not read the last field,\n\t\t\t * EAsize, fortunately since it varies by subdialect and\n\t\t\t * also note it differs on Set vs Get, ie two bytes or 4\n\t\t\t * bytes depending but we don't care here.\n\t\t\t */\n\t\t\tif (legacy)\n\t\t\t\tsize = sizeof(FILE_INFO_STANDARD);\n\t\t\telse\n\t\t\t\tsize = sizeof(FILE_ALL_INFO);\n\t\t\tmemcpy((char *) data, (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset, size);\n\t\t} else\n\t\t    rc = -ENOMEM;\n\t}\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto QPathInfoRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(FILE_ALL_INFO)",
            "GFP_KERNEL"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_is_path_accessible(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t\tstruct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *file_info;\n\n\tfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (file_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, file_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_remap(cifs_sb));\n\n\tif (rc == -EOPNOTSUPP || rc == -EINVAL)\n\t\trc = SMBQueryInformation(xid, tcon, full_path, file_info,\n\t\t\t\tcifs_sb->local_nls, cifs_remap(cifs_sb));\n\tkfree(file_info);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_qfs_tcon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "514-519",
    "snippet": "static void\ncifs_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\tCIFSSMBQFSAttributeInfo(xid, tcon);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBQFSAttributeInfo",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSAttributeInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5141-5209",
          "snippet": "int\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSAttributeInfo\\n\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSAttributeInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSAttributeInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x105  SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_ATTRIBUTE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSAttributeInfo\\n\");\nQFSAttributeRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_ATTRIBUTE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in QFSAttributeInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < 13) {\n\t\t\t/* BB also check if enough bytes returned */\n\t\t\trc = -EIO;\t/* bad smb */\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_ATTRIBUTE_INFO\n\t\t\t     *) (((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsAttrInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_ATTRIBUTE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSAttributeRetry;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFSSMBQFSDeviceInfo",
          "args": [
            "xid",
            "tcon"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBQFSDeviceInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5211-5280",
          "snippet": "int\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBQFSDeviceInfo(const unsigned int xid, struct cifs_tcon *tcon)\n{\n/* level 0x104 SMB_QUERY_FILE_SYSTEM_INFO */\n\tTRANSACTION2_QFSI_REQ *pSMB = NULL;\n\tTRANSACTION2_QFSI_RSP *pSMBr = NULL;\n\tFILE_SYSTEM_DEVICE_INFO *response_data;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\t__u16 params, byte_count;\n\n\tcifs_dbg(FYI, \"In QFSDeviceInfo\\n\");\nQFSDeviceRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2;\t/* level */\n\tpSMB->TotalDataCount = 0;\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find exact max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(offsetof(\n\t\tstruct smb_com_transaction2_qfsi_req, InformationLevel) - 4);\n\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_QUERY_FS_INFORMATION);\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FS_DEVICE_INFO);\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in QFSDeviceInfo = %d\\n\", rc);\n\t} else {\t\t/* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) <\n\t\t\t  sizeof(FILE_SYSTEM_DEVICE_INFO))\n\t\t\trc = -EIO;\t/* bad smb */\n\t\telse {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tresponse_data =\n\t\t\t    (FILE_SYSTEM_DEVICE_INFO *)\n\t\t\t\t(((char *) &pSMBr->hdr.Protocol) +\n\t\t\t\t data_offset);\n\t\t\tmemcpy(&tcon->fsDevInfo, response_data,\n\t\t\t       sizeof(FILE_SYSTEM_DEVICE_INFO));\n\t\t}\n\t}\n\tcifs_buf_release(pSMB);\n\n\tif (rc == -EAGAIN)\n\t\tgoto QFSDeviceRetry;\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_qfs_tcon(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\tCIFSSMBQFSAttributeInfo(xid, tcon);\n}"
  },
  {
    "function_name": "cifs_negotiate_rsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "473-512",
    "snippet": "static unsigned int\ncifs_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize, defsize;\n\n\t/*\n\t * Set default value...\n\t *\n\t * HACK alert! Ancient servers have very small buffers. Even though\n\t * MS-CIFS indicates that servers are only limited by the client's\n\t * bufsize for reads, testing against win98se shows that it throws\n\t * INVALID_PARAMETER errors if you try to request too large a read.\n\t * OS/2 just sends back short reads.\n\t *\n\t * If the server doesn't advertise CAP_LARGE_READ_X, then assume that\n\t * it can't handle a read request larger than its MaxBufferSize either.\n\t */\n\tif (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_READ_CAP))\n\t\tdefsize = CIFS_DEFAULT_IOSIZE;\n\telse if (server->capabilities & CAP_LARGE_READ_X)\n\t\tdefsize = CIFS_DEFAULT_NON_POSIX_RSIZE;\n\telse\n\t\tdefsize = server->maxBuf - sizeof(READ_RSP);\n\n\trsize = volume_info->rsize ? volume_info->rsize : defsize;\n\n\t/*\n\t * no CAP_LARGE_READ_X? Then MS-CIFS states that we must limit this to\n\t * the client's MaxBufferSize.\n\t */\n\tif (!(server->capabilities & CAP_LARGE_READ_X))\n\t\trsize = min_t(unsigned int, CIFSMaxBufSize, rsize);\n\n\t/* hard limit of CIFS_MAX_RSIZE */\n\trsize = min_t(unsigned int, rsize, CIFS_MAX_RSIZE);\n\n\treturn rsize;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rsize",
            "CIFS_MAX_RSIZE"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "CIFSMaxBufSize",
            "rsize"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_negotiate_rsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int rsize, defsize;\n\n\t/*\n\t * Set default value...\n\t *\n\t * HACK alert! Ancient servers have very small buffers. Even though\n\t * MS-CIFS indicates that servers are only limited by the client's\n\t * bufsize for reads, testing against win98se shows that it throws\n\t * INVALID_PARAMETER errors if you try to request too large a read.\n\t * OS/2 just sends back short reads.\n\t *\n\t * If the server doesn't advertise CAP_LARGE_READ_X, then assume that\n\t * it can't handle a read request larger than its MaxBufferSize either.\n\t */\n\tif (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_READ_CAP))\n\t\tdefsize = CIFS_DEFAULT_IOSIZE;\n\telse if (server->capabilities & CAP_LARGE_READ_X)\n\t\tdefsize = CIFS_DEFAULT_NON_POSIX_RSIZE;\n\telse\n\t\tdefsize = server->maxBuf - sizeof(READ_RSP);\n\n\trsize = volume_info->rsize ? volume_info->rsize : defsize;\n\n\t/*\n\t * no CAP_LARGE_READ_X? Then MS-CIFS states that we must limit this to\n\t * the client's MaxBufferSize.\n\t */\n\tif (!(server->capabilities & CAP_LARGE_READ_X))\n\t\trsize = min_t(unsigned int, CIFSMaxBufSize, rsize);\n\n\t/* hard limit of CIFS_MAX_RSIZE */\n\trsize = min_t(unsigned int, rsize, CIFS_MAX_RSIZE);\n\n\treturn rsize;\n}"
  },
  {
    "function_name": "cifs_negotiate_wsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "438-471",
    "snippet": "static unsigned int\ncifs_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t/* start with specified wsize, or default */\n\tif (volume_info->wsize)\n\t\twsize = volume_info->wsize;\n\telse if (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = CIFS_DEFAULT_IOSIZE;\n\telse\n\t\twsize = CIFS_DEFAULT_NON_POSIX_WSIZE;\n\n\t/* can server support 24-bit write sizes? (via UNIX extensions) */\n\tif (!tcon->unix_ext || !(unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = min_t(unsigned int, wsize, CIFS_MAX_RFC1002_WSIZE);\n\n\t/*\n\t * no CAP_LARGE_WRITE_X or is signing enabled without CAP_UNIX set?\n\t * Limit it to max buffer offered by the server, minus the size of the\n\t * WRITEX header, not including the 4 byte RFC1001 length.\n\t */\n\tif (!(server->capabilities & CAP_LARGE_WRITE_X) ||\n\t    (!(server->capabilities & CAP_UNIX) && server->sign))\n\t\twsize = min_t(unsigned int, wsize,\n\t\t\t\tserver->maxBuf - sizeof(WRITE_REQ) + 4);\n\n\t/* hard limit of CIFS_MAX_WSIZE */\n\twsize = min_t(unsigned int, wsize, CIFS_MAX_WSIZE);\n\n\treturn wsize;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "wsize",
            "CIFS_MAX_WSIZE"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "wsize",
            "server->maxBuf - sizeof(WRITE_REQ) + 4"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "wsize",
            "CIFS_MAX_RFC1002_WSIZE"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_negotiate_wsize(struct cifs_tcon *tcon, struct smb_vol *volume_info)\n{\n\t__u64 unix_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int wsize;\n\n\t/* start with specified wsize, or default */\n\tif (volume_info->wsize)\n\t\twsize = volume_info->wsize;\n\telse if (tcon->unix_ext && (unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = CIFS_DEFAULT_IOSIZE;\n\telse\n\t\twsize = CIFS_DEFAULT_NON_POSIX_WSIZE;\n\n\t/* can server support 24-bit write sizes? (via UNIX extensions) */\n\tif (!tcon->unix_ext || !(unix_cap & CIFS_UNIX_LARGE_WRITE_CAP))\n\t\twsize = min_t(unsigned int, wsize, CIFS_MAX_RFC1002_WSIZE);\n\n\t/*\n\t * no CAP_LARGE_WRITE_X or is signing enabled without CAP_UNIX set?\n\t * Limit it to max buffer offered by the server, minus the size of the\n\t * WRITEX header, not including the 4 byte RFC1001 length.\n\t */\n\tif (!(server->capabilities & CAP_LARGE_WRITE_X) ||\n\t    (!(server->capabilities & CAP_UNIX) && server->sign))\n\t\twsize = min_t(unsigned int, wsize,\n\t\t\t\tserver->maxBuf - sizeof(WRITE_REQ) + 4);\n\n\t/* hard limit of CIFS_MAX_WSIZE */\n\twsize = min_t(unsigned int, wsize, CIFS_MAX_WSIZE);\n\n\treturn wsize;\n}"
  },
  {
    "function_name": "cifs_negotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "423-436",
    "snippet": "static int\ncifs_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc;\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\tset_credits(ses->server, 1);\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFSSMBNegotiate",
          "args": [
            "xid",
            "ses"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBNegotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "544-648",
          "snippet": "int\nCIFSSMBNegotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 count;\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Mid = get_next_mid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif (should_set_ext_sec_flag(ses->sectype)) {\n\t\tcifs_dbg(FYI, \"Requesting extended security.\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcifs_dbg(FYI, \"Dialect: %d\\n\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_LANMAN;\n\t\trc = decode_lanman_negprot_rsp(server, pSMBr);\n\t\tgoto signing_check;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17, NTLM or better */\n\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcifs_dbg(FYI, \"share mode security\\n\");\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcifs_dbg(NOISY, \"Max buf = %d\\n\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t\trc = decode_ext_sec_blob(ses, pSMBr);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t} else {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\t}\n\nsigning_check:\n\tif (!rc)\n\t\trc = cifs_enable_signing(server, ses->sign);\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcifs_dbg(FYI, \"negprot rc %d\\n\", rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CIFS_NUM_PROT 1",
            "#define CIFS_NUM_PROT 3",
            "#define CIFS_NUM_PROT 2",
            "#define CIFS_NUM_PROT 4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\n#define CIFS_NUM_PROT 1\n#define CIFS_NUM_PROT 3\n#define CIFS_NUM_PROT 2\n#define CIFS_NUM_PROT 4\n\nint\nCIFSSMBNegotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tNEGOTIATE_REQ *pSMB;\n\tNEGOTIATE_RSP *pSMBr;\n\tint rc = 0;\n\tint bytes_returned;\n\tint i;\n\tstruct TCP_Server_Info *server = ses->server;\n\tu16 count;\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = smb_init(SMB_COM_NEGOTIATE, 0, NULL /* no tcon yet */ ,\n\t\t      (void **) &pSMB, (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Mid = get_next_mid(server);\n\tpSMB->hdr.Flags2 |= (SMBFLG2_UNICODE | SMBFLG2_ERR_STATUS);\n\n\tif (should_set_ext_sec_flag(ses->sectype)) {\n\t\tcifs_dbg(FYI, \"Requesting extended security.\");\n\t\tpSMB->hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < CIFS_NUM_PROT; i++) {\n\t\tstrncpy(pSMB->DialectsArray+count, protocols[i].name, 16);\n\t\tcount += strlen(protocols[i].name) + 1;\n\t\t/* null at end of source and target buffers anyway */\n\t}\n\tinc_rfc1001_len(pSMB, count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc != 0)\n\t\tgoto neg_err_exit;\n\n\tserver->dialect = le16_to_cpu(pSMBr->DialectIndex);\n\tcifs_dbg(FYI, \"Dialect: %d\\n\", server->dialect);\n\t/* Check wct = 1 error case */\n\tif ((pSMBr->hdr.WordCount < 13) || (server->dialect == BAD_PROT)) {\n\t\t/* core returns wct = 1, but we do not ask for core - otherwise\n\t\tsmall wct just comes when dialect index is -1 indicating we\n\t\tcould not negotiate a common dialect */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t} else if (pSMBr->hdr.WordCount == 13) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_LANMAN;\n\t\trc = decode_lanman_negprot_rsp(server, pSMBr);\n\t\tgoto signing_check;\n\t} else if (pSMBr->hdr.WordCount != 17) {\n\t\t/* unknown wct */\n\t\trc = -EOPNOTSUPP;\n\t\tgoto neg_err_exit;\n\t}\n\t/* else wct == 17, NTLM or better */\n\n\tserver->sec_mode = pSMBr->SecurityMode;\n\tif ((server->sec_mode & SECMODE_USER) == 0)\n\t\tcifs_dbg(FYI, \"share mode security\\n\");\n\n\t/* one byte, so no need to convert this or EncryptionKeyLen from\n\t   little endian */\n\tserver->maxReq = min_t(unsigned int, le16_to_cpu(pSMBr->MaxMpxCount),\n\t\t\t       cifs_max_pending);\n\tset_credits(server, server->maxReq);\n\t/* probably no need to store and check maxvcs */\n\tserver->maxBuf = le32_to_cpu(pSMBr->MaxBufferSize);\n\tserver->max_rw = le32_to_cpu(pSMBr->MaxRawSize);\n\tcifs_dbg(NOISY, \"Max buf = %d\\n\", ses->server->maxBuf);\n\tserver->capabilities = le32_to_cpu(pSMBr->Capabilities);\n\tserver->timeAdj = (int)(__s16)le16_to_cpu(pSMBr->ServerTimeZone);\n\tserver->timeAdj *= 60;\n\n\tif (pSMBr->EncryptionKeyLength == CIFS_CRYPTO_KEY_SIZE) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tmemcpy(ses->server->cryptkey, pSMBr->u.EncryptionKey,\n\t\t       CIFS_CRYPTO_KEY_SIZE);\n\t} else if ((pSMBr->hdr.Flags2 & SMBFLG2_EXT_SEC ||\n\t\t\tserver->capabilities & CAP_EXTENDED_SECURITY) &&\n\t\t\t\t(pSMBr->EncryptionKeyLength == 0)) {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t\trc = decode_ext_sec_blob(ses, pSMBr);\n\t} else if (server->sec_mode & SECMODE_PW_ENCRYPT) {\n\t\trc = -EIO; /* no crypt key only if plain text pwd */\n\t} else {\n\t\tserver->negflavor = CIFS_NEGFLAVOR_UNENCAP;\n\t\tserver->capabilities &= ~CAP_EXTENDED_SECURITY;\n\t}\n\nsigning_check:\n\tif (!rc)\n\t\trc = cifs_enable_signing(server, ses->sign);\nneg_err_exit:\n\tcifs_buf_release(pSMB);\n\n\tcifs_dbg(FYI, \"negprot rc %d\\n\", rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_credits",
          "args": [
            "ses->server",
            "1"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "127-134",
          "snippet": "static void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncifs_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc;\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\tset_credits(ses->server, 1);\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_need_neg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "417-421",
    "snippet": "static bool\ncifs_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->maxBuf == 0;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\ncifs_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->maxBuf == 0;\n}"
  },
  {
    "function_name": "cifs_check_trans2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "386-415",
    "snippet": "static bool\ncifs_check_trans2(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t  char *buf, int malformed)\n{\n\tif (malformed)\n\t\treturn false;\n\tif (check2ndT2(buf) <= 0)\n\t\treturn false;\n\tmid->multiRsp = true;\n\tif (mid->resp_buf) {\n\t\t/* merge response - fix up 1st*/\n\t\tmalformed = coalesce_t2(buf, mid->resp_buf);\n\t\tif (malformed > 0)\n\t\t\treturn true;\n\t\t/* All parts received or packet is malformed. */\n\t\tmid->multiEnd = true;\n\t\tdequeue_mid(mid, malformed);\n\t\treturn true;\n\t}\n\tif (!server->large_buf) {\n\t\t/*FIXME: switch to already allocated largebuf?*/\n\t\tcifs_dbg(VFS, \"1st trans2 resp needs bigbuf\\n\");\n\t} else {\n\t\t/* Have first buffer */\n\t\tmid->resp_buf = buf;\n\t\tmid->large_buf = true;\n\t\tserver->bigbuf = NULL;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"1st trans2 resp needs bigbuf\\n\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_mid",
          "args": [
            "mid",
            "malformed"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "657-670",
          "snippet": "void\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coalesce_t2",
          "args": [
            "buf",
            "mid->resp_buf"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "coalesce_t2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "285-374",
          "snippet": "static int\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\n{\n\tstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)target_hdr;\n\tchar *data_area_of_tgt;\n\tchar *data_area_of_src;\n\tint remaining;\n\tunsigned int byte_count, total_in_tgt;\n\t__u16 tgt_total_cnt, src_total_cnt, total_in_src;\n\n\tsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\n\ttgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (tgt_total_cnt != src_total_cnt)\n\t\tcifs_dbg(FYI, \"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\",\n\t\t\t src_total_cnt, tgt_total_cnt);\n\n\ttotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = tgt_total_cnt - total_in_tgt;\n\n\tif (remaining < 0) {\n\t\tcifs_dbg(FYI, \"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\\n\",\n\t\t\t tgt_total_cnt, total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (remaining == 0) {\n\t\t/* nothing to do, ignore */\n\t\tcifs_dbg(FYI, \"no more data remains\\n\");\n\t\treturn 0;\n\t}\n\n\ttotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\n\tif (remaining < total_in_src)\n\t\tcifs_dbg(FYI, \"transact2 2nd response contains too much data\\n\");\n\n\t/* find end of first SMB data area */\n\tdata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\n\t/* validate target area */\n\tdata_area_of_src = (char *)&pSMBs->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\n\n\tdata_area_of_tgt += total_in_tgt;\n\n\ttotal_in_tgt += total_in_src;\n\t/* is the result too big for the field? */\n\tif (total_in_tgt > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced DataCount too large (%u)\\n\",\n\t\t\t total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\tput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\n\n\t/* fix up the BCC */\n\tbyte_count = get_bcc(target_hdr);\n\tbyte_count += total_in_src;\n\t/* is the result too big for the field? */\n\tif (byte_count > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced BCC too large (%u)\\n\", byte_count);\n\t\treturn -EPROTO;\n\t}\n\tput_bcc(byte_count, target_hdr);\n\n\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\n\tbyte_count += total_in_src;\n\t/* don't allow buffer to overflow */\n\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",\n\t\t\t byte_count);\n\t\treturn -ENOBUFS;\n\t}\n\ttarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\n\n\tif (remaining != total_in_src) {\n\t\t/* more responses to go */\n\t\tcifs_dbg(FYI, \"waiting for more secondary responses\\n\");\n\t\treturn 1;\n\t}\n\n\t/* we are done */\n\tcifs_dbg(FYI, \"found the last secondary response\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\n{\n\tstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)target_hdr;\n\tchar *data_area_of_tgt;\n\tchar *data_area_of_src;\n\tint remaining;\n\tunsigned int byte_count, total_in_tgt;\n\t__u16 tgt_total_cnt, src_total_cnt, total_in_src;\n\n\tsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\n\ttgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (tgt_total_cnt != src_total_cnt)\n\t\tcifs_dbg(FYI, \"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\",\n\t\t\t src_total_cnt, tgt_total_cnt);\n\n\ttotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = tgt_total_cnt - total_in_tgt;\n\n\tif (remaining < 0) {\n\t\tcifs_dbg(FYI, \"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\\n\",\n\t\t\t tgt_total_cnt, total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (remaining == 0) {\n\t\t/* nothing to do, ignore */\n\t\tcifs_dbg(FYI, \"no more data remains\\n\");\n\t\treturn 0;\n\t}\n\n\ttotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\n\tif (remaining < total_in_src)\n\t\tcifs_dbg(FYI, \"transact2 2nd response contains too much data\\n\");\n\n\t/* find end of first SMB data area */\n\tdata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\n\t/* validate target area */\n\tdata_area_of_src = (char *)&pSMBs->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\n\n\tdata_area_of_tgt += total_in_tgt;\n\n\ttotal_in_tgt += total_in_src;\n\t/* is the result too big for the field? */\n\tif (total_in_tgt > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced DataCount too large (%u)\\n\",\n\t\t\t total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\tput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\n\n\t/* fix up the BCC */\n\tbyte_count = get_bcc(target_hdr);\n\tbyte_count += total_in_src;\n\t/* is the result too big for the field? */\n\tif (byte_count > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced BCC too large (%u)\\n\", byte_count);\n\t\treturn -EPROTO;\n\t}\n\tput_bcc(byte_count, target_hdr);\n\n\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\n\tbyte_count += total_in_src;\n\t/* don't allow buffer to overflow */\n\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",\n\t\t\t byte_count);\n\t\treturn -ENOBUFS;\n\t}\n\ttarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\n\n\tif (remaining != total_in_src) {\n\t\t/* more responses to go */\n\t\tcifs_dbg(FYI, \"waiting for more secondary responses\\n\");\n\t\treturn 1;\n\t}\n\n\t/* we are done */\n\tcifs_dbg(FYI, \"found the last secondary response\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check2ndT2",
          "args": [
            "buf"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "check2ndT2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "242-283",
          "snippet": "static int\ncheck2ndT2(char *buf)\n{\n\tstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcifs_dbg(FYI, \"invalid transact2 word count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tif (total_data_size == data_in_this_rsp)\n\t\treturn 0;\n\telse if (total_data_size < data_in_this_rsp) {\n\t\tcifs_dbg(FYI, \"total data %d smaller than data in frame %d\\n\",\n\t\t\t total_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tcifs_dbg(FYI, \"missing %d bytes from transact2, check next response\\n\",\n\t\t remaining);\n\tif (total_data_size > CIFSMaxBufSize) {\n\t\tcifs_dbg(VFS, \"TotalDataSize %d is over maximum buffer %d\\n\",\n\t\t\t total_data_size, CIFSMaxBufSize);\n\t\treturn -EINVAL;\n\t}\n\treturn remaining;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncheck2ndT2(char *buf)\n{\n\tstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcifs_dbg(FYI, \"invalid transact2 word count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tif (total_data_size == data_in_this_rsp)\n\t\treturn 0;\n\telse if (total_data_size < data_in_this_rsp) {\n\t\tcifs_dbg(FYI, \"total data %d smaller than data in frame %d\\n\",\n\t\t\t total_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tcifs_dbg(FYI, \"missing %d bytes from transact2, check next response\\n\",\n\t\t remaining);\n\tif (total_data_size > CIFSMaxBufSize) {\n\t\tcifs_dbg(VFS, \"TotalDataSize %d is over maximum buffer %d\\n\",\n\t\t\t total_data_size, CIFSMaxBufSize);\n\t\treturn -EINVAL;\n\t}\n\treturn remaining;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\ncifs_check_trans2(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t\t  char *buf, int malformed)\n{\n\tif (malformed)\n\t\treturn false;\n\tif (check2ndT2(buf) <= 0)\n\t\treturn false;\n\tmid->multiRsp = true;\n\tif (mid->resp_buf) {\n\t\t/* merge response - fix up 1st*/\n\t\tmalformed = coalesce_t2(buf, mid->resp_buf);\n\t\tif (malformed > 0)\n\t\t\treturn true;\n\t\t/* All parts received or packet is malformed. */\n\t\tmid->multiEnd = true;\n\t\tdequeue_mid(mid, malformed);\n\t\treturn true;\n\t}\n\tif (!server->large_buf) {\n\t\t/*FIXME: switch to already allocated largebuf?*/\n\t\tcifs_dbg(VFS, \"1st trans2 resp needs bigbuf\\n\");\n\t} else {\n\t\t/* Have first buffer */\n\t\tmid->resp_buf = buf;\n\t\tmid->large_buf = true;\n\t\tserver->bigbuf = NULL;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "cifs_downgrade_oplock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "376-384",
    "snippet": "static void\ncifs_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t\tstruct cifsInodeInfo *cinode, bool set_level2)\n{\n\tif (set_level2)\n\t\tcifs_set_oplock_level(cinode, OPLOCK_READ);\n\telse\n\t\tcifs_set_oplock_level(cinode, 0);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_set_oplock_level",
          "args": [
            "cinode",
            "0"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_set_oplock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "533-547",
          "snippet": "void cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid cifs_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock)\n{\n\toplock &= 0xF;\n\n\tif (oplock == OPLOCK_EXCLUSIVE) {\n\t\tcinode->oplock = CIFS_CACHE_WRITE_FLG | CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Exclusive Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else if (oplock == OPLOCK_READ) {\n\t\tcinode->oplock = CIFS_CACHE_READ_FLG;\n\t\tcifs_dbg(FYI, \"Level II Oplock granted on inode %p\\n\",\n\t\t\t &cinode->vfs_inode);\n\t} else\n\t\tcinode->oplock = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_downgrade_oplock(struct TCP_Server_Info *server,\n\t\t\tstruct cifsInodeInfo *cinode, bool set_level2)\n{\n\tif (set_level2)\n\t\tcifs_set_oplock_level(cinode, OPLOCK_READ);\n\telse\n\t\tcifs_set_oplock_level(cinode, 0);\n}"
  },
  {
    "function_name": "coalesce_t2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "285-374",
    "snippet": "static int\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\n{\n\tstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)target_hdr;\n\tchar *data_area_of_tgt;\n\tchar *data_area_of_src;\n\tint remaining;\n\tunsigned int byte_count, total_in_tgt;\n\t__u16 tgt_total_cnt, src_total_cnt, total_in_src;\n\n\tsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\n\ttgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (tgt_total_cnt != src_total_cnt)\n\t\tcifs_dbg(FYI, \"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\",\n\t\t\t src_total_cnt, tgt_total_cnt);\n\n\ttotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = tgt_total_cnt - total_in_tgt;\n\n\tif (remaining < 0) {\n\t\tcifs_dbg(FYI, \"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\\n\",\n\t\t\t tgt_total_cnt, total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (remaining == 0) {\n\t\t/* nothing to do, ignore */\n\t\tcifs_dbg(FYI, \"no more data remains\\n\");\n\t\treturn 0;\n\t}\n\n\ttotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\n\tif (remaining < total_in_src)\n\t\tcifs_dbg(FYI, \"transact2 2nd response contains too much data\\n\");\n\n\t/* find end of first SMB data area */\n\tdata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\n\t/* validate target area */\n\tdata_area_of_src = (char *)&pSMBs->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\n\n\tdata_area_of_tgt += total_in_tgt;\n\n\ttotal_in_tgt += total_in_src;\n\t/* is the result too big for the field? */\n\tif (total_in_tgt > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced DataCount too large (%u)\\n\",\n\t\t\t total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\tput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\n\n\t/* fix up the BCC */\n\tbyte_count = get_bcc(target_hdr);\n\tbyte_count += total_in_src;\n\t/* is the result too big for the field? */\n\tif (byte_count > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced BCC too large (%u)\\n\", byte_count);\n\t\treturn -EPROTO;\n\t}\n\tput_bcc(byte_count, target_hdr);\n\n\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\n\tbyte_count += total_in_src;\n\t/* don't allow buffer to overflow */\n\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",\n\t\t\t byte_count);\n\t\treturn -ENOBUFS;\n\t}\n\ttarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\n\n\tif (remaining != total_in_src) {\n\t\t/* more responses to go */\n\t\tcifs_dbg(FYI, \"waiting for more secondary responses\\n\");\n\t\treturn 1;\n\t}\n\n\t/* we are done */\n\tcifs_dbg(FYI, \"found the last secondary response\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"found the last secondary response\\n\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"waiting for more secondary responses\\n\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data_area_of_tgt",
            "data_area_of_src",
            "total_in_src"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "byte_count"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"coalesced BCC exceeds buffer size (%u)\\n\"",
            "byte_count"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "target_hdr->smb_buf_length"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bcc",
          "args": [
            "byte_count",
            "target_hdr"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "put_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "455-461",
          "snippet": "static inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"coalesced BCC too large (%u)\\n\"",
            "byte_count"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bcc",
          "args": [
            "target_hdr"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "get_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "446-452",
          "snippet": "static inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline __u16\nget_bcc(struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\treturn get_unaligned_le16(bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned_le16",
          "args": [
            "total_in_tgt",
            "&pSMBt->t2_rsp.DataCount"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"coalesced DataCount too large (%u)\\n\"",
            "total_in_tgt"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBs->t2_rsp.DataOffset"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBt->t2_rsp.DataOffset"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"transact2 2nd response contains too much data\\n\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBs->t2_rsp.DataCount"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"no more data remains\\n\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\\n\"",
            "tgt_total_cnt",
            "total_in_tgt"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBt->t2_rsp.DataCount"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\"",
            "src_total_cnt",
            "tgt_total_cnt"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBt->t2_rsp.TotalDataCount"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBs->t2_rsp.TotalDataCount"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncoalesce_t2(char *second_buf, struct smb_hdr *target_hdr)\n{\n\tstruct smb_t2_rsp *pSMBs = (struct smb_t2_rsp *)second_buf;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)target_hdr;\n\tchar *data_area_of_tgt;\n\tchar *data_area_of_src;\n\tint remaining;\n\tunsigned int byte_count, total_in_tgt;\n\t__u16 tgt_total_cnt, src_total_cnt, total_in_src;\n\n\tsrc_total_cnt = get_unaligned_le16(&pSMBs->t2_rsp.TotalDataCount);\n\ttgt_total_cnt = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\n\tif (tgt_total_cnt != src_total_cnt)\n\t\tcifs_dbg(FYI, \"total data count of primary and secondary t2 differ source=%hu target=%hu\\n\",\n\t\t\t src_total_cnt, tgt_total_cnt);\n\n\ttotal_in_tgt = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tremaining = tgt_total_cnt - total_in_tgt;\n\n\tif (remaining < 0) {\n\t\tcifs_dbg(FYI, \"Server sent too much data. tgt_total_cnt=%hu total_in_tgt=%hu\\n\",\n\t\t\t tgt_total_cnt, total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\n\tif (remaining == 0) {\n\t\t/* nothing to do, ignore */\n\t\tcifs_dbg(FYI, \"no more data remains\\n\");\n\t\treturn 0;\n\t}\n\n\ttotal_in_src = get_unaligned_le16(&pSMBs->t2_rsp.DataCount);\n\tif (remaining < total_in_src)\n\t\tcifs_dbg(FYI, \"transact2 2nd response contains too much data\\n\");\n\n\t/* find end of first SMB data area */\n\tdata_area_of_tgt = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBt->t2_rsp.DataOffset);\n\n\t/* validate target area */\n\tdata_area_of_src = (char *)&pSMBs->hdr.Protocol +\n\t\t\t\tget_unaligned_le16(&pSMBs->t2_rsp.DataOffset);\n\n\tdata_area_of_tgt += total_in_tgt;\n\n\ttotal_in_tgt += total_in_src;\n\t/* is the result too big for the field? */\n\tif (total_in_tgt > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced DataCount too large (%u)\\n\",\n\t\t\t total_in_tgt);\n\t\treturn -EPROTO;\n\t}\n\tput_unaligned_le16(total_in_tgt, &pSMBt->t2_rsp.DataCount);\n\n\t/* fix up the BCC */\n\tbyte_count = get_bcc(target_hdr);\n\tbyte_count += total_in_src;\n\t/* is the result too big for the field? */\n\tif (byte_count > USHRT_MAX) {\n\t\tcifs_dbg(FYI, \"coalesced BCC too large (%u)\\n\", byte_count);\n\t\treturn -EPROTO;\n\t}\n\tput_bcc(byte_count, target_hdr);\n\n\tbyte_count = be32_to_cpu(target_hdr->smb_buf_length);\n\tbyte_count += total_in_src;\n\t/* don't allow buffer to overflow */\n\tif (byte_count > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) {\n\t\tcifs_dbg(FYI, \"coalesced BCC exceeds buffer size (%u)\\n\",\n\t\t\t byte_count);\n\t\treturn -ENOBUFS;\n\t}\n\ttarget_hdr->smb_buf_length = cpu_to_be32(byte_count);\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_tgt, data_area_of_src, total_in_src);\n\n\tif (remaining != total_in_src) {\n\t\t/* more responses to go */\n\t\tcifs_dbg(FYI, \"waiting for more secondary responses\\n\");\n\t\treturn 1;\n\t}\n\n\t/* we are done */\n\tcifs_dbg(FYI, \"found the last secondary response\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "check2ndT2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "242-283",
    "snippet": "static int\ncheck2ndT2(char *buf)\n{\n\tstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcifs_dbg(FYI, \"invalid transact2 word count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tif (total_data_size == data_in_this_rsp)\n\t\treturn 0;\n\telse if (total_data_size < data_in_this_rsp) {\n\t\tcifs_dbg(FYI, \"total data %d smaller than data in frame %d\\n\",\n\t\t\t total_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tcifs_dbg(FYI, \"missing %d bytes from transact2, check next response\\n\",\n\t\t remaining);\n\tif (total_data_size > CIFSMaxBufSize) {\n\t\tcifs_dbg(VFS, \"TotalDataSize %d is over maximum buffer %d\\n\",\n\t\t\t total_data_size, CIFSMaxBufSize);\n\t\treturn -EINVAL;\n\t}\n\treturn remaining;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"TotalDataSize %d is over maximum buffer %d\\n\"",
            "total_data_size",
            "CIFSMaxBufSize"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"missing %d bytes from transact2, check next response\\n\"",
            "remaining"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"total data %d smaller than data in frame %d\\n\"",
            "total_data_size",
            "data_in_this_rsp"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBt->t2_rsp.DataCount"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_le16",
          "args": [
            "&pSMBt->t2_rsp.TotalDataCount"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"invalid transact2 word count\\n\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\ncheck2ndT2(char *buf)\n{\n\tstruct smb_hdr *pSMB = (struct smb_hdr *)buf;\n\tstruct smb_t2_rsp *pSMBt;\n\tint remaining;\n\t__u16 total_data_size, data_in_this_rsp;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcifs_dbg(FYI, \"invalid transact2 word count\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = get_unaligned_le16(&pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = get_unaligned_le16(&pSMBt->t2_rsp.DataCount);\n\n\tif (total_data_size == data_in_this_rsp)\n\t\treturn 0;\n\telse if (total_data_size < data_in_this_rsp) {\n\t\tcifs_dbg(FYI, \"total data %d smaller than data in frame %d\\n\",\n\t\t\t total_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tcifs_dbg(FYI, \"missing %d bytes from transact2, check next response\\n\",\n\t\t remaining);\n\tif (total_data_size > CIFSMaxBufSize) {\n\t\tcifs_dbg(VFS, \"TotalDataSize %d is over maximum buffer %d\\n\",\n\t\t\t total_data_size, CIFSMaxBufSize);\n\t\treturn -EINVAL;\n\t}\n\treturn remaining;\n}"
  },
  {
    "function_name": "cifs_get_next_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "169-234",
    "snippet": "static __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mid_entry",
            "&server->pending_mid_q",
            "qhead"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(server->CurrentMid) & 0xffff"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic __u64\ncifs_get_next_mid(struct TCP_Server_Info *server)\n{\n\t__u64 mid = 0;\n\t__u16 last_mid, cur_mid;\n\tbool collision;\n\n\tspin_lock(&GlobalMid_Lock);\n\n\t/* mid is 16 bit only for CIFS/SMB */\n\tcur_mid = (__u16)((server->CurrentMid) & 0xffff);\n\t/* we do not want to loop forever */\n\tlast_mid = cur_mid;\n\tcur_mid++;\n\n\t/*\n\t * This nested loop looks more expensive than it is.\n\t * In practice the list of pending requests is short,\n\t * fewer than 50, and the mids are likely to be unique\n\t * on the first pass through the loop unless some request\n\t * takes longer than the 64 thousand requests before it\n\t * (and it would also have to have been a request that\n\t * did not time out).\n\t */\n\twhile (cur_mid != last_mid) {\n\t\tstruct mid_q_entry *mid_entry;\n\t\tunsigned int num_mids;\n\n\t\tcollision = false;\n\t\tif (cur_mid == 0)\n\t\t\tcur_mid++;\n\n\t\tnum_mids = 0;\n\t\tlist_for_each_entry(mid_entry, &server->pending_mid_q, qhead) {\n\t\t\t++num_mids;\n\t\t\tif (mid_entry->mid == cur_mid &&\n\t\t\t    mid_entry->mid_state == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* This mid is in use, try a different one */\n\t\t\t\tcollision = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if we have more than 32k mids in the list, then something\n\t\t * is very wrong. Possibly a local user is trying to DoS the\n\t\t * box by issuing long-running calls and SIGKILL'ing them. If\n\t\t * we get to 2^16 mids then we're in big trouble as this\n\t\t * function could loop forever.\n\t\t *\n\t\t * Go ahead and assign out the mid in this situation, but force\n\t\t * an eventual reconnect to clean out the pending_mid_q.\n\t\t */\n\t\tif (num_mids > 32768)\n\t\t\tserver->tcpStatus = CifsNeedReconnect;\n\n\t\tif (!collision) {\n\t\t\tmid = (__u64)cur_mid;\n\t\t\tserver->CurrentMid = mid;\n\t\t\tbreak;\n\t\t}\n\t\tcur_mid++;\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn mid;\n}"
  },
  {
    "function_name": "cifs_get_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "142-146",
    "snippet": "static unsigned int\ncifs_get_credits(struct mid_q_entry *mid)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_get_credits(struct mid_q_entry *mid)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_get_credits_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "136-140",
    "snippet": "static int *\ncifs_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\treturn &server->credits;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int *\ncifs_get_credits_field(struct TCP_Server_Info *server, const int optype)\n{\n\treturn &server->credits;\n}"
  },
  {
    "function_name": "cifs_set_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "127-134",
    "snippet": "static void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tserver->oplocks = val > 1 ? enable_oplocks : false;\n\tspin_unlock(&server->req_lock);\n}"
  },
  {
    "function_name": "cifs_add_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "116-125",
    "snippet": "static void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&server->request_q"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_wake_up_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "40-44",
          "snippet": "void\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nvoid\ncifs_wake_up_task(struct mid_q_entry *mid)\n{\n\twake_up_process(mid->callback_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&server->req_lock"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&server->req_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic void\ncifs_add_credits(struct TCP_Server_Info *server, const unsigned int add,\n\t\t const int optype)\n{\n\tspin_lock(&server->req_lock);\n\tserver->credits += add;\n\tserver->in_flight--;\n\tspin_unlock(&server->req_lock);\n\twake_up(&server->request_q);\n}"
  },
  {
    "function_name": "cifs_find_mid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "97-114",
    "snippet": "static struct mid_q_entry *\ncifs_find_mid(struct TCP_Server_Info *server, char *buffer)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct mid_q_entry *mid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif (compare_mid(mid->mid, buf) &&\n\t\t    mid->mid_state == MID_REQUEST_SUBMITTED &&\n\t\t    le16_to_cpu(mid->command) == buf->Command) {\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "mid->command"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_mid",
          "args": [
            "mid->mid",
            "buf"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "compare_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "687-691",
          "snippet": "static inline bool\ncompare_mid(__u16 mid, const struct smb_hdr *smb)\n{\n\treturn mid == le16_to_cpu(smb->Mid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncompare_mid(__u16 mid, const struct smb_hdr *smb)\n{\n\treturn mid == le16_to_cpu(smb->Mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mid",
            "&server->pending_mid_q",
            "qhead"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&GlobalMid_Lock"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic struct mid_q_entry *\ncifs_find_mid(struct TCP_Server_Info *server, char *buffer)\n{\n\tstruct smb_hdr *buf = (struct smb_hdr *)buffer;\n\tstruct mid_q_entry *mid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_entry(mid, &server->pending_mid_q, qhead) {\n\t\tif (compare_mid(mid->mid, buf) &&\n\t\t    mid->mid_state == MID_REQUEST_SUBMITTED &&\n\t\t    le16_to_cpu(mid->command) == buf->Command) {\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t\treturn mid;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cifs_read_data_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "89-95",
    "snippet": "static unsigned int\ncifs_read_data_length(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\n\t       le16_to_cpu(rsp->DataLength);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->DataLength"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_read_data_length(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\n\t       le16_to_cpu(rsp->DataLength);\n}"
  },
  {
    "function_name": "cifs_read_data_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "82-87",
    "snippet": "static unsigned int\ncifs_read_data_offset(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn le16_to_cpu(rsp->DataOffset);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->DataOffset"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_read_data_offset(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn le16_to_cpu(rsp->DataOffset);\n}"
  },
  {
    "function_name": "cifs_compare_fids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "76-80",
    "snippet": "static bool\ncifs_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.netfid == ob2->fid.netfid;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic bool\ncifs_compare_fids(struct cifsFileInfo *ob1, struct cifsFileInfo *ob2)\n{\n\treturn ob1->fid.netfid == ob2->fid.netfid;\n}"
  },
  {
    "function_name": "send_nt_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
    "lines": "38-74",
    "snippet": "static int\nsend_nt_cancel(struct TCP_Server_Info *server, void *buf,\n\t       struct mid_q_entry *mid)\n{\n\tint rc = 0;\n\tstruct smb_hdr *in_buf = (struct smb_hdr *)buf;\n\n\t/* -4 for RFC1001 length and +2 for BCC field */\n\tin_buf->smb_buf_length = cpu_to_be32(sizeof(struct smb_hdr) - 4  + 2);\n\tin_buf->Command = SMB_COM_NT_CANCEL;\n\tin_buf->WordCount = 0;\n\tput_bcc(0, in_buf);\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_sign_smb(in_buf, server, &mid->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * The response to this call was already factored into the sequence\n\t * number when the call went out, so we must adjust it back downward\n\t * after signing here.\n\t */\n\t--server->sequence_number;\n\trc = smb_send(server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tif (rc < 0)\n\t\tserver->sequence_number--;\n\n\tmutex_unlock(&server->srv_mutex);\n\n\tcifs_dbg(FYI, \"issued NT_CANCEL for mid %u, rc = %d\\n\",\n\t\t get_mid(in_buf), rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/vfs.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"issued NT_CANCEL for mid %u, rc = %d\\n\"",
            "get_mid(in_buf)",
            "rc"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mid",
          "args": [
            "in_buf"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "get_mid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "681-685",
          "snippet": "static inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline __u16\nget_mid(const struct smb_hdr *smb)\n{\n\treturn le16_to_cpu(smb->Mid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb_send",
          "args": [
            "server",
            "in_buf",
            "be32_to_cpu(in_buf->smb_buf_length)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "smb_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/transport.c",
          "lines": "378-388",
          "snippet": "int\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/highmem.h>",
            "#include <linux/tcp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/delay.h>",
            "#include <linux/net.h>",
            "#include <linux/wait.h>",
            "#include <linux/gfp.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/highmem.h>\n#include <linux/tcp.h>\n#include <linux/freezer.h>\n#include <linux/delay.h>\n#include <linux/net.h>\n#include <linux/wait.h>\n#include <linux/gfp.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n\nint\nsmb_send(struct TCP_Server_Info *server, struct smb_hdr *smb_buffer,\n\t unsigned int smb_buf_length)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = smb_buffer;\n\tiov.iov_len = smb_buf_length + 4;\n\n\treturn smb_sendv(server, &iov, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "in_buf->smb_buf_length"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sign_smb",
          "args": [
            "in_buf",
            "server",
            "&mid->sequence_number"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sign_smb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsencrypt.c",
          "lines": "194-204",
          "snippet": "int cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/random.h>",
            "#include <linux/ctype.h>",
            "#include \"ntlmssp.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/random.h>\n#include <linux/ctype.h>\n#include \"ntlmssp.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint cifs_sign_smb(struct smb_hdr *cifs_pdu, struct TCP_Server_Info *server,\n\t\t  __u32 *pexpected_response_sequence_number)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = cifs_pdu;\n\tiov.iov_len = be32_to_cpu(cifs_pdu->smb_buf_length) + 4;\n\n\treturn cifs_sign_smbv(&iov, 1, server,\n\t\t\t      pexpected_response_sequence_number);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&server->srv_mutex"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bcc",
          "args": [
            "0",
            "in_buf"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "put_bcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifspdu.h",
          "lines": "455-461",
          "snippet": "static inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}",
          "includes": [
            "#include \"smbfsctl.h\"",
            "#include <asm/unaligned.h>",
            "#include <net/sock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smbfsctl.h\"\n#include <asm/unaligned.h>\n#include <net/sock.h>\n\nstatic inline void\nput_bcc(__u16 count, struct smb_hdr *hdr)\n{\n\t__le16 *bc_ptr = (__le16 *)BCC(hdr);\n\n\tput_unaligned_le16(count, bc_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sizeof(struct smb_hdr) - 4  + 2"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic int\nsend_nt_cancel(struct TCP_Server_Info *server, void *buf,\n\t       struct mid_q_entry *mid)\n{\n\tint rc = 0;\n\tstruct smb_hdr *in_buf = (struct smb_hdr *)buf;\n\n\t/* -4 for RFC1001 length and +2 for BCC field */\n\tin_buf->smb_buf_length = cpu_to_be32(sizeof(struct smb_hdr) - 4  + 2);\n\tin_buf->Command = SMB_COM_NT_CANCEL;\n\tin_buf->WordCount = 0;\n\tput_bcc(0, in_buf);\n\n\tmutex_lock(&server->srv_mutex);\n\trc = cifs_sign_smb(in_buf, server, &mid->sequence_number);\n\tif (rc) {\n\t\tmutex_unlock(&server->srv_mutex);\n\t\treturn rc;\n\t}\n\n\t/*\n\t * The response to this call was already factored into the sequence\n\t * number when the call went out, so we must adjust it back downward\n\t * after signing here.\n\t */\n\t--server->sequence_number;\n\trc = smb_send(server, in_buf, be32_to_cpu(in_buf->smb_buf_length));\n\tif (rc < 0)\n\t\tserver->sequence_number--;\n\n\tmutex_unlock(&server->srv_mutex);\n\n\tcifs_dbg(FYI, \"issued NT_CANCEL for mid %u, rc = %d\\n\",\n\t\t get_mid(in_buf), rc);\n\n\treturn rc;\n}"
  }
]