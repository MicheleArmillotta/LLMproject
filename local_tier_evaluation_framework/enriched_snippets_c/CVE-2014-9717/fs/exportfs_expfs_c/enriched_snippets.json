[
  {
    "function_name": "exportfs_decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "412-541",
    "snippet": "struct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int get_name(const struct path *path, char *name, struct dentry *child);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "result"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_acceptable_alias",
          "args": [
            "result",
            "acceptable",
            "context"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "find_acceptable_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "40-70",
          "snippet": "static struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\n\tinode = result->d_inode;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tdget(dentry);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (toput)\n\t\t\tdput(toput);\n\t\tif (dentry != result && acceptable(context, dentry)) {\n\t\t\tdput(result);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t\ttoput = dentry;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (toput)\n\t\tdput(toput);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\n\tinode = result->d_inode;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tdget(dentry);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (toput)\n\t\t\tdput(toput);\n\t\tif (dentry != result && acceptable(context, dentry)) {\n\t\t\tdput(result);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t\ttoput = dentry;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (toput)\n\t\tdput(toput);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nresult"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&target_dir->d_inode->i_mutex"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "nbuf",
            "target_dir",
            "strlen(nbuf)"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nbuf"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&target_dir->d_inode->i_mutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_get_name",
          "args": [
            "mnt",
            "target_dir",
            "nbuf",
            "result"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "25-35",
          "snippet": "static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstatic int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reconnect_path",
          "args": [
            "mnt",
            "target_dir",
            "nbuf"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "reconnect_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "204-229",
          "snippet": "static int\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\n{\n\tstruct dentry *dentry, *parent;\n\n\tdentry = dget(target_dir);\n\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tBUG_ON(dentry == mnt->mnt_sb->s_root);\n\n\t\tif (IS_ROOT(dentry))\n\t\t\tparent = reconnect_one(mnt, dentry, nbuf);\n\t\telse\n\t\t\tparent = dget_parent(dentry);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\t\tdput(dentry);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\tclear_disconnected(target_dir);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\n{\n\tstruct dentry *dentry, *parent;\n\n\tdentry = dget(target_dir);\n\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tBUG_ON(dentry == mnt->mnt_sb->s_root);\n\n\t\tif (IS_ROOT(dentry))\n\t\t\tparent = reconnect_one(mnt, dentry, nbuf);\n\t\telse\n\t\t\tparent = dget_parent(dentry);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\t\tdput(dentry);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\tclear_disconnected(target_dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "target_dir"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "target_dir"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nop->fh_to_parent",
          "args": [
            "mnt->mnt_sb",
            "fid",
            "fh_len",
            "fileid_type"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptable",
          "args": [
            "context",
            "result"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dentry_acceptable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fhandle.c",
          "lines": "133-136",
          "snippet": "static int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "result"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "result"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nop->fh_to_dentry",
          "args": [
            "mnt->mnt_sb",
            "fid",
            "fh_len",
            "fileid_type"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstruct dentry *exportfs_decode_fh(struct vfsmount *mnt, struct fid *fid,\n\t\tint fh_len, int fileid_type,\n\t\tint (*acceptable)(void *, struct dentry *), void *context)\n{\n\tconst struct export_operations *nop = mnt->mnt_sb->s_export_op;\n\tstruct dentry *result, *alias;\n\tchar nbuf[NAME_MAX+1];\n\tint err;\n\n\t/*\n\t * Try to get any dentry for the given file handle from the filesystem.\n\t */\n\tif (!nop || !nop->fh_to_dentry)\n\t\treturn ERR_PTR(-ESTALE);\n\tresult = nop->fh_to_dentry(mnt->mnt_sb, fid, fh_len, fileid_type);\n\tif (!result)\n\t\tresult = ERR_PTR(-ESTALE);\n\tif (IS_ERR(result))\n\t\treturn result;\n\n\tif (d_is_dir(result)) {\n\t\t/*\n\t\t * This request is for a directory.\n\t\t *\n\t\t * On the positive side there is only one dentry for each\n\t\t * directory inode.  On the negative side this implies that we\n\t\t * to ensure our dentry is connected all the way up to the\n\t\t * filesystem root.\n\t\t */\n\t\tif (result->d_flags & DCACHE_DISCONNECTED) {\n\t\t\terr = reconnect_path(mnt, result, nbuf);\n\t\t\tif (err)\n\t\t\t\tgoto err_result;\n\t\t}\n\n\t\tif (!acceptable(context, result)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\t/*\n\t\t * It's not a directory.  Life is a little more complicated.\n\t\t */\n\t\tstruct dentry *target_dir, *nresult;\n\n\t\t/*\n\t\t * See if either the dentry we just got from the filesystem\n\t\t * or any alias for it is acceptable.  This is always true\n\t\t * if this filesystem is exported without the subtreecheck\n\t\t * option.  If the filesystem is exported with the subtree\n\t\t * check option there's a fair chance we need to look at\n\t\t * the parent directory in the file handle and make sure\n\t\t * it's connected to the filesystem root.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (alias)\n\t\t\treturn alias;\n\n\t\t/*\n\t\t * Try to extract a dentry for the parent directory from the\n\t\t * file handle.  If this fails we'll have to give up.\n\t\t */\n\t\terr = -ESTALE;\n\t\tif (!nop->fh_to_parent)\n\t\t\tgoto err_result;\n\n\t\ttarget_dir = nop->fh_to_parent(mnt->mnt_sb, fid,\n\t\t\t\tfh_len, fileid_type);\n\t\tif (!target_dir)\n\t\t\tgoto err_result;\n\t\terr = PTR_ERR(target_dir);\n\t\tif (IS_ERR(target_dir))\n\t\t\tgoto err_result;\n\n\t\t/*\n\t\t * And as usual we need to make sure the parent directory is\n\t\t * connected to the filesystem root.  The VFS really doesn't\n\t\t * like disconnected directories..\n\t\t */\n\t\terr = reconnect_path(mnt, target_dir, nbuf);\n\t\tif (err) {\n\t\t\tdput(target_dir);\n\t\t\tgoto err_result;\n\t\t}\n\n\t\t/*\n\t\t * Now that we've got both a well-connected parent and a\n\t\t * dentry for the inode we're after, make sure that our\n\t\t * inode is actually connected to the parent.\n\t\t */\n\t\terr = exportfs_get_name(mnt, target_dir, nbuf, result);\n\t\tif (!err) {\n\t\t\tmutex_lock(&target_dir->d_inode->i_mutex);\n\t\t\tnresult = lookup_one_len(nbuf, target_dir,\n\t\t\t\t\t\t strlen(nbuf));\n\t\t\tmutex_unlock(&target_dir->d_inode->i_mutex);\n\t\t\tif (!IS_ERR(nresult)) {\n\t\t\t\tif (nresult->d_inode) {\n\t\t\t\t\tdput(result);\n\t\t\t\t\tresult = nresult;\n\t\t\t\t} else\n\t\t\t\t\tdput(nresult);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * At this point we are done with the parent, but it's pinned\n\t\t * by the child dentry anyway.\n\t\t */\n\t\tdput(target_dir);\n\n\t\t/*\n\t\t * And finally make sure the dentry is actually acceptable\n\t\t * to NFSD.\n\t\t */\n\t\talias = find_acceptable_alias(result, acceptable, context);\n\t\tif (!alias) {\n\t\t\terr = -EACCES;\n\t\t\tgoto err_result;\n\t\t}\n\n\t\treturn alias;\n\t}\n\n err_result:\n\tdput(result);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "exportfs_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "389-409",
    "snippet": "int exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "p"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exportfs_encode_inode_fh",
          "args": [
            "inode",
            "fid",
            "max_len",
            "parent"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_encode_inode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "377-386",
          "snippet": "int exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_fh(struct dentry *dentry, struct fid *fid, int *max_len,\n\t\tint connectable)\n{\n\tint error;\n\tstruct dentry *p = NULL;\n\tstruct inode *inode = dentry->d_inode, *parent = NULL;\n\n\tif (connectable && !S_ISDIR(inode->i_mode)) {\n\t\tp = dget_parent(dentry);\n\t\t/*\n\t\t * note that while p might've ceased to be our parent already,\n\t\t * it's still pinned by and still positive.\n\t\t */\n\t\tparent = p->d_inode;\n\t}\n\n\terror = exportfs_encode_inode_fh(inode, fid, max_len, parent);\n\tdput(p);\n\n\treturn error;\n}"
  },
  {
    "function_name": "exportfs_encode_inode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "377-386",
    "snippet": "int exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "export_encode_fh",
          "args": [
            "inode",
            "fid",
            "max_len",
            "parent"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "export_encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "350-375",
          "snippet": "static int export_encode_fh(struct inode *inode, struct fid *fid,\n\t\tint *max_len, struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = FILEID_INO32_GEN;\n\n\tif (parent && (len < 4)) {\n\t\t*max_len = 4;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 2;\n\tfid->i32.ino = inode->i_ino;\n\tfid->i32.gen = inode->i_generation;\n\tif (parent) {\n\t\tfid->i32.parent_ino = parent->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tlen = 4;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t}\n\t*max_len = len;\n\treturn type;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int export_encode_fh(struct inode *inode, struct fid *fid,\n\t\tint *max_len, struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = FILEID_INO32_GEN;\n\n\tif (parent && (len < 4)) {\n\t\t*max_len = 4;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 2;\n\tfid->i32.ino = inode->i_ino;\n\tfid->i32.gen = inode->i_generation;\n\tif (parent) {\n\t\tfid->i32.parent_ino = parent->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tlen = 4;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t}\n\t*max_len = len;\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nop->encode_fh",
          "args": [
            "inode",
            "fid->raw",
            "max_len",
            "parent"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nint exportfs_encode_inode_fh(struct inode *inode, struct fid *fid,\n\t\t\t     int *max_len, struct inode *parent)\n{\n\tconst struct export_operations *nop = inode->i_sb->s_export_op;\n\n\tif (nop && nop->encode_fh)\n\t\treturn nop->encode_fh(inode, fid->raw, max_len, parent);\n\n\treturn export_encode_fh(inode, fid, max_len, parent);\n}"
  },
  {
    "function_name": "export_encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "350-375",
    "snippet": "static int export_encode_fh(struct inode *inode, struct fid *fid,\n\t\tint *max_len, struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = FILEID_INO32_GEN;\n\n\tif (parent && (len < 4)) {\n\t\t*max_len = 4;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 2;\n\tfid->i32.ino = inode->i_ino;\n\tfid->i32.gen = inode->i_generation;\n\tif (parent) {\n\t\tfid->i32.parent_ino = parent->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tlen = 4;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t}\n\t*max_len = len;\n\treturn type;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int export_encode_fh(struct inode *inode, struct fid *fid,\n\t\tint *max_len, struct inode *parent)\n{\n\tint len = *max_len;\n\tint type = FILEID_INO32_GEN;\n\n\tif (parent && (len < 4)) {\n\t\t*max_len = 4;\n\t\treturn FILEID_INVALID;\n\t} else if (len < 2) {\n\t\t*max_len = 2;\n\t\treturn FILEID_INVALID;\n\t}\n\n\tlen = 2;\n\tfid->i32.ino = inode->i_ino;\n\tfid->i32.gen = inode->i_generation;\n\tif (parent) {\n\t\tfid->i32.parent_ino = parent->i_ino;\n\t\tfid->i32.parent_gen = parent->i_generation;\n\t\tlen = 4;\n\t\ttype = FILEID_INO32_GEN_PARENT;\n\t}\n\t*max_len = len;\n\treturn type;\n}"
  },
  {
    "function_name": "get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "270-336",
    "snippet": "static int get_name(const struct path *path, char *name, struct dentry *child)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *dir = path->dentry->d_inode;\n\tint error;\n\tstruct file *file;\n\tstruct kstat stat;\n\tstruct path child_path = {\n\t\t.mnt = path->mnt,\n\t\t.dentry = child,\n\t};\n\tstruct getdents_callback buffer = {\n\t\t.ctx.actor = filldir_one,\n\t\t.name = name,\n\t};\n\n\terror = -ENOTDIR;\n\tif (!dir || !S_ISDIR(dir->i_mode))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!dir->i_fop)\n\t\tgoto out;\n\t/*\n\t * inode->i_ino is unsigned long, kstat->ino is u64, so the\n\t * former would be insufficient on 32-bit hosts when the\n\t * filesystem supports 64-bit inode numbers.  So we need to\n\t * actually call ->getattr, not just read i_ino:\n\t */\n\terror = vfs_getattr_nosec(&child_path, &stat);\n\tif (error)\n\t\treturn error;\n\tbuffer.ino = stat.ino;\n\t/*\n\t * Open the directory ...\n\t */\n\tfile = dentry_open(path, O_RDONLY, cred);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!file->f_op->iterate)\n\t\tgoto out_close;\n\n\tbuffer.sequence = 0;\n\twhile (1) {\n\t\tint old_seq = buffer.sequence;\n\n\t\terror = iterate_dir(file, &buffer.ctx);\n\t\tif (buffer.found) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\terror = -ENOENT;\n\t\tif (old_seq == buffer.sequence)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tfput(file);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int get_name(const struct path *path, char *name, struct dentry *child);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "file",
            "&buffer.ctx"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "path",
            "O_RDONLY",
            "cred"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "821-849",
          "snippet": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr_nosec",
          "args": [
            "&child_path",
            "&stat"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getattr_nosec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "52-61",
          "snippet": "int vfs_getattr_nosec(struct path *path, struct kstat *stat)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->getattr)\n\t\treturn inode->i_op->getattr(path->mnt, path->dentry, stat);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nint vfs_getattr_nosec(struct path *path, struct kstat *stat)\n{\n\tstruct inode *inode = path->dentry->d_inode;\n\n\tif (inode->i_op->getattr)\n\t\treturn inode->i_op->getattr(path->mnt, path->dentry, stat);\n\n\tgeneric_fillattr(inode, stat);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dir->i_mode"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *dir = path->dentry->d_inode;\n\tint error;\n\tstruct file *file;\n\tstruct kstat stat;\n\tstruct path child_path = {\n\t\t.mnt = path->mnt,\n\t\t.dentry = child,\n\t};\n\tstruct getdents_callback buffer = {\n\t\t.ctx.actor = filldir_one,\n\t\t.name = name,\n\t};\n\n\terror = -ENOTDIR;\n\tif (!dir || !S_ISDIR(dir->i_mode))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!dir->i_fop)\n\t\tgoto out;\n\t/*\n\t * inode->i_ino is unsigned long, kstat->ino is u64, so the\n\t * former would be insufficient on 32-bit hosts when the\n\t * filesystem supports 64-bit inode numbers.  So we need to\n\t * actually call ->getattr, not just read i_ino:\n\t */\n\terror = vfs_getattr_nosec(&child_path, &stat);\n\tif (error)\n\t\treturn error;\n\tbuffer.ino = stat.ino;\n\t/*\n\t * Open the directory ...\n\t */\n\tfile = dentry_open(path, O_RDONLY, cred);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!file->f_op->iterate)\n\t\tgoto out_close;\n\n\tbuffer.sequence = 0;\n\twhile (1) {\n\t\tint old_seq = buffer.sequence;\n\n\t\terror = iterate_dir(file, &buffer.ctx);\n\t\tif (buffer.found) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\terror = -ENOENT;\n\t\tif (old_seq == buffer.sequence)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tfput(file);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "filldir_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "244-259",
    "snippet": "static int filldir_one(struct dir_context *ctx, const char *name, int len,\n\t\t\tloff_t pos, u64 ino, unsigned int d_type)\n{\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tint result = 0;\n\n\tbuf->sequence++;\n\tif (buf->ino == ino && len <= NAME_MAX) {\n\t\tmemcpy(buf->name, name, len);\n\t\tbuf->name[len] = '\\0';\n\t\tbuf->found = 1;\n\t\tresult = -1;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf->name",
            "name",
            "len"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structgetdents_callback",
            "ctx"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int filldir_one(struct dir_context *ctx, const char *name, int len,\n\t\t\tloff_t pos, u64 ino, unsigned int d_type)\n{\n\tstruct getdents_callback *buf =\n\t\tcontainer_of(ctx, struct getdents_callback, ctx);\n\tint result = 0;\n\n\tbuf->sequence++;\n\tif (buf->ino == ino && len <= NAME_MAX) {\n\t\tmemcpy(buf->name, name, len);\n\t\tbuf->name[len] = '\\0';\n\t\tbuf->found = 1;\n\t\tresult = -1;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "reconnect_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "204-229",
    "snippet": "static int\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\n{\n\tstruct dentry *dentry, *parent;\n\n\tdentry = dget(target_dir);\n\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tBUG_ON(dentry == mnt->mnt_sb->s_root);\n\n\t\tif (IS_ROOT(dentry))\n\t\t\tparent = reconnect_one(mnt, dentry, nbuf);\n\t\telse\n\t\t\tparent = dget_parent(dentry);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\t\tdput(dentry);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\tclear_disconnected(target_dir);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_disconnected",
          "args": [
            "target_dir"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "clear_disconnected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "89-105",
          "snippet": "static void clear_disconnected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tWARN_ON_ONCE(IS_ROOT(dentry));\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_DISCONNECTED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdput(dentry);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic void clear_disconnected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tWARN_ON_ONCE(IS_ROOT(dentry));\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_DISCONNECTED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdput(dentry);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reconnect_one",
          "args": [
            "mnt",
            "dentry",
            "nbuf"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "reconnect_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "119-185",
          "snippet": "static struct dentry *reconnect_one(struct vfsmount *mnt,\n\t\tstruct dentry *dentry, char *nbuf)\n{\n\tstruct dentry *parent;\n\tstruct dentry *tmp;\n\tint err;\n\n\tparent = ERR_PTR(-EACCES);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (mnt->mnt_sb->s_export_op->get_parent)\n\t\tparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (IS_ERR(parent)) {\n\t\tdprintk(\"%s: get_parent of %ld failed, err %d\\n\",\n\t\t\t__func__, dentry->d_inode->i_ino, PTR_ERR(parent));\n\t\treturn parent;\n\t}\n\n\tdprintk(\"%s: find name of %lu in %lu\\n\", __func__,\n\t\tdentry->d_inode->i_ino, parent->d_inode->i_ino);\n\terr = exportfs_get_name(mnt, parent, nbuf, dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_reconnected;\n\tif (err)\n\t\tgoto out_err;\n\tdprintk(\"%s: found name: %s\\n\", __func__, nbuf);\n\tmutex_lock(&parent->d_inode->i_mutex);\n\ttmp = lookup_one_len(nbuf, parent, strlen(nbuf));\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(tmp)) {\n\t\tdprintk(\"%s: lookup failed: %d\\n\", __func__, PTR_ERR(tmp));\n\t\tgoto out_err;\n\t}\n\tif (tmp != dentry) {\n\t\tdput(tmp);\n\t\tgoto out_reconnected;\n\t}\n\tdput(tmp);\n\tif (IS_ROOT(dentry)) {\n\t\terr = -ESTALE;\n\t\tgoto out_err;\n\t}\n\treturn parent;\n\nout_err:\n\tdput(parent);\n\treturn ERR_PTR(err);\nout_reconnected:\n\tdput(parent);\n\t/*\n\t * Someone must have renamed our entry into another parent, in\n\t * which case it has been reconnected by the rename.\n\t *\n\t * Or someone removed it entirely, in which case filehandle\n\t * lookup will succeed but the directory is now IS_DEAD and\n\t * subsequent operations on it will fail.\n\t *\n\t * Alternatively, maybe there was no race at all, and the\n\t * filesystem is just corrupt and gave us a parent that doesn't\n\t * actually contain any entry pointing to this inode.  So,\n\t * double check that this worked and return -ESTALE if not:\n\t */\n\tif (!dentry_connected(dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *reconnect_one(struct vfsmount *mnt,\n\t\tstruct dentry *dentry, char *nbuf)\n{\n\tstruct dentry *parent;\n\tstruct dentry *tmp;\n\tint err;\n\n\tparent = ERR_PTR(-EACCES);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (mnt->mnt_sb->s_export_op->get_parent)\n\t\tparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (IS_ERR(parent)) {\n\t\tdprintk(\"%s: get_parent of %ld failed, err %d\\n\",\n\t\t\t__func__, dentry->d_inode->i_ino, PTR_ERR(parent));\n\t\treturn parent;\n\t}\n\n\tdprintk(\"%s: find name of %lu in %lu\\n\", __func__,\n\t\tdentry->d_inode->i_ino, parent->d_inode->i_ino);\n\terr = exportfs_get_name(mnt, parent, nbuf, dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_reconnected;\n\tif (err)\n\t\tgoto out_err;\n\tdprintk(\"%s: found name: %s\\n\", __func__, nbuf);\n\tmutex_lock(&parent->d_inode->i_mutex);\n\ttmp = lookup_one_len(nbuf, parent, strlen(nbuf));\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(tmp)) {\n\t\tdprintk(\"%s: lookup failed: %d\\n\", __func__, PTR_ERR(tmp));\n\t\tgoto out_err;\n\t}\n\tif (tmp != dentry) {\n\t\tdput(tmp);\n\t\tgoto out_reconnected;\n\t}\n\tdput(tmp);\n\tif (IS_ROOT(dentry)) {\n\t\terr = -ESTALE;\n\t\tgoto out_err;\n\t}\n\treturn parent;\n\nout_err:\n\tdput(parent);\n\treturn ERR_PTR(err);\nout_reconnected:\n\tdput(parent);\n\t/*\n\t * Someone must have renamed our entry into another parent, in\n\t * which case it has been reconnected by the rename.\n\t *\n\t * Or someone removed it entirely, in which case filehandle\n\t * lookup will succeed but the directory is now IS_DEAD and\n\t * subsequent operations on it will fail.\n\t *\n\t * Alternatively, maybe there was no race at all, and the\n\t * filesystem is just corrupt and gave us a parent that doesn't\n\t * actually contain any entry pointing to this inode.  So,\n\t * double check that this worked and return -ESTALE if not:\n\t */\n\tif (!dentry_connected(dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry == mnt->mnt_sb->s_root"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int\nreconnect_path(struct vfsmount *mnt, struct dentry *target_dir, char *nbuf)\n{\n\tstruct dentry *dentry, *parent;\n\n\tdentry = dget(target_dir);\n\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tBUG_ON(dentry == mnt->mnt_sb->s_root);\n\n\t\tif (IS_ROOT(dentry))\n\t\t\tparent = reconnect_one(mnt, dentry, nbuf);\n\t\telse\n\t\t\tparent = dget_parent(dentry);\n\n\t\tif (!parent)\n\t\t\tbreak;\n\t\tdput(dentry);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\tclear_disconnected(target_dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "reconnect_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "119-185",
    "snippet": "static struct dentry *reconnect_one(struct vfsmount *mnt,\n\t\tstruct dentry *dentry, char *nbuf)\n{\n\tstruct dentry *parent;\n\tstruct dentry *tmp;\n\tint err;\n\n\tparent = ERR_PTR(-EACCES);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (mnt->mnt_sb->s_export_op->get_parent)\n\t\tparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (IS_ERR(parent)) {\n\t\tdprintk(\"%s: get_parent of %ld failed, err %d\\n\",\n\t\t\t__func__, dentry->d_inode->i_ino, PTR_ERR(parent));\n\t\treturn parent;\n\t}\n\n\tdprintk(\"%s: find name of %lu in %lu\\n\", __func__,\n\t\tdentry->d_inode->i_ino, parent->d_inode->i_ino);\n\terr = exportfs_get_name(mnt, parent, nbuf, dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_reconnected;\n\tif (err)\n\t\tgoto out_err;\n\tdprintk(\"%s: found name: %s\\n\", __func__, nbuf);\n\tmutex_lock(&parent->d_inode->i_mutex);\n\ttmp = lookup_one_len(nbuf, parent, strlen(nbuf));\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(tmp)) {\n\t\tdprintk(\"%s: lookup failed: %d\\n\", __func__, PTR_ERR(tmp));\n\t\tgoto out_err;\n\t}\n\tif (tmp != dentry) {\n\t\tdput(tmp);\n\t\tgoto out_reconnected;\n\t}\n\tdput(tmp);\n\tif (IS_ROOT(dentry)) {\n\t\terr = -ESTALE;\n\t\tgoto out_err;\n\t}\n\treturn parent;\n\nout_err:\n\tdput(parent);\n\treturn ERR_PTR(err);\nout_reconnected:\n\tdput(parent);\n\t/*\n\t * Someone must have renamed our entry into another parent, in\n\t * which case it has been reconnected by the rename.\n\t *\n\t * Or someone removed it entirely, in which case filehandle\n\t * lookup will succeed but the directory is now IS_DEAD and\n\t * subsequent operations on it will fail.\n\t *\n\t * Alternatively, maybe there was no race at all, and the\n\t * filesystem is just corrupt and gave us a parent that doesn't\n\t * actually contain any entry pointing to this inode.  So,\n\t * double check that this worked and return -ESTALE if not:\n\t */\n\tif (!dentry_connected(dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_connected",
          "args": [
            "dentry"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "72-87",
          "snippet": "static bool dentry_connected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tdput(dentry);\n\t\tif (IS_ROOT(dentry)) {\n\t\t\tdput(parent);\n\t\t\treturn false;\n\t\t}\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\treturn true;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic bool dentry_connected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tdput(dentry);\n\t\tif (IS_ROOT(dentry)) {\n\t\t\tdput(parent);\n\t\t\treturn false;\n\t\t}\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: lookup failed: %d\\n\"",
            "__func__",
            "PTR_ERR(tmp)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tmp"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "nbuf",
            "parent",
            "strlen(nbuf)"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nbuf"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&parent->d_inode->i_mutex"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: found name: %s\\n\"",
            "__func__",
            "nbuf"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_get_name",
          "args": [
            "mnt",
            "parent",
            "nbuf",
            "dentry"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "exportfs_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "25-35",
          "snippet": "static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstatic int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: find name of %lu in %lu\\n\"",
            "__func__",
            "dentry->d_inode->i_ino",
            "parent->d_inode->i_ino"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: get_parent of %ld failed, err %d\\n\"",
            "__func__",
            "dentry->d_inode->i_ino",
            "PTR_ERR(parent)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt->mnt_sb->s_export_op->get_parent",
          "args": [
            "dentry"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *reconnect_one(struct vfsmount *mnt,\n\t\tstruct dentry *dentry, char *nbuf)\n{\n\tstruct dentry *parent;\n\tstruct dentry *tmp;\n\tint err;\n\n\tparent = ERR_PTR(-EACCES);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\tif (mnt->mnt_sb->s_export_op->get_parent)\n\t\tparent = mnt->mnt_sb->s_export_op->get_parent(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\tif (IS_ERR(parent)) {\n\t\tdprintk(\"%s: get_parent of %ld failed, err %d\\n\",\n\t\t\t__func__, dentry->d_inode->i_ino, PTR_ERR(parent));\n\t\treturn parent;\n\t}\n\n\tdprintk(\"%s: find name of %lu in %lu\\n\", __func__,\n\t\tdentry->d_inode->i_ino, parent->d_inode->i_ino);\n\terr = exportfs_get_name(mnt, parent, nbuf, dentry);\n\tif (err == -ENOENT)\n\t\tgoto out_reconnected;\n\tif (err)\n\t\tgoto out_err;\n\tdprintk(\"%s: found name: %s\\n\", __func__, nbuf);\n\tmutex_lock(&parent->d_inode->i_mutex);\n\ttmp = lookup_one_len(nbuf, parent, strlen(nbuf));\n\tmutex_unlock(&parent->d_inode->i_mutex);\n\tif (IS_ERR(tmp)) {\n\t\tdprintk(\"%s: lookup failed: %d\\n\", __func__, PTR_ERR(tmp));\n\t\tgoto out_err;\n\t}\n\tif (tmp != dentry) {\n\t\tdput(tmp);\n\t\tgoto out_reconnected;\n\t}\n\tdput(tmp);\n\tif (IS_ROOT(dentry)) {\n\t\terr = -ESTALE;\n\t\tgoto out_err;\n\t}\n\treturn parent;\n\nout_err:\n\tdput(parent);\n\treturn ERR_PTR(err);\nout_reconnected:\n\tdput(parent);\n\t/*\n\t * Someone must have renamed our entry into another parent, in\n\t * which case it has been reconnected by the rename.\n\t *\n\t * Or someone removed it entirely, in which case filehandle\n\t * lookup will succeed but the directory is now IS_DEAD and\n\t * subsequent operations on it will fail.\n\t *\n\t * Alternatively, maybe there was no race at all, and the\n\t * filesystem is just corrupt and gave us a parent that doesn't\n\t * actually contain any entry pointing to this inode.  So,\n\t * double check that this worked and return -ESTALE if not:\n\t */\n\tif (!dentry_connected(dentry))\n\t\treturn ERR_PTR(-ESTALE);\n\treturn NULL;\n}"
  },
  {
    "function_name": "clear_disconnected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "89-105",
    "snippet": "static void clear_disconnected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tWARN_ON_ONCE(IS_ROOT(dentry));\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_DISCONNECTED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdput(dentry);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ROOT(dentry)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic void clear_disconnected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tWARN_ON_ONCE(IS_ROOT(dentry));\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tdentry->d_flags &= ~DCACHE_DISCONNECTED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\tdput(dentry);\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n}"
  },
  {
    "function_name": "dentry_connected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "72-87",
    "snippet": "static bool dentry_connected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tdput(dentry);\n\t\tif (IS_ROOT(dentry)) {\n\t\t\tdput(parent);\n\t\t\treturn false;\n\t\t}\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\treturn true;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic bool dentry_connected(struct dentry *dentry)\n{\n\tdget(dentry);\n\twhile (dentry->d_flags & DCACHE_DISCONNECTED) {\n\t\tstruct dentry *parent = dget_parent(dentry);\n\n\t\tdput(dentry);\n\t\tif (IS_ROOT(dentry)) {\n\t\t\tdput(parent);\n\t\t\treturn false;\n\t\t}\n\t\tdentry = parent;\n\t}\n\tdput(dentry);\n\treturn true;\n}"
  },
  {
    "function_name": "find_acceptable_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "40-70",
    "snippet": "static struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\n\tinode = result->d_inode;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tdget(dentry);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (toput)\n\t\t\tdput(toput);\n\t\tif (dentry != result && acceptable(context, dentry)) {\n\t\t\tdput(result);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t\ttoput = dentry;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (toput)\n\t\tdput(toput);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "toput"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "acceptable",
          "args": [
            "context",
            "dentry"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_dentry_acceptable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fhandle.c",
          "lines": "133-136",
          "snippet": "static int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/fs_struct.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n\nstatic int vfs_dentry_acceptable(void *context, struct dentry *dentry)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "dentry",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic struct dentry *\nfind_acceptable_alias(struct dentry *result,\n\t\tint (*acceptable)(void *context, struct dentry *dentry),\n\t\tvoid *context)\n{\n\tstruct dentry *dentry, *toput = NULL;\n\tstruct inode *inode;\n\n\tif (acceptable(context, result))\n\t\treturn result;\n\n\tinode = result->d_inode;\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tdget(dentry);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (toput)\n\t\t\tdput(toput);\n\t\tif (dentry != result && acceptable(context, dentry)) {\n\t\t\tdput(result);\n\t\t\treturn dentry;\n\t\t}\n\t\tspin_lock(&inode->i_lock);\n\t\ttoput = dentry;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (toput)\n\t\tdput(toput);\n\treturn NULL;\n}"
  },
  {
    "function_name": "exportfs_get_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
    "lines": "25-35",
    "snippet": "static int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int get_name(const struct path *path, char *name, struct dentry *child);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_name",
          "args": [
            "&path",
            "name",
            "child"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exportfs/expfs.c",
          "lines": "270-336",
          "snippet": "static int get_name(const struct path *path, char *name, struct dentry *child)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *dir = path->dentry->d_inode;\n\tint error;\n\tstruct file *file;\n\tstruct kstat stat;\n\tstruct path child_path = {\n\t\t.mnt = path->mnt,\n\t\t.dentry = child,\n\t};\n\tstruct getdents_callback buffer = {\n\t\t.ctx.actor = filldir_one,\n\t\t.name = name,\n\t};\n\n\terror = -ENOTDIR;\n\tif (!dir || !S_ISDIR(dir->i_mode))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!dir->i_fop)\n\t\tgoto out;\n\t/*\n\t * inode->i_ino is unsigned long, kstat->ino is u64, so the\n\t * former would be insufficient on 32-bit hosts when the\n\t * filesystem supports 64-bit inode numbers.  So we need to\n\t * actually call ->getattr, not just read i_ino:\n\t */\n\terror = vfs_getattr_nosec(&child_path, &stat);\n\tif (error)\n\t\treturn error;\n\tbuffer.ino = stat.ino;\n\t/*\n\t * Open the directory ...\n\t */\n\tfile = dentry_open(path, O_RDONLY, cred);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!file->f_op->iterate)\n\t\tgoto out_close;\n\n\tbuffer.sequence = 0;\n\twhile (1) {\n\t\tint old_seq = buffer.sequence;\n\n\t\terror = iterate_dir(file, &buffer.ctx);\n\t\tif (buffer.found) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\terror = -ENOENT;\n\t\tif (old_seq == buffer.sequence)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tfput(file);\nout:\n\treturn error;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int get_name(const struct path *path, char *name, struct dentry *child);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct inode *dir = path->dentry->d_inode;\n\tint error;\n\tstruct file *file;\n\tstruct kstat stat;\n\tstruct path child_path = {\n\t\t.mnt = path->mnt,\n\t\t.dentry = child,\n\t};\n\tstruct getdents_callback buffer = {\n\t\t.ctx.actor = filldir_one,\n\t\t.name = name,\n\t};\n\n\terror = -ENOTDIR;\n\tif (!dir || !S_ISDIR(dir->i_mode))\n\t\tgoto out;\n\terror = -EINVAL;\n\tif (!dir->i_fop)\n\t\tgoto out;\n\t/*\n\t * inode->i_ino is unsigned long, kstat->ino is u64, so the\n\t * former would be insufficient on 32-bit hosts when the\n\t * filesystem supports 64-bit inode numbers.  So we need to\n\t * actually call ->getattr, not just read i_ino:\n\t */\n\terror = vfs_getattr_nosec(&child_path, &stat);\n\tif (error)\n\t\treturn error;\n\tbuffer.ino = stat.ino;\n\t/*\n\t * Open the directory ...\n\t */\n\tfile = dentry_open(path, O_RDONLY, cred);\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terror = -EINVAL;\n\tif (!file->f_op->iterate)\n\t\tgoto out_close;\n\n\tbuffer.sequence = 0;\n\twhile (1) {\n\t\tint old_seq = buffer.sequence;\n\n\t\terror = iterate_dir(file, &buffer.ctx);\n\t\tif (buffer.found) {\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\terror = -ENOENT;\n\t\tif (old_seq == buffer.sequence)\n\t\t\tbreak;\n\t}\n\nout_close:\n\tfput(file);\nout:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n\nstatic int get_name(const struct path *path, char *name, struct dentry *child);\n\nstatic int exportfs_get_name(struct vfsmount *mnt, struct dentry *dir,\n\t\tchar *name, struct dentry *child)\n{\n\tconst struct export_operations *nop = dir->d_sb->s_export_op;\n\tstruct path path = {.mnt = mnt, .dentry = dir};\n\n\tif (nop->get_name)\n\t\treturn nop->get_name(dir, name, child);\n\telse\n\t\treturn get_name(&path, name, child);\n}"
  }
]