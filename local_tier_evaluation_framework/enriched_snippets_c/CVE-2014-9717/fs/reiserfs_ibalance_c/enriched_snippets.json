[
  {
    "function_name": "balance_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "803-1160",
    "snippet": "int balance_internal(struct tree_balance *tb,\n\t\t     int h,\t/* level of the tree */\n\t\t     int child_pos,\n\t\t     /* key for insertion on higher level    */\n\t\t     struct item_head *insert_key,\n\t\t     /* node for insertion on higher level */\n\t\t     struct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\t/*\n\t * we return this: it is 0 if there is no S[h],\n\t * else it is tb->S[h]->b_item_order\n\t */\n\tint order;\n\tint insert_num, n, k;\n\tstruct buffer_head *S_new;\n\tstruct item_head new_insert_key;\n\tstruct buffer_head *new_insert_ptr = NULL;\n\tstruct item_head *new_insert_key_addr = insert_key;\n\n\tRFALSE(h < 1, \"h (%d) can not be < 1 on internal level\", h);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[h]);\n\n\torder =\n\t    (tbSh) ? PATH_H_POSITION(tb->tb_path,\n\t\t\t\t     h + 1) /*tb->S[h]->b_item_order */ : 0;\n\n\t/*\n\t * Using insert_size[h] calculate the number insert_num of items\n\t * that must be inserted to or deleted from S[h].\n\t */\n\tinsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\n\n\t/* Check whether insert_num is proper * */\n\tRFALSE(insert_num < -2 || insert_num > 2,\n\t       \"incorrect number of items inserted to the internal node (%d)\",\n\t       insert_num);\n\tRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\n\t       \"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\",\n\t       insert_num, h);\n\n\t/* Make balance in case insert_num < 0 */\n\tif (insert_num < 0) {\n\t\tbalance_internal_when_delete(tb, h, child_pos);\n\t\treturn order;\n\t}\n\n\tk = 0;\n\tif (tb->lnum[h] > 0) {\n\t\t/*\n\t\t * shift lnum[h] items from S[h] to the left neighbor L[h].\n\t\t * check how many of new items fall into L[h] or CFL[h] after\n\t\t * shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tb->L[h]);\t/* number of items in L[h] */\n\t\tif (tb->lnum[h] <= child_pos) {\n\t\t\t/* new items don't fall into L[h] or CFL[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h]);\n\t\t\tchild_pos -= tb->lnum[h];\n\t\t} else if (tb->lnum[h] > child_pos + insert_num) {\n\t\t\t/* all new items fall into L[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h] - insert_num);\n\t\t\t/* insert insert_num keys and node-pointers into L[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next */\n\t\t\t\t\t       n + child_pos + 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/*\n\t\t\t * some items fall into L[h] or CFL[h],\n\t\t\t * but some don't fall\n\t\t\t */\n\t\t\tinternal_shift1_left(tb, h, child_pos + 1);\n\t\t\t/* calculate number of new items that fall into L[h] */\n\t\t\tk = tb->lnum[h] - child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next, */\n\t\t\t\t\t       n + child_pos + 1, k,\n\t\t\t\t\t       insert_key, insert_ptr);\n\n\t\t\treplace_lkey(tb, h, insert_key + k);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in S[h] by\n\t\t\t * node-ptr to insert_ptr[k]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tbSh, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k]));\n\t\t\tput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t\tk++;\n\t\t\tinsert_key += k;\n\t\t\tinsert_ptr += k;\n\t\t\tinsert_num -= k;\n\t\t\tchild_pos = 0;\n\t\t}\n\t}\n\t/* tb->lnum[h] > 0 */\n\tif (tb->rnum[h] > 0) {\n\t\t/*shift rnum[h] items from S[h] to the right neighbor R[h] */\n\t\t/*\n\t\t * check how many of new items fall into R or CFR\n\t\t * after shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tif (n - tb->rnum[h] >= child_pos)\n\t\t\t/* new items fall into S[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h]);\n\t\telse if (n + insert_num - tb->rnum[h] < child_pos) {\n\t\t\t/* all new items fall into R[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h] - insert_num);\n\n\t\t\t/* insert insert_num keys and node-pointers into R[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h],tb->S[h-1]->b_next */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       tb->rnum[h] - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* one of the items falls into CFR[h] */\n\t\t\tinternal_shift1_right(tb, h, n - child_pos + 1);\n\t\t\t/* calculate number of new items that fall into R[h] */\n\t\t\tk = tb->rnum[h] - n + child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h], tb->R[h]->b_child, */\n\t\t\t\t\t       0, k, insert_key + 1,\n\t\t\t\t\t       insert_ptr + 1);\n\n\t\t\treplace_rkey(tb, h, insert_key + insert_num - k - 1);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in R[h] by\n\t\t\t * node-ptr insert_ptr[insert_num-k-1]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tb->R[h], 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->R[h], 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t}\n\n\t/** Fill new node that appears instead of S[h] **/\n\tRFALSE(tb->blknum[h] > 2, \"blknum can not be > 2 for internal level\");\n\tRFALSE(tb->blknum[h] < 0, \"blknum can not be < 0\");\n\n\tif (!tb->blknum[h]) {\t/* node S[h] is empty now */\n\t\tRFALSE(!tbSh, \"S[h] is equal NULL\");\n\n\t\t/* do what is needed for buffer thrown from tree */\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn order;\n\t}\n\n\tif (!tbSh) {\n\t\t/* create new root */\n\t\tstruct disk_child *dc;\n\t\tstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\n\t\tstruct block_head *blkh;\n\n\t\tif (tb->blknum[h] != 1)\n\t\t\treiserfs_panic(NULL, \"ibalance-3\", \"One new node \"\n\t\t\t\t       \"required for creating the new root\");\n\t\t/* S[h] = empty buffer from the list FEB. */\n\t\ttbSh = get_FEB(tb);\n\t\tblkh = B_BLK_HEAD(tbSh);\n\t\tset_blkh_level(blkh, h + 1);\n\n\t\t/* Put the unique node-pointer to S[h] that points to S[h-1]. */\n\n\t\tdc = B_N_CHILD(tbSh, 0);\n\t\tput_dc_block_number(dc, tbSh_1->b_blocknr);\n\t\tput_dc_size(dc,\n\t\t\t    (MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\n\n\t\ttb->insert_size[h] -= DC_SIZE;\n\t\tset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(tbSh);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t/* put new root into path structure */\n\t\tPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\n\t\t    tbSh;\n\n\t\t/* Change root in structure super block. */\n\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\n\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\n\t\tdo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\n\t}\n\n\tif (tb->blknum[h] == 2) {\n\t\tint snum;\n\t\tstruct buffer_info dest_bi, src_bi;\n\n\t\t/* S_new = free buffer from list FEB */\n\t\tS_new = get_FEB(tb);\n\n\t\tset_blkh_level(B_BLK_HEAD(S_new), h + 1);\n\n\t\tdest_bi.tb = tb;\n\t\tdest_bi.bi_bh = S_new;\n\t\tdest_bi.bi_parent = NULL;\n\t\tdest_bi.bi_position = 0;\n\t\tsrc_bi.tb = tb;\n\t\tsrc_bi.bi_bh = tbSh;\n\t\tsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tsnum = (insert_num + n + 1) / 2;\n\t\tif (n - snum >= child_pos) {\n\t\t\t/* new items don't fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/* new_insert_key = (n - snum)'th key in S[h] */\n\t\t\tmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST, snum, 0);\n\t\t} else if (n + insert_num - snum < child_pos) {\n\t\t\t/* all new items fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/*\n\t\t\t * new_insert_key = (n + insert_item - snum)'th\n\t\t\t * key in S[h]\n\t\t\t */\n\t\t\tmemcpy(&new_insert_key,\n\t\t\t       internal_key(tbSh, n + insert_num - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     snum - insert_num, 0);\n\n\t\t\t/*\n\t\t\t * insert insert_num keys and node-pointers\n\t\t\t * into S_new\n\t\t\t */\n\t\t\tinternal_insert_childs(&dest_bi,\n\t\t\t\t\t       /*S_new,tb->S[h-1]->b_next, */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       snum - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* some items fall into S_new, but some don't fall */\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     n - child_pos + 1, 1);\n\t\t\t/* calculate number of new items that fall into S_new */\n\t\t\tk = snum - n + child_pos - 1;\n\n\t\t\tinternal_insert_childs(&dest_bi, /*S_new, */ 0, k,\n\t\t\t\t\t       insert_key + 1, insert_ptr + 1);\n\n\t\t\t/* new_insert_key = insert_key[insert_num - k - 1] */\n\t\t\tmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\n\t\t\t       KEY_SIZE);\n\t\t\t/*\n\t\t\t * replace first node-ptr in S_new by node-ptr\n\t\t\t * to insert_ptr[insert_num-k-1]\n\t\t\t */\n\n\t\t\tdc = B_N_CHILD(S_new, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    (MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1])));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, S_new, 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t\t/* new_insert_ptr = node_pointer to S_new */\n\t\tnew_insert_ptr = S_new;\n\n\t\tRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new), \"cm-00001: bad S_new (%b)\",\n\t\t       S_new);\n\n\t\t/* S_new is released in unfix_nodes */\n\t}\n\n\tn = B_NR_ITEMS(tbSh);\t/*number of items in S[h] */\n\n\tif (0 <= child_pos && child_pos <= n && insert_num > 0) {\n\t\tbi.tb = tb;\n\t\tbi.bi_bh = tbSh;\n\t\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tinternal_insert_childs(&bi,\t/*tbSh, */\n\t\t\t\t       /*          ( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next, */\n\t\t\t\t       child_pos, insert_num, insert_key,\n\t\t\t\t       insert_ptr);\n\t}\n\n\tmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\n\tinsert_ptr[0] = new_insert_ptr;\n\n\treturn order;\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
      "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
    ],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_insert_key_addr",
            "&new_insert_key",
            "KEY_SIZE"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_insert_childs",
          "args": [
            "&bi",
            "/*tbSh, *//*          ( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next, */child_pos",
            "insert_num",
            "insert_key",
            "insert_ptr"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "internal_insert_childs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "126-199",
          "snippet": "static void internal_insert_childs(struct buffer_info *cur_bi,\n\t\t\t\t   int to, int count,\n\t\t\t\t   struct item_head *inserted,\n\t\t\t\t   struct buffer_head **bh)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tstruct block_head *blkh;\n\tint nr;\n\tstruct reiserfs_key *ih;\n\tstruct disk_child new_dc[2];\n\tstruct disk_child *dc;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(count > 2, \"too many children (%d) are to be inserted\", count);\n\tRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\n\t       \"no enough free space (%d), needed %d bytes\",\n\t       B_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\n\n\t/* prepare space for count disk_child */\n\tdc = B_N_CHILD(cur, to + 1);\n\n\tmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\n\n\t/* copy to_be_insert disk children */\n\tfor (i = 0; i < count; i++) {\n\t\tput_dc_size(&new_dc[i],\n\t\t\t    MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\n\t\tput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\n\t}\n\tmemcpy(dc, new_dc, DC_SIZE * count);\n\n\t/* prepare space for count items  */\n\tih = internal_key(cur, ((to == -1) ? 0 : to));\n\n\tmemmove(ih + count, ih,\n\t\t(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\n\n\t/* copy item headers (keys) */\n\tmemcpy(ih, inserted, KEY_SIZE);\n\tif (count > 1)\n\t\tmemcpy(ih + 1, inserted + 1, KEY_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_childs(struct buffer_info *cur_bi,\n\t\t\t\t   int to, int count,\n\t\t\t\t   struct item_head *inserted,\n\t\t\t\t   struct buffer_head **bh)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tstruct block_head *blkh;\n\tint nr;\n\tstruct reiserfs_key *ih;\n\tstruct disk_child new_dc[2];\n\tstruct disk_child *dc;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(count > 2, \"too many children (%d) are to be inserted\", count);\n\tRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\n\t       \"no enough free space (%d), needed %d bytes\",\n\t       B_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\n\n\t/* prepare space for count disk_child */\n\tdc = B_N_CHILD(cur, to + 1);\n\n\tmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\n\n\t/* copy to_be_insert disk children */\n\tfor (i = 0; i < count; i++) {\n\t\tput_dc_size(&new_dc[i],\n\t\t\t    MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\n\t\tput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\n\t}\n\tmemcpy(dc, new_dc, DC_SIZE * count);\n\n\t/* prepare space for count items  */\n\tih = internal_key(cur, ((to == -1) ? 0 : to));\n\n\tmemmove(ih + count, ih,\n\t\t(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\n\n\t/* copy item headers (keys) */\n\tmemcpy(ih, inserted, KEY_SIZE);\n\tif (count > 1)\n\t\tmemcpy(ih + 1, inserted + 1, KEY_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbSh"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new)",
            "\"cm-00001: bad S_new (%b)\"",
            "S_new"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "S_new"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "S_new"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "S_new"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "S_new",
            "0"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_block_number",
          "args": [
            "dc",
            "insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "dc",
            "(MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1]))"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1]"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "insert_ptr[insert_num - k - 1]"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "S_new",
            "0"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_insert_key",
            "insert_key + insert_num - k - 1",
            "KEY_SIZE"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_move_pointers_items",
          "args": [
            "&dest_bi",
            "&src_bi",
            "LAST_TO_FIRST",
            "n - child_pos + 1",
            "1"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "internal_move_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "394-426",
          "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_insert_key",
            "internal_key(tbSh, n + insert_num - snum)",
            "KEY_SIZE"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tbSh",
            "n + insert_num - snum"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new_insert_key",
            "internal_key(tbSh, n - snum)",
            "KEY_SIZE"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbSh"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_level",
          "args": [
            "B_BLK_HEAD(S_new)",
            "h + 1"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "S_new"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_FEB",
          "args": [
            "tb"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "get_FEB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1494-1513",
          "snippet": "struct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nstruct buffer_head *get_FEB(struct tree_balance *tb)\n{\n\tint i;\n\tstruct buffer_info bi;\n\n\tfor (i = 0; i < MAX_FEB_SIZE; i++)\n\t\tif (tb->FEB[i] != NULL)\n\t\t\tbreak;\n\n\tif (i == MAX_FEB_SIZE)\n\t\treiserfs_panic(tb->tb_sb, \"vs-12300\", \"FEB list is empty\");\n\n\tbuffer_info_init_bh(tb, &bi, tb->FEB[i]);\n\tmake_empty_node(&bi);\n\tset_buffer_uptodate(tb->FEB[i]);\n\ttb->used[i] = tb->FEB[i];\n\ttb->FEB[i] = NULL;\n\n\treturn tb->used[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_sb_dirty",
          "args": [
            "tb",
            "REISERFS_SB(tb->tb_sb)->s_sbh",
            "1"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PUT_SB_TREE_HEIGHT",
          "args": [
            "tb->tb_sb",
            "SB_TREE_HEIGHT(tb->tb_sb) + 1"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_TREE_HEIGHT",
          "args": [
            "tb->tb_sb"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_SB_ROOT_BLOCK",
          "args": [
            "tb->tb_sb",
            "tbSh->b_blocknr"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_OFFSET_PBUFFER",
          "args": [
            "tb->tb_path",
            "ILLEGAL_PATH_ELEMENT_OFFSET"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_internal",
          "args": [
            "tbSh"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "759-764",
          "snippet": "void check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tbSh",
            "0"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) - DC_SIZE"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "dc",
            "(MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1))"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "tbSh_1"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "tbSh_1"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_block_number",
          "args": [
            "dc",
            "tbSh_1->b_blocknr"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tbSh",
            "0"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_level",
          "args": [
            "blkh",
            "h + 1"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "tbSh"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "NULL",
            "\"ibalance-3\"",
            "\"One new node \"\n\t\t\t\t       \"required for creating the new root\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h - 1"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_invalidate_buffer",
          "args": [
            "tb",
            "tbSh"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_invalidate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1551-1560",
          "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "!tbSh",
            "\"S[h] is equal NULL\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[h] < 0",
            "\"blknum can not be < 0\""
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[h] > 2",
            "\"blknum can not be > 2 for internal level\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tb->R[h]",
            "0"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_block_number",
          "args": [
            "dc",
            "insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "dc",
            "MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1])"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tb->R[h]",
            "0"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_rkey",
          "args": [
            "tb",
            "h",
            "insert_key + insert_num - k - 1"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "replace_rkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "775-787",
          "snippet": "static void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\n\t       \"R[h](%p) and CFR[h](%p) must exist in replace_rkey\",\n\t       tb->R[h], tb->CFR[h]);\n\tRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\n\t       \"R[h] can not be empty if it exists (item number=%d)\",\n\t       B_NR_ITEMS(tb->R[h]));\n\n\tmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\n\t       \"R[h](%p) and CFR[h](%p) must exist in replace_rkey\",\n\t       tb->R[h], tb->CFR[h]);\n\tRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\n\t       \"R[h] can not be empty if it exists (item number=%d)\",\n\t       B_NR_ITEMS(tb->R[h]));\n\n\tmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_right_neighbor_position",
          "args": [
            "tb",
            "h"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "get_right_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1604-1616",
          "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift1_right",
          "args": [
            "tb",
            "h",
            "n - child_pos + 1"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift1_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "609-626",
          "snippet": "static void internal_shift1_right(struct tree_balance *tb,\n\t\t\t\t  int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert rkey from CFR[h] to right neighbor R[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 1);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift1_right(struct tree_balance *tb,\n\t\t\t\t  int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert rkey from CFR[h] to right neighbor R[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift_right",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_R",
            "tb",
            "h",
            "tb->rnum[h] - insert_num"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "560-601",
          "snippet": "static void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbSh"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tbSh",
            "0"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_block_number",
          "args": [
            "dc",
            "insert_ptr[k]->b_blocknr"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "dc",
            "MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k])"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "insert_ptr[k]"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "insert_ptr[k]"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "tbSh",
            "0"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_lkey",
          "args": [
            "tb",
            "h",
            "insert_key + k"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "replace_lkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "760-772",
          "snippet": "static void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\n\t       \"L[h](%p) and CFL[h](%p) must exist in replace_lkey\",\n\t       tb->L[h], tb->CFL[h]);\n\n\tif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\n\t\treturn;\n\n\tmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\n\t       \"L[h](%p) and CFL[h](%p) must exist in replace_lkey\",\n\t       tb->L[h], tb->CFL[h]);\n\n\tif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\n\t\treturn;\n\n\tmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_left_neighbor_position",
          "args": [
            "tb",
            "h"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1590-1602",
          "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift1_left",
          "args": [
            "tb",
            "h",
            "child_pos + 1"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift1_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "534-552",
          "snippet": "static void internal_shift1_left(struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 1);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift1_left(struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift_left",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_L",
            "tb",
            "h",
            "tb->lnum[h] - insert_num"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "488-526",
          "snippet": "static void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[h]"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_internal_when_delete",
          "args": [
            "tb",
            "h",
            "child_pos"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "balance_internal_when_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "632-757",
          "snippet": "static void balance_internal_when_delete(struct tree_balance *tb,\n\t\t\t\t\t int h, int child_pos)\n{\n\tint insert_num;\n\tint n;\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\tinsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\n\n\t/* delete child-node-pointer(s) together with their left item(s) */\n\tbi.tb = tb;\n\tbi.bi_bh = tbSh;\n\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tinternal_delete_childs(&bi, child_pos, -insert_num);\n\n\tRFALSE(tb->blknum[h] > 1,\n\t       \"tb->blknum[%d]=%d when insert_size < 0\", h, tb->blknum[h]);\n\n\tn = B_NR_ITEMS(tbSh);\n\n\tif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\n\t\tif (tb->blknum[h] == 0) {\n\t\t\t/* node S[h] (root of the tree) is empty now */\n\t\t\tstruct buffer_head *new_root;\n\n\t\t\tRFALSE(n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE,\n\t\t\t       \"buffer must have only 0 keys (%d)\", n);\n\t\t\tRFALSE(bi.bi_parent, \"root has parent (%p)\",\n\t\t\t       bi.bi_parent);\n\n\t\t\t/* choose a new root */\n\t\t\tif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\n\t\t\t\tnew_root = tb->R[h - 1];\n\t\t\telse\n\t\t\t\tnew_root = tb->L[h - 1];\n\t\t\t/*\n\t\t\t * switch super block's tree root block\n\t\t\t * number to the new value */\n\t\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\n\t\t\t/*REISERFS_SB(tb->tb_sb)->s_rs->s_tree_height --; */\n\t\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb,\n\t\t\t\t\t   SB_TREE_HEIGHT(tb->tb_sb) - 1);\n\n\t\t\tdo_balance_mark_sb_dirty(tb,\n\t\t\t\t\t\t REISERFS_SB(tb->tb_sb)->s_sbh,\n\t\t\t\t\t\t 1);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\t\t\t/* use check_internal if new root is an internal node */\n\t\t\tif (h > 1)\n\t\t\t\tcheck_internal(new_root);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t\t/* do what is needed for buffer thrown from tree */\n\t\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* join S[h] with L[h] */\n\tif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\n\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\",\n\t\t       h, tb->rnum[h]);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\n\t/* join S[h] with R[h] */\n\tif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\",\n\t\t       h, tb->lnum[h]);\n\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn;\n\t}\n\n\t/* borrow from left neighbor L[h] */\n\tif (tb->lnum[h] < 0) {\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"wrong tb->rnum[%d]==%d when borrow from L[h]\", h,\n\t\t       tb->rnum[h]);\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\n\t\t\t\t     -tb->lnum[h]);\n\t\treturn;\n\t}\n\n\t/* borrow from right neighbor R[h] */\n\tif (tb->rnum[h] < 0) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when borrow from R[h]\",\n\t\t       h, tb->lnum[h]);\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\t/*tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], -tb->rnum[h]); */\n\t\treturn;\n\t}\n\n\t/* split S[h] into two parts and put them into neighbors */\n\tif (tb->lnum[h] > 0) {\n\t\tRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\n\t\t       \"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h], n);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\t/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], tb->lnum[h]); */\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t     tb->rnum[h]);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\treiserfs_panic(tb->tb_sb, \"ibalance-2\",\n\t\t       \"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h]);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
            "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void balance_internal_when_delete(struct tree_balance *tb,\n\t\t\t\t\t int h, int child_pos)\n{\n\tint insert_num;\n\tint n;\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\tinsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\n\n\t/* delete child-node-pointer(s) together with their left item(s) */\n\tbi.tb = tb;\n\tbi.bi_bh = tbSh;\n\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tinternal_delete_childs(&bi, child_pos, -insert_num);\n\n\tRFALSE(tb->blknum[h] > 1,\n\t       \"tb->blknum[%d]=%d when insert_size < 0\", h, tb->blknum[h]);\n\n\tn = B_NR_ITEMS(tbSh);\n\n\tif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\n\t\tif (tb->blknum[h] == 0) {\n\t\t\t/* node S[h] (root of the tree) is empty now */\n\t\t\tstruct buffer_head *new_root;\n\n\t\t\tRFALSE(n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE,\n\t\t\t       \"buffer must have only 0 keys (%d)\", n);\n\t\t\tRFALSE(bi.bi_parent, \"root has parent (%p)\",\n\t\t\t       bi.bi_parent);\n\n\t\t\t/* choose a new root */\n\t\t\tif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\n\t\t\t\tnew_root = tb->R[h - 1];\n\t\t\telse\n\t\t\t\tnew_root = tb->L[h - 1];\n\t\t\t/*\n\t\t\t * switch super block's tree root block\n\t\t\t * number to the new value */\n\t\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\n\t\t\t/*REISERFS_SB(tb->tb_sb)->s_rs->s_tree_height --; */\n\t\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb,\n\t\t\t\t\t   SB_TREE_HEIGHT(tb->tb_sb) - 1);\n\n\t\t\tdo_balance_mark_sb_dirty(tb,\n\t\t\t\t\t\t REISERFS_SB(tb->tb_sb)->s_sbh,\n\t\t\t\t\t\t 1);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\t\t\t/* use check_internal if new root is an internal node */\n\t\t\tif (h > 1)\n\t\t\t\tcheck_internal(new_root);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t\t/* do what is needed for buffer thrown from tree */\n\t\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* join S[h] with L[h] */\n\tif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\n\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\",\n\t\t       h, tb->rnum[h]);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\n\t/* join S[h] with R[h] */\n\tif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\",\n\t\t       h, tb->lnum[h]);\n\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn;\n\t}\n\n\t/* borrow from left neighbor L[h] */\n\tif (tb->lnum[h] < 0) {\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"wrong tb->rnum[%d]==%d when borrow from L[h]\", h,\n\t\t       tb->rnum[h]);\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\n\t\t\t\t     -tb->lnum[h]);\n\t\treturn;\n\t}\n\n\t/* borrow from right neighbor R[h] */\n\tif (tb->rnum[h] < 0) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when borrow from R[h]\",\n\t\t       h, tb->lnum[h]);\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\t/*tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], -tb->rnum[h]); */\n\t\treturn;\n\t}\n\n\t/* split S[h] into two parts and put them into neighbors */\n\tif (tb->lnum[h] > 0) {\n\t\tRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\n\t\t       \"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h], n);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\t/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], tb->lnum[h]); */\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t     tb->rnum[h]);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\treiserfs_panic(tb->tb_sb, \"ibalance-2\",\n\t\t       \"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "h > 1 && (insert_num > 1 || insert_num < -1)",
            "\"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\"",
            "insert_num",
            "h"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "insert_num < -2 || insert_num > 2",
            "\"incorrect number of items inserted to the internal node (%d)\"",
            "insert_num"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "tb->tb_sb",
            "balance_at[h]"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "h < 1",
            "\"h (%d) can not be < 1 on internal level\"",
            "h"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nint balance_internal(struct tree_balance *tb,\n\t\t     int h,\t/* level of the tree */\n\t\t     int child_pos,\n\t\t     /* key for insertion on higher level    */\n\t\t     struct item_head *insert_key,\n\t\t     /* node for insertion on higher level */\n\t\t     struct buffer_head **insert_ptr)\n{\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\t/*\n\t * we return this: it is 0 if there is no S[h],\n\t * else it is tb->S[h]->b_item_order\n\t */\n\tint order;\n\tint insert_num, n, k;\n\tstruct buffer_head *S_new;\n\tstruct item_head new_insert_key;\n\tstruct buffer_head *new_insert_ptr = NULL;\n\tstruct item_head *new_insert_key_addr = insert_key;\n\n\tRFALSE(h < 1, \"h (%d) can not be < 1 on internal level\", h);\n\n\tPROC_INFO_INC(tb->tb_sb, balance_at[h]);\n\n\torder =\n\t    (tbSh) ? PATH_H_POSITION(tb->tb_path,\n\t\t\t\t     h + 1) /*tb->S[h]->b_item_order */ : 0;\n\n\t/*\n\t * Using insert_size[h] calculate the number insert_num of items\n\t * that must be inserted to or deleted from S[h].\n\t */\n\tinsert_num = tb->insert_size[h] / ((int)(KEY_SIZE + DC_SIZE));\n\n\t/* Check whether insert_num is proper * */\n\tRFALSE(insert_num < -2 || insert_num > 2,\n\t       \"incorrect number of items inserted to the internal node (%d)\",\n\t       insert_num);\n\tRFALSE(h > 1 && (insert_num > 1 || insert_num < -1),\n\t       \"incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level\",\n\t       insert_num, h);\n\n\t/* Make balance in case insert_num < 0 */\n\tif (insert_num < 0) {\n\t\tbalance_internal_when_delete(tb, h, child_pos);\n\t\treturn order;\n\t}\n\n\tk = 0;\n\tif (tb->lnum[h] > 0) {\n\t\t/*\n\t\t * shift lnum[h] items from S[h] to the left neighbor L[h].\n\t\t * check how many of new items fall into L[h] or CFL[h] after\n\t\t * shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tb->L[h]);\t/* number of items in L[h] */\n\t\tif (tb->lnum[h] <= child_pos) {\n\t\t\t/* new items don't fall into L[h] or CFL[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h]);\n\t\t\tchild_pos -= tb->lnum[h];\n\t\t} else if (tb->lnum[h] > child_pos + insert_num) {\n\t\t\t/* all new items fall into L[h] */\n\t\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t\t    tb->lnum[h] - insert_num);\n\t\t\t/* insert insert_num keys and node-pointers into L[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next */\n\t\t\t\t\t       n + child_pos + 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/*\n\t\t\t * some items fall into L[h] or CFL[h],\n\t\t\t * but some don't fall\n\t\t\t */\n\t\t\tinternal_shift1_left(tb, h, child_pos + 1);\n\t\t\t/* calculate number of new items that fall into L[h] */\n\t\t\tk = tb->lnum[h] - child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->L[h];\n\t\t\tbi.bi_parent = tb->FL[h];\n\t\t\tbi.bi_position = get_left_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->L[h], tb->S[h-1]->b_next, */\n\t\t\t\t\t       n + child_pos + 1, k,\n\t\t\t\t\t       insert_key, insert_ptr);\n\n\t\t\treplace_lkey(tb, h, insert_key + k);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in S[h] by\n\t\t\t * node-ptr to insert_ptr[k]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tbSh, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr[k]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr[k]));\n\t\t\tput_dc_block_number(dc, insert_ptr[k]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t\tk++;\n\t\t\tinsert_key += k;\n\t\t\tinsert_ptr += k;\n\t\t\tinsert_num -= k;\n\t\t\tchild_pos = 0;\n\t\t}\n\t}\n\t/* tb->lnum[h] > 0 */\n\tif (tb->rnum[h] > 0) {\n\t\t/*shift rnum[h] items from S[h] to the right neighbor R[h] */\n\t\t/*\n\t\t * check how many of new items fall into R or CFR\n\t\t * after shifting\n\t\t */\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tif (n - tb->rnum[h] >= child_pos)\n\t\t\t/* new items fall into S[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h]);\n\t\telse if (n + insert_num - tb->rnum[h] < child_pos) {\n\t\t\t/* all new items fall into R[h] */\n\t\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t\t     tb->rnum[h] - insert_num);\n\n\t\t\t/* insert insert_num keys and node-pointers into R[h] */\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h],tb->S[h-1]->b_next */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       tb->rnum[h] - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* one of the items falls into CFR[h] */\n\t\t\tinternal_shift1_right(tb, h, n - child_pos + 1);\n\t\t\t/* calculate number of new items that fall into R[h] */\n\t\t\tk = tb->rnum[h] - n + child_pos - 1;\n\t\t\tbi.tb = tb;\n\t\t\tbi.bi_bh = tb->R[h];\n\t\t\tbi.bi_parent = tb->FR[h];\n\t\t\tbi.bi_position = get_right_neighbor_position(tb, h);\n\t\t\tinternal_insert_childs(&bi,\n\t\t\t\t\t       /*tb->R[h], tb->R[h]->b_child, */\n\t\t\t\t\t       0, k, insert_key + 1,\n\t\t\t\t\t       insert_ptr + 1);\n\n\t\t\treplace_rkey(tb, h, insert_key + insert_num - k - 1);\n\n\t\t\t/*\n\t\t\t * replace the first node-ptr in R[h] by\n\t\t\t * node-ptr insert_ptr[insert_num-k-1]\n\t\t\t */\n\t\t\tdc = B_N_CHILD(tb->R[h], 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    MAX_CHILD_SIZE(insert_ptr\n\t\t\t\t\t\t   [insert_num - k - 1]) -\n\t\t\t\t    B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t [insert_num - k - 1]));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, tb->R[h], 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t}\n\n\t/** Fill new node that appears instead of S[h] **/\n\tRFALSE(tb->blknum[h] > 2, \"blknum can not be > 2 for internal level\");\n\tRFALSE(tb->blknum[h] < 0, \"blknum can not be < 0\");\n\n\tif (!tb->blknum[h]) {\t/* node S[h] is empty now */\n\t\tRFALSE(!tbSh, \"S[h] is equal NULL\");\n\n\t\t/* do what is needed for buffer thrown from tree */\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn order;\n\t}\n\n\tif (!tbSh) {\n\t\t/* create new root */\n\t\tstruct disk_child *dc;\n\t\tstruct buffer_head *tbSh_1 = PATH_H_PBUFFER(tb->tb_path, h - 1);\n\t\tstruct block_head *blkh;\n\n\t\tif (tb->blknum[h] != 1)\n\t\t\treiserfs_panic(NULL, \"ibalance-3\", \"One new node \"\n\t\t\t\t       \"required for creating the new root\");\n\t\t/* S[h] = empty buffer from the list FEB. */\n\t\ttbSh = get_FEB(tb);\n\t\tblkh = B_BLK_HEAD(tbSh);\n\t\tset_blkh_level(blkh, h + 1);\n\n\t\t/* Put the unique node-pointer to S[h] that points to S[h-1]. */\n\n\t\tdc = B_N_CHILD(tbSh, 0);\n\t\tput_dc_block_number(dc, tbSh_1->b_blocknr);\n\t\tput_dc_size(dc,\n\t\t\t    (MAX_CHILD_SIZE(tbSh_1) - B_FREE_SPACE(tbSh_1)));\n\n\t\ttb->insert_size[h] -= DC_SIZE;\n\t\tset_blkh_free_space(blkh, blkh_free_space(blkh) - DC_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(tb, tbSh, 0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(tbSh);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t/* put new root into path structure */\n\t\tPATH_OFFSET_PBUFFER(tb->tb_path, ILLEGAL_PATH_ELEMENT_OFFSET) =\n\t\t    tbSh;\n\n\t\t/* Change root in structure super block. */\n\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, tbSh->b_blocknr);\n\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb, SB_TREE_HEIGHT(tb->tb_sb) + 1);\n\t\tdo_balance_mark_sb_dirty(tb, REISERFS_SB(tb->tb_sb)->s_sbh, 1);\n\t}\n\n\tif (tb->blknum[h] == 2) {\n\t\tint snum;\n\t\tstruct buffer_info dest_bi, src_bi;\n\n\t\t/* S_new = free buffer from list FEB */\n\t\tS_new = get_FEB(tb);\n\n\t\tset_blkh_level(B_BLK_HEAD(S_new), h + 1);\n\n\t\tdest_bi.tb = tb;\n\t\tdest_bi.bi_bh = S_new;\n\t\tdest_bi.bi_parent = NULL;\n\t\tdest_bi.bi_position = 0;\n\t\tsrc_bi.tb = tb;\n\t\tsrc_bi.bi_bh = tbSh;\n\t\tsrc_bi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\t\tn = B_NR_ITEMS(tbSh);\t/* number of items in S[h] */\n\t\tsnum = (insert_num + n + 1) / 2;\n\t\tif (n - snum >= child_pos) {\n\t\t\t/* new items don't fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/* new_insert_key = (n - snum)'th key in S[h] */\n\t\t\tmemcpy(&new_insert_key, internal_key(tbSh, n - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST, snum, 0);\n\t\t} else if (n + insert_num - snum < child_pos) {\n\t\t\t/* all new items fall into S_new */\n\t\t\t/*  store the delimiting key for the next level */\n\t\t\t/*\n\t\t\t * new_insert_key = (n + insert_item - snum)'th\n\t\t\t * key in S[h]\n\t\t\t */\n\t\t\tmemcpy(&new_insert_key,\n\t\t\t       internal_key(tbSh, n + insert_num - snum),\n\t\t\t       KEY_SIZE);\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     snum - insert_num, 0);\n\n\t\t\t/*\n\t\t\t * insert insert_num keys and node-pointers\n\t\t\t * into S_new\n\t\t\t */\n\t\t\tinternal_insert_childs(&dest_bi,\n\t\t\t\t\t       /*S_new,tb->S[h-1]->b_next, */\n\t\t\t\t\t       child_pos - n - insert_num +\n\t\t\t\t\t       snum - 1,\n\t\t\t\t\t       insert_num, insert_key,\n\t\t\t\t\t       insert_ptr);\n\n\t\t\tinsert_num = 0;\n\t\t} else {\n\t\t\tstruct disk_child *dc;\n\n\t\t\t/* some items fall into S_new, but some don't fall */\n\t\t\t/* last parameter is del_par */\n\t\t\tinternal_move_pointers_items(&dest_bi, &src_bi,\n\t\t\t\t\t\t     LAST_TO_FIRST,\n\t\t\t\t\t\t     n - child_pos + 1, 1);\n\t\t\t/* calculate number of new items that fall into S_new */\n\t\t\tk = snum - n + child_pos - 1;\n\n\t\t\tinternal_insert_childs(&dest_bi, /*S_new, */ 0, k,\n\t\t\t\t\t       insert_key + 1, insert_ptr + 1);\n\n\t\t\t/* new_insert_key = insert_key[insert_num - k - 1] */\n\t\t\tmemcpy(&new_insert_key, insert_key + insert_num - k - 1,\n\t\t\t       KEY_SIZE);\n\t\t\t/*\n\t\t\t * replace first node-ptr in S_new by node-ptr\n\t\t\t * to insert_ptr[insert_num-k-1]\n\t\t\t */\n\n\t\t\tdc = B_N_CHILD(S_new, 0);\n\t\t\tput_dc_size(dc,\n\t\t\t\t    (MAX_CHILD_SIZE\n\t\t\t\t     (insert_ptr[insert_num - k - 1]) -\n\t\t\t\t     B_FREE_SPACE(insert_ptr\n\t\t\t\t\t\t  [insert_num - k - 1])));\n\t\t\tput_dc_block_number(dc,\n\t\t\t\t\t    insert_ptr[insert_num - k -\n\t\t\t\t\t\t       1]->b_blocknr);\n\n\t\t\tdo_balance_mark_internal_dirty(tb, S_new, 0);\n\n\t\t\tinsert_num -= (k + 1);\n\t\t}\n\t\t/* new_insert_ptr = node_pointer to S_new */\n\t\tnew_insert_ptr = S_new;\n\n\t\tRFALSE(!buffer_journaled(S_new) || buffer_journal_dirty(S_new)\n\t\t       || buffer_dirty(S_new), \"cm-00001: bad S_new (%b)\",\n\t\t       S_new);\n\n\t\t/* S_new is released in unfix_nodes */\n\t}\n\n\tn = B_NR_ITEMS(tbSh);\t/*number of items in S[h] */\n\n\tif (0 <= child_pos && child_pos <= n && insert_num > 0) {\n\t\tbi.tb = tb;\n\t\tbi.bi_bh = tbSh;\n\t\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tinternal_insert_childs(&bi,\t/*tbSh, */\n\t\t\t\t       /*          ( tb->S[h-1]->b_parent == tb->S[h] ) ? tb->S[h-1]->b_next :  tb->S[h]->b_child->b_next, */\n\t\t\t\t       child_pos, insert_num, insert_key,\n\t\t\t\t       insert_ptr);\n\t}\n\n\tmemcpy(new_insert_key_addr, &new_insert_key, KEY_SIZE);\n\tinsert_ptr[0] = new_insert_ptr;\n\n\treturn order;\n}"
  },
  {
    "function_name": "replace_rkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "775-787",
    "snippet": "static void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\n\t       \"R[h](%p) and CFR[h](%p) must exist in replace_rkey\",\n\t       tb->R[h], tb->CFR[h]);\n\tRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\n\t       \"R[h] can not be empty if it exists (item number=%d)\",\n\t       B_NR_ITEMS(tb->R[h]));\n\n\tmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tb->CFR[h]",
            "0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "internal_key(tb->CFR[h], tb->rkey[h])",
            "key",
            "KEY_SIZE"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFR[h]",
            "tb->rkey[h]"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_NR_ITEMS(tb->R[h]) == 0",
            "\"R[h] can not be empty if it exists (item number=%d)\"",
            "B_NR_ITEMS(tb->R[h])"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->R[h]"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->R[h]"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->R[h] == NULL || tb->CFR[h] == NULL",
            "\"R[h](%p) and CFR[h](%p) must exist in replace_rkey\"",
            "tb->R[h]",
            "tb->CFR[h]"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void replace_rkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->R[h] == NULL || tb->CFR[h] == NULL,\n\t       \"R[h](%p) and CFR[h](%p) must exist in replace_rkey\",\n\t       tb->R[h], tb->CFR[h]);\n\tRFALSE(B_NR_ITEMS(tb->R[h]) == 0,\n\t       \"R[h] can not be empty if it exists (item number=%d)\",\n\t       B_NR_ITEMS(tb->R[h]));\n\n\tmemcpy(internal_key(tb->CFR[h], tb->rkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFR[h], 0);\n}"
  },
  {
    "function_name": "replace_lkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "760-772",
    "snippet": "static void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\n\t       \"L[h](%p) and CFL[h](%p) must exist in replace_lkey\",\n\t       tb->L[h], tb->CFL[h]);\n\n\tif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\n\t\treturn;\n\n\tmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "tb",
            "tb->CFL[h]",
            "0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "internal_key(tb->CFL[h], tb->lkey[h])",
            "key",
            "KEY_SIZE"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "tb->CFL[h]",
            "tb->lkey[h]"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "PATH_H_PBUFFER(tb->tb_path, h)"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->L[h] == NULL || tb->CFL[h] == NULL",
            "\"L[h](%p) and CFL[h](%p) must exist in replace_lkey\"",
            "tb->L[h]",
            "tb->CFL[h]"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void replace_lkey(struct tree_balance *tb, int h, struct item_head *key)\n{\n\tRFALSE(tb->L[h] == NULL || tb->CFL[h] == NULL,\n\t       \"L[h](%p) and CFL[h](%p) must exist in replace_lkey\",\n\t       tb->L[h], tb->CFL[h]);\n\n\tif (B_NR_ITEMS(PATH_H_PBUFFER(tb->tb_path, h)) == 0)\n\t\treturn;\n\n\tmemcpy(internal_key(tb->CFL[h], tb->lkey[h]), key, KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, tb->CFL[h], 0);\n}"
  },
  {
    "function_name": "balance_internal_when_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "632-757",
    "snippet": "static void balance_internal_when_delete(struct tree_balance *tb,\n\t\t\t\t\t int h, int child_pos)\n{\n\tint insert_num;\n\tint n;\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\tinsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\n\n\t/* delete child-node-pointer(s) together with their left item(s) */\n\tbi.tb = tb;\n\tbi.bi_bh = tbSh;\n\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tinternal_delete_childs(&bi, child_pos, -insert_num);\n\n\tRFALSE(tb->blknum[h] > 1,\n\t       \"tb->blknum[%d]=%d when insert_size < 0\", h, tb->blknum[h]);\n\n\tn = B_NR_ITEMS(tbSh);\n\n\tif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\n\t\tif (tb->blknum[h] == 0) {\n\t\t\t/* node S[h] (root of the tree) is empty now */\n\t\t\tstruct buffer_head *new_root;\n\n\t\t\tRFALSE(n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE,\n\t\t\t       \"buffer must have only 0 keys (%d)\", n);\n\t\t\tRFALSE(bi.bi_parent, \"root has parent (%p)\",\n\t\t\t       bi.bi_parent);\n\n\t\t\t/* choose a new root */\n\t\t\tif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\n\t\t\t\tnew_root = tb->R[h - 1];\n\t\t\telse\n\t\t\t\tnew_root = tb->L[h - 1];\n\t\t\t/*\n\t\t\t * switch super block's tree root block\n\t\t\t * number to the new value */\n\t\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\n\t\t\t/*REISERFS_SB(tb->tb_sb)->s_rs->s_tree_height --; */\n\t\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb,\n\t\t\t\t\t   SB_TREE_HEIGHT(tb->tb_sb) - 1);\n\n\t\t\tdo_balance_mark_sb_dirty(tb,\n\t\t\t\t\t\t REISERFS_SB(tb->tb_sb)->s_sbh,\n\t\t\t\t\t\t 1);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\t\t\t/* use check_internal if new root is an internal node */\n\t\t\tif (h > 1)\n\t\t\t\tcheck_internal(new_root);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t\t/* do what is needed for buffer thrown from tree */\n\t\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* join S[h] with L[h] */\n\tif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\n\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\",\n\t\t       h, tb->rnum[h]);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\n\t/* join S[h] with R[h] */\n\tif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\",\n\t\t       h, tb->lnum[h]);\n\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn;\n\t}\n\n\t/* borrow from left neighbor L[h] */\n\tif (tb->lnum[h] < 0) {\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"wrong tb->rnum[%d]==%d when borrow from L[h]\", h,\n\t\t       tb->rnum[h]);\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\n\t\t\t\t     -tb->lnum[h]);\n\t\treturn;\n\t}\n\n\t/* borrow from right neighbor R[h] */\n\tif (tb->rnum[h] < 0) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when borrow from R[h]\",\n\t\t       h, tb->lnum[h]);\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\t/*tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], -tb->rnum[h]); */\n\t\treturn;\n\t}\n\n\t/* split S[h] into two parts and put them into neighbors */\n\tif (tb->lnum[h] > 0) {\n\t\tRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\n\t\t       \"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h], n);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\t/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], tb->lnum[h]); */\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t     tb->rnum[h]);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\treiserfs_panic(tb->tb_sb, \"ibalance-2\",\n\t\t       \"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h]);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
      "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
      "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
      "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
    ],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"ibalance-2\"",
            "\"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\"",
            "h",
            "tb->lnum[h]",
            "h",
            "tb->rnum[h]"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_invalidate_buffer",
          "args": [
            "tb",
            "tbSh"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_invalidate_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1551-1560",
          "snippet": "void reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb, struct buffer_head *bh)\n{\n\tstruct block_head *blkh;\n\tblkh = B_BLK_HEAD(bh);\n\tset_blkh_level(blkh, FREE_LEVEL);\n\tset_blkh_nr_item(blkh, 0);\n\n\tclear_buffer_dirty(bh);\n\tstore_thrown(tb, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift_right",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_R",
            "tb",
            "h",
            "tb->rnum[h]"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "560-601",
          "snippet": "static void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_shift_left",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_L",
            "tb",
            "h",
            "tb->lnum[h]"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "internal_shift_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "488-526",
          "snippet": "static void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1",
            "\"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\"",
            "h",
            "tb->lnum[h]",
            "h",
            "tb->rnum[h]",
            "n"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->lnum[h] != 0",
            "\"invalid tb->lnum[%d]==%d when borrow from R[h]\"",
            "h",
            "tb->lnum[h]"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rnum[h] != 0",
            "\"wrong tb->rnum[%d]==%d when borrow from L[h]\"",
            "h",
            "tb->rnum[h]"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->lnum[h] != 0",
            "\"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\"",
            "h",
            "tb->lnum[h]"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->R[h]"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->rnum[h] != 0",
            "\"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\"",
            "h",
            "tb->rnum[h]"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[h]"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_internal",
          "args": [
            "new_root"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "759-764",
          "snippet": "void check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_sb_dirty",
          "args": [
            "tb",
            "REISERFS_SB(tb->tb_sb)->s_sbh",
            "1"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "tb->tb_sb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PUT_SB_TREE_HEIGHT",
          "args": [
            "tb->tb_sb",
            "SB_TREE_HEIGHT(tb->tb_sb) - 1"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_TREE_HEIGHT",
          "args": [
            "tb->tb_sb"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PUT_SB_ROOT_BLOCK",
          "args": [
            "tb->tb_sb",
            "new_root->b_blocknr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tb->L[h - 1]"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "bi.bi_parent",
            "\"root has parent (%p)\"",
            "bi.bi_parent"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE",
            "\"buffer must have only 0 keys (%d)\"",
            "n"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "tbSh"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "tbSh"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "tbSh"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "tb->blknum[h] > 1",
            "\"tb->blknum[%d]=%d when insert_size < 0\"",
            "h",
            "tb->blknum[h]"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_delete_childs",
          "args": [
            "&bi",
            "child_pos",
            "-insert_num"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "internal_delete_childs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "277-288",
          "snippet": "static void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\n{\n\tint i_from;\n\n\ti_from = (from == 0) ? from : from - 1;\n\n\t/*\n\t * delete n pointers starting from `from' position in CUR;\n\t * delete n keys starting from 'i_from' position in CUR;\n\t */\n\tinternal_delete_pointers_items(cur_bi, from, i_from, n);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\n{\n\tint i_from;\n\n\ti_from = (from == 0) ? from : from - 1;\n\n\t/*\n\t * delete n pointers starting from `from' position in CUR;\n\t * delete n keys starting from 'i_from' position in CUR;\n\t */\n\tinternal_delete_pointers_items(cur_bi, from, i_from, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void balance_internal_when_delete(struct tree_balance *tb,\n\t\t\t\t\t int h, int child_pos)\n{\n\tint insert_num;\n\tint n;\n\tstruct buffer_head *tbSh = PATH_H_PBUFFER(tb->tb_path, h);\n\tstruct buffer_info bi;\n\n\tinsert_num = tb->insert_size[h] / ((int)(DC_SIZE + KEY_SIZE));\n\n\t/* delete child-node-pointer(s) together with their left item(s) */\n\tbi.tb = tb;\n\tbi.bi_bh = tbSh;\n\tbi.bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\tbi.bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tinternal_delete_childs(&bi, child_pos, -insert_num);\n\n\tRFALSE(tb->blknum[h] > 1,\n\t       \"tb->blknum[%d]=%d when insert_size < 0\", h, tb->blknum[h]);\n\n\tn = B_NR_ITEMS(tbSh);\n\n\tif (tb->lnum[h] == 0 && tb->rnum[h] == 0) {\n\t\tif (tb->blknum[h] == 0) {\n\t\t\t/* node S[h] (root of the tree) is empty now */\n\t\t\tstruct buffer_head *new_root;\n\n\t\t\tRFALSE(n\n\t\t\t       || B_FREE_SPACE(tbSh) !=\n\t\t\t       MAX_CHILD_SIZE(tbSh) - DC_SIZE,\n\t\t\t       \"buffer must have only 0 keys (%d)\", n);\n\t\t\tRFALSE(bi.bi_parent, \"root has parent (%p)\",\n\t\t\t       bi.bi_parent);\n\n\t\t\t/* choose a new root */\n\t\t\tif (!tb->L[h - 1] || !B_NR_ITEMS(tb->L[h - 1]))\n\t\t\t\tnew_root = tb->R[h - 1];\n\t\t\telse\n\t\t\t\tnew_root = tb->L[h - 1];\n\t\t\t/*\n\t\t\t * switch super block's tree root block\n\t\t\t * number to the new value */\n\t\t\tPUT_SB_ROOT_BLOCK(tb->tb_sb, new_root->b_blocknr);\n\t\t\t/*REISERFS_SB(tb->tb_sb)->s_rs->s_tree_height --; */\n\t\t\tPUT_SB_TREE_HEIGHT(tb->tb_sb,\n\t\t\t\t\t   SB_TREE_HEIGHT(tb->tb_sb) - 1);\n\n\t\t\tdo_balance_mark_sb_dirty(tb,\n\t\t\t\t\t\t REISERFS_SB(tb->tb_sb)->s_sbh,\n\t\t\t\t\t\t 1);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\t\t\t/* use check_internal if new root is an internal node */\n\t\t\tif (h > 1)\n\t\t\t\tcheck_internal(new_root);\n\t\t\t/*&&&&&&&&&&&&&&&&&&&&&& */\n\n\t\t\t/* do what is needed for buffer thrown from tree */\n\t\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* join S[h] with L[h] */\n\tif (tb->L[h] && tb->lnum[h] == -B_NR_ITEMS(tb->L[h]) - 1) {\n\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"invalid tb->rnum[%d]==%d when joining S[h] with L[h]\",\n\t\t       h, tb->rnum[h]);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, n + 1);\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\n\t/* join S[h] with R[h] */\n\tif (tb->R[h] && tb->rnum[h] == -B_NR_ITEMS(tb->R[h]) - 1) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when joining S[h] with R[h]\",\n\t\t       h, tb->lnum[h]);\n\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h, n + 1);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\t\treturn;\n\t}\n\n\t/* borrow from left neighbor L[h] */\n\tif (tb->lnum[h] < 0) {\n\t\tRFALSE(tb->rnum[h] != 0,\n\t\t       \"wrong tb->rnum[%d]==%d when borrow from L[h]\", h,\n\t\t       tb->rnum[h]);\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_L_TO_S, tb, h,\n\t\t\t\t     -tb->lnum[h]);\n\t\treturn;\n\t}\n\n\t/* borrow from right neighbor R[h] */\n\tif (tb->rnum[h] < 0) {\n\t\tRFALSE(tb->lnum[h] != 0,\n\t\t       \"invalid tb->lnum[%d]==%d when borrow from R[h]\",\n\t\t       h, tb->lnum[h]);\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_R_TO_S, tb, h, -tb->rnum[h]);\t/*tb->S[h], tb->CFR[h], tb->rkey[h], tb->R[h], -tb->rnum[h]); */\n\t\treturn;\n\t}\n\n\t/* split S[h] into two parts and put them into neighbors */\n\tif (tb->lnum[h] > 0) {\n\t\tRFALSE(tb->rnum[h] == 0 || tb->lnum[h] + tb->rnum[h] != n + 1,\n\t\t       \"invalid tb->lnum[%d]==%d or tb->rnum[%d]==%d when S[h](item number == %d) is split between them\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h], n);\n\n\t\tinternal_shift_left(INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);\t/*tb->L[h], tb->CFL[h], tb->lkey[h], tb->S[h], tb->lnum[h]); */\n\t\tinternal_shift_right(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t     tb->rnum[h]);\n\n\t\treiserfs_invalidate_buffer(tb, tbSh);\n\n\t\treturn;\n\t}\n\treiserfs_panic(tb->tb_sb, \"ibalance-2\",\n\t\t       \"unexpected tb->lnum[%d]==%d or tb->rnum[%d]==%d\",\n\t\t       h, tb->lnum[h], h, tb->rnum[h]);\n}"
  },
  {
    "function_name": "internal_shift1_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "609-626",
    "snippet": "static void internal_shift1_right(struct tree_balance *tb,\n\t\t\t\t  int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert rkey from CFR[h] to right neighbor R[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 1);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define INTERNAL_SHIFT_FROM_S_TO_R 3"
    ],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_move_pointers_items",
          "args": [
            "&dest_bi",
            "&src_bi",
            "LAST_TO_FIRST",
            "pointer_amount",
            "1"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "internal_move_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "394-426",
          "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_insert_key",
          "args": [
            "&dest_bi",
            "0",
            "cf",
            "d_key_position"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "internal_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "429-478",
          "snippet": "static void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_define_dest_src_infos",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_R",
            "tb",
            "h",
            "&dest_bi",
            "&src_bi",
            "&d_key_position",
            "&cf"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "internal_define_dest_src_infos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "27-119",
          "snippet": "static void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_INSERT_TO_R 6",
            "#define INTERNAL_INSERT_TO_L 5",
            "#define INTERNAL_INSERT_TO_S 4",
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
            "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_INSERT_TO_R 6\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift1_right(struct tree_balance *tb,\n\t\t\t\t  int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_R, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert rkey from CFR[h] to right neighbor R[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 1);\n}"
  },
  {
    "function_name": "internal_shift_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "560-601",
    "snippet": "static void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_move_pointers_items",
          "args": [
            "&dest_bi",
            "&src_bi",
            "LAST_TO_FIRST",
            "pointer_amount",
            "0"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "internal_move_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "394-426",
          "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "cf",
            "d_key_position",
            "src_bi.bi_bh",
            "nr - pointer_amount"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h]",
            "\"src (%p) must be == tb->S[h](%p) when it disappears\"",
            "src_bi.bi_bh",
            "PATH_H_PBUFFER(tb->tb_path, h)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_insert_key",
          "args": [
            "&dest_bi",
            "0",
            "cf",
            "d_key_position"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "internal_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "429-478",
          "snippet": "static void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src_bi.bi_bh"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_define_dest_src_infos",
          "args": [
            "mode",
            "tb",
            "h",
            "&dest_bi",
            "&src_bi",
            "&d_key_position",
            "&cf"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "internal_define_dest_src_infos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "27-119",
          "snippet": "static void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_INSERT_TO_R 6",
            "#define INTERNAL_INSERT_TO_L 5",
            "#define INTERNAL_INSERT_TO_S 4",
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
            "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_INSERT_TO_R 6\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_right(\n\t\t\t\t /*\n\t\t\t\t  * INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S\n\t\t\t\t  */\n\t\t\t\t int mode,\n\t\t\t\t struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\tint nr;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\tnr = B_NR_ITEMS(src_bi.bi_bh);\n\n\tif (pointer_amount > 0) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest\n\t\t * and src to dest node into position 0\n\t\t */\n\t\tinternal_insert_key(&dest_bi, 0, cf, d_key_position);\n\t\tif (nr == pointer_amount - 1) {\n\t\t\tRFALSE(src_bi.bi_bh != PATH_H_PBUFFER(tb->tb_path, h) /*tb->S[h] */ ||\n\t\t\t       dest_bi.bi_bh != tb->R[h],\n\t\t\t       \"src (%p) must be == tb->S[h](%p) when it disappears\",\n\t\t\t       src_bi.bi_bh, PATH_H_PBUFFER(tb->tb_path, h));\n\t\t\t/* when S[h] disappers replace left delemiting key as well */\n\t\t\tif (tb->CFL[h])\n\t\t\t\treplace_key(tb, cf, d_key_position, tb->CFL[h],\n\t\t\t\t\t    tb->lkey[h]);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    nr - pointer_amount);\n\t}\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, LAST_TO_FIRST,\n\t\t\t\t     pointer_amount, 0);\n}"
  },
  {
    "function_name": "internal_shift1_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "534-552",
    "snippet": "static void internal_shift1_left(struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 1);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
    ],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_move_pointers_items",
          "args": [
            "&dest_bi",
            "&src_bi",
            "FIRST_TO_LAST",
            "pointer_amount",
            "1"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "internal_move_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "394-426",
          "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_insert_key",
          "args": [
            "&dest_bi",
            "B_NR_ITEMS(dest_bi.bi_bh)",
            "cf",
            "d_key_position"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "internal_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "429-478",
          "snippet": "static void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest_bi.bi_bh"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_define_dest_src_infos",
          "args": [
            "INTERNAL_SHIFT_FROM_S_TO_L",
            "tb",
            "h",
            "&dest_bi",
            "&src_bi",
            "&d_key_position",
            "&cf"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "internal_define_dest_src_infos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "27-119",
          "snippet": "static void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_INSERT_TO_R 6",
            "#define INTERNAL_INSERT_TO_L 5",
            "#define INTERNAL_INSERT_TO_S 4",
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
            "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_INSERT_TO_R 6\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift1_left(struct tree_balance *tb,\n\t\t\t\t int h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(INTERNAL_SHIFT_FROM_S_TO_L, tb, h,\n\t\t\t\t       &dest_bi, &src_bi, &d_key_position, &cf);\n\n\t/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */\n\tif (pointer_amount > 0)\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 1);\n}"
  },
  {
    "function_name": "internal_shift_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "488-526",
    "snippet": "static void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_move_pointers_items",
          "args": [
            "&dest_bi",
            "&src_bi",
            "FIRST_TO_LAST",
            "pointer_amount",
            "0"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "internal_move_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "394-426",
          "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_key",
          "args": [
            "tb",
            "cf",
            "d_key_position",
            "src_bi.bi_bh",
            "pointer_amount - 1"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "replace_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1563-1588",
          "snippet": "void replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\n#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty\n\nvoid replace_key(struct tree_balance *tb, struct buffer_head *dest, int n_dest,\n\t\t struct buffer_head *src, int n_src)\n{\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"vs-12305: source or destination buffer is 0 (src=%p, dest=%p)\",\n\t       src, dest);\n\tRFALSE(!B_IS_KEYS_LEVEL(dest),\n\t       \"vs-12310: invalid level (%z) for destination buffer. dest must be leaf\",\n\t       dest);\n\tRFALSE(n_dest < 0 || n_src < 0,\n\t       \"vs-12315: src(%d) or dest(%d) key number < 0\", n_src, n_dest);\n\tRFALSE(n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),\n\t       \"vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big\",\n\t       n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));\n\n\tif (B_IS_ITEMS_LEVEL(src))\n\t\t/* source buffer contains leaf node */\n\t\tmemcpy(internal_key(dest, n_dest), item_head(src, n_src),\n\t\t       KEY_SIZE);\n\telse\n\t\tmemcpy(internal_key(dest, n_dest), internal_key(src, n_src),\n\t\t       KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(tb, dest, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src_bi.bi_bh"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_insert_key",
          "args": [
            "&dest_bi",
            "B_NR_ITEMS(dest_bi.bi_bh)",
            "cf",
            "d_key_position"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "internal_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "429-478",
          "snippet": "static void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest_bi.bi_bh"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_define_dest_src_infos",
          "args": [
            "mode",
            "tb",
            "h",
            "&dest_bi",
            "&src_bi",
            "&d_key_position",
            "&cf"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "internal_define_dest_src_infos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "27-119",
          "snippet": "static void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define INTERNAL_INSERT_TO_R 6",
            "#define INTERNAL_INSERT_TO_L 5",
            "#define INTERNAL_INSERT_TO_S 4",
            "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
            "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
            "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
            "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
          ],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_INSERT_TO_R 6\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_shift_left(\n\t\t\t\t/*\n\t\t\t\t * INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S\n\t\t\t\t */\n\t\t\t\tint mode,\n\t\t\t\tstruct tree_balance *tb,\n\t\t\t\tint h, int pointer_amount)\n{\n\tstruct buffer_info dest_bi, src_bi;\n\tstruct buffer_head *cf;\n\tint d_key_position;\n\n\tinternal_define_dest_src_infos(mode, tb, h, &dest_bi, &src_bi,\n\t\t\t\t       &d_key_position, &cf);\n\n\t/*printk(\"pointer_amount = %d\\n\",pointer_amount); */\n\n\tif (pointer_amount) {\n\t\t/*\n\t\t * insert delimiting key from common father of dest and\n\t\t * src to node dest into position B_NR_ITEM(dest)\n\t\t */\n\t\tinternal_insert_key(&dest_bi, B_NR_ITEMS(dest_bi.bi_bh), cf,\n\t\t\t\t    d_key_position);\n\n\t\tif (B_NR_ITEMS(src_bi.bi_bh) == pointer_amount - 1) {\n\t\t\tif (src_bi.bi_position /*src->b_item_order */  == 0)\n\t\t\t\treplace_key(tb, cf, d_key_position,\n\t\t\t\t\t    src_bi.\n\t\t\t\t\t    bi_parent /*src->b_parent */ , 0);\n\t\t} else\n\t\t\treplace_key(tb, cf, d_key_position, src_bi.bi_bh,\n\t\t\t\t    pointer_amount - 1);\n\t}\n\t/* last parameter is del_parameter */\n\tinternal_move_pointers_items(&dest_bi, &src_bi, FIRST_TO_LAST,\n\t\t\t\t     pointer_amount, 0);\n\n}"
  },
  {
    "function_name": "internal_insert_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "429-478",
    "snippet": "static void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "dest_bi->tb",
            "dest_bi->bi_parent",
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + KEY_SIZE"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "dest_bi->bi_parent",
            "dest_bi->bi_position"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "dest_bi->tb",
            "dest",
            "0"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) - KEY_SIZE"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) + 1"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key",
            "internal_key(src, src_position)",
            "KEY_SIZE"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "src",
            "src_position"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "key + 1",
            "key",
            "(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "dest"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_FREE_SPACE(dest) < KEY_SIZE",
            "\"no enough free space (%d) in dest buffer\"",
            "B_FREE_SPACE(dest)"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "dest"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "dest"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src)",
            "\"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\"",
            "dest_position_before",
            "B_NR_ITEMS(dest)",
            "src_position",
            "B_NR_ITEMS(src)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dest_position_before < 0 || src_position < 0",
            "\"source(%d) or dest(%d) key number less than 0\"",
            "src_position",
            "dest_position_before"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dest == NULL || src == NULL",
            "\"source(%p) or dest(%p) buffer is 0\"",
            "src",
            "dest"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_key(struct buffer_info *dest_bi,\n\t\t\t\t/* insert key before key with n_dest number */\n\t\t\t\tint dest_position_before,\n\t\t\t\tstruct buffer_head *src, int src_position)\n{\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"source(%p) or dest(%p) buffer is 0\", src, dest);\n\tRFALSE(dest_position_before < 0 || src_position < 0,\n\t       \"source(%d) or dest(%d) key number less than 0\",\n\t       src_position, dest_position_before);\n\tRFALSE(dest_position_before > B_NR_ITEMS(dest) ||\n\t       src_position >= B_NR_ITEMS(src),\n\t       \"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))\",\n\t       dest_position_before, B_NR_ITEMS(dest),\n\t       src_position, B_NR_ITEMS(src));\n\tRFALSE(B_FREE_SPACE(dest) < KEY_SIZE,\n\t       \"no enough free space (%d) in dest buffer\", B_FREE_SPACE(dest));\n\n\tblkh = B_BLK_HEAD(dest);\n\tnr = blkh_nr_item(blkh);\n\n\t/* prepare space for inserting key */\n\tkey = internal_key(dest, dest_position_before);\n\tmemmove(key + 1, key,\n\t\t(nr - dest_position_before) * KEY_SIZE + (nr + 1) * DC_SIZE);\n\n\t/* insert key */\n\tmemcpy(key, internal_key(src, src_position), KEY_SIZE);\n\n\t/* Change dirt, free space, item number fields. */\n\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1);\n\tset_blkh_free_space(blkh, blkh_free_space(blkh) - KEY_SIZE);\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc, dc_size(t_dc) + KEY_SIZE);\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t}\n}"
  },
  {
    "function_name": "internal_move_pointers_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "394-426",
    "snippet": "static void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_delete_pointers_items",
          "args": [
            "src_bi",
            "j + 1 - cpy_num + del_par",
            "i",
            "cpy_num - del_par"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "internal_delete_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "205-274",
          "snippet": "static void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src_bi->bi_bh"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_copy_pointers_items",
          "args": [
            "dest_bi",
            "src_bi->bi_bh",
            "last_first",
            "cpy_num"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "internal_copy_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "298-385",
          "snippet": "static void internal_copy_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_head *src,\n\t\t\t\t\t int last_first, int cpy_num)\n{\n\t/*\n\t * ATTENTION! Number of node pointers in DEST is equal to number\n\t * of items in DEST  as delimiting key have already inserted to\n\t * buffer dest.\n\t */\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr_dest, nr_src;\n\tint dest_order, src_order;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tnr_src = B_NR_ITEMS(src);\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"src (%p) or dest (%p) buffer is 0\", src, dest);\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"invalid last_first parameter (%d)\", last_first);\n\tRFALSE(nr_src < cpy_num - 1,\n\t       \"no so many items (%d) in src (%d)\", cpy_num, nr_src);\n\tRFALSE(cpy_num < 0, \"cpy_num less than 0 (%d)\", cpy_num);\n\tRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\n\t       \"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\",\n\t       cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\t/* coping */\n\tblkh = B_BLK_HEAD(dest);\n\tnr_dest = blkh_nr_item(blkh);\n\n\t/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest; */\n\t/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0; */\n\t(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\n\t\t\t\t\t nr_src - cpy_num + 1) : (dest_order =\n\t\t\t\t\t\t\t\t  nr_dest,\n\t\t\t\t\t\t\t\t  src_order =\n\t\t\t\t\t\t\t\t  0);\n\n\t/* prepare space for cpy_num pointers */\n\tdc = B_N_CHILD(dest, dest_order);\n\n\tmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\n\n\t/* insert pointers */\n\tmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\n\n\t/* prepare space for cpy_num - 1 item headers */\n\tkey = internal_key(dest, dest_order);\n\tmemmove(key + cpy_num - 1, key,\n\t\tKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num));\n\n\t/* insert headers */\n\tmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(dest);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(dest_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_copy_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_head *src,\n\t\t\t\t\t int last_first, int cpy_num)\n{\n\t/*\n\t * ATTENTION! Number of node pointers in DEST is equal to number\n\t * of items in DEST  as delimiting key have already inserted to\n\t * buffer dest.\n\t */\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr_dest, nr_src;\n\tint dest_order, src_order;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tnr_src = B_NR_ITEMS(src);\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"src (%p) or dest (%p) buffer is 0\", src, dest);\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"invalid last_first parameter (%d)\", last_first);\n\tRFALSE(nr_src < cpy_num - 1,\n\t       \"no so many items (%d) in src (%d)\", cpy_num, nr_src);\n\tRFALSE(cpy_num < 0, \"cpy_num less than 0 (%d)\", cpy_num);\n\tRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\n\t       \"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\",\n\t       cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\t/* coping */\n\tblkh = B_BLK_HEAD(dest);\n\tnr_dest = blkh_nr_item(blkh);\n\n\t/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest; */\n\t/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0; */\n\t(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\n\t\t\t\t\t nr_src - cpy_num + 1) : (dest_order =\n\t\t\t\t\t\t\t\t  nr_dest,\n\t\t\t\t\t\t\t\t  src_order =\n\t\t\t\t\t\t\t\t  0);\n\n\t/* prepare space for cpy_num pointers */\n\tdc = B_N_CHILD(dest, dest_order);\n\n\tmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\n\n\t/* insert pointers */\n\tmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\n\n\t/* prepare space for cpy_num - 1 item headers */\n\tkey = internal_key(dest, dest_order);\n\tmemmove(key + cpy_num - 1, key,\n\t\tKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num));\n\n\t/* insert headers */\n\tmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(dest);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(dest_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_move_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_info *src_bi,\n\t\t\t\t\t int last_first, int cpy_num,\n\t\t\t\t\t int del_par)\n{\n\tint first_pointer;\n\tint first_item;\n\n\tinternal_copy_pointers_items(dest_bi, src_bi->bi_bh, last_first,\n\t\t\t\t     cpy_num);\n\n\tif (last_first == FIRST_TO_LAST) {\t/* shift_left occurs */\n\t\tfirst_pointer = 0;\n\t\tfirst_item = 0;\n\t\t/*\n\t\t * delete cpy_num - del_par pointers and keys starting for\n\t\t * pointers with first_pointer, for key - with first_item\n\t\t */\n\t\tinternal_delete_pointers_items(src_bi, first_pointer,\n\t\t\t\t\t       first_item, cpy_num - del_par);\n\t} else {\t\t/* shift_right occurs */\n\t\tint i, j;\n\n\t\ti = (cpy_num - del_par ==\n\t\t     (j =\n\t\t      B_NR_ITEMS(src_bi->bi_bh)) + 1) ? 0 : j - cpy_num +\n\t\t    del_par;\n\n\t\tinternal_delete_pointers_items(src_bi,\n\t\t\t\t\t       j + 1 - cpy_num + del_par, i,\n\t\t\t\t\t       cpy_num - del_par);\n\t}\n}"
  },
  {
    "function_name": "internal_copy_pointers_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "298-385",
    "snippet": "static void internal_copy_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_head *src,\n\t\t\t\t\t int last_first, int cpy_num)\n{\n\t/*\n\t * ATTENTION! Number of node pointers in DEST is equal to number\n\t * of items in DEST  as delimiting key have already inserted to\n\t * buffer dest.\n\t */\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr_dest, nr_src;\n\tint dest_order, src_order;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tnr_src = B_NR_ITEMS(src);\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"src (%p) or dest (%p) buffer is 0\", src, dest);\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"invalid last_first parameter (%d)\", last_first);\n\tRFALSE(nr_src < cpy_num - 1,\n\t       \"no so many items (%d) in src (%d)\", cpy_num, nr_src);\n\tRFALSE(cpy_num < 0, \"cpy_num less than 0 (%d)\", cpy_num);\n\tRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\n\t       \"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\",\n\t       cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\t/* coping */\n\tblkh = B_BLK_HEAD(dest);\n\tnr_dest = blkh_nr_item(blkh);\n\n\t/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest; */\n\t/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0; */\n\t(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\n\t\t\t\t\t nr_src - cpy_num + 1) : (dest_order =\n\t\t\t\t\t\t\t\t  nr_dest,\n\t\t\t\t\t\t\t\t  src_order =\n\t\t\t\t\t\t\t\t  0);\n\n\t/* prepare space for cpy_num pointers */\n\tdc = B_N_CHILD(dest, dest_order);\n\n\tmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\n\n\t/* insert pointers */\n\tmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\n\n\t/* prepare space for cpy_num - 1 item headers */\n\tkey = internal_key(dest, dest_order);\n\tmemmove(key + cpy_num - 1, key,\n\t\tKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num));\n\n\t/* insert headers */\n\tmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(dest);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(dest_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_internal",
          "args": [
            "dest_bi->bi_parent"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "759-764",
          "snippet": "void check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "dest_bi->tb",
            "dest_bi->bi_parent",
            "0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "dest_bi->bi_parent",
            "dest_bi->bi_position"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "dest_bi->tb",
            "dest",
            "0"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) + (cpy_num - 1)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key",
            "internal_key(src, src_order)",
            "KEY_SIZE * (cpy_num - 1)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "src",
            "src_order"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "key + cpy_num - 1",
            "key",
            "KEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dc",
            "B_N_CHILD(src, src_order)",
            "DC_SIZE * cpy_num"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "src",
            "src_order"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dc + cpy_num",
            "dc",
            "(nr_dest - dest_order) * DC_SIZE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "dest",
            "dest_order"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "dest"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest)",
            "\"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\"",
            "cpy_num",
            "B_NR_ITEMS(dest)",
            "MAX_NR_KEY(dest)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "dest"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_NR_KEY",
          "args": [
            "dest"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "dest"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cpy_num < 0",
            "\"cpy_num less than 0 (%d)\"",
            "cpy_num"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "nr_src < cpy_num - 1",
            "\"no so many items (%d) in src (%d)\"",
            "cpy_num",
            "nr_src"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST",
            "\"invalid last_first parameter (%d)\"",
            "last_first"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "dest == NULL || src == NULL",
            "\"src (%p) or dest (%p) buffer is 0\"",
            "src",
            "dest"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "src"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_copy_pointers_items(struct buffer_info *dest_bi,\n\t\t\t\t\t struct buffer_head *src,\n\t\t\t\t\t int last_first, int cpy_num)\n{\n\t/*\n\t * ATTENTION! Number of node pointers in DEST is equal to number\n\t * of items in DEST  as delimiting key have already inserted to\n\t * buffer dest.\n\t */\n\tstruct buffer_head *dest = dest_bi->bi_bh;\n\tint nr_dest, nr_src;\n\tint dest_order, src_order;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tnr_src = B_NR_ITEMS(src);\n\n\tRFALSE(dest == NULL || src == NULL,\n\t       \"src (%p) or dest (%p) buffer is 0\", src, dest);\n\tRFALSE(last_first != FIRST_TO_LAST && last_first != LAST_TO_FIRST,\n\t       \"invalid last_first parameter (%d)\", last_first);\n\tRFALSE(nr_src < cpy_num - 1,\n\t       \"no so many items (%d) in src (%d)\", cpy_num, nr_src);\n\tRFALSE(cpy_num < 0, \"cpy_num less than 0 (%d)\", cpy_num);\n\tRFALSE(cpy_num - 1 + B_NR_ITEMS(dest) > (int)MAX_NR_KEY(dest),\n\t       \"cpy_num (%d) + item number in dest (%d) can not be > MAX_NR_KEY(%d)\",\n\t       cpy_num, B_NR_ITEMS(dest), MAX_NR_KEY(dest));\n\n\tif (cpy_num == 0)\n\t\treturn;\n\n\t/* coping */\n\tblkh = B_BLK_HEAD(dest);\n\tnr_dest = blkh_nr_item(blkh);\n\n\t/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest; */\n\t/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0; */\n\t(last_first == LAST_TO_FIRST) ? (dest_order = 0, src_order =\n\t\t\t\t\t nr_src - cpy_num + 1) : (dest_order =\n\t\t\t\t\t\t\t\t  nr_dest,\n\t\t\t\t\t\t\t\t  src_order =\n\t\t\t\t\t\t\t\t  0);\n\n\t/* prepare space for cpy_num pointers */\n\tdc = B_N_CHILD(dest, dest_order);\n\n\tmemmove(dc + cpy_num, dc, (nr_dest - dest_order) * DC_SIZE);\n\n\t/* insert pointers */\n\tmemcpy(dc, B_N_CHILD(src, src_order), DC_SIZE * cpy_num);\n\n\t/* prepare space for cpy_num - 1 item headers */\n\tkey = internal_key(dest, dest_order);\n\tmemmove(key + cpy_num - 1, key,\n\t\tKEY_SIZE * (nr_dest - dest_order) + DC_SIZE * (nr_dest +\n\t\t\t\t\t\t\t       cpy_num));\n\n\t/* insert headers */\n\tmemcpy(key, internal_key(src, src_order), KEY_SIZE * (cpy_num - 1));\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1));\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\tdo_balance_mark_internal_dirty(dest_bi->tb, dest, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(dest);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (dest_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (KEY_SIZE * (cpy_num - 1) +\n\t\t\t\t\t     DC_SIZE * cpy_num));\n\n\t\tdo_balance_mark_internal_dirty(dest_bi->tb, dest_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(dest_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}"
  },
  {
    "function_name": "internal_delete_childs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "277-288",
    "snippet": "static void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\n{\n\tint i_from;\n\n\ti_from = (from == 0) ? from : from - 1;\n\n\t/*\n\t * delete n pointers starting from `from' position in CUR;\n\t * delete n keys starting from 'i_from' position in CUR;\n\t */\n\tinternal_delete_pointers_items(cur_bi, from, i_from, n);\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_delete_pointers_items",
          "args": [
            "cur_bi",
            "from",
            "i_from",
            "n"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "internal_delete_pointers_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
          "lines": "205-274",
          "snippet": "static void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nstatic void internal_delete_childs(struct buffer_info *cur_bi, int from, int n)\n{\n\tint i_from;\n\n\ti_from = (from == 0) ? from : from - 1;\n\n\t/*\n\t * delete n pointers starting from `from' position in CUR;\n\t * delete n keys starting from 'i_from' position in CUR;\n\t */\n\tinternal_delete_pointers_items(cur_bi, from, i_from, n);\n}"
  },
  {
    "function_name": "internal_delete_pointers_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "205-274",
    "snippet": "static void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_internal",
          "args": [
            "cur_bi->bi_parent"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "759-764",
          "snippet": "void check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "cur_bi->tb",
            "cur_bi->bi_parent",
            "0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "cur_bi->bi_parent",
            "cur_bi->bi_position"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "cur_bi->tb",
            "cur",
            "0"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE))"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) - del_num"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "key",
            "key + del_num",
            "(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "cur",
            "first_i"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dc",
            "dc + del_num",
            "(nr + 1 - first_p - del_num) * DC_SIZE"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "cur",
            "first_p"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "first_i + del_num > B_NR_ITEMS(cur)",
            "\"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\"",
            "first_i",
            "del_num",
            "first_i + del_num",
            "cur",
            "cur"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "cur"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_empty_node",
          "args": [
            "cur_bi"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "make_empty_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1479-1491",
          "snippet": "void make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nvoid make_empty_node(struct buffer_info *bi)\n{\n\tstruct block_head *blkh;\n\n\tRFALSE(bi->bi_bh == NULL, \"PAP-12295: pointer to the buffer is NULL\");\n\n\tblkh = B_BLK_HEAD(bi->bi_bh);\n\tset_blkh_nr_item(blkh, 0);\n\tset_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));\n\n\tif (bi->bi_parent)\n\t\tB_N_CHILD(bi->bi_parent, bi->bi_position)->dc_size = 0;\t/* Endian safe if 0 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "first_i != 0",
            "\"1st deleted key must have order 0, not %d\"",
            "first_i"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "cur"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0",
            "\"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\"",
            "first_p",
            "first_p + del_num",
            "B_NR_ITEMS(cur) + 1",
            "first_i"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "cur"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_NR_ITEMS",
          "args": [
            "cur"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "del_num < 0",
            "\"negative number of items (%d) can not be deleted\"",
            "del_num"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "cur == NULL",
            "\"buffer is 0\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_delete_pointers_items(struct buffer_info *cur_bi,\n\t\t\t\t\t   int first_p,\n\t\t\t\t\t   int first_i, int del_num)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tint nr;\n\tstruct block_head *blkh;\n\tstruct reiserfs_key *key;\n\tstruct disk_child *dc;\n\n\tRFALSE(cur == NULL, \"buffer is 0\");\n\tRFALSE(del_num < 0,\n\t       \"negative number of items (%d) can not be deleted\", del_num);\n\tRFALSE(first_p < 0 || first_p + del_num > B_NR_ITEMS(cur) + 1\n\t       || first_i < 0,\n\t       \"first pointer order (%d) < 0 or \"\n\t       \"no so many pointers (%d), only (%d) or \"\n\t       \"first key order %d < 0\", first_p, first_p + del_num,\n\t       B_NR_ITEMS(cur) + 1, first_i);\n\tif (del_num == 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tif (first_p == 0 && del_num == nr + 1) {\n\t\tRFALSE(first_i != 0,\n\t\t       \"1st deleted key must have order 0, not %d\", first_i);\n\t\tmake_empty_node(cur_bi);\n\t\treturn;\n\t}\n\n\tRFALSE(first_i + del_num > B_NR_ITEMS(cur),\n\t       \"first_i = %d del_num = %d \"\n\t       \"no so many keys (%d) in the node (%b)(%z)\",\n\t       first_i, del_num, first_i + del_num, cur, cur);\n\n\t/* deleting */\n\tdc = B_N_CHILD(cur, first_p);\n\n\tmemmove(dc, dc + del_num, (nr + 1 - first_p - del_num) * DC_SIZE);\n\tkey = internal_key(cur, first_i);\n\tmemmove(key, key + del_num,\n\t\t(nr - first_i - del_num) * KEY_SIZE + (nr + 1 -\n\t\t\t\t\t\t       del_num) * DC_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) +\n\t\t\t    (del_num * (KEY_SIZE + DC_SIZE)));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc;\n\t\tt_dc = B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE)));\n\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n}"
  },
  {
    "function_name": "internal_insert_childs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "126-199",
    "snippet": "static void internal_insert_childs(struct buffer_info *cur_bi,\n\t\t\t\t   int to, int count,\n\t\t\t\t   struct item_head *inserted,\n\t\t\t\t   struct buffer_head **bh)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tstruct block_head *blkh;\n\tint nr;\n\tstruct reiserfs_key *ih;\n\tstruct disk_child new_dc[2];\n\tstruct disk_child *dc;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(count > 2, \"too many children (%d) are to be inserted\", count);\n\tRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\n\t       \"no enough free space (%d), needed %d bytes\",\n\t       B_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\n\n\t/* prepare space for count disk_child */\n\tdc = B_N_CHILD(cur, to + 1);\n\n\tmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\n\n\t/* copy to_be_insert disk children */\n\tfor (i = 0; i < count; i++) {\n\t\tput_dc_size(&new_dc[i],\n\t\t\t    MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\n\t\tput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\n\t}\n\tmemcpy(dc, new_dc, DC_SIZE * count);\n\n\t/* prepare space for count items  */\n\tih = internal_key(cur, ((to == -1) ? 0 : to));\n\n\tmemmove(ih + count, ih,\n\t\t(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\n\n\t/* copy item headers (keys) */\n\tmemcpy(ih, inserted, KEY_SIZE);\n\tif (count > 1)\n\t\tmemcpy(ih + 1, inserted + 1, KEY_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_internal",
          "args": [
            "cur_bi->bi_parent"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "check_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "759-764",
          "snippet": "void check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid check_internal(struct buffer_head *bh)\n{\n\tif (!bh)\n\t\treturn;\n\tcheck_internal_block_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "cur_bi->tb",
            "cur_bi->bi_parent",
            "0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "t_dc",
            "dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE))"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dc_size",
          "args": [
            "t_dc"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "cur_bi->bi_parent",
            "cur_bi->bi_position"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_balance_mark_internal_dirty",
          "args": [
            "cur_bi->tb",
            "cur",
            "0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_free_space",
          "args": [
            "blkh",
            "blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_free_space",
          "args": [
            "blkh"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blkh_nr_item",
          "args": [
            "blkh",
            "blkh_nr_item(blkh) + count"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ih + 1",
            "inserted + 1",
            "KEY_SIZE"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ih",
            "inserted",
            "KEY_SIZE"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ih + count",
            "ih",
            "(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_key",
          "args": [
            "cur",
            "((to == -1) ? 0 : to)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2189-2195",
          "snippet": "static inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_free_jh(struct buffer_head *bh);",
            "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);",
            "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);",
            "int journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);",
            "void reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);",
            "int B_IS_IN_TREE(const struct buffer_head *);",
            "extern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);",
            "extern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);",
            "extern void decrement_bcount(struct buffer_head *bh);",
            "void reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);",
            "struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);",
            "void reiserfs_unmap_buffer(struct buffer_head *);",
            "void print_indirect_item(struct buffer_head *bh, int item_num);",
            "void print_block(struct buffer_head *bh, ...);",
            "void check_leaf(struct buffer_head *bh);",
            "void check_internal(struct buffer_head *bh);",
            "int balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);",
            "void reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);",
            "void replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_free_jh(struct buffer_head *bh);\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh);\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);\nint journal_mark_dirty(struct reiserfs_transaction_handle *,\n\t\t       struct buffer_head *bh);\nvoid reiserfs_restore_prepared_buffer(struct super_block *,\n\t\t\t\t      struct buffer_head *bh);\nint B_IS_IN_TREE(const struct buffer_head *);\nextern int comp_le_keys(const struct reiserfs_key *,\n\t\t\tconst struct reiserfs_key *);\nextern int comp_short_le_keys(const struct reiserfs_key *,\n\t\t\t      const struct reiserfs_key *);\nextern void decrement_bcount(struct buffer_head *bh);\nvoid reiserfs_delete_solid_item(struct reiserfs_transaction_handle *th,\n\t\t\t\tstruct inode *inode, struct reiserfs_key *key);\nstruct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key);\nvoid reiserfs_unmap_buffer(struct buffer_head *);\nvoid print_indirect_item(struct buffer_head *bh, int item_num);\nvoid print_block(struct buffer_head *bh, ...);\nvoid check_leaf(struct buffer_head *bh);\nvoid check_internal(struct buffer_head *bh);\nint balance_internal(struct tree_balance *, int, int, struct item_head *,\n\t\t     struct buffer_head **);\nvoid reiserfs_invalidate_buffer(struct tree_balance *tb,\n\t\t\t\tstruct buffer_head *bh);\nvoid replace_key(struct tree_balance *tb, struct buffer_head *, int,\n\t\t struct buffer_head *, int);\n\nstatic inline struct reiserfs_key *internal_key(struct buffer_head *bh,\n\t\t\t\t\t\tint item_num)\n{\n\tstruct reiserfs_key *key = reiserfs_node_data(bh);\n\n\treturn &key[item_num];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dc",
            "new_dc",
            "DC_SIZE * count"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_block_number",
          "args": [
            "&new_dc[i]",
            "bh[i]->b_blocknr"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_dc_size",
          "args": [
            "&new_dc[i]",
            "MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i])"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "bh[i]"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX_CHILD_SIZE",
          "args": [
            "bh[i]"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dc + count",
            "dc",
            "(nr + 1 - (to + 1)) * DC_SIZE"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_N_CHILD",
          "args": [
            "cur",
            "to + 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE)",
            "\"no enough free space (%d), needed %d bytes\"",
            "B_FREE_SPACE(cur)",
            "count * (KEY_SIZE + DC_SIZE)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "cur"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_FREE_SPACE",
          "args": [
            "cur"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "count > 2",
            "\"too many children (%d) are to be inserted\"",
            "count"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkh_nr_item",
          "args": [
            "blkh"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B_BLK_HEAD",
          "args": [
            "cur"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_insert_childs(struct buffer_info *cur_bi,\n\t\t\t\t   int to, int count,\n\t\t\t\t   struct item_head *inserted,\n\t\t\t\t   struct buffer_head **bh)\n{\n\tstruct buffer_head *cur = cur_bi->bi_bh;\n\tstruct block_head *blkh;\n\tint nr;\n\tstruct reiserfs_key *ih;\n\tstruct disk_child new_dc[2];\n\tstruct disk_child *dc;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn;\n\n\tblkh = B_BLK_HEAD(cur);\n\tnr = blkh_nr_item(blkh);\n\n\tRFALSE(count > 2, \"too many children (%d) are to be inserted\", count);\n\tRFALSE(B_FREE_SPACE(cur) < count * (KEY_SIZE + DC_SIZE),\n\t       \"no enough free space (%d), needed %d bytes\",\n\t       B_FREE_SPACE(cur), count * (KEY_SIZE + DC_SIZE));\n\n\t/* prepare space for count disk_child */\n\tdc = B_N_CHILD(cur, to + 1);\n\n\tmemmove(dc + count, dc, (nr + 1 - (to + 1)) * DC_SIZE);\n\n\t/* copy to_be_insert disk children */\n\tfor (i = 0; i < count; i++) {\n\t\tput_dc_size(&new_dc[i],\n\t\t\t    MAX_CHILD_SIZE(bh[i]) - B_FREE_SPACE(bh[i]));\n\t\tput_dc_block_number(&new_dc[i], bh[i]->b_blocknr);\n\t}\n\tmemcpy(dc, new_dc, DC_SIZE * count);\n\n\t/* prepare space for count items  */\n\tih = internal_key(cur, ((to == -1) ? 0 : to));\n\n\tmemmove(ih + count, ih,\n\t\t(nr - to) * KEY_SIZE + (nr + 1 + count) * DC_SIZE);\n\n\t/* copy item headers (keys) */\n\tmemcpy(ih, inserted, KEY_SIZE);\n\tif (count > 1)\n\t\tmemcpy(ih + 1, inserted + 1, KEY_SIZE);\n\n\t/* sizes, item number */\n\tset_blkh_nr_item(blkh, blkh_nr_item(blkh) + count);\n\tset_blkh_free_space(blkh,\n\t\t\t    blkh_free_space(blkh) - count * (DC_SIZE +\n\t\t\t\t\t\t\t     KEY_SIZE));\n\n\tdo_balance_mark_internal_dirty(cur_bi->tb, cur, 0);\n\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\tcheck_internal(cur);\n\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\n\tif (cur_bi->bi_parent) {\n\t\tstruct disk_child *t_dc =\n\t\t    B_N_CHILD(cur_bi->bi_parent, cur_bi->bi_position);\n\t\tput_dc_size(t_dc,\n\t\t\t    dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)));\n\t\tdo_balance_mark_internal_dirty(cur_bi->tb, cur_bi->bi_parent,\n\t\t\t\t\t       0);\n\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t\tcheck_internal(cur_bi->bi_parent);\n\t\t/*&&&&&&&&&&&&&&&&&&&&&&&& */\n\t}\n\n}"
  },
  {
    "function_name": "internal_define_dest_src_infos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/ibalance.c",
    "lines": "27-119",
    "snippet": "static void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}",
    "includes": [
      "#include <linux/buffer_head.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define INTERNAL_INSERT_TO_R 6",
      "#define INTERNAL_INSERT_TO_L 5",
      "#define INTERNAL_INSERT_TO_S 4",
      "#define INTERNAL_SHIFT_FROM_S_TO_R 3",
      "#define INTERNAL_SHIFT_FROM_L_TO_S 2",
      "#define INTERNAL_SHIFT_FROM_R_TO_S 1",
      "#define INTERNAL_SHIFT_FROM_S_TO_L 0"
    ],
    "globals_used": [
      "int balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "tb->tb_sb",
            "\"ibalance-1\"",
            "\"shift type is unknown (%d)\"",
            "shift_mode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_right_neighbor_position",
          "args": [
            "tb",
            "h"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "get_right_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1604-1616",
          "snippet": "int get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_right_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FR[h] == NULL,\n\t       \"vs-12330: F[%d](%p) or FR[%d](%p) does not exist\",\n\t       h, PATH_H_PPARENT(tb->tb_path, h), h, tb->FR[h]);\n\n\tif (Sh_position == B_NR_ITEMS(PATH_H_PPARENT(tb->tb_path, h)))\n\t\treturn 0;\n\telse\n\t\treturn Sh_position + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_left_neighbor_position",
          "args": [
            "tb",
            "h"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "get_left_neighbor_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/do_balan.c",
          "lines": "1590-1602",
          "snippet": "int get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/uaccess.h>\n\nint get_left_neighbor_position(struct tree_balance *tb, int h)\n{\n\tint Sh_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\n\tRFALSE(PATH_H_PPARENT(tb->tb_path, h) == NULL || tb->FL[h] == NULL,\n\t       \"vs-12325: FL[%d](%p) or F[%d](%p) does not exist\",\n\t       h, tb->FL[h], h, PATH_H_PPARENT(tb->tb_path, h));\n\n\tif (Sh_position == 0)\n\t\treturn B_NR_ITEMS(tb->FL[h]);\n\telse\n\t\treturn Sh_position - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_POSITION",
          "args": [
            "tb->tb_path",
            "h + 1"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PPARENT",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PATH_H_PBUFFER",
          "args": [
            "tb->tb_path",
            "h"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "src_bi",
            "0",
            "sizeof(struct buffer_info)"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest_bi",
            "0",
            "sizeof(struct buffer_info)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#define INTERNAL_INSERT_TO_R 6\n#define INTERNAL_INSERT_TO_L 5\n#define INTERNAL_INSERT_TO_S 4\n#define INTERNAL_SHIFT_FROM_S_TO_R 3\n#define INTERNAL_SHIFT_FROM_L_TO_S 2\n#define INTERNAL_SHIFT_FROM_R_TO_S 1\n#define INTERNAL_SHIFT_FROM_S_TO_L 0\n\nint balance_internal(struct tree_balance *,\n\t\t     int, int, struct item_head *, struct buffer_head **);\n\nstatic void internal_define_dest_src_infos(int shift_mode,\n\t\t\t\t\t   struct tree_balance *tb,\n\t\t\t\t\t   int h,\n\t\t\t\t\t   struct buffer_info *dest_bi,\n\t\t\t\t\t   struct buffer_info *src_bi,\n\t\t\t\t\t   int *d_key, struct buffer_head **cf)\n{\n\tmemset(dest_bi, 0, sizeof(struct buffer_info));\n\tmemset(src_bi, 0, sizeof(struct buffer_info));\n\t/* define dest, src, dest parent, dest position */\n\tswitch (shift_mode) {\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_S_TO_L:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\tcase INTERNAL_SHIFT_FROM_L_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->L[h];\n\t\tsrc_bi->bi_parent = tb->FL[h];\n\t\tsrc_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\t/* dest position is analog of dest->b_item_order */\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->lkey[h];\n\t\t*cf = tb->CFL[h];\n\t\tbreak;\n\n\t/* used in internal_shift_left */\n\tcase INTERNAL_SHIFT_FROM_R_TO_S:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = tb->R[h];\n\t\tsrc_bi->bi_parent = tb->FR[h];\n\t\tsrc_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_SHIFT_FROM_S_TO_R:\n\t\tsrc_bi->tb = tb;\n\t\tsrc_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tsrc_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tsrc_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\t*d_key = tb->rkey[h];\n\t\t*cf = tb->CFR[h];\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_L:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->L[h];\n\t\tdest_bi->bi_parent = tb->FL[h];\n\t\tdest_bi->bi_position = get_left_neighbor_position(tb, h);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_S:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = PATH_H_PBUFFER(tb->tb_path, h);\n\t\tdest_bi->bi_parent = PATH_H_PPARENT(tb->tb_path, h);\n\t\tdest_bi->bi_position = PATH_H_POSITION(tb->tb_path, h + 1);\n\t\tbreak;\n\n\tcase INTERNAL_INSERT_TO_R:\n\t\tdest_bi->tb = tb;\n\t\tdest_bi->bi_bh = tb->R[h];\n\t\tdest_bi->bi_parent = tb->FR[h];\n\t\tdest_bi->bi_position = get_right_neighbor_position(tb, h);\n\t\tbreak;\n\n\tdefault:\n\t\treiserfs_panic(tb->tb_sb, \"ibalance-1\",\n\t\t\t       \"shift type is unknown (%d)\",\n\t\t\t       shift_mode);\n\t}\n}"
  }
]