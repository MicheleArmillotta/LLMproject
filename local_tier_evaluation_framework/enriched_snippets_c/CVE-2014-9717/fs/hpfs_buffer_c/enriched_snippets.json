[
  {
    "function_name": "hpfs_mark_4buffers_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "192-204",
    "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "qbh->bh[3]"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qbh->bh[3]->b_data",
            "qbh->data + 3 * 512",
            "512"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qbh->bh[2]->b_data",
            "qbh->data + 2 * 512",
            "512"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qbh->bh[1]->b_data",
            "qbh->data + 1 * 512",
            "512"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "qbh->bh[0]->b_data",
            "qbh->data + 0 * 512",
            "512"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "qbh->data != qbh->bh[0]->b_data"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
  },
  {
    "function_name": "hpfs_brelse4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "182-190",
    "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "qbh->bh[3]"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qbh->data"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "qbh->data != qbh->bh[0]->b_data"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
  },
  {
    "function_name": "hpfs_get_4sectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "140-179",
    "snippet": "void *hpfs_get_4sectors(struct super_block *s, unsigned secno,\n                          struct quad_buffer_head *qbh)\n{\n\tcond_resched();\n\n\thpfs_lock_assert(s);\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!hpfs_get_sector(s, secno + 0, &qbh->bh[0])) goto bail0;\n\tif (!hpfs_get_sector(s, secno + 1, &qbh->bh[1])) goto bail1;\n\tif (!hpfs_get_sector(s, secno + 2, &qbh->bh[2])) goto bail2;\n\tif (!hpfs_get_sector(s, secno + 3, &qbh->bh[3])) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tif (!(qbh->data = kmalloc(2048, GFP_NOFS))) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\treturn qbh->data;\n\nbail4:\n\tbrelse(qbh->bh[3]);\nbail3:\n\tbrelse(qbh->bh[2]);\nbail2:\n\tbrelse(qbh->bh[1]);\nbail1:\n\tbrelse(qbh->bh[0]);\nbail0:\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "qbh->bh[0]"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): out of memory\\n\"",
            "__func__"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2048",
            "GFP_NOFS"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_get_sector",
          "args": [
            "s",
            "secno + 3",
            "&qbh->bh[3]"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_sector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "65-82",
          "snippet": "void *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): unaligned read\\n\"",
            "__func__"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock_assert",
          "args": [
            "s"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_4sectors(struct super_block *s, unsigned secno,\n                          struct quad_buffer_head *qbh)\n{\n\tcond_resched();\n\n\thpfs_lock_assert(s);\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!hpfs_get_sector(s, secno + 0, &qbh->bh[0])) goto bail0;\n\tif (!hpfs_get_sector(s, secno + 1, &qbh->bh[1])) goto bail1;\n\tif (!hpfs_get_sector(s, secno + 2, &qbh->bh[2])) goto bail2;\n\tif (!hpfs_get_sector(s, secno + 3, &qbh->bh[3])) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tif (!(qbh->data = kmalloc(2048, GFP_NOFS))) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\treturn qbh->data;\n\nbail4:\n\tbrelse(qbh->bh[3]);\nbail3:\n\tbrelse(qbh->bh[2]);\nbail2:\n\tbrelse(qbh->bh[1]);\nbail1:\n\tbrelse(qbh->bh[0]);\nbail0:\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_map_4sectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "86-136",
    "snippet": "void *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "qbh->bh[0]"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 3 * 512",
            "qbh->bh[3]->b_data",
            "512"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 2 * 512",
            "qbh->bh[2]->b_data",
            "512"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 1 * 512",
            "qbh->bh[1]->b_data",
            "512"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + 0 * 512",
            "qbh->bh[0]->b_data",
            "512"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): out of memory\\n\"",
            "__func__"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2048",
            "GFP_NOFS"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "secno + 3"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "secno + 2"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "secno + 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "secno + 0"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_prefetch_sectors",
          "args": [
            "s",
            "secno",
            "4 + ahead"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_prefetch_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "13-39",
          "snippet": "void hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): unaligned read\\n\"",
            "__func__"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock_assert",
          "args": [
            "s"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_4sectors(struct super_block *s, unsigned secno, struct quad_buffer_head *qbh,\n\t\t   int ahead)\n{\n\tchar *data;\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif (secno & 3) {\n\t\tpr_err(\"%s(): unaligned read\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\thpfs_prefetch_sectors(s, secno, 4 + ahead);\n\n\tif (!(qbh->bh[0] = sb_bread(s, secno + 0))) goto bail0;\n\tif (!(qbh->bh[1] = sb_bread(s, secno + 1))) goto bail1;\n\tif (!(qbh->bh[2] = sb_bread(s, secno + 2))) goto bail2;\n\tif (!(qbh->bh[3] = sb_bread(s, secno + 3))) goto bail3;\n\n\tif (likely(qbh->bh[1]->b_data == qbh->bh[0]->b_data + 1 * 512) &&\n\t    likely(qbh->bh[2]->b_data == qbh->bh[0]->b_data + 2 * 512) &&\n\t    likely(qbh->bh[3]->b_data == qbh->bh[0]->b_data + 3 * 512)) {\n\t\treturn qbh->data = qbh->bh[0]->b_data;\n\t}\n\n\tqbh->data = data = kmalloc(2048, GFP_NOFS);\n\tif (!data) {\n\t\tpr_err(\"%s(): out of memory\\n\", __func__);\n\t\tgoto bail4;\n\t}\n\n\tmemcpy(data + 0 * 512, qbh->bh[0]->b_data, 512);\n\tmemcpy(data + 1 * 512, qbh->bh[1]->b_data, 512);\n\tmemcpy(data + 2 * 512, qbh->bh[2]->b_data, 512);\n\tmemcpy(data + 3 * 512, qbh->bh[3]->b_data, 512);\n\n\treturn data;\n\n bail4:\n\tbrelse(qbh->bh[3]);\n bail3:\n\tbrelse(qbh->bh[2]);\n bail2:\n\tbrelse(qbh->bh[1]);\n bail1:\n\tbrelse(qbh->bh[0]);\n bail0:\n\treturn NULL;\n}"
  },
  {
    "function_name": "hpfs_get_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "65-82",
    "snippet": "void *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): getblk failed\\n\"",
            "__func__"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "s",
            "secno"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock_assert",
          "args": [
            "s"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_get_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp)\n{\n\tstruct buffer_head *bh;\n\t/*return hpfs_map_sector(s, secno, bhp, 0);*/\n\n\thpfs_lock_assert(s);\n\n\tcond_resched();\n\n\tif ((*bhp = bh = sb_getblk(s, secno)) != NULL) {\n\t\tif (!buffer_uptodate(bh)) wait_on_buffer(bh);\n\t\tset_buffer_uptodate(bh);\n\t\treturn bh->b_data;\n\t} else {\n\t\tpr_err(\"%s(): getblk failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "hpfs_map_sector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "43-61",
    "snippet": "void *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(): read error\\n\"",
            "__func__"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "secno"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_prefetch_sectors",
          "args": [
            "s",
            "secno",
            "ahead"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_prefetch_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "13-39",
          "snippet": "void hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock_assert",
          "args": [
            "s"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid *hpfs_map_sector(struct super_block *s, unsigned secno, struct buffer_head **bhp,\n\t\t int ahead)\n{\n\tstruct buffer_head *bh;\n\n\thpfs_lock_assert(s);\n\n\thpfs_prefetch_sectors(s, secno, ahead);\n\n\tcond_resched();\n\n\t*bhp = bh = sb_bread(s, secno);\n\tif (bh != NULL)\n\t\treturn bh->b_data;\n\telse {\n\t\tpr_err(\"%s(): read error\\n\", __func__);\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "hpfs_prefetch_sectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
    "lines": "13-39",
    "snippet": "void hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_breadahead",
          "args": [
            "s",
            "secno"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "secno >= hpfs_sb(s)->sb_fs_size"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "s"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "s",
            "secno"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "secno >= hpfs_sb(s)->sb_fs_size"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_prefetch_sectors(struct super_block *s, unsigned secno, int n)\n{\n\tstruct buffer_head *bh;\n\tstruct blk_plug plug;\n\n\tif (n <= 0 || unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\treturn;\n\n\tbh = sb_find_get_block(s, secno);\n\tif (bh) {\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tbrelse(bh);\n\t};\n\n\tblk_start_plug(&plug);\n\twhile (n > 0) {\n\t\tif (unlikely(secno >= hpfs_sb(s)->sb_fs_size))\n\t\t\tbreak;\n\t\tsb_breadahead(s, secno);\n\t\tsecno++;\n\t\tn--;\n\t}\n\tblk_finish_plug(&plug);\n}"
  }
]