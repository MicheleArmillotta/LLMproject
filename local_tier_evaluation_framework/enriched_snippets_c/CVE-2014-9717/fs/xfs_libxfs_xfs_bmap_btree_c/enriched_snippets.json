[
  {
    "function_name": "xfs_bmbt_change_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "858-883",
    "snippet": "int\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_change_owner",
          "args": [
            "cur",
            "new_owner",
            "buffer_list"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "4024-4067",
          "snippet": "int\nxfs_btree_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tunion xfs_btree_ptr     lptr;\n\tint\t\t\tlevel;\n\tstruct xfs_btree_block\t*block = NULL;\n\tint\t\t\terror = 0;\n\n\tcur->bc_ops->init_ptr_from_cur(cur, &lptr);\n\n\t/* for each level */\n\tfor (level = cur->bc_nlevels - 1; level >= 0; level--) {\n\t\t/* grab the left hand block */\n\t\terror = xfs_btree_lookup_get_block(cur, level, &lptr, &block);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* readahead the left most block for the next level down */\n\t\tif (level > 0) {\n\t\t\tunion xfs_btree_ptr     *ptr;\n\n\t\t\tptr = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\txfs_btree_readahead_ptr(cur, ptr, 1);\n\n\t\t\t/* save for the next iteration of the loop */\n\t\t\tlptr = *ptr;\n\t\t}\n\n\t\t/* for each buffer in the level */\n\t\tdo {\n\t\t\terror = xfs_btree_block_change_owner(cur, level,\n\t\t\t\t\t\t\t     new_owner,\n\t\t\t\t\t\t\t     buffer_list);\n\t\t} while (!error);\n\n\t\tif (error != -ENOENT)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_change_owner(\n\tstruct xfs_btree_cur\t*cur,\n\t__uint64_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tunion xfs_btree_ptr     lptr;\n\tint\t\t\tlevel;\n\tstruct xfs_btree_block\t*block = NULL;\n\tint\t\t\terror = 0;\n\n\tcur->bc_ops->init_ptr_from_cur(cur, &lptr);\n\n\t/* for each level */\n\tfor (level = cur->bc_nlevels - 1; level >= 0; level--) {\n\t\t/* grab the left hand block */\n\t\terror = xfs_btree_lookup_get_block(cur, level, &lptr, &block);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/* readahead the left most block for the next level down */\n\t\tif (level > 0) {\n\t\t\tunion xfs_btree_ptr     *ptr;\n\n\t\t\tptr = xfs_btree_ptr_addr(cur, 1, block);\n\t\t\txfs_btree_readahead_ptr(cur, ptr, 1);\n\n\t\t\t/* save for the next iteration of the loop */\n\t\t\tlptr = *ptr;\n\t\t}\n\n\t\t/* for each buffer in the level */\n\t\tdo {\n\t\t\terror = xfs_btree_block_change_owner(cur, level,\n\t\t\t\t\t\t\t     new_owner,\n\t\t\t\t\t\t\t     buffer_list);\n\t\t} while (!error);\n\n\t\tif (error != -ENOENT)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "ip->i_mount",
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_format == XFS_DINODE_FMT_BTREE"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(tp && buffer_list)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp || buffer_list"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmdr_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "829-839",
    "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
  },
  {
    "function_name": "xfs_bmbt_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "813-824",
    "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BMBT_BLOCK_LEN",
          "args": [
            "mp"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
  },
  {
    "function_name": "xfs_bmbt_init_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "776-808",
    "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_SIZE",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ifp->if_broot->bb_level"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_btree_cur_zone",
            "KM_SLEEP"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
  },
  {
    "function_name": "xfs_bmbt_recs_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "738-747",
    "snippet": "STATIC int\nxfs_bmbt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\treturn xfs_bmbt_disk_get_startoff(&r1->bmbt) +\n\t\txfs_bmbt_disk_get_blockcount(&r1->bmbt) <=\n\t\txfs_bmbt_disk_get_startoff(&r2->bmbt);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_startoff",
          "args": [
            "&r2->bmbt"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "187-193",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_blockcount",
          "args": [
            "&r1->bmbt"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "177-182",
          "snippet": "xfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_recs_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*r1,\n\tunion xfs_btree_rec\t*r2)\n{\n\treturn xfs_bmbt_disk_get_startoff(&r1->bmbt) +\n\t\txfs_bmbt_disk_get_blockcount(&r1->bmbt) <=\n\t\txfs_bmbt_disk_get_startoff(&r2->bmbt);\n}"
  },
  {
    "function_name": "xfs_bmbt_keys_inorder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "728-736",
    "snippet": "STATIC int\nxfs_bmbt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\treturn be64_to_cpu(k1->bmbt.br_startoff) <\n\t\tbe64_to_cpu(k2->bmbt.br_startoff);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "k2->bmbt.br_startoff"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "k1->bmbt.br_startoff"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_keys_inorder(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*k1,\n\tunion xfs_btree_key\t*k2)\n{\n\treturn be64_to_cpu(k1->bmbt.br_startoff) <\n\t\tbe64_to_cpu(k2->bmbt.br_startoff);\n}"
  },
  {
    "function_name": "xfs_bmbt_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "708-719",
    "snippet": "static void\nxfs_bmbt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_bmbt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_lblock_calc_crc(bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lblock_calc_crc",
          "args": [
            "bp"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lblock_calc_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "226-238",
          "snippet": "void\nxfs_btree_lblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.l.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_lblock_calc_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn;\n\tif (bip)\n\t\tblock->bb_u.l.bb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\txfs_buf_update_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_verify",
          "args": [
            "bp"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "638-691",
          "snippet": "static bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_bmbt_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_bmbt_verify(bp)) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\txfs_btree_lblock_calc_crc(bp);\n}"
  },
  {
    "function_name": "xfs_bmbt_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "693-706",
    "snippet": "static void\nxfs_bmbt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_lblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_bmbt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_btree_corrupt",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_verify",
          "args": [
            "bp"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "638-691",
          "snippet": "static bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_lblock_verify_crc",
          "args": [
            "bp"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lblock_verify_crc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "240-248",
          "snippet": "bool\nxfs_btree_lblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nbool\nxfs_btree_lblock_verify_crc(\n\tstruct xfs_buf\t\t*bp)\n{\n\tif (xfs_sb_version_hascrc(&bp->b_target->bt_mount->m_sb))\n\t\treturn xfs_buf_verify_cksum(bp, XFS_BTREE_LBLOCK_CRC_OFF);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic void\nxfs_bmbt_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tif (!xfs_btree_lblock_verify_crc(bp))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_bmbt_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error) {\n\t\ttrace_xfs_btree_corrupt(bp, _RET_IP_);\n\t\txfs_verifier_error(bp);\n\t}\n}"
  },
  {
    "function_name": "xfs_bmbt_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "638-691",
    "snippet": "static bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "be64_to_cpu(block->bb_u.l.bb_rightsib)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "be64_to_cpu(block->bb_u.l.bb_leftsib)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_leftsib"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "mp->m_bm_maxlevels[0]",
            "mp->m_bm_maxlevels[1]"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "829-839",
          "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_MAGIC"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_owner"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_blkno"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&block->bb_u.l.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_CRC_MAGIC"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nstatic bool\nxfs_bmbt_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_btree_block\t*block = XFS_BUF_TO_BLOCK(bp);\n\tunsigned int\t\tlevel;\n\n\tswitch (block->bb_magic) {\n\tcase cpu_to_be32(XFS_BMAP_CRC_MAGIC):\n\t\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(block->bb_u.l.bb_blkno) != bp->b_bn)\n\t\t\treturn false;\n\t\t/*\n\t\t * XXX: need a better way of verifying the owner here. Right now\n\t\t * just make sure there has been one set.\n\t\t */\n\t\tif (be64_to_cpu(block->bb_u.l.bb_owner) == 0)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase cpu_to_be32(XFS_BMAP_MAGIC):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t/*\n\t * numrecs and level verification.\n\t *\n\t * We don't know what fork we belong to, so just verify that the level\n\t * is less than the maximum of the two. Later checks will be more\n\t * precise.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tif (level > max(mp->m_bm_maxlevels[0], mp->m_bm_maxlevels[1]))\n\t\treturn false;\n\tif (be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn false;\n\n\t/* sibling pointer verification */\n\tif (!block->bb_u.l.bb_leftsib ||\n\t    (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_leftsib))))\n\t\treturn false;\n\tif (!block->bb_u.l.bb_rightsib ||\n\t    (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&\n\t     !XFS_FSB_SANITY_CHECK(mp, be64_to_cpu(block->bb_u.l.bb_rightsib))))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_bmbt_key_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "629-636",
    "snippet": "STATIC __int64_t\nxfs_bmbt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\treturn (__int64_t)be64_to_cpu(key->bmbt.br_startoff) -\n\t\t\t\t      cur->bc_rec.b.br_startoff;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "key->bmbt.br_startoff"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC __int64_t\nxfs_bmbt_key_diff(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_key\t*key)\n{\n\treturn (__int64_t)be64_to_cpu(key->bmbt.br_startoff) -\n\t\t\t\t      cur->bc_rec.b.br_startoff;\n}"
  },
  {
    "function_name": "xfs_bmbt_init_ptr_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "621-627",
    "snippet": "STATIC void\nxfs_bmbt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tptr->l = 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_bmbt_init_ptr_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*ptr)\n{\n\tptr->l = 0;\n}"
  },
  {
    "function_name": "xfs_bmbt_init_rec_from_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "613-619",
    "snippet": "STATIC void\nxfs_bmbt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\txfs_bmbt_disk_set_all(&rec->bmbt, &cur->bc_rec.b);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_set_all",
          "args": [
            "&rec->bmbt",
            "&cur->bc_rec.b"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "267-274",
          "snippet": "STATIC void\nxfs_bmbt_disk_set_all(\n\txfs_bmbt_rec_t\t*r,\n\txfs_bmbt_irec_t *s)\n{\n\txfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t\t  s->br_blockcount, s->br_state);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmbt_disk_set_all(\n\txfs_bmbt_rec_t\t*r,\n\txfs_bmbt_irec_t *s)\n{\n\txfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t\t  s->br_blockcount, s->br_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_bmbt_init_rec_from_cur(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\txfs_bmbt_disk_set_all(&rec->bmbt, &cur->bc_rec.b);\n}"
  },
  {
    "function_name": "xfs_bmbt_init_rec_from_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "602-611",
    "snippet": "STATIC void\nxfs_bmbt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(key->bmbt.br_startoff != 0);\n\n\txfs_bmbt_disk_set_allf(&rec->bmbt, be64_to_cpu(key->bmbt.br_startoff),\n\t\t\t       0, 0, XFS_EXT_NORM);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_set_allf",
          "args": [
            "&rec->bmbt",
            "be64_to_cpu(key->bmbt.br_startoff)",
            "0",
            "0",
            "XFS_EXT_NORM"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "239-262",
          "snippet": "void\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "key->bmbt.br_startoff"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key->bmbt.br_startoff != 0"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmbt_init_rec_from_key(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tASSERT(key->bmbt.br_startoff != 0);\n\n\txfs_bmbt_disk_set_allf(&rec->bmbt, be64_to_cpu(key->bmbt.br_startoff),\n\t\t\t       0, 0, XFS_EXT_NORM);\n}"
  },
  {
    "function_name": "xfs_bmbt_init_key_from_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "593-600",
    "snippet": "STATIC void\nxfs_bmbt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tkey->bmbt.br_startoff =\n\t\tcpu_to_be64(xfs_bmbt_disk_get_startoff(&rec->bmbt));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "xfs_bmbt_disk_get_startoff(&rec->bmbt)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_startoff",
          "args": [
            "&rec->bmbt"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "187-193",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmbt_init_key_from_rec(\n\tunion xfs_btree_key\t*key,\n\tunion xfs_btree_rec\t*rec)\n{\n\tkey->bmbt.br_startoff =\n\t\tcpu_to_be64(xfs_bmbt_disk_get_startoff(&rec->bmbt));\n}"
  },
  {
    "function_name": "xfs_bmbt_get_dmaxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "583-591",
    "snippet": "STATIC int\nxfs_bmbt_get_dmaxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level != cur->bc_nlevels - 1)\n\t\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\treturn xfs_bmdr_maxrecs(cur->bc_private.b.forksize, level == 0);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmdr_maxrecs",
          "args": [
            "cur->bc_private.b.forksize",
            "level == 0"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "829-839",
          "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_get_dmaxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level != cur->bc_nlevels - 1)\n\t\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\treturn xfs_bmdr_maxrecs(cur->bc_private.b.forksize, level == 0);\n}"
  },
  {
    "function_name": "xfs_bmbt_get_maxrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "555-572",
    "snippet": "int\nxfs_bmbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0);\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_maxrecs",
          "args": [
            "cur->bc_mp",
            "ifp->if_broot_bytes",
            "level == 0"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "813-824",
          "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "cur->bc_private.b.ip",
            "cur->bc_private.b.whichfork"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0);\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\n}"
  },
  {
    "function_name": "xfs_bmbt_get_minrecs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "537-553",
    "snippet": "STATIC int\nxfs_bmbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0) / 2;\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmnr[level != 0];\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_maxrecs",
          "args": [
            "cur->bc_mp",
            "ifp->if_broot_bytes",
            "level == 0"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "813-824",
          "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "cur->bc_private.b.ip",
            "cur->bc_private.b.whichfork"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_get_minrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0) / 2;\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmnr[level != 0];\n}"
  },
  {
    "function_name": "xfs_bmbt_free_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "518-535",
    "snippet": "STATIC int\nxfs_bmbt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_trans\t*tp = cur->bc_tp;\n\txfs_fsblock_t\t\tfsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));\n\n\txfs_bmap_add_free(fsbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "bp"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "XFS_TRANS_DQ_BCOUNT",
            "-1L"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_free",
          "args": [
            "fsbno",
            "1",
            "cur->bc_private.b.flist",
            "mp"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "594-635",
          "snippet": "void\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DADDR_TO_FSB",
          "args": [
            "mp",
            "XFS_BUF_ADDR(bp)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bp"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_free_block(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = cur->bc_mp;\n\tstruct xfs_inode\t*ip = cur->bc_private.b.ip;\n\tstruct xfs_trans\t*tp = cur->bc_tp;\n\txfs_fsblock_t\t\tfsbno = XFS_DADDR_TO_FSB(mp, XFS_BUF_ADDR(bp));\n\n\txfs_bmap_add_free(fsbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmbt_alloc_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "433-516",
    "snippet": "STATIC int\nxfs_bmbt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\txfs_alloc_arg_t\t\targs;\t\t/* block allocation args */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = cur->bc_tp;\n\targs.mp = cur->bc_mp;\n\targs.fsbno = cur->bc_private.b.firstblock;\n\targs.firstblock = args.fsbno;\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\targs.fsbno = be64_to_cpu(start->l);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\t/*\n\t\t * Make sure there is sufficient room left in the AG to\n\t\t * complete a full tree split for an extent insert.  If\n\t\t * we are converting the middle part of an extent then\n\t\t * we may need space for two tree splits.\n\t\t *\n\t\t * We are relying on the caller to make the correct block\n\t\t * reservation for this operation to succeed.  If the\n\t\t * reservation amount is insufficient then we may fail a\n\t\t * block allocation here and corrupt the filesystem.\n\t\t */\n\t\targs.minleft = xfs_trans_get_block_res(args.tp);\n\t} else if (cur->bc_private.b.flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL;\n\tif (!args.wasdel && xfs_trans_get_block_res(args.tp) == 0) {\n\t\terror = -ENOSPC;\n\t\tgoto error0;\n\t}\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto error0;\n\n\tif (args.fsbno == NULLFSBLOCK && args.minleft) {\n\t\t/*\n\t\t * Could not find an AG with enough free space to satisfy\n\t\t * a full btree split.  Try again without minleft and if\n\t\t * successful activate the lowspace algorithm.\n\t\t */\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.minleft = 0;\n\t\terror = xfs_alloc_vextent(&args);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tcur->bc_private.b.flist->xbf_low = 1;\n\t}\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == 1);\n\tcur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tcur->bc_private.b.ip->i_d.di_nblocks++;\n\txfs_trans_log_inode(args.tp, cur->bc_private.b.ip, XFS_ILOG_CORE);\n\txfs_trans_mod_dquot_byino(args.tp, cur->bc_private.b.ip,\n\t\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\n\tnew->l = cpu_to_be64(args.fsbno);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\n error0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_ERROR"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args.fsbno"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "args.tp",
            "cur->bc_private.b.ip",
            "XFS_TRANS_DQ_BCOUNT",
            "1L"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "args.tp",
            "cur->bc_private.b.ip",
            "XFS_ILOG_CORE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.len == 1"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BTREE_TRACE_CURSOR",
          "args": [
            "cur",
            "XBT_EXIT"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_block_res",
          "args": [
            "args.tp"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_block_res",
          "args": [
            "args.tp"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "start->l"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC int\nxfs_bmbt_alloc_block(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_ptr\t*start,\n\tunion xfs_btree_ptr\t*new,\n\tint\t\t\t*stat)\n{\n\txfs_alloc_arg_t\t\targs;\t\t/* block allocation args */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = cur->bc_tp;\n\targs.mp = cur->bc_mp;\n\targs.fsbno = cur->bc_private.b.firstblock;\n\targs.firstblock = args.fsbno;\n\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\targs.fsbno = be64_to_cpu(start->l);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\t/*\n\t\t * Make sure there is sufficient room left in the AG to\n\t\t * complete a full tree split for an extent insert.  If\n\t\t * we are converting the middle part of an extent then\n\t\t * we may need space for two tree splits.\n\t\t *\n\t\t * We are relying on the caller to make the correct block\n\t\t * reservation for this operation to succeed.  If the\n\t\t * reservation amount is insufficient then we may fail a\n\t\t * block allocation here and corrupt the filesystem.\n\t\t */\n\t\targs.minleft = xfs_trans_get_block_res(args.tp);\n\t} else if (cur->bc_private.b.flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL;\n\tif (!args.wasdel && xfs_trans_get_block_res(args.tp) == 0) {\n\t\terror = -ENOSPC;\n\t\tgoto error0;\n\t}\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto error0;\n\n\tif (args.fsbno == NULLFSBLOCK && args.minleft) {\n\t\t/*\n\t\t * Could not find an AG with enough free space to satisfy\n\t\t * a full btree split.  Try again without minleft and if\n\t\t * successful activate the lowspace algorithm.\n\t\t */\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.minleft = 0;\n\t\terror = xfs_alloc_vextent(&args);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tcur->bc_private.b.flist->xbf_low = 1;\n\t}\n\tif (args.fsbno == NULLFSBLOCK) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t*stat = 0;\n\t\treturn 0;\n\t}\n\tASSERT(args.len == 1);\n\tcur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tcur->bc_private.b.ip->i_d.di_nblocks++;\n\txfs_trans_log_inode(args.tp, cur->bc_private.b.ip, XFS_ILOG_CORE);\n\txfs_trans_mod_dquot_byino(args.tp, cur->bc_private.b.ip,\n\t\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\n\tnew->l = cpu_to_be64(args.fsbno);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\n error0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmbt_update_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "418-431",
    "snippet": "STATIC void\nxfs_bmbt_update_cursor(\n\tstruct xfs_btree_cur\t*src,\n\tstruct xfs_btree_cur\t*dst)\n{\n\tASSERT((dst->bc_private.b.firstblock != NULLFSBLOCK) ||\n\t       (dst->bc_private.b.ip->i_d.di_flags & XFS_DIFLAG_REALTIME));\n\tASSERT(dst->bc_private.b.flist == src->bc_private.b.flist);\n\n\tdst->bc_private.b.allocated += src->bc_private.b.allocated;\n\tdst->bc_private.b.firstblock = src->bc_private.b.firstblock;\n\n\tsrc->bc_private.b.allocated = 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dst->bc_private.b.flist == src->bc_private.b.flist"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(dst->bc_private.b.firstblock != NULLFSBLOCK) ||\n\t       (dst->bc_private.b.ip->i_d.di_flags & XFS_DIFLAG_REALTIME)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nSTATIC void\nxfs_bmbt_update_cursor(\n\tstruct xfs_btree_cur\t*src,\n\tstruct xfs_btree_cur\t*dst)\n{\n\tASSERT((dst->bc_private.b.firstblock != NULLFSBLOCK) ||\n\t       (dst->bc_private.b.ip->i_d.di_flags & XFS_DIFLAG_REALTIME));\n\tASSERT(dst->bc_private.b.flist == src->bc_private.b.flist);\n\n\tdst->bc_private.b.allocated += src->bc_private.b.allocated;\n\tdst->bc_private.b.firstblock = src->bc_private.b.firstblock;\n\n\tsrc->bc_private.b.allocated = 0;\n}"
  },
  {
    "function_name": "xfs_bmbt_dup_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "398-416",
    "snippet": "xfs_btree_cur *\nxfs_bmbt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tstruct xfs_btree_cur\t*new;\n\n\tnew = xfs_bmbt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.b.ip, cur->bc_private.b.whichfork);\n\n\t/*\n\t * Copy the firstblock, flist, and flags values,\n\t * since init cursor doesn't get them.\n\t */\n\tnew->bc_private.b.firstblock = cur->bc_private.b.firstblock;\n\tnew->bc_private.b.flist = cur->bc_private.b.flist;\n\tnew->bc_private.b.flags = cur->bc_private.b.flags;\n\n\treturn new;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "cur->bc_mp",
            "cur->bc_tp",
            "cur->bc_private.b.ip",
            "cur->bc_private.b.whichfork"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_btree_cur *\nxfs_bmbt_dup_cursor(\n\tstruct xfs_btree_cur\t*cur)\n{\n\tstruct xfs_btree_cur\t*new;\n\n\tnew = xfs_bmbt_init_cursor(cur->bc_mp, cur->bc_tp,\n\t\t\tcur->bc_private.b.ip, cur->bc_private.b.whichfork);\n\n\t/*\n\t * Copy the firstblock, flist, and flags values,\n\t * since init cursor doesn't get them.\n\t */\n\tnew->bc_private.b.firstblock = cur->bc_private.b.firstblock;\n\tnew->bc_private.b.flist = cur->bc_private.b.flist;\n\tnew->bc_private.b.flags = cur->bc_private.b.flags;\n\n\treturn new;\n}"
  },
  {
    "function_name": "xfs_check_nostate_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "380-395",
    "snippet": "int\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "idx"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmbt_to_bmdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "336-370",
    "snippet": "void\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tpp",
            "fpp",
            "sizeof(*fpp) * dmxr"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tkp",
            "fkp",
            "sizeof(*fkp) * dmxr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dblock->bb_numrecs"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_PTR_ADDR",
          "args": [
            "dblock",
            "1",
            "dmxr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "rblock",
            "1",
            "rblocklen"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_KEY_ADDR",
          "args": [
            "dblock",
            "1"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_KEY_ADDR",
          "args": [
            "mp",
            "rblock",
            "1"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmdr_maxrecs",
          "args": [
            "dblocklen",
            "0"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "829-839",
          "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_level != 0"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSBLOCK"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_MAGIC"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "XFS_BUF_DADDR_NULL"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&rblock->bb_u.l.bb_uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_CRC_MAGIC"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_bmbt_to_bmdr(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen)\n{\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_CRC_MAGIC));\n\t\tASSERT(uuid_equal(&rblock->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid));\n\t\tASSERT(rblock->bb_u.l.bb_blkno ==\n\t\t       cpu_to_be64(XFS_BUF_DADDR_NULL));\n\t} else\n\t\tASSERT(rblock->bb_magic == cpu_to_be32(XFS_BMAP_MAGIC));\n\tASSERT(rblock->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK));\n\tASSERT(rblock->bb_level != 0);\n\tdblock->bb_level = rblock->bb_level;\n\tdblock->bb_numrecs = rblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\ttkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\tfpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\ttpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}"
  },
  {
    "function_name": "xfs_bmbt_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "321-331",
    "snippet": "void\nxfs_bmbt_set_state(\n\txfs_bmbt_rec_host_t *r,\n\txfs_exntst_t\tv)\n{\n\tASSERT(v == XFS_EXT_NORM || v == XFS_EXT_UNWRITTEN);\n\tif (v == XFS_EXT_NORM)\n\t\tr->l0 &= xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN);\n\telse\n\t\tr->l0 |= xfs_mask64hi(BMBT_EXNTFLAG_BITLEN);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "BMBT_EXNTFLAG_BITLEN"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "64 - BMBT_EXNTFLAG_BITLEN"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "v == XFS_EXT_NORM || v == XFS_EXT_UNWRITTEN"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_state(\n\txfs_bmbt_rec_host_t *r,\n\txfs_exntst_t\tv)\n{\n\tASSERT(v == XFS_EXT_NORM || v == XFS_EXT_UNWRITTEN);\n\tif (v == XFS_EXT_NORM)\n\t\tr->l0 &= xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN);\n\telse\n\t\tr->l0 |= xfs_mask64hi(BMBT_EXNTFLAG_BITLEN);\n}"
  },
  {
    "function_name": "xfs_bmbt_set_startoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "307-316",
    "snippet": "void\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "9"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "1"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(v & xfs_mask64hi(9)) == 0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}"
  },
  {
    "function_name": "xfs_bmbt_set_startblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "292-302",
    "snippet": "void\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "v << 21"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "v >> 43"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "55"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(v & xfs_mask64hi(12)) == 0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}"
  },
  {
    "function_name": "xfs_bmbt_set_blockcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "279-287",
    "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "v & xfs_mask64lo(21)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "43"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(v & xfs_mask64hi(43)) == 0"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
  },
  {
    "function_name": "xfs_bmbt_disk_set_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "267-274",
    "snippet": "STATIC void\nxfs_bmbt_disk_set_all(\n\txfs_bmbt_rec_t\t*r,\n\txfs_bmbt_irec_t *s)\n{\n\txfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t\t  s->br_blockcount, s->br_state);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_set_allf",
          "args": [
            "r",
            "s->br_startoff",
            "s->br_startblock",
            "s->br_blockcount",
            "s->br_state"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "239-262",
          "snippet": "void\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmbt_disk_set_all(\n\txfs_bmbt_rec_t\t*r,\n\txfs_bmbt_irec_t *s)\n{\n\txfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t\t  s->br_blockcount, s->br_state);\n}"
  },
  {
    "function_name": "xfs_bmbt_disk_set_allf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "239-262",
    "snippet": "void\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21))"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "64-BMBT_STARTBLOCK_BITLEN"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}"
  },
  {
    "function_name": "xfs_bmbt_set_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "226-233",
    "snippet": "void\nxfs_bmbt_set_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t\t*s)\n{\n\txfs_bmbt_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t     s->br_blockcount, s->br_state);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "r",
            "s->br_startoff",
            "s->br_startblock",
            "s->br_blockcount",
            "s->br_state"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t\t*s)\n{\n\txfs_bmbt_set_allf(r, s->br_startoff, s->br_startblock,\n\t\t\t     s->br_blockcount, s->br_state);\n}"
  },
  {
    "function_name": "xfs_bmbt_set_allf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "199-221",
    "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64hi",
          "args": [
            "64-BMBT_STARTBLOCK_BITLEN"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64hi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "28-31",
          "snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64hi(int n)\n{\n\treturn (__uint64_t)-1 << (64 - (n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
  },
  {
    "function_name": "xfs_bmbt_disk_get_startoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "187-193",
    "snippet": "xfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "64 - BMBT_EXNTFLAG_BITLEN"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "r->l0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
  },
  {
    "function_name": "xfs_bmbt_disk_get_blockcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "177-182",
    "snippet": "xfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "be64_to_cpu(r->l1) & xfs_mask64lo(21)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "r->l1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}"
  },
  {
    "function_name": "xfs_bmbt_get_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "163-172",
    "snippet": "xfs_exntst_t\nxfs_bmbt_get_state(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\tint\text_flag;\n\n\text_flag = (int)((r->l0) >> (64 - BMBT_EXNTFLAG_BITLEN));\n\treturn xfs_extent_state(xfs_bmbt_get_blockcount(r),\n\t\t\t\text_flag);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_extent_state",
          "args": [
            "xfs_bmbt_get_blockcount(r)",
            "ext_flag"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "42-52",
          "snippet": "STATIC xfs_exntst_t\nxfs_extent_state(\n\txfs_filblks_t\t\tblks,\n\tint\t\t\textent_flag)\n{\n\tif (extent_flag) {\n\t\tASSERT(blks != 0);\t/* saved for DMIG */\n\t\treturn XFS_EXT_UNWRITTEN;\n\t}\n\treturn XFS_EXT_NORM;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_exntst_t\nxfs_extent_state(\n\txfs_filblks_t\t\tblks,\n\tint\t\t\textent_flag)\n{\n\tif (extent_flag) {\n\t\tASSERT(blks != 0);\t/* saved for DMIG */\n\t\treturn XFS_EXT_UNWRITTEN;\n\t}\n\treturn XFS_EXT_NORM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_blockcount",
          "args": [
            "r"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "134-139",
          "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_exntst_t\nxfs_bmbt_get_state(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\tint\text_flag;\n\n\text_flag = (int)((r->l0) >> (64 - BMBT_EXNTFLAG_BITLEN));\n\treturn xfs_extent_state(xfs_bmbt_get_blockcount(r),\n\t\t\t\text_flag);\n}"
  },
  {
    "function_name": "xfs_bmbt_get_startoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "155-161",
    "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "64 - BMBT_EXNTFLAG_BITLEN"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
  },
  {
    "function_name": "xfs_bmbt_get_startblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "144-150",
    "snippet": "xfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "9"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}"
  },
  {
    "function_name": "xfs_bmbt_get_blockcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "134-139",
    "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "r->l1 & xfs_mask64lo(21)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
  },
  {
    "function_name": "xfs_bmbt_get_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "123-129",
    "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_bmbt_get_all",
          "args": [
            "r->l0",
            "r->l1",
            "s"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "99-121",
          "snippet": "STATIC void\n__xfs_bmbt_get_all(\n\t\t__uint64_t l0,\n\t\t__uint64_t l1,\n\t\txfs_bmbt_irec_t *s)\n{\n\tint\text_flag;\n\txfs_exntst_t st;\n\n\text_flag = (int)(l0 >> (64 - BMBT_EXNTFLAG_BITLEN));\n\ts->br_startoff = ((xfs_fileoff_t)l0 &\n\t\t\t   xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n\ts->br_startblock = (((xfs_fsblock_t)l0 & xfs_mask64lo(9)) << 43) |\n\t\t\t   (((xfs_fsblock_t)l1) >> 21);\n\ts->br_blockcount = (xfs_filblks_t)(l1 & xfs_mask64lo(21));\n\t/* This is xfs_extent_state() in-line */\n\tif (ext_flag) {\n\t\tASSERT(s->br_blockcount != 0);\t/* saved for DMIG */\n\t\tst = XFS_EXT_UNWRITTEN;\n\t} else\n\t\tst = XFS_EXT_NORM;\n\ts->br_state = st;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\n__xfs_bmbt_get_all(\n\t\t__uint64_t l0,\n\t\t__uint64_t l1,\n\t\txfs_bmbt_irec_t *s)\n{\n\tint\text_flag;\n\txfs_exntst_t st;\n\n\text_flag = (int)(l0 >> (64 - BMBT_EXNTFLAG_BITLEN));\n\ts->br_startoff = ((xfs_fileoff_t)l0 &\n\t\t\t   xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n\ts->br_startblock = (((xfs_fsblock_t)l0 & xfs_mask64lo(9)) << 43) |\n\t\t\t   (((xfs_fsblock_t)l1) >> 21);\n\ts->br_blockcount = (xfs_filblks_t)(l1 & xfs_mask64lo(21));\n\t/* This is xfs_extent_state() in-line */\n\tif (ext_flag) {\n\t\tASSERT(s->br_blockcount != 0);\t/* saved for DMIG */\n\t\tst = XFS_EXT_UNWRITTEN;\n\t} else\n\t\tst = XFS_EXT_NORM;\n\ts->br_state = st;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
  },
  {
    "function_name": "__xfs_bmbt_get_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "99-121",
    "snippet": "STATIC void\n__xfs_bmbt_get_all(\n\t\t__uint64_t l0,\n\t\t__uint64_t l1,\n\t\txfs_bmbt_irec_t *s)\n{\n\tint\text_flag;\n\txfs_exntst_t st;\n\n\text_flag = (int)(l0 >> (64 - BMBT_EXNTFLAG_BITLEN));\n\ts->br_startoff = ((xfs_fileoff_t)l0 &\n\t\t\t   xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n\ts->br_startblock = (((xfs_fsblock_t)l0 & xfs_mask64lo(9)) << 43) |\n\t\t\t   (((xfs_fsblock_t)l1) >> 21);\n\ts->br_blockcount = (xfs_filblks_t)(l1 & xfs_mask64lo(21));\n\t/* This is xfs_extent_state() in-line */\n\tif (ext_flag) {\n\t\tASSERT(s->br_blockcount != 0);\t/* saved for DMIG */\n\t\tst = XFS_EXT_UNWRITTEN;\n\t} else\n\t\tst = XFS_EXT_NORM;\n\ts->br_state = st;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "s->br_blockcount != 0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "l1 & xfs_mask64lo(21)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mask64lo",
          "args": [
            "21"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mask64lo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "36-39",
          "snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __uint64_t xfs_mask64lo(int n)\n{\n\treturn ((__uint64_t)1 << (n)) - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\n__xfs_bmbt_get_all(\n\t\t__uint64_t l0,\n\t\t__uint64_t l1,\n\t\txfs_bmbt_irec_t *s)\n{\n\tint\text_flag;\n\txfs_exntst_t st;\n\n\text_flag = (int)(l0 >> (64 - BMBT_EXNTFLAG_BITLEN));\n\ts->br_startoff = ((xfs_fileoff_t)l0 &\n\t\t\t   xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n\ts->br_startblock = (((xfs_fsblock_t)l0 & xfs_mask64lo(9)) << 43) |\n\t\t\t   (((xfs_fsblock_t)l1) >> 21);\n\ts->br_blockcount = (xfs_filblks_t)(l1 & xfs_mask64lo(21));\n\t/* This is xfs_extent_state() in-line */\n\tif (ext_flag) {\n\t\tASSERT(s->br_blockcount != 0);\t/* saved for DMIG */\n\t\tst = XFS_EXT_UNWRITTEN;\n\t} else\n\t\tst = XFS_EXT_NORM;\n\ts->br_state = st;\n}"
  },
  {
    "function_name": "xfs_bmdr_to_bmbt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "57-92",
    "snippet": "void\nxfs_bmdr_to_bmbt(\n\tstruct xfs_inode\t*ip,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\trblock->bb_level = dblock->bb_level;\n\tASSERT(be16_to_cpu(rblock->bb_level) > 0);\n\trblock->bb_numrecs = dblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\ttkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\tfpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\ttpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tpp",
            "fpp",
            "sizeof(*fpp) * dmxr"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tkp",
            "fkp",
            "sizeof(*fkp) * dmxr"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dblock->bb_numrecs"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "rblock",
            "1",
            "rblocklen"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_PTR_ADDR",
          "args": [
            "dblock",
            "1",
            "dmxr"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_KEY_ADDR",
          "args": [
            "mp",
            "rblock",
            "1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_KEY_ADDR",
          "args": [
            "dblock",
            "1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmdr_maxrecs",
          "args": [
            "dblocklen",
            "0"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "829-839",
          "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(rblock->bb_level) > 0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rblock->bb_level"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_init_block_int",
          "args": [
            "mp",
            "rblock",
            "XFS_BUF_DADDR_NULL",
            "XFS_BMAP_MAGIC",
            "0",
            "0",
            "ip->i_ino",
            "XFS_BTREE_LONG_PTRS"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "982-1020",
          "snippet": "void\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_bmdr_to_bmbt(\n\tstruct xfs_inode\t*ip,\n\txfs_bmdr_block_t\t*dblock,\n\tint\t\t\tdblocklen,\n\tstruct xfs_btree_block\t*rblock,\n\tint\t\t\trblocklen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tdmxr;\n\txfs_bmbt_key_t\t\t*fkp;\n\t__be64\t\t\t*fpp;\n\txfs_bmbt_key_t\t\t*tkp;\n\t__be64\t\t\t*tpp;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, rblock, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\trblock->bb_level = dblock->bb_level;\n\tASSERT(be16_to_cpu(rblock->bb_level) > 0);\n\trblock->bb_numrecs = dblock->bb_numrecs;\n\tdmxr = xfs_bmdr_maxrecs(dblocklen, 0);\n\tfkp = XFS_BMDR_KEY_ADDR(dblock, 1);\n\ttkp = XFS_BMBT_KEY_ADDR(mp, rblock, 1);\n\tfpp = XFS_BMDR_PTR_ADDR(dblock, 1, dmxr);\n\ttpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, rblocklen);\n\tdmxr = be16_to_cpu(dblock->bb_numrecs);\n\tmemcpy(tkp, fkp, sizeof(*fkp) * dmxr);\n\tmemcpy(tpp, fpp, sizeof(*fpp) * dmxr);\n}"
  },
  {
    "function_name": "xfs_extent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
    "lines": "42-52",
    "snippet": "STATIC xfs_exntst_t\nxfs_extent_state(\n\txfs_filblks_t\t\tblks,\n\tint\t\t\textent_flag)\n{\n\tif (extent_flag) {\n\t\tASSERT(blks != 0);\t/* saved for DMIG */\n\t\treturn XFS_EXT_UNWRITTEN;\n\t}\n\treturn XFS_EXT_NORM;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blks != 0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_exntst_t\nxfs_extent_state(\n\txfs_filblks_t\t\tblks,\n\tint\t\t\textent_flag)\n{\n\tif (extent_flag) {\n\t\tASSERT(blks != 0);\t/* saved for DMIG */\n\t\treturn XFS_EXT_UNWRITTEN;\n\t}\n\treturn XFS_EXT_NORM;\n}"
  }
]