[
  {
    "function_name": "reiserfs_abort_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "4388-4403",
    "snippet": "void reiserfs_abort_journal(struct super_block *sb, int errno)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tif (test_bit(J_ABORTED, &journal->j_state))\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\tsb->s_flags |= MS_RDONLY;\n\tset_bit(J_ABORTED, &journal->j_state);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "J_ABORTED",
            "&journal->j_state"
          ],
          "line": 4398
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "J_ABORTED",
            "&journal->j_state"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_abort_journal(struct super_block *sb, int errno)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tif (test_bit(J_ABORTED, &journal->j_state))\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\tsb->s_flags |= MS_RDONLY;\n\tset_bit(J_ABORTED, &journal->j_state);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n}"
  },
  {
    "function_name": "do_journal_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3980-4385",
    "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
      "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
      "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
      "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
    ],
    "globals_used": [
      "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void flush_async_commits(struct work_struct *work);",
      "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "th",
            "0",
            "sizeof(*th)"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "sb",
            "\"journal end2\""
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "sb",
            "jl",
            "1"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "sb",
            "commit_trans_id"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_join_wait"
          ],
          "line": 4367
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "J_WRITERS_QUEUED",
            "&journal->j_state"
          ],
          "line": 4366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_journal",
          "args": [
            "sb"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "540-543",
          "snippet": "static inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_jlock",
            "0"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-1996\"",
            "\"could not get a list bitmap\""
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_list_bitmap",
          "args": [
            "sb",
            "journal->j_current_jl"
          ],
          "line": 4356
        },
        "resolved": true,
        "details": {
          "function_name": "get_list_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "310-338",
          "snippet": "static struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_used_journal_lists",
          "args": [
            "sb",
            "temp_jl"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "flush_used_journal_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1790-1839",
          "snippet": "static int flush_used_journal_lists(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tunsigned long len = 0;\n\tunsigned long cur_len;\n\tint ret;\n\tint i;\n\tint limit = 256;\n\tstruct reiserfs_journal_list *tjl;\n\tstruct reiserfs_journal_list *flush_jl;\n\tunsigned int trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\n\tflush_jl = tjl = jl;\n\n\t/* in data logging mode, try harder to flush a lot of blocks */\n\tif (reiserfs_data_log(s))\n\t\tlimit = 1024;\n\t/* flush for 256 transactions or limit blocks, whichever comes first */\n\tfor (i = 0; i < 256 && len < limit; i++) {\n\t\tif (atomic_read(&tjl->j_commit_left) ||\n\t\t    tjl->j_trans_id < jl->j_trans_id) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_len = atomic_read(&tjl->j_nonzerolen);\n\t\tif (cur_len > 0) {\n\t\t\ttjl->j_state &= ~LIST_TOUCHED;\n\t\t}\n\t\tlen += cur_len;\n\t\tflush_jl = tjl;\n\t\tif (tjl->j_list.next == &journal->j_journal_list)\n\t\t\tbreak;\n\t\ttjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\n\t}\n\tget_journal_list(jl);\n\tget_journal_list(flush_jl);\n\n\t/*\n\t * try to find a group of blocks we can flush across all the\n\t * transactions, but only bother if we've actually spanned\n\t * across multiple lists\n\t */\n\tif (flush_jl != jl) {\n\t\tret = kupdate_transactions(s, jl, &tjl, &trans_id, len, i);\n\t}\n\tflush_journal_list(s, flush_jl, 1);\n\tput_journal_list(s, flush_jl);\n\tput_journal_list(s, jl);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_TOUCHED 1"
          ],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_TOUCHED 1\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_used_journal_lists(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tunsigned long len = 0;\n\tunsigned long cur_len;\n\tint ret;\n\tint i;\n\tint limit = 256;\n\tstruct reiserfs_journal_list *tjl;\n\tstruct reiserfs_journal_list *flush_jl;\n\tunsigned int trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\n\tflush_jl = tjl = jl;\n\n\t/* in data logging mode, try harder to flush a lot of blocks */\n\tif (reiserfs_data_log(s))\n\t\tlimit = 1024;\n\t/* flush for 256 transactions or limit blocks, whichever comes first */\n\tfor (i = 0; i < 256 && len < limit; i++) {\n\t\tif (atomic_read(&tjl->j_commit_left) ||\n\t\t    tjl->j_trans_id < jl->j_trans_id) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_len = atomic_read(&tjl->j_nonzerolen);\n\t\tif (cur_len > 0) {\n\t\t\ttjl->j_state &= ~LIST_TOUCHED;\n\t\t}\n\t\tlen += cur_len;\n\t\tflush_jl = tjl;\n\t\tif (tjl->j_list.next == &journal->j_journal_list)\n\t\t\tbreak;\n\t\ttjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\n\t}\n\tget_journal_list(jl);\n\tget_journal_list(flush_jl);\n\n\t/*\n\t * try to find a group of blocks we can flush across all the\n\t * transactions, but only bother if we've actually spanned\n\t * across multiple lists\n\t */\n\tif (flush_jl != jl) {\n\t\tret = kupdate_transactions(s, jl, &tjl, &trans_id, len, i);\n\t}\n\tflush_journal_list(s, flush_jl, 1);\n\tput_journal_list(s, flush_jl);\n\tput_journal_list(s, jl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "entry",
            "safe",
            "&journal->j_journal_list"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "REISERFS_SB(sb)->commit_wq",
            "&journal->j_work",
            "HZ / 10"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_journal_list",
          "args": [
            "sb",
            "jl",
            "1"
          ],
          "line": 4300
        },
        "resolved": true,
        "details": {
          "function_name": "flush_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1348-1629",
          "snippet": "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_DIRTY   2",
            "#define BLOCK_NEEDS_FLUSH 4"
          ],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define BLOCK_NEEDS_FLUSH 4\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jl->j_commit_mutex"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&jl->j_tail_bh_list)"
          ],
          "line": 4287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jl->j_tail_bh_list"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_ordered_buffers",
          "args": [
            "&journal->j_dirty_buffers_lock",
            "journal",
            "jl",
            "&jl->j_tail_bh_list"
          ],
          "line": 4283
        },
        "resolved": true,
        "details": {
          "function_name": "write_ordered_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "794-883",
          "snippet": "static int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_journal_hash",
          "args": [
            "sb"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "init_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "114-119",
          "snippet": "static void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_wcount",
            "0"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jl->j_working_list",
            "&journal->j_working_list"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jl->j_list",
            "&journal->j_journal_list"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_journal_list",
          "args": [
            "sb"
          ],
          "line": 4240
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2574-2587",
          "snippet": "static struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_cond_resched",
          "args": [
            "sb"
          ],
          "line": 4231
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "843-852",
          "snippet": "static inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_cond_resched(struct super_block *s)\n{\n\tif (need_resched()) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cnode",
          "args": [
            "sb",
            "cn"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "free_cnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "394-410",
          "snippet": "static void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "cn->bh"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-2048\"",
            "\"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\""
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journaled",
          "args": [
            "cn->bh"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "tmp_bh"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_bh->b_data",
            "addr + offset_in_page(cn->bh->b_data)",
            "cn->bh->b_size"
          ],
          "line": 4210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "cn->bh->b_data"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "tmp_bh"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_getblk",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb))"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "cn->bh"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_new",
          "args": [
            "cn->bh"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "journal->j_len == 0"
          ],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_commit_trans_len",
          "args": [
            "commit",
            "journal->j_len"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_trans_id",
          "args": [
            "desc",
            "journal->j_trans_id"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_mount_id",
          "args": [
            "desc",
            "journal->j_mount_id"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_trans_len",
          "args": [
            "desc",
            "journal->j_len"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cn->bh->b_blocknr"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cn->bh->b_blocknr"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_journal_hash",
          "args": [
            "journal->j_list_hash_table",
            "jl_cn"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "insert_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "517-529",
          "snippet": "static inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-2332\"",
            "\"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\"",
            "cn->bh->b_blocknr"
          ],
          "line": 4147
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_block_in_log_or_reserved_area",
          "args": [
            "sb",
            "cn->bh->b_blocknr"
          ],
          "line": 4145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-1676\"",
            "\"get_cnode returned NULL\""
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cnode",
          "args": [
            "sb"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "get_cnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "367-389",
          "snippet": "static struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "cn->bh"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_trans_half",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_commit_left",
            "journal->j_len + 2"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_nonzerolen",
            "journal->j_len"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_older_commits_done",
            "0"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&jl->j_commit_mutex",
            "sb"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_commit_trans_id",
          "args": [
            "commit",
            "journal->j_trans_id"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "c_bh->b_data",
            "0",
            "c_bh->b_size"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_getblk",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb))"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_desc_trans_id",
          "args": [
            "desc",
            "journal->j_trans_id"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "get_journal_desc_magic(d_bh)",
            "JOURNAL_DESC_MAGIC",
            "8"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_journal_desc_magic",
          "args": [
            "d_bh"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "d_bh->b_data",
            "0",
            "d_bh->b_size"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_getblk",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_discard_all_prealloc",
          "args": [
            "th"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_discard_all_prealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/bitmap.c",
          "lines": "538-556",
          "snippet": "void reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th)\n{\n\tstruct list_head *plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;\n\n\tBUG_ON(!th->t_trans_id);\n\twhile (!list_empty(plist)) {\n\t\tstruct reiserfs_inode_info *ei;\n\t\tei = list_entry(plist->next, struct reiserfs_inode_info,\n\t\t\t\ti_prealloc_list);\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!ei->i_prealloc_count) {\n\t\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t\t       \"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\");\n\t\t}\n#endif\n\t\t__discard_prealloc(th, ei);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/errno.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n#include <linux/time.h>\n\nvoid reiserfs_discard_all_prealloc(struct reiserfs_transaction_handle *th)\n{\n\tstruct list_head *plist = &SB_JOURNAL(th->t_super)->j_prealloc_list;\n\n\tBUG_ON(!th->t_trans_id);\n\twhile (!list_empty(plist)) {\n\t\tstruct reiserfs_inode_info *ei;\n\t\tei = list_entry(plist->next, struct reiserfs_inode_info,\n\t\t\t\ti_prealloc_list);\n#ifdef CONFIG_REISERFS_CHECK\n\t\tif (!ei->i_prealloc_count) {\n\t\t\treiserfs_error(th->t_super, \"zam-4001\",\n\t\t\t\t       \"inode is in prealloc list but has \"\n\t\t\t\t       \"no preallocated blocks.\");\n\t\t}\n#endif\n\t\t__discard_prealloc(th, ei);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_async_progress_wait",
          "args": [
            "sb"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_async_progress_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "953-966",
          "snippet": "static int reiserfs_async_progress_wait(struct super_block *s)\n{\n\tstruct reiserfs_journal *j = SB_JOURNAL(s);\n\n\tif (atomic_read(&j->j_async_throttle)) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ / 10);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int reiserfs_async_progress_wait(struct super_block *s)\n{\n\tstruct reiserfs_journal *j = SB_JOURNAL(s);\n\n\tif (atomic_read(&j->j_async_throttle)) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ / 10);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_queued_writers",
          "args": [
            "sb"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "wake_queued_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2981-2986",
          "snippet": "static void wake_queued_writers(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\n\t\twake_up(&journal->j_join_wait);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void wake_queued_writers(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\n\t\twake_up(&journal->j_join_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_schedule_old_flush",
          "args": [
            "sb"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_schedule_old_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "98-117",
          "snippet": "void reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_journal_end",
          "args": [
            "th",
            "flags"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "check_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3611-3717",
          "snippet": "static int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\n\ttime_t now;\n\tint flush = flags & FLUSH_ALL;\n\tint commit_now = flags & COMMIT_NOW;\n\tint wait_on_commit = flags & WAIT;\n\tstruct reiserfs_journal_list *jl;\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tjournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\n\t/* <= 0 is allowed.  unmounting might not call begin */\n\tif (atomic_read(&journal->j_wcount) > 0)\n\t\tatomic_dec(&journal->j_wcount);\n\n\t/*\n\t * BUG, deal with case where j_len is 0, but people previously\n\t * freed blocks need to be released will be dealt with by next\n\t * transaction that actually writes something, but should be taken\n\t * care of in this trans\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * if wcount > 0, and we are called to with flush or commit_now,\n\t * we wait on j_join_wait.  We will wake up when the last writer has\n\t * finished the transaction, and started it on its way to the disk.\n\t * Then, we flush the commit or journal list, and just return 0\n\t * because the rest of journal end was already done for this\n\t * transaction.\n\t */\n\tif (atomic_read(&journal->j_wcount) > 0) {\n\t\tif (flush || commit_now) {\n\t\t\tunsigned trans_id;\n\n\t\t\tjl = journal->j_current_jl;\n\t\t\ttrans_id = jl->j_trans_id;\n\t\t\tif (wait_on_commit)\n\t\t\t\tjl->j_state |= LIST_COMMIT_PENDING;\n\t\t\tatomic_set(&journal->j_jlock, 1);\n\t\t\tif (flush) {\n\t\t\t\tjournal->j_next_full_flush = 1;\n\t\t\t}\n\t\t\tunlock_journal(sb);\n\n\t\t\t/*\n\t\t\t * sleep while the current transaction is\n\t\t\t * still j_jlocked\n\t\t\t */\n\t\t\twhile (journal->j_trans_id == trans_id) {\n\t\t\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\t\t\tqueue_log_writer(sb);\n\t\t\t\t} else {\n\t\t\t\t\tlock_journal(sb);\n\t\t\t\t\tif (journal->j_trans_id == trans_id) {\n\t\t\t\t\t\tatomic_set(&journal->j_jlock,\n\t\t\t\t\t\t\t   1);\n\t\t\t\t\t}\n\t\t\t\t\tunlock_journal(sb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(journal->j_trans_id == trans_id);\n\n\t\t\tif (commit_now\n\t\t\t    && journal_list_still_alive(sb, trans_id)\n\t\t\t    && wait_on_commit) {\n\t\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\t/* deal with old transactions where we are the last writers */\n\tnow = get_seconds();\n\tif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tcommit_now = 1;\n\t\tjournal->j_next_async_flush = 1;\n\t}\n\t/* don't batch when someone is waiting on j_join_wait */\n\t/* don't batch when syncing the commit or flushing the whole trans */\n\tif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\n\t    && !flush && !commit_now && (journal->j_len < journal->j_max_batch)\n\t    && journal->j_len_alloc < journal->j_max_batch\n\t    && journal->j_cnode_free > (journal->j_trans_max * 3)) {\n\t\tjournal->j_bcount++;\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\tif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\treiserfs_panic(sb, \"journal-003\",\n\t\t\t       \"j_start (%ld) is too high\",\n\t\t\t       journal->j_start);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\n\ttime_t now;\n\tint flush = flags & FLUSH_ALL;\n\tint commit_now = flags & COMMIT_NOW;\n\tint wait_on_commit = flags & WAIT;\n\tstruct reiserfs_journal_list *jl;\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tjournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\n\t/* <= 0 is allowed.  unmounting might not call begin */\n\tif (atomic_read(&journal->j_wcount) > 0)\n\t\tatomic_dec(&journal->j_wcount);\n\n\t/*\n\t * BUG, deal with case where j_len is 0, but people previously\n\t * freed blocks need to be released will be dealt with by next\n\t * transaction that actually writes something, but should be taken\n\t * care of in this trans\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * if wcount > 0, and we are called to with flush or commit_now,\n\t * we wait on j_join_wait.  We will wake up when the last writer has\n\t * finished the transaction, and started it on its way to the disk.\n\t * Then, we flush the commit or journal list, and just return 0\n\t * because the rest of journal end was already done for this\n\t * transaction.\n\t */\n\tif (atomic_read(&journal->j_wcount) > 0) {\n\t\tif (flush || commit_now) {\n\t\t\tunsigned trans_id;\n\n\t\t\tjl = journal->j_current_jl;\n\t\t\ttrans_id = jl->j_trans_id;\n\t\t\tif (wait_on_commit)\n\t\t\t\tjl->j_state |= LIST_COMMIT_PENDING;\n\t\t\tatomic_set(&journal->j_jlock, 1);\n\t\t\tif (flush) {\n\t\t\t\tjournal->j_next_full_flush = 1;\n\t\t\t}\n\t\t\tunlock_journal(sb);\n\n\t\t\t/*\n\t\t\t * sleep while the current transaction is\n\t\t\t * still j_jlocked\n\t\t\t */\n\t\t\twhile (journal->j_trans_id == trans_id) {\n\t\t\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\t\t\tqueue_log_writer(sb);\n\t\t\t\t} else {\n\t\t\t\t\tlock_journal(sb);\n\t\t\t\t\tif (journal->j_trans_id == trans_id) {\n\t\t\t\t\t\tatomic_set(&journal->j_jlock,\n\t\t\t\t\t\t\t   1);\n\t\t\t\t\t}\n\t\t\t\t\tunlock_journal(sb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(journal->j_trans_id == trans_id);\n\n\t\t\tif (commit_now\n\t\t\t    && journal_list_still_alive(sb, trans_id)\n\t\t\t    && wait_on_commit) {\n\t\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\t/* deal with old transactions where we are the last writers */\n\tnow = get_seconds();\n\tif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tcommit_now = 1;\n\t\tjournal->j_next_async_flush = 1;\n\t}\n\t/* don't batch when someone is waiting on j_join_wait */\n\t/* don't batch when syncing the commit or flushing the whole trans */\n\tif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\n\t    && !flush && !commit_now && (journal->j_len < journal->j_max_batch)\n\t    && journal->j_len_alloc < journal->j_max_batch\n\t    && journal->j_cnode_free > (journal->j_trans_max * 3)) {\n\t\tjournal->j_bcount++;\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\tif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\treiserfs_panic(sb, \"journal-003\",\n\t\t\t       \"j_start (%ld) is too high\",\n\t\t\t       journal->j_start);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "SB_BUFFER_WITH_SB(sb)"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "SB_BUFFER_WITH_SB(sb)",
            "1"
          ],
          "line": 4018
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_super"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "th->t_refcount > 1"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
  },
  {
    "function_name": "reiserfs_prepare_for_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3951-3968",
    "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_restore_dirty",
          "args": [
            "bh"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_test",
          "args": [
            "bh"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_prepared",
          "args": [
            "bh"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.prepare"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
  },
  {
    "function_name": "reiserfs_restore_prepared_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3920-3942",
    "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_journal_prepared",
          "args": [
            "bh"
          ],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 3939
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_test",
          "args": [
            "bh"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_dirty",
          "args": [
            "cn"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "can_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3480-3513",
          "snippet": "static int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_journal_hash_dev",
          "args": [
            "sb",
            "journal->j_list_hash_table",
            "bh->b_blocknr"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_journal_restore_dirty",
          "args": [
            "bh"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.restore_prepared"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
  },
  {
    "function_name": "reiserfs_commit_for_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3902-3918",
    "snippet": "int reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__commit_trans_jl",
          "args": [
            "inode",
            "id",
            "jl"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "__commit_trans_jl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3838-3900",
          "snippet": "static int __commit_trans_jl(struct inode *inode, unsigned long id,\n\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\t/*\n\t * is it from the current transaction,\n\t * or from an unknown transaction?\n\t */\n\tif (id == journal->j_trans_id) {\n\t\tjl = journal->j_current_jl;\n\t\t/*\n\t\t * try to let other writers come in and\n\t\t * grow this transaction\n\t\t */\n\t\tlet_transaction_grow(sb, id);\n\t\tif (journal->j_trans_id != id) {\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_begin(&th, sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* someone might have ended this transaction while we joined */\n\t\tif (journal->j_trans_id != id) {\n\t\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\t\t\tret = journal_end(&th);\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_end_sync(&th);\n\t\tif (!ret)\n\t\t\tret = 1;\n\n\t} else {\n\t\t/*\n\t\t * this gets tricky, we have to make sure the journal list in\n\t\t * the inode still exists.  We know the list is still around\n\t\t * if we've got a larger transaction id than the oldest list\n\t\t */\nflush_commit_only:\n\t\tif (journal_list_still_alive(inode->i_sb, id)) {\n\t\t\t/*\n\t\t\t * we only set ret to 1 when we know for sure\n\t\t\t * the barrier hasn't been started yet on the commit\n\t\t\t * block.\n\t\t\t */\n\t\t\tif (atomic_read(&jl->j_commit_left) > 1)\n\t\t\t\tret = 1;\n\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\tif (journal->j_errno)\n\t\t\t\tret = journal->j_errno;\n\t\t}\n\t}\n\t/* otherwise the list is gone, and long since committed */\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int __commit_trans_jl(struct inode *inode, unsigned long id,\n\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\t/*\n\t * is it from the current transaction,\n\t * or from an unknown transaction?\n\t */\n\tif (id == journal->j_trans_id) {\n\t\tjl = journal->j_current_jl;\n\t\t/*\n\t\t * try to let other writers come in and\n\t\t * grow this transaction\n\t\t */\n\t\tlet_transaction_grow(sb, id);\n\t\tif (journal->j_trans_id != id) {\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_begin(&th, sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* someone might have ended this transaction while we joined */\n\t\tif (journal->j_trans_id != id) {\n\t\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\t\t\tret = journal_end(&th);\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_end_sync(&th);\n\t\tif (!ret)\n\t\t\tret = 1;\n\n\t} else {\n\t\t/*\n\t\t * this gets tricky, we have to make sure the journal list in\n\t\t * the inode still exists.  We know the list is still around\n\t\t * if we've got a larger transaction id than the oldest list\n\t\t */\nflush_commit_only:\n\t\tif (journal_list_still_alive(inode->i_sb, id)) {\n\t\t\t/*\n\t\t\t * we only set ret to 1 when we know for sure\n\t\t\t * the barrier hasn't been started yet on the commit\n\t\t\t * block.\n\t\t\t */\n\t\t\tif (atomic_read(&jl->j_commit_left) > 1)\n\t\t\t\tret = 1;\n\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\tif (journal->j_errno)\n\t\t\t\tret = journal->j_errno;\n\t\t}\n\t}\n\t/* otherwise the list is gone, and long since committed */\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3913
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_update_inode_transaction",
          "args": [
            "inode"
          ],
          "line": 3912
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_update_inode_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3827-3832",
          "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nint reiserfs_commit_for_inode(struct inode *inode)\n{\n\tunsigned int id = REISERFS_I(inode)->i_trans_id;\n\tstruct reiserfs_journal_list *jl = REISERFS_I(inode)->i_jl;\n\n\t/*\n\t * for the whole inode, assume unset id means it was\n\t * changed in the current transaction.  More conservative\n\t */\n\tif (!id || !jl) {\n\t\treiserfs_update_inode_transaction(inode);\n\t\tid = REISERFS_I(inode)->i_trans_id;\n\t\t/* jl will be updated in __commit_trans_jl */\n\t}\n\n\treturn __commit_trans_jl(inode, id, jl);\n}"
  },
  {
    "function_name": "__commit_trans_jl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3838-3900",
    "snippet": "static int __commit_trans_jl(struct inode *inode, unsigned long id,\n\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\t/*\n\t * is it from the current transaction,\n\t * or from an unknown transaction?\n\t */\n\tif (id == journal->j_trans_id) {\n\t\tjl = journal->j_current_jl;\n\t\t/*\n\t\t * try to let other writers come in and\n\t\t * grow this transaction\n\t\t */\n\t\tlet_transaction_grow(sb, id);\n\t\tif (journal->j_trans_id != id) {\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_begin(&th, sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* someone might have ended this transaction while we joined */\n\t\tif (journal->j_trans_id != id) {\n\t\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\t\t\tret = journal_end(&th);\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_end_sync(&th);\n\t\tif (!ret)\n\t\t\tret = 1;\n\n\t} else {\n\t\t/*\n\t\t * this gets tricky, we have to make sure the journal list in\n\t\t * the inode still exists.  We know the list is still around\n\t\t * if we've got a larger transaction id than the oldest list\n\t\t */\nflush_commit_only:\n\t\tif (journal_list_still_alive(inode->i_sb, id)) {\n\t\t\t/*\n\t\t\t * we only set ret to 1 when we know for sure\n\t\t\t * the barrier hasn't been started yet on the commit\n\t\t\t * block.\n\t\t\t */\n\t\t\tif (atomic_read(&jl->j_commit_left) > 1)\n\t\t\t\tret = 1;\n\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\tif (journal->j_errno)\n\t\t\t\tret = journal->j_errno;\n\t\t}\n\t}\n\t/* otherwise the list is gone, and long since committed */\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "sb",
            "jl",
            "1"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "inode->i_sb",
            "id"
          ],
          "line": 3885
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_end_sync",
          "args": [
            "&th"
          ],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(sb)"
          ],
          "line": 3869
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "SB_BUFFER_WITH_SB(sb)",
            "1"
          ],
          "line": 3867
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "&th",
            "sb",
            "1"
          ],
          "line": 3861
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "let_transaction_grow",
          "args": [
            "sb",
            "id"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "let_transaction_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2988-3011",
          "snippet": "static void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned long bcount = journal->j_bcount;\n\twhile (1) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\tschedule_timeout_uninterruptible(1);\n\t\treiserfs_write_lock_nested(sb, depth);\n\n\t\tjournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\n\t\twhile ((atomic_read(&journal->j_wcount) > 0 ||\n\t\t\tatomic_read(&journal->j_jlock)) &&\n\t\t       journal->j_trans_id == trans_id) {\n\t\t\tqueue_log_writer(sb);\n\t\t}\n\t\tif (journal->j_trans_id != trans_id)\n\t\t\tbreak;\n\t\tif (bcount == journal->j_bcount)\n\t\t\tbreak;\n\t\tbcount = journal->j_bcount;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned long bcount = journal->j_bcount;\n\twhile (1) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\tschedule_timeout_uninterruptible(1);\n\t\treiserfs_write_lock_nested(sb, depth);\n\n\t\tjournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\n\t\twhile ((atomic_read(&journal->j_wcount) > 0 ||\n\t\t\tatomic_read(&journal->j_jlock)) &&\n\t\t       journal->j_trans_id == trans_id) {\n\t\t\tqueue_log_writer(sb);\n\t\t}\n\t\tif (journal->j_trans_id != trans_id)\n\t\t\tbreak;\n\t\tif (bcount == journal->j_bcount)\n\t\t\tbreak;\n\t\tbcount = journal->j_bcount;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int __commit_trans_jl(struct inode *inode, unsigned long id,\n\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_transaction_handle th;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\t/*\n\t * is it from the current transaction,\n\t * or from an unknown transaction?\n\t */\n\tif (id == journal->j_trans_id) {\n\t\tjl = journal->j_current_jl;\n\t\t/*\n\t\t * try to let other writers come in and\n\t\t * grow this transaction\n\t\t */\n\t\tlet_transaction_grow(sb, id);\n\t\tif (journal->j_trans_id != id) {\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_begin(&th, sb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* someone might have ended this transaction while we joined */\n\t\tif (journal->j_trans_id != id) {\n\t\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\t\t\tret = journal_end(&th);\n\t\t\tgoto flush_commit_only;\n\t\t}\n\n\t\tret = journal_end_sync(&th);\n\t\tif (!ret)\n\t\t\tret = 1;\n\n\t} else {\n\t\t/*\n\t\t * this gets tricky, we have to make sure the journal list in\n\t\t * the inode still exists.  We know the list is still around\n\t\t * if we've got a larger transaction id than the oldest list\n\t\t */\nflush_commit_only:\n\t\tif (journal_list_still_alive(inode->i_sb, id)) {\n\t\t\t/*\n\t\t\t * we only set ret to 1 when we know for sure\n\t\t\t * the barrier hasn't been started yet on the commit\n\t\t\t * block.\n\t\t\t */\n\t\t\tif (atomic_read(&jl->j_commit_left) > 1)\n\t\t\t\tret = 1;\n\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\tif (journal->j_errno)\n\t\t\t\tret = journal->j_errno;\n\t\t}\n\t}\n\t/* otherwise the list is gone, and long since committed */\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_update_inode_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3827-3832",
    "snippet": "void reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "REISERFS_I",
          "args": [
            "inode"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1147-1150",
          "snippet": "static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void reiserfs_vfs_truncate_file(struct inode *inode);",
            "int reiserfs_commit_for_inode(struct inode *);",
            "int reiserfs_inode_needs_commit(struct inode *);",
            "void reiserfs_update_inode_transaction(struct inode *);",
            "int reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);",
            "void reiserfs_evict_inode(struct inode *inode);",
            "void sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nvoid reiserfs_vfs_truncate_file(struct inode *inode);\nint reiserfs_commit_for_inode(struct inode *);\nint reiserfs_inode_needs_commit(struct inode *);\nvoid reiserfs_update_inode_transaction(struct inode *);\nint reiserfs_delete_object(struct reiserfs_transaction_handle *th,\n\t\t\t   struct inode *inode);\nvoid reiserfs_evict_inode(struct inode *inode);\nvoid sd_attrs_to_i_attrs(__u16 sd_attrs, struct inode *inode);\n\nstatic inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct reiserfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_update_inode_transaction(struct inode *inode)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(inode->i_sb);\n\tREISERFS_I(inode)->i_jl = journal->j_current_jl;\n\tREISERFS_I(inode)->i_trans_id = journal->j_trans_id;\n}"
  },
  {
    "function_name": "journal_mark_freed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3736-3825",
    "snippet": "int journal_mark_freed(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb, b_blocknr_t blocknr)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\tint cleaned = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (cn && cn->bh) {\n\t\tbh = cn->bh;\n\t\tget_bh(bh);\n\t}\n\t/* if it is journal new, we just remove it from this transaction */\n\tif (bh && buffer_journal_new(bh)) {\n\t\tclear_buffer_journal_new(bh);\n\t\tclear_prepared_bits(bh);\n\t\treiserfs_clean_and_file_buffer(bh);\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\t} else {\n\t\t/*\n\t\t * set the bit for this block in the journal bitmap\n\t\t * for this transaction\n\t\t */\n\t\tjb = journal->j_current_jl->j_list_bitmap;\n\t\tif (!jb) {\n\t\t\treiserfs_panic(sb, \"journal-1702\",\n\t\t\t\t       \"journal_list_bitmap is NULL\");\n\t\t}\n\t\tset_bit_in_list_bitmap(sb, blocknr, jb);\n\n\t\t/* Note, the entire while loop is not allowed to schedule.  */\n\n\t\tif (bh) {\n\t\t\tclear_prepared_bits(bh);\n\t\t\treiserfs_clean_and_file_buffer(bh);\n\t\t}\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\n\t\t/*\n\t\t * find all older transactions with this block,\n\t\t * make sure they don't try to write it out\n\t\t */\n\t\tcn = get_journal_hash_dev(sb, journal->j_list_hash_table,\n\t\t\t\t\t  blocknr);\n\t\twhile (cn) {\n\t\t\tif (sb == cn->sb && blocknr == cn->blocknr) {\n\t\t\t\tset_bit(BLOCK_FREED, &cn->state);\n\t\t\t\tif (cn->bh) {\n\t\t\t\t\t/*\n\t\t\t\t\t * remove_from_transaction will brelse\n\t\t\t\t\t * the buffer if it was in the current\n\t\t\t\t\t * trans\n\t\t\t\t\t */\n\t\t\t\t\tif (!cleaned) {\n\t\t\t\t\t\tclear_buffer_journal_dirty(cn->\n\t\t\t\t\t\t\t\t\t   bh);\n\t\t\t\t\t\tclear_buffer_dirty(cn->bh);\n\t\t\t\t\t\tclear_buffer_journal_test(cn->\n\t\t\t\t\t\t\t\t\t  bh);\n\t\t\t\t\t\tcleaned = 1;\n\t\t\t\t\t\tput_bh(cn->bh);\n\t\t\t\t\t\tif (atomic_read\n\t\t\t\t\t\t    (&cn->bh->b_count) < 0) {\n\t\t\t\t\t\t\treiserfs_warning(sb,\n\t\t\t\t\t\t\t\t \"journal-2138\",\n\t\t\t\t\t\t\t\t \"cn->bh->b_count < 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * since we are clearing the bh,\n\t\t\t\t\t * we MUST dec nonzerolen\n\t\t\t\t\t */\n\t\t\t\t\tif (cn->jlist) {\n\t\t\t\t\t\tatomic_dec(&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen);\n\t\t\t\t\t}\n\t\t\t\t\tcn->bh = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcn = cn->hnext;\n\t\t}\n\t}\n\n\tif (bh)\n\t\trelease_buffer_page(bh); /* get_hash grabs the buffer */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define BLOCK_FREED 2"
    ],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "bh"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "604-617",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-2138\"",
            "\"cn->bh->b_count < 0\""
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cn->bh->b_count"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "cn->bh"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_test",
          "args": [
            "cn->\n\t\t\t\t\t\t\t\t\t  bh"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_dirty",
          "args": [
            "cn->\n\t\t\t\t\t\t\t\t\t   bh"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BLOCK_FREED",
            "&cn->state"
          ],
          "line": 3785
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_journal_hash_dev",
          "args": [
            "sb",
            "journal->j_list_hash_table",
            "blocknr"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_transaction",
          "args": [
            "sb",
            "blocknr",
            "cleaned"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3422-3467",
          "snippet": "static int remove_from_transaction(struct super_block *sb,\n\t\t\t\t   b_blocknr_t blocknr, int already_cleaned)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (!cn || !cn->bh) {\n\t\treturn ret;\n\t}\n\tbh = cn->bh;\n\tif (cn->prev) {\n\t\tcn->prev->next = cn->next;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = cn->prev;\n\t}\n\tif (cn == journal->j_first) {\n\t\tjournal->j_first = cn->next;\n\t}\n\tif (cn == journal->j_last) {\n\t\tjournal->j_last = cn->prev;\n\t}\n\tif (bh)\n\t\tremove_journal_hash(sb, journal->j_hash_table, NULL,\n\t\t\t\t    bh->b_blocknr, 0);\n\tclear_buffer_journaled(bh);\t/* don't log this one */\n\n\tif (!already_cleaned) {\n\t\tclear_buffer_journal_dirty(bh);\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t\tput_bh(bh);\n\t\tif (atomic_read(&bh->b_count) < 0) {\n\t\t\treiserfs_warning(sb, \"journal-1752\",\n\t\t\t\t\t \"b_count < 0\");\n\t\t}\n\t\tret = 1;\n\t}\n\tjournal->j_len--;\n\tjournal->j_len_alloc--;\n\tfree_cnode(sb, cn);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int remove_from_transaction(struct super_block *sb,\n\t\t\t\t   b_blocknr_t blocknr, int already_cleaned)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (!cn || !cn->bh) {\n\t\treturn ret;\n\t}\n\tbh = cn->bh;\n\tif (cn->prev) {\n\t\tcn->prev->next = cn->next;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = cn->prev;\n\t}\n\tif (cn == journal->j_first) {\n\t\tjournal->j_first = cn->next;\n\t}\n\tif (cn == journal->j_last) {\n\t\tjournal->j_last = cn->prev;\n\t}\n\tif (bh)\n\t\tremove_journal_hash(sb, journal->j_hash_table, NULL,\n\t\t\t\t    bh->b_blocknr, 0);\n\tclear_buffer_journaled(bh);\t/* don't log this one */\n\n\tif (!already_cleaned) {\n\t\tclear_buffer_journal_dirty(bh);\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t\tput_bh(bh);\n\t\tif (atomic_read(&bh->b_count) < 0) {\n\t\t\treiserfs_warning(sb, \"journal-1752\",\n\t\t\t\t\t \"b_count < 0\");\n\t\t}\n\t\tret = 1;\n\t}\n\tjournal->j_len--;\n\tjournal->j_len_alloc--;\n\tfree_cnode(sb, cn);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_clean_and_file_buffer",
          "args": [
            "bh"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_clean_and_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "127-134",
          "snippet": "static int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\n{\n\tif (bh) {\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\n{\n\tif (bh) {\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_prepared_bits",
          "args": [
            "bh"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "clear_prepared_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "412-416",
          "snippet": "static void clear_prepared_bits(struct buffer_head *bh)\n{\n\tclear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void clear_prepared_bits(struct buffer_head *bh)\n{\n\tclear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit_in_list_bitmap",
          "args": [
            "sb",
            "blocknr",
            "jb"
          ],
          "line": 3767
        },
        "resolved": true,
        "details": {
          "function_name": "set_bit_in_list_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "210-222",
          "snippet": "static int set_bit_in_list_bitmap(struct super_block *sb,\n\t\t\t\t  b_blocknr_t block,\n\t\t\t\t  struct reiserfs_list_bitmap *jb)\n{\n\tunsigned int bmap_nr = block / (sb->s_blocksize << 3);\n\tunsigned int bit_nr = block % (sb->s_blocksize << 3);\n\n\tif (!jb->bitmaps[bmap_nr]) {\n\t\tjb->bitmaps[bmap_nr] = get_bitmap_node(sb);\n\t}\n\tset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int set_bit_in_list_bitmap(struct super_block *sb,\n\t\t\t\t  b_blocknr_t block,\n\t\t\t\t  struct reiserfs_list_bitmap *jb)\n{\n\tunsigned int bmap_nr = block / (sb->s_blocksize << 3);\n\tunsigned int bit_nr = block % (sb->s_blocksize << 3);\n\n\tif (!jb->bitmaps[bmap_nr]) {\n\t\tjb->bitmaps[bmap_nr] = get_bitmap_node(sb);\n\t}\n\tset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-1702\"",
            "\"journal_list_bitmap is NULL\""
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_new",
          "args": [
            "bh"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_new",
          "args": [
            "bh"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BLOCK_FREED 2\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_freed(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb, b_blocknr_t blocknr)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\tint cleaned = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (cn && cn->bh) {\n\t\tbh = cn->bh;\n\t\tget_bh(bh);\n\t}\n\t/* if it is journal new, we just remove it from this transaction */\n\tif (bh && buffer_journal_new(bh)) {\n\t\tclear_buffer_journal_new(bh);\n\t\tclear_prepared_bits(bh);\n\t\treiserfs_clean_and_file_buffer(bh);\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\t} else {\n\t\t/*\n\t\t * set the bit for this block in the journal bitmap\n\t\t * for this transaction\n\t\t */\n\t\tjb = journal->j_current_jl->j_list_bitmap;\n\t\tif (!jb) {\n\t\t\treiserfs_panic(sb, \"journal-1702\",\n\t\t\t\t       \"journal_list_bitmap is NULL\");\n\t\t}\n\t\tset_bit_in_list_bitmap(sb, blocknr, jb);\n\n\t\t/* Note, the entire while loop is not allowed to schedule.  */\n\n\t\tif (bh) {\n\t\t\tclear_prepared_bits(bh);\n\t\t\treiserfs_clean_and_file_buffer(bh);\n\t\t}\n\t\tcleaned = remove_from_transaction(sb, blocknr, cleaned);\n\n\t\t/*\n\t\t * find all older transactions with this block,\n\t\t * make sure they don't try to write it out\n\t\t */\n\t\tcn = get_journal_hash_dev(sb, journal->j_list_hash_table,\n\t\t\t\t\t  blocknr);\n\t\twhile (cn) {\n\t\t\tif (sb == cn->sb && blocknr == cn->blocknr) {\n\t\t\t\tset_bit(BLOCK_FREED, &cn->state);\n\t\t\t\tif (cn->bh) {\n\t\t\t\t\t/*\n\t\t\t\t\t * remove_from_transaction will brelse\n\t\t\t\t\t * the buffer if it was in the current\n\t\t\t\t\t * trans\n\t\t\t\t\t */\n\t\t\t\t\tif (!cleaned) {\n\t\t\t\t\t\tclear_buffer_journal_dirty(cn->\n\t\t\t\t\t\t\t\t\t   bh);\n\t\t\t\t\t\tclear_buffer_dirty(cn->bh);\n\t\t\t\t\t\tclear_buffer_journal_test(cn->\n\t\t\t\t\t\t\t\t\t  bh);\n\t\t\t\t\t\tcleaned = 1;\n\t\t\t\t\t\tput_bh(cn->bh);\n\t\t\t\t\t\tif (atomic_read\n\t\t\t\t\t\t    (&cn->bh->b_count) < 0) {\n\t\t\t\t\t\t\treiserfs_warning(sb,\n\t\t\t\t\t\t\t\t \"journal-2138\",\n\t\t\t\t\t\t\t\t \"cn->bh->b_count < 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * since we are clearing the bh,\n\t\t\t\t\t * we MUST dec nonzerolen\n\t\t\t\t\t */\n\t\t\t\t\tif (cn->jlist) {\n\t\t\t\t\t\tatomic_dec(&cn->jlist->\n\t\t\t\t\t\t\t   j_nonzerolen);\n\t\t\t\t\t}\n\t\t\t\t\tcn->bh = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcn = cn->hnext;\n\t\t}\n\t}\n\n\tif (bh)\n\t\trelease_buffer_page(bh); /* get_hash grabs the buffer */\n\treturn 0;\n}"
  },
  {
    "function_name": "check_journal_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3611-3717",
    "snippet": "static int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\n\ttime_t now;\n\tint flush = flags & FLUSH_ALL;\n\tint commit_now = flags & COMMIT_NOW;\n\tint wait_on_commit = flags & WAIT;\n\tstruct reiserfs_journal_list *jl;\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tjournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\n\t/* <= 0 is allowed.  unmounting might not call begin */\n\tif (atomic_read(&journal->j_wcount) > 0)\n\t\tatomic_dec(&journal->j_wcount);\n\n\t/*\n\t * BUG, deal with case where j_len is 0, but people previously\n\t * freed blocks need to be released will be dealt with by next\n\t * transaction that actually writes something, but should be taken\n\t * care of in this trans\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * if wcount > 0, and we are called to with flush or commit_now,\n\t * we wait on j_join_wait.  We will wake up when the last writer has\n\t * finished the transaction, and started it on its way to the disk.\n\t * Then, we flush the commit or journal list, and just return 0\n\t * because the rest of journal end was already done for this\n\t * transaction.\n\t */\n\tif (atomic_read(&journal->j_wcount) > 0) {\n\t\tif (flush || commit_now) {\n\t\t\tunsigned trans_id;\n\n\t\t\tjl = journal->j_current_jl;\n\t\t\ttrans_id = jl->j_trans_id;\n\t\t\tif (wait_on_commit)\n\t\t\t\tjl->j_state |= LIST_COMMIT_PENDING;\n\t\t\tatomic_set(&journal->j_jlock, 1);\n\t\t\tif (flush) {\n\t\t\t\tjournal->j_next_full_flush = 1;\n\t\t\t}\n\t\t\tunlock_journal(sb);\n\n\t\t\t/*\n\t\t\t * sleep while the current transaction is\n\t\t\t * still j_jlocked\n\t\t\t */\n\t\t\twhile (journal->j_trans_id == trans_id) {\n\t\t\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\t\t\tqueue_log_writer(sb);\n\t\t\t\t} else {\n\t\t\t\t\tlock_journal(sb);\n\t\t\t\t\tif (journal->j_trans_id == trans_id) {\n\t\t\t\t\t\tatomic_set(&journal->j_jlock,\n\t\t\t\t\t\t\t   1);\n\t\t\t\t\t}\n\t\t\t\t\tunlock_journal(sb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(journal->j_trans_id == trans_id);\n\n\t\t\tif (commit_now\n\t\t\t    && journal_list_still_alive(sb, trans_id)\n\t\t\t    && wait_on_commit) {\n\t\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\t/* deal with old transactions where we are the last writers */\n\tnow = get_seconds();\n\tif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tcommit_now = 1;\n\t\tjournal->j_next_async_flush = 1;\n\t}\n\t/* don't batch when someone is waiting on j_join_wait */\n\t/* don't batch when syncing the commit or flushing the whole trans */\n\tif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\n\t    && !flush && !commit_now && (journal->j_len < journal->j_max_batch)\n\t    && journal->j_len_alloc < journal->j_max_batch\n\t    && journal->j_cnode_free > (journal->j_trans_max * 3)) {\n\t\tjournal->j_bcount++;\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\tif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\treiserfs_panic(sb, \"journal-003\",\n\t\t\t       \"j_start (%ld) is too high\",\n\t\t\t       journal->j_start);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
      "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
      "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
      "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
    ],
    "globals_used": [
      "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-003\"",
            "\"j_start (%ld) is too high\"",
            "journal->j_start"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_journal",
          "args": [
            "sb"
          ],
          "line": 3707
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "540-543",
          "snippet": "static inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "sb",
            "jl",
            "1"
          ],
          "line": 3686
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "sb",
            "trans_id"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "journal->j_trans_id == trans_id"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_jlock",
            "1"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_log_writer",
          "args": [
            "sb"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "queue_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2959-2979",
          "snippet": "static void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_jlock",
            "1"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "journal->j_len == 0"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int check_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\n\ttime_t now;\n\tint flush = flags & FLUSH_ALL;\n\tint commit_now = flags & COMMIT_NOW;\n\tint wait_on_commit = flags & WAIT;\n\tstruct reiserfs_journal_list *jl;\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tjournal->j_len_alloc -= (th->t_blocks_allocated - th->t_blocks_logged);\n\t/* <= 0 is allowed.  unmounting might not call begin */\n\tif (atomic_read(&journal->j_wcount) > 0)\n\t\tatomic_dec(&journal->j_wcount);\n\n\t/*\n\t * BUG, deal with case where j_len is 0, but people previously\n\t * freed blocks need to be released will be dealt with by next\n\t * transaction that actually writes something, but should be taken\n\t * care of in this trans\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * if wcount > 0, and we are called to with flush or commit_now,\n\t * we wait on j_join_wait.  We will wake up when the last writer has\n\t * finished the transaction, and started it on its way to the disk.\n\t * Then, we flush the commit or journal list, and just return 0\n\t * because the rest of journal end was already done for this\n\t * transaction.\n\t */\n\tif (atomic_read(&journal->j_wcount) > 0) {\n\t\tif (flush || commit_now) {\n\t\t\tunsigned trans_id;\n\n\t\t\tjl = journal->j_current_jl;\n\t\t\ttrans_id = jl->j_trans_id;\n\t\t\tif (wait_on_commit)\n\t\t\t\tjl->j_state |= LIST_COMMIT_PENDING;\n\t\t\tatomic_set(&journal->j_jlock, 1);\n\t\t\tif (flush) {\n\t\t\t\tjournal->j_next_full_flush = 1;\n\t\t\t}\n\t\t\tunlock_journal(sb);\n\n\t\t\t/*\n\t\t\t * sleep while the current transaction is\n\t\t\t * still j_jlocked\n\t\t\t */\n\t\t\twhile (journal->j_trans_id == trans_id) {\n\t\t\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\t\t\tqueue_log_writer(sb);\n\t\t\t\t} else {\n\t\t\t\t\tlock_journal(sb);\n\t\t\t\t\tif (journal->j_trans_id == trans_id) {\n\t\t\t\t\t\tatomic_set(&journal->j_jlock,\n\t\t\t\t\t\t\t   1);\n\t\t\t\t\t}\n\t\t\t\t\tunlock_journal(sb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(journal->j_trans_id == trans_id);\n\n\t\t\tif (commit_now\n\t\t\t    && journal_list_still_alive(sb, trans_id)\n\t\t\t    && wait_on_commit) {\n\t\t\t\tflush_commit_list(sb, jl, 1);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\t/* deal with old transactions where we are the last writers */\n\tnow = get_seconds();\n\tif ((now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tcommit_now = 1;\n\t\tjournal->j_next_async_flush = 1;\n\t}\n\t/* don't batch when someone is waiting on j_join_wait */\n\t/* don't batch when syncing the commit or flushing the whole trans */\n\tif (!(journal->j_must_wait > 0) && !(atomic_read(&journal->j_jlock))\n\t    && !flush && !commit_now && (journal->j_len < journal->j_max_batch)\n\t    && journal->j_len_alloc < journal->j_max_batch\n\t    && journal->j_cnode_free > (journal->j_trans_max * 3)) {\n\t\tjournal->j_bcount++;\n\t\tunlock_journal(sb);\n\t\treturn 0;\n\t}\n\n\tif (journal->j_start > SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\treiserfs_panic(sb, \"journal-003\",\n\t\t\t       \"j_start (%ld) is too high\",\n\t\t\t       journal->j_start);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "reiserfs_flush_old_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3558-3594",
    "snippet": "void reiserfs_flush_old_commits(struct super_block *sb)\n{\n\ttime_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = get_seconds();\n\t/*\n\t * safety check so we don't flush while we are replaying the log during\n\t * mount\n\t */\n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t/*\n\t * check the current transaction.  If there are no writers, and it is\n\t * too old, finish it, and force the commit blocks to disk\n\t */\n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\n\t\t\t/*\n\t\t\t * we're only being called from kreiserfsd, it makes\n\t\t\t * no sense to do an async commit so that kreiserfsd\n\t\t\t * can do it later\n\t\t\t */\n\t\t\tdo_journal_end(&th, COMMIT_NOW | WAIT);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
      "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_end",
          "args": [
            "&th",
            "COMMIT_NOW | WAIT"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3980-4385",
          "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&th",
            "SB_BUFFER_WITH_SB(sb)"
          ],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "SB_BUFFER_WITH_SB(sb)",
            "1"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_join",
          "args": [
            "&th",
            "sb"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "journal_join_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3203-3215",
          "snippet": "int journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&journal->j_journal_list"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_flush_old_commits(struct super_block *sb)\n{\n\ttime_t now;\n\tstruct reiserfs_transaction_handle th;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tnow = get_seconds();\n\t/*\n\t * safety check so we don't flush while we are replaying the log during\n\t * mount\n\t */\n\tif (list_empty(&journal->j_journal_list))\n\t\treturn;\n\n\t/*\n\t * check the current transaction.  If there are no writers, and it is\n\t * too old, finish it, and force the commit blocks to disk\n\t */\n\tif (atomic_read(&journal->j_wcount) <= 0 &&\n\t    journal->j_trans_start_time > 0 &&\n\t    journal->j_len > 0 &&\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age) {\n\t\tif (!journal_join(&th, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&th, SB_BUFFER_WITH_SB(sb));\n\n\t\t\t/*\n\t\t\t * we're only being called from kreiserfsd, it makes\n\t\t\t * no sense to do an async commit so that kreiserfsd\n\t\t\t * can do it later\n\t\t\t */\n\t\t\tdo_journal_end(&th, COMMIT_NOW | WAIT);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "flush_async_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3536-3552",
    "snippet": "static void flush_async_commits(struct work_struct *work)\n{\n\tstruct reiserfs_journal *journal =\n\t\tcontainer_of(work, struct reiserfs_journal, j_work.work);\n\tstruct super_block *sb = journal->j_work_sb;\n\tstruct reiserfs_journal_list *jl;\n\tstruct list_head *entry;\n\n\treiserfs_write_lock(sb);\n\tif (!list_empty(&journal->j_journal_list)) {\n\t\t/* last entry is the youngest, commit it and you get everything */\n\t\tentry = journal->j_journal_list.prev;\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\t\tflush_commit_list(sb, jl, 1);\n\t}\n\treiserfs_write_unlock(sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void flush_async_commits(struct work_struct *work);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "sb",
            "jl",
            "1"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&journal->j_journal_list"
          ],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structreiserfs_journal",
            "j_work.work"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void flush_async_commits(struct work_struct *work)\n{\n\tstruct reiserfs_journal *journal =\n\t\tcontainer_of(work, struct reiserfs_journal, j_work.work);\n\tstruct super_block *sb = journal->j_work_sb;\n\tstruct reiserfs_journal_list *jl;\n\tstruct list_head *entry;\n\n\treiserfs_write_lock(sb);\n\tif (!list_empty(&journal->j_journal_list)) {\n\t\t/* last entry is the youngest, commit it and you get everything */\n\t\tentry = journal->j_journal_list.prev;\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\t\tflush_commit_list(sb, jl, 1);\n\t}\n\treiserfs_write_unlock(sb);\n}"
  },
  {
    "function_name": "journal_end_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3519-3533",
    "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
      "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_end",
          "args": [
            "th",
            "COMMIT_NOW | WAIT"
          ],
          "line": 3532
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3980-4385",
          "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "SB_BUFFER_WITH_SB(sb)"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "SB_BUFFER_WITH_SB(sb)",
            "1"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "th->t_refcount > 1"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
  },
  {
    "function_name": "can_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3480-3513",
    "snippet": "static int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cur->jlist->j_commit_left"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}"
  },
  {
    "function_name": "remove_from_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3422-3467",
    "snippet": "static int remove_from_transaction(struct super_block *sb,\n\t\t\t\t   b_blocknr_t blocknr, int already_cleaned)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (!cn || !cn->bh) {\n\t\treturn ret;\n\t}\n\tbh = cn->bh;\n\tif (cn->prev) {\n\t\tcn->prev->next = cn->next;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = cn->prev;\n\t}\n\tif (cn == journal->j_first) {\n\t\tjournal->j_first = cn->next;\n\t}\n\tif (cn == journal->j_last) {\n\t\tjournal->j_last = cn->prev;\n\t}\n\tif (bh)\n\t\tremove_journal_hash(sb, journal->j_hash_table, NULL,\n\t\t\t\t    bh->b_blocknr, 0);\n\tclear_buffer_journaled(bh);\t/* don't log this one */\n\n\tif (!already_cleaned) {\n\t\tclear_buffer_journal_dirty(bh);\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t\tput_bh(bh);\n\t\tif (atomic_read(&bh->b_count) < 0) {\n\t\t\treiserfs_warning(sb, \"journal-1752\",\n\t\t\t\t\t \"b_count < 0\");\n\t\t}\n\t\tret = 1;\n\t}\n\tjournal->j_len--;\n\tjournal->j_len_alloc--;\n\tfree_cnode(sb, cn);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cnode",
          "args": [
            "sb",
            "cn"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "free_cnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "394-410",
          "snippet": "static void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1752\"",
            "\"b_count < 0\""
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_test",
          "args": [
            "bh"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_journal_hash",
          "args": [
            "sb",
            "journal->j_hash_table",
            "NULL",
            "bh->b_blocknr",
            "0"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "remove_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1845-1884",
          "snippet": "void remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define BLOCK_FREED 2"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BLOCK_FREED 2\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nvoid remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_journal_hash_dev",
          "args": [
            "sb",
            "journal->j_hash_table",
            "blocknr"
          ],
          "line": 3430
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int remove_from_transaction(struct super_block *sb,\n\t\t\t\t   b_blocknr_t blocknr, int already_cleaned)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint ret = 0;\n\n\tcn = get_journal_hash_dev(sb, journal->j_hash_table, blocknr);\n\tif (!cn || !cn->bh) {\n\t\treturn ret;\n\t}\n\tbh = cn->bh;\n\tif (cn->prev) {\n\t\tcn->prev->next = cn->next;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = cn->prev;\n\t}\n\tif (cn == journal->j_first) {\n\t\tjournal->j_first = cn->next;\n\t}\n\tif (cn == journal->j_last) {\n\t\tjournal->j_last = cn->prev;\n\t}\n\tif (bh)\n\t\tremove_journal_hash(sb, journal->j_hash_table, NULL,\n\t\t\t\t    bh->b_blocknr, 0);\n\tclear_buffer_journaled(bh);\t/* don't log this one */\n\n\tif (!already_cleaned) {\n\t\tclear_buffer_journal_dirty(bh);\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t\tput_bh(bh);\n\t\tif (atomic_read(&bh->b_count) < 0) {\n\t\t\treiserfs_warning(sb, \"journal-1752\",\n\t\t\t\t\t \"b_count < 0\");\n\t\t}\n\t\tret = 1;\n\t}\n\tjournal->j_len--;\n\tjournal->j_len_alloc--;\n\tfree_cnode(sb, cn);\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3381-3412",
    "snippet": "int journal_end(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tif (!current->journal_info && th->t_refcount > 1)\n\t\treiserfs_warning(sb, \"REISER-NESTING\",\n\t\t\t\t \"th NULL, refcount %d\", th->t_refcount);\n\n\tif (!th->t_trans_id) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\tth->t_refcount--;\n\tif (th->t_refcount > 0) {\n\t\tstruct reiserfs_transaction_handle *cur_th =\n\t\t    current->journal_info;\n\n\t\t/*\n\t\t * we aren't allowed to close a nested transaction on a\n\t\t * different filesystem from the one in the task struct\n\t\t */\n\t\tBUG_ON(cur_th->t_super != th->t_super);\n\n\t\tif (th != cur_th) {\n\t\t\tmemcpy(current->journal_info, th, sizeof(*th));\n\t\t\tth->t_trans_id = 0;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn do_journal_end(th, 0);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_end",
          "args": [
            "th",
            "0"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3980-4385",
          "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "current->journal_info",
            "th",
            "sizeof(*th)"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cur_th->t_super != th->t_super"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"REISER-NESTING\"",
            "\"th NULL, refcount %d\"",
            "th->t_refcount"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_end(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tif (!current->journal_info && th->t_refcount > 1)\n\t\treiserfs_warning(sb, \"REISER-NESTING\",\n\t\t\t\t \"th NULL, refcount %d\", th->t_refcount);\n\n\tif (!th->t_trans_id) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\tth->t_refcount--;\n\tif (th->t_refcount > 0) {\n\t\tstruct reiserfs_transaction_handle *cur_th =\n\t\t    current->journal_info;\n\n\t\t/*\n\t\t * we aren't allowed to close a nested transaction on a\n\t\t * different filesystem from the one in the task struct\n\t\t */\n\t\tBUG_ON(cur_th->t_super != th->t_super);\n\n\t\tif (th != cur_th) {\n\t\t\tmemcpy(current->journal_info, th, sizeof(*th));\n\t\t\tth->t_trans_id = 0;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn do_journal_end(th, 0);\n\t}\n}"
  },
  {
    "function_name": "journal_mark_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3274-3379",
    "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_schedule_old_flush",
          "args": [
            "sb"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_schedule_old_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "98-117",
          "snippet": "void reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid reiserfs_schedule_old_flush(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sbi = REISERFS_SB(s);\n\tunsigned long delay;\n\n\t/*\n\t * Avoid scheduling flush when sb is being shut down. It can race\n\t * with journal shutdown and free still queued delayed work.\n\t */\n\tif (s->s_flags & MS_RDONLY || !(s->s_flags & MS_ACTIVE))\n\t\treturn;\n\n\tspin_lock(&sbi->old_work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->old_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->old_work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_journal_hash",
          "args": [
            "journal->j_hash_table",
            "cn"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "insert_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "517-529",
          "snippet": "static inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "sb",
            "\"journal-4\"",
            "\"get_cnode failed!\""
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cnode",
          "args": [
            "sb"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "get_cnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "367-389",
          "snippet": "static struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.mark_dirty_notjournal"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "th->t_super",
            "\"journal-1413\"",
            "\"j_len (%lu) is too big\"",
            "journal->j_len"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1409\"",
            "\"returning because j_wcount was %d\"",
            "atomic_read(&journal->j_wcount)"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "bh"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.mark_dirty_already"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_restore_dirty",
          "args": [
            "bh"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_journal_prepared",
          "args": [
            "bh"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.mark_dirty"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3217-3262",
    "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_refcount"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "current->journal_info != th"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_journal_begin_r",
          "args": [
            "th",
            "sb",
            "nblocks",
            "JBEGIN_REG"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_begin_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3020-3140",
          "snippet": "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\n\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"clm-2100\"",
            "\"nesting info a different FS\""
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"reiserfs-2005\"",
            "\"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\""
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "th",
            "cur_th",
            "sizeof(*th)"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cur_th->t_refcount"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_join_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3203-3215",
    "snippet": "int journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_begin_r",
          "args": [
            "th",
            "sb",
            "1",
            "JBEGIN_ABORT"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_begin_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3020-3140",
          "snippet": "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\n\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cur_th && cur_th->t_refcount > 1"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}"
  },
  {
    "function_name": "journal_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3189-3201",
    "snippet": "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_JOIN);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_begin_r",
          "args": [
            "th",
            "sb",
            "1",
            "JBEGIN_JOIN"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_begin_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3020-3140",
          "snippet": "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\n\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cur_th && cur_th->t_refcount > 1"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_JOIN);\n}"
  },
  {
    "function_name": "reiserfs_end_persistent_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3174-3187",
    "snippet": "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "th"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_end",
          "args": [
            "th"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "journal_end_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3519-3533",
          "snippet": "int journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_end_sync(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\tBUG_ON(!th->t_trans_id);\n\t/* you can sync while nested, very, very bad */\n\tBUG_ON(th->t_refcount > 1);\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\treturn do_journal_end(th, COMMIT_NOW | WAIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tint ret = 0;\n\tif (th->t_trans_id)\n\t\tret = journal_end(th);\n\telse\n\t\tret = -EIO;\n\tif (th->t_refcount == 0) {\n\t\tSB_JOURNAL(s)->j_persistent_trans--;\n\t\tkfree(th);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_persistent_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3142-3172",
    "snippet": "struct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "th"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_begin",
          "args": [
            "th",
            "s",
            "nblocks"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "journal_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3217-3262",
          "snippet": "int journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_begin(struct reiserfs_transaction_handle *th,\n\t\t  struct super_block *sb, unsigned long nblocks)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\tint ret;\n\n\tth->t_handle_save = NULL;\n\tif (cur_th) {\n\t\t/* we are nesting into the current transaction */\n\t\tif (cur_th->t_super == sb) {\n\t\t\tBUG_ON(!cur_th->t_refcount);\n\t\t\tcur_th->t_refcount++;\n\t\t\tmemcpy(th, cur_th, sizeof(*th));\n\t\t\tif (th->t_refcount <= 1)\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2005\",\n\t\t\t\t\t\t \"BAD: refcount <= 1, but \"\n\t\t\t\t\t\t \"journal_info != 0\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * we've ended up with a handle from a different\n\t\t\t * filesystem.  save it and restore on journal_end.\n\t\t\t * This should never really happen...\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"clm-2100\",\n\t\t\t\t\t \"nesting info a different FS\");\n\t\t\tth->t_handle_save = current->journal_info;\n\t\t\tcurrent->journal_info = th;\n\t\t}\n\t} else {\n\t\tcurrent->journal_info = th;\n\t}\n\tret = do_journal_begin_r(th, sb, nblocks, JBEGIN_REG);\n\tBUG_ON(current->journal_info != th);\n\n\t/*\n\t * I guess this boils down to being the reciprocal of clm-2100 above.\n\t * If do_journal_begin_r fails, we need to put it back, since\n\t * journal_end won't be called to do it. */\n\tif (ret)\n\t\tcurrent->journal_info = th->t_handle_save;\n\telse\n\t\tBUG_ON(!th->t_refcount);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct reiserfs_transaction_handle)",
            "GFP_NOFS"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "th->t_refcount < 2"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_transaction_running",
          "args": [
            "s"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_transaction_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "2896-2904",
          "snippet": "static inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "int reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_block_writes(struct reiserfs_transaction_handle *th);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_end(struct reiserfs_transaction_handle *);",
            "int journal_end_sync(struct reiserfs_transaction_handle *);",
            "int journal_transaction_should_end(struct reiserfs_transaction_handle *, int);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nint reiserfs_end_persistent_transaction(struct reiserfs_transaction_handle *);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_end(struct reiserfs_transaction_handle *);\nint journal_end_sync(struct reiserfs_transaction_handle *);\nint journal_transaction_should_end(struct reiserfs_transaction_handle *, int);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline int reiserfs_transaction_running(struct super_block *s)\n{\n\tstruct reiserfs_transaction_handle *th = current->journal_info;\n\tif (th && th->t_super == s)\n\t\treturn 1;\n\tif (th && th->t_super == NULL)\n\t\tBUG();\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstruct reiserfs_transaction_handle *reiserfs_persistent_transaction(struct\n\t\t\t\t\t\t\t\t    super_block\n\t\t\t\t\t\t\t\t    *s,\n\t\t\t\t\t\t\t\t    int nblocks)\n{\n\tint ret;\n\tstruct reiserfs_transaction_handle *th;\n\n\t/*\n\t * if we're nesting into an existing transaction.  It will be\n\t * persistent on its own\n\t */\n\tif (reiserfs_transaction_running(s)) {\n\t\tth = current->journal_info;\n\t\tth->t_refcount++;\n\t\tBUG_ON(th->t_refcount < 2);\n\n\t\treturn th;\n\t}\n\tth = kmalloc(sizeof(struct reiserfs_transaction_handle), GFP_NOFS);\n\tif (!th)\n\t\treturn NULL;\n\tret = journal_begin(th, s, nblocks);\n\tif (ret) {\n\t\tkfree(th);\n\t\treturn NULL;\n\t}\n\n\tSB_JOURNAL(s)->j_persistent_trans++;\n\treturn th;\n}"
  },
  {
    "function_name": "do_journal_begin_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "3020-3140",
    "snippet": "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define COMMIT_NOW  2\t\t/* end and commit this transaction */"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "th",
            "0",
            "sizeof(*th)"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&th->t_list"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_journal",
          "args": [
            "sb"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "540-543",
          "snippet": "static inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.journal_relock_wcount"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_journal_end",
          "args": [
            "&myth",
            "COMMIT_NOW"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3980-4385",
          "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_join",
          "args": [
            "&myth",
            "sb"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "journal_join_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3203-3215",
          "snippet": "int journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_log_writer",
          "args": [
            "sb"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "queue_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2959-2979",
          "snippet": "static void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.journal_relock_writers"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_wait_on_write_block",
          "args": [
            "sb"
          ],
          "line": 3052
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_wait_on_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2952-2957",
          "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "J_WRITERS_BLOCKED",
            "&journal->j_state"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.journal_being"
          ],
          "line": 3035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nblocks > journal->j_trans_max"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "sb",
            "\"journal_begin\""
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\n\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, unsigned long nblocks,\n\t\t\t      int join)\n{\n\ttime_t now = get_seconds();\n\tunsigned int old_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_transaction_handle myth;\n\tint sched_count = 0;\n\tint retval;\n\tint depth;\n\n\treiserfs_check_lock_depth(sb, \"journal_begin\");\n\tBUG_ON(nblocks > journal->j_trans_max);\n\n\tPROC_INFO_INC(sb, journal.journal_being);\n\t/* set here for journal_join */\n\tth->t_refcount = 1;\n\tth->t_super = sb;\n\nrelock:\n\tlock_journal(sb);\n\tif (join != JBEGIN_ABORT && reiserfs_is_journal_aborted(journal)) {\n\t\tunlock_journal(sb);\n\t\tretval = journal->j_errno;\n\t\tgoto out_fail;\n\t}\n\tjournal->j_bcount++;\n\n\tif (test_bit(J_WRITERS_BLOCKED, &journal->j_state)) {\n\t\tunlock_journal(sb);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\treiserfs_wait_on_write_block(sb);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tPROC_INFO_INC(sb, journal.journal_relock_writers);\n\t\tgoto relock;\n\t}\n\tnow = get_seconds();\n\n\t/*\n\t * if there is no room in the journal OR\n\t * if this transaction is too old, and we weren't called joinable,\n\t * wait for it to finish before beginning we don't sleep if there\n\t * aren't other writers\n\t */\n\n\tif ((!join && journal->j_must_wait > 0) ||\n\t    (!join\n\t     && (journal->j_len_alloc + nblocks + 2) >= journal->j_max_batch)\n\t    || (!join && atomic_read(&journal->j_wcount) > 0\n\t\t&& journal->j_trans_start_time > 0\n\t\t&& (now - journal->j_trans_start_time) >\n\t\tjournal->j_max_trans_age) || (!join\n\t\t\t\t\t      && atomic_read(&journal->j_jlock))\n\t    || (!join && journal->j_cnode_free < (journal->j_trans_max * 3))) {\n\n\t\told_trans_id = journal->j_trans_id;\n\t\t/* allow others to finish this transaction */\n\t\tunlock_journal(sb);\n\n\t\tif (!join && (journal->j_len_alloc + nblocks + 2) >=\n\t\t    journal->j_max_batch &&\n\t\t    ((journal->j_len + nblocks + 2) * 100) <\n\t\t    (journal->j_len_alloc * 75)) {\n\t\t\tif (atomic_read(&journal->j_wcount) > 10) {\n\t\t\t\tsched_count++;\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * don't mess with joining the transaction if all we\n\t\t * have to do is wait for someone else to do a commit\n\t\t */\n\t\tif (atomic_read(&journal->j_jlock)) {\n\t\t\twhile (journal->j_trans_id == old_trans_id &&\n\t\t\t       atomic_read(&journal->j_jlock)) {\n\t\t\t\tqueue_log_writer(sb);\n\t\t\t}\n\t\t\tgoto relock;\n\t\t}\n\t\tretval = journal_join(&myth, sb);\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\t/* someone might have ended the transaction while we joined */\n\t\tif (old_trans_id != journal->j_trans_id) {\n\t\t\tretval = do_journal_end(&myth, 0);\n\t\t} else {\n\t\t\tretval = do_journal_end(&myth, COMMIT_NOW);\n\t\t}\n\n\t\tif (retval)\n\t\t\tgoto out_fail;\n\n\t\tPROC_INFO_INC(sb, journal.journal_relock_wcount);\n\t\tgoto relock;\n\t}\n\t/* we are the first writer, set trans_id */\n\tif (journal->j_trans_start_time == 0) {\n\t\tjournal->j_trans_start_time = get_seconds();\n\t}\n\tatomic_inc(&journal->j_wcount);\n\tjournal->j_len_alloc += nblocks;\n\tth->t_blocks_logged = 0;\n\tth->t_blocks_allocated = nblocks;\n\tth->t_trans_id = journal->j_trans_id;\n\tunlock_journal(sb);\n\tINIT_LIST_HEAD(&th->t_list);\n\treturn 0;\n\nout_fail:\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\treturn retval;\n}"
  },
  {
    "function_name": "let_transaction_grow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2988-3011",
    "snippet": "static void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned long bcount = journal->j_bcount;\n\twhile (1) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\tschedule_timeout_uninterruptible(1);\n\t\treiserfs_write_lock_nested(sb, depth);\n\n\t\tjournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\n\t\twhile ((atomic_read(&journal->j_wcount) > 0 ||\n\t\t\tatomic_read(&journal->j_jlock)) &&\n\t\t       journal->j_trans_id == trans_id) {\n\t\t\tqueue_log_writer(sb);\n\t\t}\n\t\tif (journal->j_trans_id != trans_id)\n\t\t\tbreak;\n\t\tif (bcount == journal->j_bcount)\n\t\t\tbreak;\n\t\tbcount = journal->j_bcount;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_log_writer",
          "args": [
            "sb"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "queue_log_writer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2959-2979",
          "snippet": "static void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 2997
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void let_transaction_grow(struct super_block *sb, unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned long bcount = journal->j_bcount;\n\twhile (1) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\tschedule_timeout_uninterruptible(1);\n\t\treiserfs_write_lock_nested(sb, depth);\n\n\t\tjournal->j_current_jl->j_state |= LIST_COMMIT_PENDING;\n\t\twhile ((atomic_read(&journal->j_wcount) > 0 ||\n\t\t\tatomic_read(&journal->j_jlock)) &&\n\t\t       journal->j_trans_id == trans_id) {\n\t\t\tqueue_log_writer(sb);\n\t\t}\n\t\tif (journal->j_trans_id != trans_id)\n\t\t\tbreak;\n\t\tif (bcount == journal->j_bcount)\n\t\t\tbreak;\n\t\tbcount = journal->j_bcount;\n\t}\n}"
  },
  {
    "function_name": "wake_queued_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2981-2986",
    "snippet": "static void wake_queued_writers(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\n\t\twake_up(&journal->j_join_wait);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_join_wait"
          ],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "J_WRITERS_QUEUED",
            "&journal->j_state"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void wake_queued_writers(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (test_and_clear_bit(J_WRITERS_QUEUED, &journal->j_state))\n\t\twake_up(&journal->j_join_wait);\n}"
  },
  {
    "function_name": "queue_log_writer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2959-2979",
    "snippet": "static void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&journal->j_join_wait",
            "&wait"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "J_WRITERS_QUEUED",
            "&journal->j_state"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&journal->j_join_wait",
            "&wait"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_entry",
          "args": [
            "&wait",
            "current"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "J_WRITERS_QUEUED",
            "&journal->j_state"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void queue_log_writer(struct super_block *s)\n{\n\twait_queue_t wait;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tset_bit(J_WRITERS_QUEUED, &journal->j_state);\n\n\t/*\n\t * we don't want to use wait_event here because\n\t * we only want to wait once.\n\t */\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&journal->j_join_wait, &wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tif (test_bit(J_WRITERS_QUEUED, &journal->j_state)) {\n\t\tint depth = reiserfs_write_unlock_nested(s);\n\t\tschedule();\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&journal->j_join_wait, &wait);\n}"
  },
  {
    "function_name": "reiserfs_wait_on_write_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2952-2957",
    "snippet": "void reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_join_wait",
            "!test_bit(J_WRITERS_BLOCKED, &journal->j_state)"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "J_WRITERS_BLOCKED",
            "&journal->j_state"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_wait_on_write_block(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\twait_event(journal->j_join_wait,\n\t\t   !test_bit(J_WRITERS_BLOCKED, &journal->j_state));\n}"
  },
  {
    "function_name": "reiserfs_allow_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2944-2949",
    "snippet": "void reiserfs_allow_writes(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_join_wait"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "J_WRITERS_BLOCKED",
            "&journal->j_state"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nvoid reiserfs_allow_writes(struct super_block *s)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tclear_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n}"
  },
  {
    "function_name": "reiserfs_block_writes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2934-2941",
    "snippet": "void reiserfs_block_writes(struct reiserfs_transaction_handle *th)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\tBUG_ON(!th->t_trans_id);\n\tjournal->j_must_wait = 1;\n\tset_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\treturn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "J_WRITERS_BLOCKED",
            "&journal->j_state"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "th->t_super"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_block_writes(struct reiserfs_transaction_handle *th)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\tBUG_ON(!th->t_trans_id);\n\tjournal->j_must_wait = 1;\n\tset_bit(J_WRITERS_BLOCKED, &journal->j_state);\n\treturn;\n}"
  },
  {
    "function_name": "journal_transaction_should_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2911-2931",
    "snippet": "int journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_jlock"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "th->t_super"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_transaction_should_end(struct reiserfs_transaction_handle *th,\n\t\t\t\t   int new_alloc)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(th->t_super);\n\ttime_t now = get_seconds();\n\t/* cannot restart while nested */\n\tBUG_ON(!th->t_trans_id);\n\tif (th->t_refcount > 1)\n\t\treturn 0;\n\tif (journal->j_must_wait > 0 ||\n\t    (journal->j_len_alloc + new_alloc) >= journal->j_max_batch ||\n\t    atomic_read(&journal->j_jlock) ||\n\t    (now - journal->j_trans_start_time) > journal->j_max_trans_age ||\n\t    journal->j_cnode_free < (journal->j_trans_max * 3)) {\n\t\treturn 1;\n\t}\n\n\tjournal->j_len_alloc += new_alloc;\n\tth->t_blocks_allocated += new_alloc ;\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2718-2904",
    "snippet": "int journal_init(struct super_block *sb, const char *j_dev_name,\n\t\t int old_format, unsigned int commit_max_age)\n{\n\tint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\n\tstruct buffer_head *bhjh;\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal;\n\tstruct reiserfs_journal_list *jl;\n\tchar b[BDEVNAME_SIZE];\n\tint ret;\n\n\tjournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\n\tif (!journal) {\n\t\treiserfs_warning(sb, \"journal-1256\",\n\t\t\t\t \"unable to get memory for journal structure\");\n\t\treturn 1;\n\t}\n\tINIT_LIST_HEAD(&journal->j_bitmap_nodes);\n\tINIT_LIST_HEAD(&journal->j_prealloc_list);\n\tINIT_LIST_HEAD(&journal->j_working_list);\n\tINIT_LIST_HEAD(&journal->j_journal_list);\n\tjournal->j_persistent_trans = 0;\n\tif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\n\t\t\t\t\t   reiserfs_bmap_count(sb)))\n\t\tgoto free_and_return;\n\n\tallocate_bitmap_nodes(sb);\n\n\t/* reserved for journal area support */\n\tSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\n\t\t\t\t\t\t REISERFS_OLD_DISK_OFFSET_IN_BYTES\n\t\t\t\t\t\t / sb->s_blocksize +\n\t\t\t\t\t\t reiserfs_bmap_count(sb) +\n\t\t\t\t\t\t 1 :\n\t\t\t\t\t\t REISERFS_DISK_OFFSET_IN_BYTES /\n\t\t\t\t\t\t sb->s_blocksize + 2);\n\n\t/*\n\t * Sanity check to see is the standard journal fitting\n\t * within first bitmap (actual for small blocksizes)\n\t */\n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\n\t     SB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal does not fit for area addressed \"\n\t\t\t\t \"by first of bitmap blocks. It starts at \"\n\t\t\t\t \"%u and its size is %u. Block size %ld\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t\t\t sb->s_blocksize);\n\t\tgoto free_and_return;\n\t}\n\n\tif (journal_init_dev(sb, journal, j_dev_name) != 0) {\n\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t \"unable to initialize journal device\");\n\t\tgoto free_and_return;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(sb);\n\n\t/* read journal header */\n\tbhjh = journal_bread(sb,\n\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!bhjh) {\n\t\treiserfs_warning(sb, \"sh-459\",\n\t\t\t\t \"unable to read journal header\");\n\t\tgoto free_and_return;\n\t}\n\tjh = (struct reiserfs_journal_header *)(bhjh->b_data);\n\n\t/* make sure that journal matches to the super block */\n\tif (is_reiserfs_jr(rs)\n\t    && (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\n\t\tsb_jp_journal_magic(rs))) {\n\t\treiserfs_warning(sb, \"sh-460\",\n\t\t\t\t \"journal header magic %x (device %s) does \"\n\t\t\t\t \"not match to magic found in super block %x\",\n\t\t\t\t jh->jh_journal.jp_journal_magic,\n\t\t\t\t bdevname(journal->j_dev_bd, b),\n\t\t\t\t sb_jp_journal_magic(rs));\n\t\tbrelse(bhjh);\n\t\tgoto free_and_return;\n\t}\n\n\tjournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\n\tjournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\n\tjournal->j_max_commit_age =\n\t    le32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\n\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\n\tif (check_advise_trans_params(sb, journal) != 0)\n\t        goto free_and_return;\n\tjournal->j_default_max_commit_age = journal->j_max_commit_age;\n\n\tif (commit_max_age != 0) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t}\n\n\treiserfs_info(sb, \"journal params: device %s, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\",\n\t\t      bdevname(journal->j_dev_bd, b),\n\t\t      SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t      SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t      journal->j_trans_max,\n\t\t      journal->j_max_batch,\n\t\t      journal->j_max_commit_age, journal->j_max_trans_age);\n\n\tbrelse(bhjh);\n\n\tjournal->j_list_bitmap_index = 0;\n\tjournal_list_init(sb);\n\n\tmemset(journal->j_list_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n\n\tINIT_LIST_HEAD(&journal->j_dirty_buffers);\n\tspin_lock_init(&journal->j_dirty_buffers_lock);\n\n\tjournal->j_start = 0;\n\tjournal->j_len = 0;\n\tjournal->j_len_alloc = 0;\n\tatomic_set(&journal->j_wcount, 0);\n\tatomic_set(&journal->j_async_throttle, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_trans_start_time = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tinit_waitqueue_head(&journal->j_join_wait);\n\tmutex_init(&journal->j_mutex);\n\tmutex_init(&journal->j_flush_mutex);\n\n\tjournal->j_trans_id = 10;\n\tjournal->j_mount_id = 10;\n\tjournal->j_state = 0;\n\tatomic_set(&journal->j_jlock, 0);\n\tjournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\n\tjournal->j_cnode_free_orig = journal->j_cnode_free_list;\n\tjournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\n\tjournal->j_cnode_used = 0;\n\tjournal->j_must_wait = 0;\n\n\tif (journal->j_cnode_free == 0) {\n\t\treiserfs_warning(sb, \"journal-2004\", \"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\",\n\t\t                 sizeof (struct reiserfs_journal_cnode) * num_cnodes);\n        \tgoto free_and_return;\n\t}\n\n\tinit_journal_hash(sb);\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * get_list_bitmap() may call flush_commit_list() which\n\t * requires the lock. Calling flush_commit_list() shouldn't happen\n\t * this early but I like to be paranoid.\n\t */\n\treiserfs_write_lock(sb);\n\tjl->j_list_bitmap = get_list_bitmap(sb, jl);\n\treiserfs_write_unlock(sb);\n\tif (!jl->j_list_bitmap) {\n\t\treiserfs_warning(sb, \"journal-2005\",\n\t\t\t\t \"get_list_bitmap failed for journal list 0\");\n\t\tgoto free_and_return;\n\t}\n\n\tret = journal_read(sb);\n\tif (ret < 0) {\n\t\treiserfs_warning(sb, \"reiserfs-2006\",\n\t\t\t\t \"Replay Failure, unable to mount\");\n\t\tgoto free_and_return;\n\t}\n\n\tINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\n\tjournal->j_work_sb = sb;\n\treturn 0;\nfree_and_return:\n\tfree_journal_ram(sb);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_journal_ram",
          "args": [
            "sb"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "free_journal_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1886-1904",
          "snippet": "static void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&journal->j_work",
            "flush_async_commits"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"reiserfs-2006\"",
            "\"Replay Failure, unable to mount\""
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_read",
          "args": [
            "sb"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "journal_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2374-2572",
          "snippet": "static int journal_read(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tunsigned int oldest_trans_id = 0;\n\tunsigned int oldest_invalid_trans_id = 0;\n\ttime_t start;\n\tunsigned long oldest_start = 0;\n\tunsigned long cur_dblock = 0;\n\tunsigned long newest_mount_id = 9;\n\tstruct buffer_head *d_bh;\n\tstruct reiserfs_journal_header *jh;\n\tint valid_journal_header = 0;\n\tint replay_count = 0;\n\tint continue_replay = 1;\n\tint ret;\n\tchar b[BDEVNAME_SIZE];\n\n\tcur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_info(sb, \"checking transaction log (%s)\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\tstart = get_seconds();\n\n\t/*\n\t * step 1, read in the journal header block.  Check the transaction\n\t * it says is the first unflushed, and if that transaction is not\n\t * valid, replay is done\n\t */\n\tjournal->j_header_bh = journal_bread(sb,\n\t\t\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!journal->j_header_bh) {\n\t\treturn 1;\n\t}\n\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\n\tif (le32_to_cpu(jh->j_first_unflushed_offset) <\n\t    SB_ONDISK_JOURNAL_SIZE(sb)\n\t    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\n\t\toldest_start =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t    le32_to_cpu(jh->j_first_unflushed_offset);\n\t\toldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\tnewest_mount_id = le32_to_cpu(jh->j_mount_id);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1153: found in \"\n\t\t\t       \"header: first_unflushed_offset %d, last_flushed_trans_id \"\n\t\t\t       \"%lu\", le32_to_cpu(jh->j_first_unflushed_offset),\n\t\t\t       le32_to_cpu(jh->j_last_flush_trans_id));\n\t\tvalid_journal_header = 1;\n\n\t\t/*\n\t\t * now, we try to read the first unflushed offset.  If it\n\t\t * is not valid, there is nothing more we can do, and it\n\t\t * makes no sense to read through the whole log.\n\t\t */\n\t\td_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset));\n\t\tret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\n\t\tif (!ret) {\n\t\t\tcontinue_replay = 0;\n\t\t}\n\t\tbrelse(d_bh);\n\t\tgoto start_log_replay;\n\t}\n\n\t/*\n\t * ok, there are transactions that need to be replayed.  start\n\t * with the first log block, find all the valid transactions, and\n\t * pick out the oldest.\n\t */\n\twhile (continue_replay\n\t       && cur_dblock <\n\t       (SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\tSB_ONDISK_JOURNAL_SIZE(sb))) {\n\t\t/*\n\t\t * Note that it is required for blocksize of primary fs\n\t\t * device and journal device to be the same\n\t\t */\n\t\td_bh =\n\t\t    reiserfs_breada(journal->j_dev_bd, cur_dblock,\n\t\t\t\t    sb->s_blocksize,\n\t\t\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tret =\n\t\t    journal_transaction_is_valid(sb, d_bh,\n\t\t\t\t\t\t &oldest_invalid_trans_id,\n\t\t\t\t\t\t &newest_mount_id);\n\t\tif (ret == 1) {\n\t\t\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\t\t\tif (oldest_start == 0) {\t/* init all oldest_ values */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1179: Setting \"\n\t\t\t\t\t       \"oldest_start to offset %llu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t} else if (oldest_trans_id > get_desc_trans_id(desc)) {\n\t\t\t\t/* one we just read was older */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1180: Resetting \"\n\t\t\t\t\t       \"oldest_start to offset %lu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t}\n\t\t\tif (newest_mount_id < get_desc_mount_id(desc)) {\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1299: Setting \"\n\t\t\t\t\t       \"newest_mount_id to %d\",\n\t\t\t\t\t       get_desc_mount_id(desc));\n\t\t\t}\n\t\t\tcur_dblock += get_desc_trans_len(desc) + 2;\n\t\t} else {\n\t\t\tcur_dblock++;\n\t\t}\n\t\tbrelse(d_bh);\n\t}\n\nstart_log_replay:\n\tcur_dblock = oldest_start;\n\tif (oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1206: Starting replay \"\n\t\t\t       \"from offset %llu, trans_id %lu\",\n\t\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       oldest_trans_id);\n\n\t}\n\treplay_count = 0;\n\twhile (continue_replay && oldest_trans_id > 0) {\n\t\tret =\n\t\t    journal_read_transaction(sb, cur_dblock, oldest_start,\n\t\t\t\t\t     oldest_trans_id, newest_mount_id);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_dblock =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\n\t\treplay_count++;\n\t\tif (cur_dblock == oldest_start)\n\t\t\tbreak;\n\t}\n\n\tif (oldest_trans_id == 0) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1225: No valid \" \"transactions found\");\n\t}\n\t/*\n\t * j_start does not get set correctly if we don't replay any\n\t * transactions.  if we had a valid journal_header, set j_start\n\t * to the first unflushed transaction value, copy the trans_id\n\t * from the header\n\t */\n\tif (valid_journal_header && replay_count == 0) {\n\t\tjournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\n\t\tjournal->j_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\t/* check for trans_id overflow */\n\t\tif (journal->j_trans_id == 0)\n\t\t\tjournal->j_trans_id = 10;\n\t\tjournal->j_last_flush_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id);\n\t\tjournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\n\t} else {\n\t\tjournal->j_mount_id = newest_mount_id + 1;\n\t}\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\", journal->j_mount_id);\n\tjournal->j_first_unflushed_offset = journal->j_start;\n\tif (replay_count > 0) {\n\t\treiserfs_info(sb,\n\t\t\t      \"replayed %d transactions in %lu seconds\\n\",\n\t\t\t      replay_count, get_seconds() - start);\n\t}\n\t/* needed to satisfy the locking in _update_journal_header_block */\n\treiserfs_write_lock(sb);\n\tif (!bdev_read_only(sb->s_bdev) &&\n\t    _update_journal_header_block(sb, journal->j_start,\n\t\t\t\t\t journal->j_last_flush_trans_id)) {\n\t\treiserfs_write_unlock(sb);\n\t\t/*\n\t\t * replay failed, caller must call free_journal_ram and abort\n\t\t * the mount\n\t\t */\n\t\treturn -1;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_read(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tunsigned int oldest_trans_id = 0;\n\tunsigned int oldest_invalid_trans_id = 0;\n\ttime_t start;\n\tunsigned long oldest_start = 0;\n\tunsigned long cur_dblock = 0;\n\tunsigned long newest_mount_id = 9;\n\tstruct buffer_head *d_bh;\n\tstruct reiserfs_journal_header *jh;\n\tint valid_journal_header = 0;\n\tint replay_count = 0;\n\tint continue_replay = 1;\n\tint ret;\n\tchar b[BDEVNAME_SIZE];\n\n\tcur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_info(sb, \"checking transaction log (%s)\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\tstart = get_seconds();\n\n\t/*\n\t * step 1, read in the journal header block.  Check the transaction\n\t * it says is the first unflushed, and if that transaction is not\n\t * valid, replay is done\n\t */\n\tjournal->j_header_bh = journal_bread(sb,\n\t\t\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!journal->j_header_bh) {\n\t\treturn 1;\n\t}\n\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\n\tif (le32_to_cpu(jh->j_first_unflushed_offset) <\n\t    SB_ONDISK_JOURNAL_SIZE(sb)\n\t    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\n\t\toldest_start =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t    le32_to_cpu(jh->j_first_unflushed_offset);\n\t\toldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\tnewest_mount_id = le32_to_cpu(jh->j_mount_id);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1153: found in \"\n\t\t\t       \"header: first_unflushed_offset %d, last_flushed_trans_id \"\n\t\t\t       \"%lu\", le32_to_cpu(jh->j_first_unflushed_offset),\n\t\t\t       le32_to_cpu(jh->j_last_flush_trans_id));\n\t\tvalid_journal_header = 1;\n\n\t\t/*\n\t\t * now, we try to read the first unflushed offset.  If it\n\t\t * is not valid, there is nothing more we can do, and it\n\t\t * makes no sense to read through the whole log.\n\t\t */\n\t\td_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset));\n\t\tret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\n\t\tif (!ret) {\n\t\t\tcontinue_replay = 0;\n\t\t}\n\t\tbrelse(d_bh);\n\t\tgoto start_log_replay;\n\t}\n\n\t/*\n\t * ok, there are transactions that need to be replayed.  start\n\t * with the first log block, find all the valid transactions, and\n\t * pick out the oldest.\n\t */\n\twhile (continue_replay\n\t       && cur_dblock <\n\t       (SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\tSB_ONDISK_JOURNAL_SIZE(sb))) {\n\t\t/*\n\t\t * Note that it is required for blocksize of primary fs\n\t\t * device and journal device to be the same\n\t\t */\n\t\td_bh =\n\t\t    reiserfs_breada(journal->j_dev_bd, cur_dblock,\n\t\t\t\t    sb->s_blocksize,\n\t\t\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tret =\n\t\t    journal_transaction_is_valid(sb, d_bh,\n\t\t\t\t\t\t &oldest_invalid_trans_id,\n\t\t\t\t\t\t &newest_mount_id);\n\t\tif (ret == 1) {\n\t\t\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\t\t\tif (oldest_start == 0) {\t/* init all oldest_ values */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1179: Setting \"\n\t\t\t\t\t       \"oldest_start to offset %llu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t} else if (oldest_trans_id > get_desc_trans_id(desc)) {\n\t\t\t\t/* one we just read was older */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1180: Resetting \"\n\t\t\t\t\t       \"oldest_start to offset %lu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t}\n\t\t\tif (newest_mount_id < get_desc_mount_id(desc)) {\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1299: Setting \"\n\t\t\t\t\t       \"newest_mount_id to %d\",\n\t\t\t\t\t       get_desc_mount_id(desc));\n\t\t\t}\n\t\t\tcur_dblock += get_desc_trans_len(desc) + 2;\n\t\t} else {\n\t\t\tcur_dblock++;\n\t\t}\n\t\tbrelse(d_bh);\n\t}\n\nstart_log_replay:\n\tcur_dblock = oldest_start;\n\tif (oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1206: Starting replay \"\n\t\t\t       \"from offset %llu, trans_id %lu\",\n\t\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       oldest_trans_id);\n\n\t}\n\treplay_count = 0;\n\twhile (continue_replay && oldest_trans_id > 0) {\n\t\tret =\n\t\t    journal_read_transaction(sb, cur_dblock, oldest_start,\n\t\t\t\t\t     oldest_trans_id, newest_mount_id);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_dblock =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\n\t\treplay_count++;\n\t\tif (cur_dblock == oldest_start)\n\t\t\tbreak;\n\t}\n\n\tif (oldest_trans_id == 0) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1225: No valid \" \"transactions found\");\n\t}\n\t/*\n\t * j_start does not get set correctly if we don't replay any\n\t * transactions.  if we had a valid journal_header, set j_start\n\t * to the first unflushed transaction value, copy the trans_id\n\t * from the header\n\t */\n\tif (valid_journal_header && replay_count == 0) {\n\t\tjournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\n\t\tjournal->j_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\t/* check for trans_id overflow */\n\t\tif (journal->j_trans_id == 0)\n\t\t\tjournal->j_trans_id = 10;\n\t\tjournal->j_last_flush_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id);\n\t\tjournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\n\t} else {\n\t\tjournal->j_mount_id = newest_mount_id + 1;\n\t}\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\", journal->j_mount_id);\n\tjournal->j_first_unflushed_offset = journal->j_start;\n\tif (replay_count > 0) {\n\t\treiserfs_info(sb,\n\t\t\t      \"replayed %d transactions in %lu seconds\\n\",\n\t\t\t      replay_count, get_seconds() - start);\n\t}\n\t/* needed to satisfy the locking in _update_journal_header_block */\n\treiserfs_write_lock(sb);\n\tif (!bdev_read_only(sb->s_bdev) &&\n\t    _update_journal_header_block(sb, journal->j_start,\n\t\t\t\t\t journal->j_last_flush_trans_id)) {\n\t\treiserfs_write_unlock(sb);\n\t\t/*\n\t\t * replay failed, caller must call free_journal_ram and abort\n\t\t * the mount\n\t\t */\n\t\treturn -1;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-2005\"",
            "\"get_list_bitmap failed for journal list 0\""
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_list_bitmap",
          "args": [
            "sb",
            "jl"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "get_list_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "310-338",
          "snippet": "static struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_journal_hash",
          "args": [
            "sb"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "init_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "114-119",
          "snippet": "static void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-2004\"",
            "\"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\"",
            "sizeof (struct reiserfs_journal_cnode) * num_cnodes"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_cnodes",
          "args": [
            "num_cnodes"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_cnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "345-364",
          "snippet": "static struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\n{\n\tstruct reiserfs_journal_cnode *head;\n\tint i;\n\tif (num_cnodes <= 0) {\n\t\treturn NULL;\n\t}\n\thead = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));\n\tif (!head) {\n\t\treturn NULL;\n\t}\n\thead[0].prev = NULL;\n\thead[0].next = head + 1;\n\tfor (i = 1; i < num_cnodes; i++) {\n\t\thead[i].prev = head + (i - 1);\n\t\thead[i].next = head + (i + 1);\t/* if last one, overwrite it after the if */\n\t}\n\thead[num_cnodes - 1].next = NULL;\n\treturn head;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\n{\n\tstruct reiserfs_journal_cnode *head;\n\tint i;\n\tif (num_cnodes <= 0) {\n\t\treturn NULL;\n\t}\n\thead = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));\n\tif (!head) {\n\t\treturn NULL;\n\t}\n\thead[0].prev = NULL;\n\thead[0].next = head + 1;\n\tfor (i = 1; i < num_cnodes; i++) {\n\t\thead[i].prev = head + (i - 1);\n\t\thead[i].next = head + (i + 1);\t/* if last one, overwrite it after the if */\n\t}\n\thead[num_cnodes - 1].next = NULL;\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_jlock",
            "0"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&journal->j_flush_mutex"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&journal->j_mutex"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_join_wait"
          ],
          "line": 2851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_async_throttle",
            "0"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_wcount",
            "0"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_dirty_buffers_lock"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_dirty_buffers"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "journal->j_list_hash_table",
            "0",
            "JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_list_init",
          "args": [
            "sb"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2589-2592",
          "snippet": "static void journal_list_init(struct super_block *sb)\n{\n\tSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic void journal_list_init(struct super_block *sb)\n{\n\tSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhjh"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "sb",
            "\"journal params: device %s, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\"",
            "bdevname(journal->j_dev_bd, b)",
            "SB_ONDISK_JOURNAL_SIZE(sb)",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb)",
            "journal->j_trans_max",
            "journal->j_max_batch",
            "journal->j_max_commit_age",
            "journal->j_max_trans_age"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev_bd",
            "b"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_advise_trans_params",
          "args": [
            "sb",
            "journal"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "check_advise_trans_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2673-2715",
          "snippet": "static int check_advise_trans_params(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal *journal)\n{\n        if (journal->j_trans_max) {\n\t\t/* Non-default journal params.  Do sanity check for them. */\n\t        int ratio = 1;\n\t\tif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\n\t\t        ratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\n\n\t\tif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\n\t\t    journal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\n\t\t    SB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\n\t\t    JOURNAL_MIN_RATIO) {\n\t\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t\t \"bad transaction max size (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_trans_max);\n\t\t\treturn 1;\n\t\t}\n\t\tif (journal->j_max_batch != (journal->j_trans_max) *\n\t\t        JOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\n\t\t\treiserfs_warning(sb, \"sh-463\",\n\t\t\t\t\t \"bad transaction max batch (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_max_batch);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default journal params.\n\t\t * The file system was created by old version\n\t\t * of mkreiserfs, so some fields contain zeros,\n\t\t * and we need to advise proper values for them\n\t\t */\n\t\tif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\n\t\t\treiserfs_warning(sb, \"sh-464\", \"bad blocksize (%u)\",\n\t\t\t\t\t sb->s_blocksize);\n\t\t\treturn 1;\n\t\t}\n\t\tjournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\n\t\tjournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\n\t\tjournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define REISERFS_STANDARD_BLKSIZE (4096)"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define REISERFS_STANDARD_BLKSIZE (4096)\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int check_advise_trans_params(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal *journal)\n{\n        if (journal->j_trans_max) {\n\t\t/* Non-default journal params.  Do sanity check for them. */\n\t        int ratio = 1;\n\t\tif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\n\t\t        ratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\n\n\t\tif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\n\t\t    journal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\n\t\t    SB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\n\t\t    JOURNAL_MIN_RATIO) {\n\t\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t\t \"bad transaction max size (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_trans_max);\n\t\t\treturn 1;\n\t\t}\n\t\tif (journal->j_max_batch != (journal->j_trans_max) *\n\t\t        JOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\n\t\t\treiserfs_warning(sb, \"sh-463\",\n\t\t\t\t\t \"bad transaction max batch (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_max_batch);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default journal params.\n\t\t * The file system was created by old version\n\t\t * of mkreiserfs, so some fields contain zeros,\n\t\t * and we need to advise proper values for them\n\t\t */\n\t\tif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\n\t\t\treiserfs_warning(sb, \"sh-464\", \"bad blocksize (%u)\",\n\t\t\t\t\t sb->s_blocksize);\n\t\t\treturn 1;\n\t\t}\n\t\tjournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\n\t\tjournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\n\t\tjournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "jh->jh_journal.jp_journal_max_commit_age"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_jp_journal_magic",
          "args": [
            "rs"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev_bd",
            "b"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_jp_journal_magic",
          "args": [
            "rs"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_reiserfs_jr",
          "args": [
            "rs"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "is_reiserfs_jr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/super.c",
          "lines": "51-55",
          "snippet": "int is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/crc32.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/time.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/crc32.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/quotaops.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/uaccess.h>\n#include <linux/time.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const char reiserfs_jr_magic_string[] = REISER2FS_JR_SUPER_MAGIC_STRING;\n\nint is_reiserfs_jr(struct reiserfs_super_block *rs)\n{\n\treturn !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,\n\t\t\tstrlen(reiserfs_jr_magic_string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"sh-459\"",
            "\"unable to read journal header\""
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"sh-462\"",
            "\"unable to initialize journal device\""
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_dev",
          "args": [
            "sb",
            "journal",
            "j_dev_name"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2603-2657",
          "snippet": "static int journal_init_dev(struct super_block *super,\n\t\t\t    struct reiserfs_journal *journal,\n\t\t\t    const char *jdev_name)\n{\n\tint result;\n\tdev_t jdev;\n\tfmode_t blkdev_mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\n\tchar b[BDEVNAME_SIZE];\n\n\tresult = 0;\n\n\tjournal->j_dev_bd = NULL;\n\tjdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\n\t    new_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\n\n\tif (bdev_read_only(super->s_bdev))\n\t\tblkdev_mode = FMODE_READ;\n\n\t/* there is no \"jdev\" option and journal is on separate device */\n\tif ((!jdev_name || !jdev_name[0])) {\n\t\tif (jdev == super->s_dev)\n\t\t\tblkdev_mode &= ~FMODE_EXCL;\n\t\tjournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode,\n\t\t\t\t\t\t      journal);\n\t\tjournal->j_dev_mode = blkdev_mode;\n\t\tif (IS_ERR(journal->j_dev_bd)) {\n\t\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\t\tjournal->j_dev_bd = NULL;\n\t\t\treiserfs_warning(super, \"sh-458\",\n\t\t\t\t\t \"cannot init journal device '%s': %i\",\n\t\t\t\t\t __bdevname(jdev, b), result);\n\t\t\treturn result;\n\t\t} else if (jdev != super->s_dev)\n\t\t\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\n\t\treturn 0;\n\t}\n\n\tjournal->j_dev_mode = blkdev_mode;\n\tjournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, journal);\n\tif (IS_ERR(journal->j_dev_bd)) {\n\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\tjournal->j_dev_bd = NULL;\n\t\treiserfs_warning(super,\n\t\t\t\t \"journal_init_dev: Cannot open '%s': %i\",\n\t\t\t\t jdev_name, result);\n\t\treturn result;\n\t}\n\n\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\treiserfs_info(super,\n\t\t      \"journal_init_dev: journal device: %s\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_init_dev(struct super_block *super,\n\t\t\t    struct reiserfs_journal *journal,\n\t\t\t    const char *jdev_name)\n{\n\tint result;\n\tdev_t jdev;\n\tfmode_t blkdev_mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\n\tchar b[BDEVNAME_SIZE];\n\n\tresult = 0;\n\n\tjournal->j_dev_bd = NULL;\n\tjdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\n\t    new_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\n\n\tif (bdev_read_only(super->s_bdev))\n\t\tblkdev_mode = FMODE_READ;\n\n\t/* there is no \"jdev\" option and journal is on separate device */\n\tif ((!jdev_name || !jdev_name[0])) {\n\t\tif (jdev == super->s_dev)\n\t\t\tblkdev_mode &= ~FMODE_EXCL;\n\t\tjournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode,\n\t\t\t\t\t\t      journal);\n\t\tjournal->j_dev_mode = blkdev_mode;\n\t\tif (IS_ERR(journal->j_dev_bd)) {\n\t\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\t\tjournal->j_dev_bd = NULL;\n\t\t\treiserfs_warning(super, \"sh-458\",\n\t\t\t\t\t \"cannot init journal device '%s': %i\",\n\t\t\t\t\t __bdevname(jdev, b), result);\n\t\t\treturn result;\n\t\t} else if (jdev != super->s_dev)\n\t\t\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\n\t\treturn 0;\n\t}\n\n\tjournal->j_dev_mode = blkdev_mode;\n\tjournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, journal);\n\tif (IS_ERR(journal->j_dev_bd)) {\n\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\tjournal->j_dev_bd = NULL;\n\t\treiserfs_warning(super,\n\t\t\t\t \"journal_init_dev: Cannot open '%s': %i\",\n\t\t\t\t jdev_name, result);\n\t\treturn result;\n\t}\n\n\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\treiserfs_info(super,\n\t\t      \"journal_init_dev: journal device: %s\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL_1st_RESERVED_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL_1st_RESERVED_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_DEVICE",
          "args": [
            "sb"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "sb"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL_1st_RESERVED_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_bitmap_nodes",
          "args": [
            "sb"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_bitmap_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "193-208",
          "snippet": "static void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_allocate_list_bitmaps",
          "args": [
            "sb",
            "journal->j_list_bitmap",
            "reiserfs_bmap_count(sb)"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_allocate_list_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "279-304",
          "snippet": "int reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_journal_list"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_working_list"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_prealloc_list"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&journal->j_bitmap_nodes"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1256\"",
            "\"unable to get memory for journal structure\""
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sizeof(struct reiserfs_journal)"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nint journal_init(struct super_block *sb, const char *j_dev_name,\n\t\t int old_format, unsigned int commit_max_age)\n{\n\tint num_cnodes = SB_ONDISK_JOURNAL_SIZE(sb) * 2;\n\tstruct buffer_head *bhjh;\n\tstruct reiserfs_super_block *rs;\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal;\n\tstruct reiserfs_journal_list *jl;\n\tchar b[BDEVNAME_SIZE];\n\tint ret;\n\n\tjournal = SB_JOURNAL(sb) = vzalloc(sizeof(struct reiserfs_journal));\n\tif (!journal) {\n\t\treiserfs_warning(sb, \"journal-1256\",\n\t\t\t\t \"unable to get memory for journal structure\");\n\t\treturn 1;\n\t}\n\tINIT_LIST_HEAD(&journal->j_bitmap_nodes);\n\tINIT_LIST_HEAD(&journal->j_prealloc_list);\n\tINIT_LIST_HEAD(&journal->j_working_list);\n\tINIT_LIST_HEAD(&journal->j_journal_list);\n\tjournal->j_persistent_trans = 0;\n\tif (reiserfs_allocate_list_bitmaps(sb, journal->j_list_bitmap,\n\t\t\t\t\t   reiserfs_bmap_count(sb)))\n\t\tgoto free_and_return;\n\n\tallocate_bitmap_nodes(sb);\n\n\t/* reserved for journal area support */\n\tSB_JOURNAL_1st_RESERVED_BLOCK(sb) = (old_format ?\n\t\t\t\t\t\t REISERFS_OLD_DISK_OFFSET_IN_BYTES\n\t\t\t\t\t\t / sb->s_blocksize +\n\t\t\t\t\t\t reiserfs_bmap_count(sb) +\n\t\t\t\t\t\t 1 :\n\t\t\t\t\t\t REISERFS_DISK_OFFSET_IN_BYTES /\n\t\t\t\t\t\t sb->s_blocksize + 2);\n\n\t/*\n\t * Sanity check to see is the standard journal fitting\n\t * within first bitmap (actual for small blocksizes)\n\t */\n\tif (!SB_ONDISK_JOURNAL_DEVICE(sb) &&\n\t    (SB_JOURNAL_1st_RESERVED_BLOCK(sb) +\n\t     SB_ONDISK_JOURNAL_SIZE(sb) > sb->s_blocksize * 8)) {\n\t\treiserfs_warning(sb, \"journal-1393\",\n\t\t\t\t \"journal does not fit for area addressed \"\n\t\t\t\t \"by first of bitmap blocks. It starts at \"\n\t\t\t\t \"%u and its size is %u. Block size %ld\",\n\t\t\t\t SB_JOURNAL_1st_RESERVED_BLOCK(sb),\n\t\t\t\t SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t\t\t sb->s_blocksize);\n\t\tgoto free_and_return;\n\t}\n\n\tif (journal_init_dev(sb, journal, j_dev_name) != 0) {\n\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t \"unable to initialize journal device\");\n\t\tgoto free_and_return;\n\t}\n\n\trs = SB_DISK_SUPER_BLOCK(sb);\n\n\t/* read journal header */\n\tbhjh = journal_bread(sb,\n\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!bhjh) {\n\t\treiserfs_warning(sb, \"sh-459\",\n\t\t\t\t \"unable to read journal header\");\n\t\tgoto free_and_return;\n\t}\n\tjh = (struct reiserfs_journal_header *)(bhjh->b_data);\n\n\t/* make sure that journal matches to the super block */\n\tif (is_reiserfs_jr(rs)\n\t    && (le32_to_cpu(jh->jh_journal.jp_journal_magic) !=\n\t\tsb_jp_journal_magic(rs))) {\n\t\treiserfs_warning(sb, \"sh-460\",\n\t\t\t\t \"journal header magic %x (device %s) does \"\n\t\t\t\t \"not match to magic found in super block %x\",\n\t\t\t\t jh->jh_journal.jp_journal_magic,\n\t\t\t\t bdevname(journal->j_dev_bd, b),\n\t\t\t\t sb_jp_journal_magic(rs));\n\t\tbrelse(bhjh);\n\t\tgoto free_and_return;\n\t}\n\n\tjournal->j_trans_max = le32_to_cpu(jh->jh_journal.jp_journal_trans_max);\n\tjournal->j_max_batch = le32_to_cpu(jh->jh_journal.jp_journal_max_batch);\n\tjournal->j_max_commit_age =\n\t    le32_to_cpu(jh->jh_journal.jp_journal_max_commit_age);\n\tjournal->j_max_trans_age = JOURNAL_MAX_TRANS_AGE;\n\n\tif (check_advise_trans_params(sb, journal) != 0)\n\t        goto free_and_return;\n\tjournal->j_default_max_commit_age = journal->j_max_commit_age;\n\n\tif (commit_max_age != 0) {\n\t\tjournal->j_max_commit_age = commit_max_age;\n\t\tjournal->j_max_trans_age = commit_max_age;\n\t}\n\n\treiserfs_info(sb, \"journal params: device %s, size %u, \"\n\t\t      \"journal first block %u, max trans len %u, max batch %u, \"\n\t\t      \"max commit age %u, max trans age %u\\n\",\n\t\t      bdevname(journal->j_dev_bd, b),\n\t\t      SB_ONDISK_JOURNAL_SIZE(sb),\n\t\t      SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t      journal->j_trans_max,\n\t\t      journal->j_max_batch,\n\t\t      journal->j_max_commit_age, journal->j_max_trans_age);\n\n\tbrelse(bhjh);\n\n\tjournal->j_list_bitmap_index = 0;\n\tjournal_list_init(sb);\n\n\tmemset(journal->j_list_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n\n\tINIT_LIST_HEAD(&journal->j_dirty_buffers);\n\tspin_lock_init(&journal->j_dirty_buffers_lock);\n\n\tjournal->j_start = 0;\n\tjournal->j_len = 0;\n\tjournal->j_len_alloc = 0;\n\tatomic_set(&journal->j_wcount, 0);\n\tatomic_set(&journal->j_async_throttle, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_trans_start_time = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tinit_waitqueue_head(&journal->j_join_wait);\n\tmutex_init(&journal->j_mutex);\n\tmutex_init(&journal->j_flush_mutex);\n\n\tjournal->j_trans_id = 10;\n\tjournal->j_mount_id = 10;\n\tjournal->j_state = 0;\n\tatomic_set(&journal->j_jlock, 0);\n\tjournal->j_cnode_free_list = allocate_cnodes(num_cnodes);\n\tjournal->j_cnode_free_orig = journal->j_cnode_free_list;\n\tjournal->j_cnode_free = journal->j_cnode_free_list ? num_cnodes : 0;\n\tjournal->j_cnode_used = 0;\n\tjournal->j_must_wait = 0;\n\n\tif (journal->j_cnode_free == 0) {\n\t\treiserfs_warning(sb, \"journal-2004\", \"Journal cnode memory \"\n\t\t                 \"allocation failed (%ld bytes). Journal is \"\n\t\t                 \"too large for available memory. Usually \"\n\t\t                 \"this is due to a journal that is too large.\",\n\t\t                 sizeof (struct reiserfs_journal_cnode) * num_cnodes);\n        \tgoto free_and_return;\n\t}\n\n\tinit_journal_hash(sb);\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * get_list_bitmap() may call flush_commit_list() which\n\t * requires the lock. Calling flush_commit_list() shouldn't happen\n\t * this early but I like to be paranoid.\n\t */\n\treiserfs_write_lock(sb);\n\tjl->j_list_bitmap = get_list_bitmap(sb, jl);\n\treiserfs_write_unlock(sb);\n\tif (!jl->j_list_bitmap) {\n\t\treiserfs_warning(sb, \"journal-2005\",\n\t\t\t\t \"get_list_bitmap failed for journal list 0\");\n\t\tgoto free_and_return;\n\t}\n\n\tret = journal_read(sb);\n\tif (ret < 0) {\n\t\treiserfs_warning(sb, \"reiserfs-2006\",\n\t\t\t\t \"Replay Failure, unable to mount\");\n\t\tgoto free_and_return;\n\t}\n\n\tINIT_DELAYED_WORK(&journal->j_work, flush_async_commits);\n\tjournal->j_work_sb = sb;\n\treturn 0;\nfree_and_return:\n\tfree_journal_ram(sb);\n\treturn 1;\n}"
  },
  {
    "function_name": "check_advise_trans_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2673-2715",
    "snippet": "static int check_advise_trans_params(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal *journal)\n{\n        if (journal->j_trans_max) {\n\t\t/* Non-default journal params.  Do sanity check for them. */\n\t        int ratio = 1;\n\t\tif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\n\t\t        ratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\n\n\t\tif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\n\t\t    journal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\n\t\t    SB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\n\t\t    JOURNAL_MIN_RATIO) {\n\t\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t\t \"bad transaction max size (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_trans_max);\n\t\t\treturn 1;\n\t\t}\n\t\tif (journal->j_max_batch != (journal->j_trans_max) *\n\t\t        JOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\n\t\t\treiserfs_warning(sb, \"sh-463\",\n\t\t\t\t\t \"bad transaction max batch (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_max_batch);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default journal params.\n\t\t * The file system was created by old version\n\t\t * of mkreiserfs, so some fields contain zeros,\n\t\t * and we need to advise proper values for them\n\t\t */\n\t\tif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\n\t\t\treiserfs_warning(sb, \"sh-464\", \"bad blocksize (%u)\",\n\t\t\t\t\t sb->s_blocksize);\n\t\t\treturn 1;\n\t\t}\n\t\tjournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\n\t\tjournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\n\t\tjournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define REISERFS_STANDARD_BLKSIZE (4096)"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"sh-464\"",
            "\"bad blocksize (%u)\"",
            "sb->s_blocksize"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define REISERFS_STANDARD_BLKSIZE (4096)\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int check_advise_trans_params(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal *journal)\n{\n        if (journal->j_trans_max) {\n\t\t/* Non-default journal params.  Do sanity check for them. */\n\t        int ratio = 1;\n\t\tif (sb->s_blocksize < REISERFS_STANDARD_BLKSIZE)\n\t\t        ratio = REISERFS_STANDARD_BLKSIZE / sb->s_blocksize;\n\n\t\tif (journal->j_trans_max > JOURNAL_TRANS_MAX_DEFAULT / ratio ||\n\t\t    journal->j_trans_max < JOURNAL_TRANS_MIN_DEFAULT / ratio ||\n\t\t    SB_ONDISK_JOURNAL_SIZE(sb) / journal->j_trans_max <\n\t\t    JOURNAL_MIN_RATIO) {\n\t\t\treiserfs_warning(sb, \"sh-462\",\n\t\t\t\t\t \"bad transaction max size (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_trans_max);\n\t\t\treturn 1;\n\t\t}\n\t\tif (journal->j_max_batch != (journal->j_trans_max) *\n\t\t        JOURNAL_MAX_BATCH_DEFAULT/JOURNAL_TRANS_MAX_DEFAULT) {\n\t\t\treiserfs_warning(sb, \"sh-463\",\n\t\t\t\t\t \"bad transaction max batch (%u). \"\n\t\t\t\t\t \"FSCK?\", journal->j_max_batch);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default journal params.\n\t\t * The file system was created by old version\n\t\t * of mkreiserfs, so some fields contain zeros,\n\t\t * and we need to advise proper values for them\n\t\t */\n\t\tif (sb->s_blocksize != REISERFS_STANDARD_BLKSIZE) {\n\t\t\treiserfs_warning(sb, \"sh-464\", \"bad blocksize (%u)\",\n\t\t\t\t\t sb->s_blocksize);\n\t\t\treturn 1;\n\t\t}\n\t\tjournal->j_trans_max = JOURNAL_TRANS_MAX_DEFAULT;\n\t\tjournal->j_max_batch = JOURNAL_MAX_BATCH_DEFAULT;\n\t\tjournal->j_max_commit_age = JOURNAL_MAX_COMMIT_AGE;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_init_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2603-2657",
    "snippet": "static int journal_init_dev(struct super_block *super,\n\t\t\t    struct reiserfs_journal *journal,\n\t\t\t    const char *jdev_name)\n{\n\tint result;\n\tdev_t jdev;\n\tfmode_t blkdev_mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\n\tchar b[BDEVNAME_SIZE];\n\n\tresult = 0;\n\n\tjournal->j_dev_bd = NULL;\n\tjdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\n\t    new_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\n\n\tif (bdev_read_only(super->s_bdev))\n\t\tblkdev_mode = FMODE_READ;\n\n\t/* there is no \"jdev\" option and journal is on separate device */\n\tif ((!jdev_name || !jdev_name[0])) {\n\t\tif (jdev == super->s_dev)\n\t\t\tblkdev_mode &= ~FMODE_EXCL;\n\t\tjournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode,\n\t\t\t\t\t\t      journal);\n\t\tjournal->j_dev_mode = blkdev_mode;\n\t\tif (IS_ERR(journal->j_dev_bd)) {\n\t\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\t\tjournal->j_dev_bd = NULL;\n\t\t\treiserfs_warning(super, \"sh-458\",\n\t\t\t\t\t \"cannot init journal device '%s': %i\",\n\t\t\t\t\t __bdevname(jdev, b), result);\n\t\t\treturn result;\n\t\t} else if (jdev != super->s_dev)\n\t\t\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\n\t\treturn 0;\n\t}\n\n\tjournal->j_dev_mode = blkdev_mode;\n\tjournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, journal);\n\tif (IS_ERR(journal->j_dev_bd)) {\n\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\tjournal->j_dev_bd = NULL;\n\t\treiserfs_warning(super,\n\t\t\t\t \"journal_init_dev: Cannot open '%s': %i\",\n\t\t\t\t jdev_name, result);\n\t\treturn result;\n\t}\n\n\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\treiserfs_info(super,\n\t\t      \"journal_init_dev: journal device: %s\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "super",
            "\"journal_init_dev: journal device: %s\\n\"",
            "bdevname(journal->j_dev_bd, b)"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev_bd",
            "b"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "journal->j_dev_bd",
            "super->s_blocksize"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "super",
            "\"journal_init_dev: Cannot open '%s': %i\"",
            "jdev_name",
            "result"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "journal->j_dev_bd"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal->j_dev_bd"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "jdev_name",
            "blkdev_mode",
            "journal"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1387-1407",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bdevname",
          "args": [
            "jdev",
            "b"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "journal->j_dev_bd"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal->j_dev_bd"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "jdev",
            "blkdev_mode",
            "journal"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "super->s_bdev"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "SB_ONDISK_JOURNAL_DEVICE(super)"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_DEVICE",
          "args": [
            "super"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_DEVICE",
          "args": [
            "super"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_init_dev(struct super_block *super,\n\t\t\t    struct reiserfs_journal *journal,\n\t\t\t    const char *jdev_name)\n{\n\tint result;\n\tdev_t jdev;\n\tfmode_t blkdev_mode = FMODE_READ | FMODE_WRITE | FMODE_EXCL;\n\tchar b[BDEVNAME_SIZE];\n\n\tresult = 0;\n\n\tjournal->j_dev_bd = NULL;\n\tjdev = SB_ONDISK_JOURNAL_DEVICE(super) ?\n\t    new_decode_dev(SB_ONDISK_JOURNAL_DEVICE(super)) : super->s_dev;\n\n\tif (bdev_read_only(super->s_bdev))\n\t\tblkdev_mode = FMODE_READ;\n\n\t/* there is no \"jdev\" option and journal is on separate device */\n\tif ((!jdev_name || !jdev_name[0])) {\n\t\tif (jdev == super->s_dev)\n\t\t\tblkdev_mode &= ~FMODE_EXCL;\n\t\tjournal->j_dev_bd = blkdev_get_by_dev(jdev, blkdev_mode,\n\t\t\t\t\t\t      journal);\n\t\tjournal->j_dev_mode = blkdev_mode;\n\t\tif (IS_ERR(journal->j_dev_bd)) {\n\t\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\t\tjournal->j_dev_bd = NULL;\n\t\t\treiserfs_warning(super, \"sh-458\",\n\t\t\t\t\t \"cannot init journal device '%s': %i\",\n\t\t\t\t\t __bdevname(jdev, b), result);\n\t\t\treturn result;\n\t\t} else if (jdev != super->s_dev)\n\t\t\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\n\t\treturn 0;\n\t}\n\n\tjournal->j_dev_mode = blkdev_mode;\n\tjournal->j_dev_bd = blkdev_get_by_path(jdev_name, blkdev_mode, journal);\n\tif (IS_ERR(journal->j_dev_bd)) {\n\t\tresult = PTR_ERR(journal->j_dev_bd);\n\t\tjournal->j_dev_bd = NULL;\n\t\treiserfs_warning(super,\n\t\t\t\t \"journal_init_dev: Cannot open '%s': %i\",\n\t\t\t\t jdev_name, result);\n\t\treturn result;\n\t}\n\n\tset_blocksize(journal->j_dev_bd, super->s_blocksize);\n\treiserfs_info(super,\n\t\t      \"journal_init_dev: journal device: %s\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\treturn 0;\n}"
  },
  {
    "function_name": "release_journal_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2594-2601",
    "snippet": "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal)\n{\n\tif (journal->j_dev_bd != NULL) {\n\t\tblkdev_put(journal->j_dev_bd, journal->j_dev_mode);\n\t\tjournal->j_dev_bd = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "journal->j_dev_bd",
            "journal->j_dev_mode"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal)\n{\n\tif (journal->j_dev_bd != NULL) {\n\t\tblkdev_put(journal->j_dev_bd, journal->j_dev_mode);\n\t\tjournal->j_dev_bd = NULL;\n\t}\n}"
  },
  {
    "function_name": "journal_list_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2589-2592",
    "snippet": "static void journal_list_init(struct super_block *sb)\n{\n\tSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_journal_list",
          "args": [
            "sb"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2574-2587",
          "snippet": "static struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic void journal_list_init(struct super_block *sb)\n{\n\tSB_JOURNAL(sb)->j_current_jl = alloc_journal_list(sb);\n}"
  },
  {
    "function_name": "alloc_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2574-2587",
    "snippet": "static struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_journal_list",
          "args": [
            "jl"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "545-548",
          "snippet": "static inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&jl->j_commit_mutex"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jl->j_bh_list"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jl->j_tail_bh_list"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jl->j_working_list"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jl->j_list"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct reiserfs_journal_list)",
            "GFP_NOFS | __GFP_NOFAIL"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *alloc_journal_list(struct super_block *s)\n{\n\tstruct reiserfs_journal_list *jl;\n\tjl = kzalloc(sizeof(struct reiserfs_journal_list),\n\t\t     GFP_NOFS | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(&jl->j_list);\n\tINIT_LIST_HEAD(&jl->j_working_list);\n\tINIT_LIST_HEAD(&jl->j_tail_bh_list);\n\tINIT_LIST_HEAD(&jl->j_bh_list);\n\tmutex_init(&jl->j_commit_mutex);\n\tSB_JOURNAL(s)->j_num_lists++;\n\tget_journal_list(jl);\n\treturn jl;\n}"
  },
  {
    "function_name": "journal_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2374-2572",
    "snippet": "static int journal_read(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tunsigned int oldest_trans_id = 0;\n\tunsigned int oldest_invalid_trans_id = 0;\n\ttime_t start;\n\tunsigned long oldest_start = 0;\n\tunsigned long cur_dblock = 0;\n\tunsigned long newest_mount_id = 9;\n\tstruct buffer_head *d_bh;\n\tstruct reiserfs_journal_header *jh;\n\tint valid_journal_header = 0;\n\tint replay_count = 0;\n\tint continue_replay = 1;\n\tint ret;\n\tchar b[BDEVNAME_SIZE];\n\n\tcur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_info(sb, \"checking transaction log (%s)\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\tstart = get_seconds();\n\n\t/*\n\t * step 1, read in the journal header block.  Check the transaction\n\t * it says is the first unflushed, and if that transaction is not\n\t * valid, replay is done\n\t */\n\tjournal->j_header_bh = journal_bread(sb,\n\t\t\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!journal->j_header_bh) {\n\t\treturn 1;\n\t}\n\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\n\tif (le32_to_cpu(jh->j_first_unflushed_offset) <\n\t    SB_ONDISK_JOURNAL_SIZE(sb)\n\t    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\n\t\toldest_start =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t    le32_to_cpu(jh->j_first_unflushed_offset);\n\t\toldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\tnewest_mount_id = le32_to_cpu(jh->j_mount_id);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1153: found in \"\n\t\t\t       \"header: first_unflushed_offset %d, last_flushed_trans_id \"\n\t\t\t       \"%lu\", le32_to_cpu(jh->j_first_unflushed_offset),\n\t\t\t       le32_to_cpu(jh->j_last_flush_trans_id));\n\t\tvalid_journal_header = 1;\n\n\t\t/*\n\t\t * now, we try to read the first unflushed offset.  If it\n\t\t * is not valid, there is nothing more we can do, and it\n\t\t * makes no sense to read through the whole log.\n\t\t */\n\t\td_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset));\n\t\tret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\n\t\tif (!ret) {\n\t\t\tcontinue_replay = 0;\n\t\t}\n\t\tbrelse(d_bh);\n\t\tgoto start_log_replay;\n\t}\n\n\t/*\n\t * ok, there are transactions that need to be replayed.  start\n\t * with the first log block, find all the valid transactions, and\n\t * pick out the oldest.\n\t */\n\twhile (continue_replay\n\t       && cur_dblock <\n\t       (SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\tSB_ONDISK_JOURNAL_SIZE(sb))) {\n\t\t/*\n\t\t * Note that it is required for blocksize of primary fs\n\t\t * device and journal device to be the same\n\t\t */\n\t\td_bh =\n\t\t    reiserfs_breada(journal->j_dev_bd, cur_dblock,\n\t\t\t\t    sb->s_blocksize,\n\t\t\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tret =\n\t\t    journal_transaction_is_valid(sb, d_bh,\n\t\t\t\t\t\t &oldest_invalid_trans_id,\n\t\t\t\t\t\t &newest_mount_id);\n\t\tif (ret == 1) {\n\t\t\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\t\t\tif (oldest_start == 0) {\t/* init all oldest_ values */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1179: Setting \"\n\t\t\t\t\t       \"oldest_start to offset %llu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t} else if (oldest_trans_id > get_desc_trans_id(desc)) {\n\t\t\t\t/* one we just read was older */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1180: Resetting \"\n\t\t\t\t\t       \"oldest_start to offset %lu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t}\n\t\t\tif (newest_mount_id < get_desc_mount_id(desc)) {\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1299: Setting \"\n\t\t\t\t\t       \"newest_mount_id to %d\",\n\t\t\t\t\t       get_desc_mount_id(desc));\n\t\t\t}\n\t\t\tcur_dblock += get_desc_trans_len(desc) + 2;\n\t\t} else {\n\t\t\tcur_dblock++;\n\t\t}\n\t\tbrelse(d_bh);\n\t}\n\nstart_log_replay:\n\tcur_dblock = oldest_start;\n\tif (oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1206: Starting replay \"\n\t\t\t       \"from offset %llu, trans_id %lu\",\n\t\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       oldest_trans_id);\n\n\t}\n\treplay_count = 0;\n\twhile (continue_replay && oldest_trans_id > 0) {\n\t\tret =\n\t\t    journal_read_transaction(sb, cur_dblock, oldest_start,\n\t\t\t\t\t     oldest_trans_id, newest_mount_id);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_dblock =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\n\t\treplay_count++;\n\t\tif (cur_dblock == oldest_start)\n\t\t\tbreak;\n\t}\n\n\tif (oldest_trans_id == 0) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1225: No valid \" \"transactions found\");\n\t}\n\t/*\n\t * j_start does not get set correctly if we don't replay any\n\t * transactions.  if we had a valid journal_header, set j_start\n\t * to the first unflushed transaction value, copy the trans_id\n\t * from the header\n\t */\n\tif (valid_journal_header && replay_count == 0) {\n\t\tjournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\n\t\tjournal->j_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\t/* check for trans_id overflow */\n\t\tif (journal->j_trans_id == 0)\n\t\t\tjournal->j_trans_id = 10;\n\t\tjournal->j_last_flush_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id);\n\t\tjournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\n\t} else {\n\t\tjournal->j_mount_id = newest_mount_id + 1;\n\t}\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\", journal->j_mount_id);\n\tjournal->j_first_unflushed_offset = journal->j_start;\n\tif (replay_count > 0) {\n\t\treiserfs_info(sb,\n\t\t\t      \"replayed %d transactions in %lu seconds\\n\",\n\t\t\t      replay_count, get_seconds() - start);\n\t}\n\t/* needed to satisfy the locking in _update_journal_header_block */\n\treiserfs_write_lock(sb);\n\tif (!bdev_read_only(sb->s_bdev) &&\n\t    _update_journal_header_block(sb, journal->j_start,\n\t\t\t\t\t journal->j_last_flush_trans_id)) {\n\t\treiserfs_write_unlock(sb);\n\t\t/*\n\t\t * replay failed, caller must call free_journal_ram and abort\n\t\t * the mount\n\t\t */\n\t\treturn -1;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_update_journal_header_block",
          "args": [
            "sb",
            "journal->j_start",
            "journal->j_last_flush_trans_id"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "_update_journal_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1238-1286",
          "snippet": "static int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_info",
          "args": [
            "sb",
            "\"replayed %d transactions in %lu seconds\\n\"",
            "replay_count",
            "get_seconds() - start"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_debug",
          "args": [
            "sb",
            "REISERFS_DEBUG_CODE",
            "\"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\"",
            "journal->j_mount_id"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "297-307",
          "snippet": "void reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "jh->j_mount_id"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_read_transaction",
          "args": [
            "sb",
            "cur_dblock",
            "oldest_start",
            "oldest_trans_id",
            "newest_mount_id"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "journal_read_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2117-2315",
          "snippet": "static int journal_read_transaction(struct super_block *sb,\n\t\t\t\t    unsigned long cur_dblock,\n\t\t\t\t    unsigned long oldest_start,\n\t\t\t\t    unsigned int oldest_trans_id,\n\t\t\t\t    unsigned long newest_mount_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tunsigned int trans_id = 0;\n\tstruct buffer_head *c_bh;\n\tstruct buffer_head *d_bh;\n\tstruct buffer_head **log_blocks = NULL;\n\tstruct buffer_head **real_blocks = NULL;\n\tunsigned int trans_offset;\n\tint i;\n\tint trans_half;\n\n\td_bh = journal_bread(sb, cur_dblock);\n\tif (!d_bh)\n\t\treturn 1;\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\ttrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1037: \"\n\t\t       \"journal_read_transaction, offset %llu, len %d mount_id %d\",\n\t\t       d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t       get_desc_trans_len(desc), get_desc_mount_id(desc));\n\tif (get_desc_trans_id(desc) < oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1039: \"\n\t\t\t       \"journal_read_trans skipping because %lu is too old\",\n\t\t\t       cur_dblock -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tif (get_desc_mount_id(desc) != newest_mount_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1146: \"\n\t\t\t       \"journal_read_trans skipping because %d is != \"\n\t\t\t       \"newest_mount_id %lu\", get_desc_mount_id(desc),\n\t\t\t       newest_mount_id);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb)));\n\tif (!c_bh) {\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal_read_transaction, \"\n\t\t\t       \"commit offset %llu had bad time %d or length %d\",\n\t\t\t       c_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_commit_trans_id(commit),\n\t\t\t       get_commit_trans_len(commit));\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\treiserfs_warning(sb, \"clm-2076\",\n\t\t\t\t \"device is readonly, unable to replay log\");\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn -EROFS;\n\t}\n\n\ttrans_id = get_desc_trans_id(desc);\n\t/*\n\t * now we know we've got a good transaction, and it was\n\t * inside the valid time ranges\n\t */\n\tlog_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t     sizeof(struct buffer_head *), GFP_NOFS);\n\treal_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t      sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!log_blocks || !real_blocks) {\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\tkfree(log_blocks);\n\t\tkfree(real_blocks);\n\t\treiserfs_warning(sb, \"journal-1169\",\n\t\t\t\t \"kmalloc failed, unable to mount FS\");\n\t\treturn -1;\n\t}\n\t/* get all the buffer heads */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tlog_blocks[i] =\n\t\t    journal_getblk(sb,\n\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tif (i < trans_half) {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(desc->j_realblock[i]));\n\t\t} else {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]));\n\t\t}\n\t\tif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\n\t\t\treiserfs_warning(sb, \"journal-1207\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\");\n\t\t\tgoto abort_replay;\n\t\t}\n\t\t/* make sure we don't try to replay onto log or reserved area */\n\t\tif (is_block_in_log_or_reserved_area\n\t\t    (sb, real_blocks[i]->b_blocknr)) {\n\t\t\treiserfs_warning(sb, \"journal-1204\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\");\nabort_replay:\n\t\t\tbrelse_array(log_blocks, i);\n\t\t\tbrelse_array(real_blocks, i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* read in the log blocks, memcpy to the corresponding real block */\n\tll_rw_block(READ, get_desc_trans_len(desc), log_blocks);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\n\t\twait_on_buffer(log_blocks[i]);\n\t\tif (!buffer_uptodate(log_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1212\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(log_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse_array(real_blocks, get_desc_trans_len(desc));\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\n\t\t       real_blocks[i]->b_size);\n\t\tset_buffer_uptodate(real_blocks[i]);\n\t\tbrelse(log_blocks[i]);\n\t}\n\t/* flush out the real blocks */\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tset_buffer_dirty(real_blocks[i]);\n\t\twrite_dirty_buffer(real_blocks[i], WRITE);\n\t}\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\twait_on_buffer(real_blocks[i]);\n\t\tif (!buffer_uptodate(real_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1226\",\n\t\t\t\t\t \"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(real_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(real_blocks[i]);\n\t}\n\tcur_dblock =\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t    ((trans_offset + get_desc_trans_len(desc) +\n\t      2) % SB_ONDISK_JOURNAL_SIZE(sb));\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"journal-1095: setting journal \" \"start to offset %ld\",\n\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\n\t/*\n\t * init starting values for the first transaction, in case\n\t * this is the last transaction to be replayed.\n\t */\n\tjournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\tjournal->j_last_flush_trans_id = trans_id;\n\tjournal->j_trans_id = trans_id + 1;\n\t/* check for trans_id overflow */\n\tif (journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tbrelse(c_bh);\n\tbrelse(d_bh);\n\tkfree(log_blocks);\n\tkfree(real_blocks);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int journal_read_transaction(struct super_block *sb,\n\t\t\t\t    unsigned long cur_dblock,\n\t\t\t\t    unsigned long oldest_start,\n\t\t\t\t    unsigned int oldest_trans_id,\n\t\t\t\t    unsigned long newest_mount_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tunsigned int trans_id = 0;\n\tstruct buffer_head *c_bh;\n\tstruct buffer_head *d_bh;\n\tstruct buffer_head **log_blocks = NULL;\n\tstruct buffer_head **real_blocks = NULL;\n\tunsigned int trans_offset;\n\tint i;\n\tint trans_half;\n\n\td_bh = journal_bread(sb, cur_dblock);\n\tif (!d_bh)\n\t\treturn 1;\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\ttrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1037: \"\n\t\t       \"journal_read_transaction, offset %llu, len %d mount_id %d\",\n\t\t       d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t       get_desc_trans_len(desc), get_desc_mount_id(desc));\n\tif (get_desc_trans_id(desc) < oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1039: \"\n\t\t\t       \"journal_read_trans skipping because %lu is too old\",\n\t\t\t       cur_dblock -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tif (get_desc_mount_id(desc) != newest_mount_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1146: \"\n\t\t\t       \"journal_read_trans skipping because %d is != \"\n\t\t\t       \"newest_mount_id %lu\", get_desc_mount_id(desc),\n\t\t\t       newest_mount_id);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb)));\n\tif (!c_bh) {\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal_read_transaction, \"\n\t\t\t       \"commit offset %llu had bad time %d or length %d\",\n\t\t\t       c_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_commit_trans_id(commit),\n\t\t\t       get_commit_trans_len(commit));\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\treiserfs_warning(sb, \"clm-2076\",\n\t\t\t\t \"device is readonly, unable to replay log\");\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn -EROFS;\n\t}\n\n\ttrans_id = get_desc_trans_id(desc);\n\t/*\n\t * now we know we've got a good transaction, and it was\n\t * inside the valid time ranges\n\t */\n\tlog_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t     sizeof(struct buffer_head *), GFP_NOFS);\n\treal_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t      sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!log_blocks || !real_blocks) {\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\tkfree(log_blocks);\n\t\tkfree(real_blocks);\n\t\treiserfs_warning(sb, \"journal-1169\",\n\t\t\t\t \"kmalloc failed, unable to mount FS\");\n\t\treturn -1;\n\t}\n\t/* get all the buffer heads */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tlog_blocks[i] =\n\t\t    journal_getblk(sb,\n\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tif (i < trans_half) {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(desc->j_realblock[i]));\n\t\t} else {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]));\n\t\t}\n\t\tif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\n\t\t\treiserfs_warning(sb, \"journal-1207\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\");\n\t\t\tgoto abort_replay;\n\t\t}\n\t\t/* make sure we don't try to replay onto log or reserved area */\n\t\tif (is_block_in_log_or_reserved_area\n\t\t    (sb, real_blocks[i]->b_blocknr)) {\n\t\t\treiserfs_warning(sb, \"journal-1204\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\");\nabort_replay:\n\t\t\tbrelse_array(log_blocks, i);\n\t\t\tbrelse_array(real_blocks, i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* read in the log blocks, memcpy to the corresponding real block */\n\tll_rw_block(READ, get_desc_trans_len(desc), log_blocks);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\n\t\twait_on_buffer(log_blocks[i]);\n\t\tif (!buffer_uptodate(log_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1212\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(log_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse_array(real_blocks, get_desc_trans_len(desc));\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\n\t\t       real_blocks[i]->b_size);\n\t\tset_buffer_uptodate(real_blocks[i]);\n\t\tbrelse(log_blocks[i]);\n\t}\n\t/* flush out the real blocks */\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tset_buffer_dirty(real_blocks[i]);\n\t\twrite_dirty_buffer(real_blocks[i], WRITE);\n\t}\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\twait_on_buffer(real_blocks[i]);\n\t\tif (!buffer_uptodate(real_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1226\",\n\t\t\t\t\t \"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(real_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(real_blocks[i]);\n\t}\n\tcur_dblock =\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t    ((trans_offset + get_desc_trans_len(desc) +\n\t      2) % SB_ONDISK_JOURNAL_SIZE(sb));\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"journal-1095: setting journal \" \"start to offset %ld\",\n\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\n\t/*\n\t * init starting values for the first transaction, in case\n\t * this is the last transaction to be replayed.\n\t */\n\tjournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\tjournal->j_last_flush_trans_id = trans_id;\n\tjournal->j_trans_id = trans_id + 1;\n\t/* check for trans_id overflow */\n\tif (journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tbrelse(c_bh);\n\tbrelse(d_bh);\n\tkfree(log_blocks);\n\tkfree(real_blocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "d_bh"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_transaction_is_valid",
          "args": [
            "sb",
            "d_bh",
            "&oldest_invalid_trans_id",
            "&newest_mount_id"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "journal_transaction_is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2012-2101",
          "snippet": "static int journal_transaction_is_valid(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *d_bh,\n\t\t\t\t\tunsigned int *oldest_invalid_trans_id,\n\t\t\t\t\tunsigned long *newest_mount_id)\n{\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\n\tunsigned long offset;\n\n\tif (!d_bh)\n\t\treturn 0;\n\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\tif (get_desc_trans_len(desc) > 0\n\t    && !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\n\t\tif (oldest_invalid_trans_id && *oldest_invalid_trans_id\n\t\t    && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-986: transaction \"\n\t\t\t\t       \"is valid returning because trans_id %d is greater than \"\n\t\t\t\t       \"oldest_invalid %lu\",\n\t\t\t\t       get_desc_trans_id(desc),\n\t\t\t\t       *oldest_invalid_trans_id);\n\t\t\treturn 0;\n\t\t}\n\t\tif (newest_mount_id\n\t\t    && *newest_mount_id > get_desc_mount_id(desc)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-1087: transaction \"\n\t\t\t\t       \"is valid returning because mount_id %d is less than \"\n\t\t\t\t       \"newest_mount_id %lu\",\n\t\t\t\t       get_desc_mount_id(desc),\n\t\t\t\t       *newest_mount_id);\n\t\t\treturn -1;\n\t\t}\n\t\tif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\n\t\t\treiserfs_warning(sb, \"journal-2018\",\n\t\t\t\t\t \"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\",\n\t\t\t\t\t get_desc_trans_len(desc));\n\t\t\treturn -1;\n\t\t}\n\t\toffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\n\t\t/*\n\t\t * ok, we have a journal description block,\n\t\t * let's see if the transaction was valid\n\t\t */\n\t\tc_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\tif (!c_bh)\n\t\t\treturn 0;\n\t\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\t\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal_transaction_is_valid, commit offset %ld had bad \"\n\t\t\t\t       \"time %d or length %d\",\n\t\t\t\t       c_bh->b_blocknr -\n\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t\t       get_commit_trans_id(commit),\n\t\t\t\t       get_commit_trans_len(commit));\n\t\t\tbrelse(c_bh);\n\t\t\tif (oldest_invalid_trans_id) {\n\t\t\t\t*oldest_invalid_trans_id =\n\t\t\t\t    get_desc_trans_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1004: \"\n\t\t\t\t\t       \"transaction_is_valid setting oldest invalid trans_id \"\n\t\t\t\t\t       \"to %d\",\n\t\t\t\t\t       get_desc_trans_id(desc));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(c_bh);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\",\n\t\t\t       d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_desc_trans_len(desc),\n\t\t\t       get_desc_trans_id(desc));\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static void queue_log_writer(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_transaction_is_valid(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *d_bh,\n\t\t\t\t\tunsigned int *oldest_invalid_trans_id,\n\t\t\t\t\tunsigned long *newest_mount_id)\n{\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\n\tunsigned long offset;\n\n\tif (!d_bh)\n\t\treturn 0;\n\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\tif (get_desc_trans_len(desc) > 0\n\t    && !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\n\t\tif (oldest_invalid_trans_id && *oldest_invalid_trans_id\n\t\t    && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-986: transaction \"\n\t\t\t\t       \"is valid returning because trans_id %d is greater than \"\n\t\t\t\t       \"oldest_invalid %lu\",\n\t\t\t\t       get_desc_trans_id(desc),\n\t\t\t\t       *oldest_invalid_trans_id);\n\t\t\treturn 0;\n\t\t}\n\t\tif (newest_mount_id\n\t\t    && *newest_mount_id > get_desc_mount_id(desc)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-1087: transaction \"\n\t\t\t\t       \"is valid returning because mount_id %d is less than \"\n\t\t\t\t       \"newest_mount_id %lu\",\n\t\t\t\t       get_desc_mount_id(desc),\n\t\t\t\t       *newest_mount_id);\n\t\t\treturn -1;\n\t\t}\n\t\tif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\n\t\t\treiserfs_warning(sb, \"journal-2018\",\n\t\t\t\t\t \"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\",\n\t\t\t\t\t get_desc_trans_len(desc));\n\t\t\treturn -1;\n\t\t}\n\t\toffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\n\t\t/*\n\t\t * ok, we have a journal description block,\n\t\t * let's see if the transaction was valid\n\t\t */\n\t\tc_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\tif (!c_bh)\n\t\t\treturn 0;\n\t\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\t\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal_transaction_is_valid, commit offset %ld had bad \"\n\t\t\t\t       \"time %d or length %d\",\n\t\t\t\t       c_bh->b_blocknr -\n\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t\t       get_commit_trans_id(commit),\n\t\t\t\t       get_commit_trans_len(commit));\n\t\t\tbrelse(c_bh);\n\t\t\tif (oldest_invalid_trans_id) {\n\t\t\t\t*oldest_invalid_trans_id =\n\t\t\t\t    get_desc_trans_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1004: \"\n\t\t\t\t\t       \"transaction_is_valid setting oldest invalid trans_id \"\n\t\t\t\t\t       \"to %d\",\n\t\t\t\t\t       get_desc_trans_id(desc));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(c_bh);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\",\n\t\t\t       d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_desc_trans_len(desc),\n\t\t\t       get_desc_trans_id(desc));\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_breada",
          "args": [
            "journal->j_dev_bd",
            "cur_dblock",
            "sb->s_blocksize",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_breada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2325-2360",
          "snippet": "static struct buffer_head *reiserfs_breada(struct block_device *dev,\n\t\t\t\t\t   b_blocknr_t block, int bufsize,\n\t\t\t\t\t   b_blocknr_t max_block)\n{\n\tstruct buffer_head *bhlist[BUFNR];\n\tunsigned int blocks = BUFNR;\n\tstruct buffer_head *bh;\n\tint i, j;\n\n\tbh = __getblk(dev, block, bufsize);\n\tif (buffer_uptodate(bh))\n\t\treturn (bh);\n\n\tif (block + BUFNR > max_block) {\n\t\tblocks = max_block - block;\n\t}\n\tbhlist[0] = bh;\n\tj = 1;\n\tfor (i = 1; i < blocks; i++) {\n\t\tbh = __getblk(dev, block + i, bufsize);\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else\n\t\t\tbhlist[j++] = bh;\n\t}\n\tll_rw_block(READ, j, bhlist);\n\tfor (i = 1; i < j; i++)\n\t\tbrelse(bhlist[i]);\n\tbh = bhlist[0];\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define BUFNR 64\t\t/*read ahead */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BUFNR 64\t\t/*read ahead */\n\nstatic struct buffer_head *reiserfs_breada(struct block_device *dev,\n\t\t\t\t\t   b_blocknr_t block, int bufsize,\n\t\t\t\t\t   b_blocknr_t max_block)\n{\n\tstruct buffer_head *bhlist[BUFNR];\n\tunsigned int blocks = BUFNR;\n\tstruct buffer_head *bh;\n\tint i, j;\n\n\tbh = __getblk(dev, block, bufsize);\n\tif (buffer_uptodate(bh))\n\t\treturn (bh);\n\n\tif (block + BUFNR > max_block) {\n\t\tblocks = max_block - block;\n\t}\n\tbhlist[0] = bh;\n\tj = 1;\n\tfor (i = 1; i < blocks; i++) {\n\t\tbh = __getblk(dev, block + i, bufsize);\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else\n\t\t\tbhlist[j++] = bh;\n\t}\n\tll_rw_block(READ, j, bhlist);\n\tfor (i = 1; i < j; i++)\n\t\tbrelse(bhlist[i]);\n\tbh = bhlist[0];\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset)"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb)"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev_bd",
            "b"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_read(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tunsigned int oldest_trans_id = 0;\n\tunsigned int oldest_invalid_trans_id = 0;\n\ttime_t start;\n\tunsigned long oldest_start = 0;\n\tunsigned long cur_dblock = 0;\n\tunsigned long newest_mount_id = 9;\n\tstruct buffer_head *d_bh;\n\tstruct reiserfs_journal_header *jh;\n\tint valid_journal_header = 0;\n\tint replay_count = 0;\n\tint continue_replay = 1;\n\tint ret;\n\tchar b[BDEVNAME_SIZE];\n\n\tcur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_info(sb, \"checking transaction log (%s)\\n\",\n\t\t      bdevname(journal->j_dev_bd, b));\n\tstart = get_seconds();\n\n\t/*\n\t * step 1, read in the journal header block.  Check the transaction\n\t * it says is the first unflushed, and if that transaction is not\n\t * valid, replay is done\n\t */\n\tjournal->j_header_bh = journal_bread(sb,\n\t\t\t\t\t     SB_ONDISK_JOURNAL_1st_BLOCK(sb)\n\t\t\t\t\t     + SB_ONDISK_JOURNAL_SIZE(sb));\n\tif (!journal->j_header_bh) {\n\t\treturn 1;\n\t}\n\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->b_data);\n\tif (le32_to_cpu(jh->j_first_unflushed_offset) <\n\t    SB_ONDISK_JOURNAL_SIZE(sb)\n\t    && le32_to_cpu(jh->j_last_flush_trans_id) > 0) {\n\t\toldest_start =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t    le32_to_cpu(jh->j_first_unflushed_offset);\n\t\toldest_trans_id = le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\tnewest_mount_id = le32_to_cpu(jh->j_mount_id);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1153: found in \"\n\t\t\t       \"header: first_unflushed_offset %d, last_flushed_trans_id \"\n\t\t\t       \"%lu\", le32_to_cpu(jh->j_first_unflushed_offset),\n\t\t\t       le32_to_cpu(jh->j_last_flush_trans_id));\n\t\tvalid_journal_header = 1;\n\n\t\t/*\n\t\t * now, we try to read the first unflushed offset.  If it\n\t\t * is not valid, there is nothing more we can do, and it\n\t\t * makes no sense to read through the whole log.\n\t\t */\n\t\td_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  le32_to_cpu(jh->j_first_unflushed_offset));\n\t\tret = journal_transaction_is_valid(sb, d_bh, NULL, NULL);\n\t\tif (!ret) {\n\t\t\tcontinue_replay = 0;\n\t\t}\n\t\tbrelse(d_bh);\n\t\tgoto start_log_replay;\n\t}\n\n\t/*\n\t * ok, there are transactions that need to be replayed.  start\n\t * with the first log block, find all the valid transactions, and\n\t * pick out the oldest.\n\t */\n\twhile (continue_replay\n\t       && cur_dblock <\n\t       (SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\tSB_ONDISK_JOURNAL_SIZE(sb))) {\n\t\t/*\n\t\t * Note that it is required for blocksize of primary fs\n\t\t * device and journal device to be the same\n\t\t */\n\t\td_bh =\n\t\t    reiserfs_breada(journal->j_dev_bd, cur_dblock,\n\t\t\t\t    sb->s_blocksize,\n\t\t\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tret =\n\t\t    journal_transaction_is_valid(sb, d_bh,\n\t\t\t\t\t\t &oldest_invalid_trans_id,\n\t\t\t\t\t\t &newest_mount_id);\n\t\tif (ret == 1) {\n\t\t\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\t\t\tif (oldest_start == 0) {\t/* init all oldest_ values */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1179: Setting \"\n\t\t\t\t\t       \"oldest_start to offset %llu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t} else if (oldest_trans_id > get_desc_trans_id(desc)) {\n\t\t\t\t/* one we just read was older */\n\t\t\t\toldest_trans_id = get_desc_trans_id(desc);\n\t\t\t\toldest_start = d_bh->b_blocknr;\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1180: Resetting \"\n\t\t\t\t\t       \"oldest_start to offset %lu, trans_id %lu\",\n\t\t\t\t\t       oldest_start -\n\t\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK\n\t\t\t\t\t       (sb), oldest_trans_id);\n\t\t\t}\n\t\t\tif (newest_mount_id < get_desc_mount_id(desc)) {\n\t\t\t\tnewest_mount_id = get_desc_mount_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1299: Setting \"\n\t\t\t\t\t       \"newest_mount_id to %d\",\n\t\t\t\t\t       get_desc_mount_id(desc));\n\t\t\t}\n\t\t\tcur_dblock += get_desc_trans_len(desc) + 2;\n\t\t} else {\n\t\t\tcur_dblock++;\n\t\t}\n\t\tbrelse(d_bh);\n\t}\n\nstart_log_replay:\n\tcur_dblock = oldest_start;\n\tif (oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1206: Starting replay \"\n\t\t\t       \"from offset %llu, trans_id %lu\",\n\t\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       oldest_trans_id);\n\n\t}\n\treplay_count = 0;\n\twhile (continue_replay && oldest_trans_id > 0) {\n\t\tret =\n\t\t    journal_read_transaction(sb, cur_dblock, oldest_start,\n\t\t\t\t\t     oldest_trans_id, newest_mount_id);\n\t\tif (ret < 0) {\n\t\t\treturn ret;\n\t\t} else if (ret != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_dblock =\n\t\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) + journal->j_start;\n\t\treplay_count++;\n\t\tif (cur_dblock == oldest_start)\n\t\t\tbreak;\n\t}\n\n\tif (oldest_trans_id == 0) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1225: No valid \" \"transactions found\");\n\t}\n\t/*\n\t * j_start does not get set correctly if we don't replay any\n\t * transactions.  if we had a valid journal_header, set j_start\n\t * to the first unflushed transaction value, copy the trans_id\n\t * from the header\n\t */\n\tif (valid_journal_header && replay_count == 0) {\n\t\tjournal->j_start = le32_to_cpu(jh->j_first_unflushed_offset);\n\t\tjournal->j_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id) + 1;\n\t\t/* check for trans_id overflow */\n\t\tif (journal->j_trans_id == 0)\n\t\t\tjournal->j_trans_id = 10;\n\t\tjournal->j_last_flush_trans_id =\n\t\t    le32_to_cpu(jh->j_last_flush_trans_id);\n\t\tjournal->j_mount_id = le32_to_cpu(jh->j_mount_id) + 1;\n\t} else {\n\t\tjournal->j_mount_id = newest_mount_id + 1;\n\t}\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1299: Setting \"\n\t\t       \"newest_mount_id to %lu\", journal->j_mount_id);\n\tjournal->j_first_unflushed_offset = journal->j_start;\n\tif (replay_count > 0) {\n\t\treiserfs_info(sb,\n\t\t\t      \"replayed %d transactions in %lu seconds\\n\",\n\t\t\t      replay_count, get_seconds() - start);\n\t}\n\t/* needed to satisfy the locking in _update_journal_header_block */\n\treiserfs_write_lock(sb);\n\tif (!bdev_read_only(sb->s_bdev) &&\n\t    _update_journal_header_block(sb, journal->j_start,\n\t\t\t\t\t journal->j_last_flush_trans_id)) {\n\t\treiserfs_write_unlock(sb);\n\t\t/*\n\t\t * replay failed, caller must call free_journal_ram and abort\n\t\t * the mount\n\t\t */\n\t\treturn -1;\n\t}\n\treiserfs_write_unlock(sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_breada",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2325-2360",
    "snippet": "static struct buffer_head *reiserfs_breada(struct block_device *dev,\n\t\t\t\t\t   b_blocknr_t block, int bufsize,\n\t\t\t\t\t   b_blocknr_t max_block)\n{\n\tstruct buffer_head *bhlist[BUFNR];\n\tunsigned int blocks = BUFNR;\n\tstruct buffer_head *bh;\n\tint i, j;\n\n\tbh = __getblk(dev, block, bufsize);\n\tif (buffer_uptodate(bh))\n\t\treturn (bh);\n\n\tif (block + BUFNR > max_block) {\n\t\tblocks = max_block - block;\n\t}\n\tbhlist[0] = bh;\n\tj = 1;\n\tfor (i = 1; i < blocks; i++) {\n\t\tbh = __getblk(dev, block + i, bufsize);\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else\n\t\t\tbhlist[j++] = bh;\n\t}\n\tll_rw_block(READ, j, bhlist);\n\tfor (i = 1; i < j; i++)\n\t\tbrelse(bhlist[i]);\n\tbh = bhlist[0];\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define BUFNR 64\t\t/*read ahead */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "j",
            "bhlist"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "dev",
            "block + i",
            "bufsize"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "dev",
            "block",
            "bufsize"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BUFNR 64\t\t/*read ahead */\n\nstatic struct buffer_head *reiserfs_breada(struct block_device *dev,\n\t\t\t\t\t   b_blocknr_t block, int bufsize,\n\t\t\t\t\t   b_blocknr_t max_block)\n{\n\tstruct buffer_head *bhlist[BUFNR];\n\tunsigned int blocks = BUFNR;\n\tstruct buffer_head *bh;\n\tint i, j;\n\n\tbh = __getblk(dev, block, bufsize);\n\tif (buffer_uptodate(bh))\n\t\treturn (bh);\n\n\tif (block + BUFNR > max_block) {\n\t\tblocks = max_block - block;\n\t}\n\tbhlist[0] = bh;\n\tj = 1;\n\tfor (i = 1; i < blocks; i++) {\n\t\tbh = __getblk(dev, block + i, bufsize);\n\t\tif (buffer_uptodate(bh)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t} else\n\t\t\tbhlist[j++] = bh;\n\t}\n\tll_rw_block(READ, j, bhlist);\n\tfor (i = 1; i < j; i++)\n\t\tbrelse(bhlist[i]);\n\tbh = bhlist[0];\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tbrelse(bh);\n\treturn NULL;\n}"
  },
  {
    "function_name": "journal_read_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2117-2315",
    "snippet": "static int journal_read_transaction(struct super_block *sb,\n\t\t\t\t    unsigned long cur_dblock,\n\t\t\t\t    unsigned long oldest_start,\n\t\t\t\t    unsigned int oldest_trans_id,\n\t\t\t\t    unsigned long newest_mount_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tunsigned int trans_id = 0;\n\tstruct buffer_head *c_bh;\n\tstruct buffer_head *d_bh;\n\tstruct buffer_head **log_blocks = NULL;\n\tstruct buffer_head **real_blocks = NULL;\n\tunsigned int trans_offset;\n\tint i;\n\tint trans_half;\n\n\td_bh = journal_bread(sb, cur_dblock);\n\tif (!d_bh)\n\t\treturn 1;\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\ttrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1037: \"\n\t\t       \"journal_read_transaction, offset %llu, len %d mount_id %d\",\n\t\t       d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t       get_desc_trans_len(desc), get_desc_mount_id(desc));\n\tif (get_desc_trans_id(desc) < oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1039: \"\n\t\t\t       \"journal_read_trans skipping because %lu is too old\",\n\t\t\t       cur_dblock -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tif (get_desc_mount_id(desc) != newest_mount_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1146: \"\n\t\t\t       \"journal_read_trans skipping because %d is != \"\n\t\t\t       \"newest_mount_id %lu\", get_desc_mount_id(desc),\n\t\t\t       newest_mount_id);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb)));\n\tif (!c_bh) {\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal_read_transaction, \"\n\t\t\t       \"commit offset %llu had bad time %d or length %d\",\n\t\t\t       c_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_commit_trans_id(commit),\n\t\t\t       get_commit_trans_len(commit));\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\treiserfs_warning(sb, \"clm-2076\",\n\t\t\t\t \"device is readonly, unable to replay log\");\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn -EROFS;\n\t}\n\n\ttrans_id = get_desc_trans_id(desc);\n\t/*\n\t * now we know we've got a good transaction, and it was\n\t * inside the valid time ranges\n\t */\n\tlog_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t     sizeof(struct buffer_head *), GFP_NOFS);\n\treal_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t      sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!log_blocks || !real_blocks) {\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\tkfree(log_blocks);\n\t\tkfree(real_blocks);\n\t\treiserfs_warning(sb, \"journal-1169\",\n\t\t\t\t \"kmalloc failed, unable to mount FS\");\n\t\treturn -1;\n\t}\n\t/* get all the buffer heads */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tlog_blocks[i] =\n\t\t    journal_getblk(sb,\n\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tif (i < trans_half) {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(desc->j_realblock[i]));\n\t\t} else {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]));\n\t\t}\n\t\tif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\n\t\t\treiserfs_warning(sb, \"journal-1207\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\");\n\t\t\tgoto abort_replay;\n\t\t}\n\t\t/* make sure we don't try to replay onto log or reserved area */\n\t\tif (is_block_in_log_or_reserved_area\n\t\t    (sb, real_blocks[i]->b_blocknr)) {\n\t\t\treiserfs_warning(sb, \"journal-1204\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\");\nabort_replay:\n\t\t\tbrelse_array(log_blocks, i);\n\t\t\tbrelse_array(real_blocks, i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* read in the log blocks, memcpy to the corresponding real block */\n\tll_rw_block(READ, get_desc_trans_len(desc), log_blocks);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\n\t\twait_on_buffer(log_blocks[i]);\n\t\tif (!buffer_uptodate(log_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1212\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(log_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse_array(real_blocks, get_desc_trans_len(desc));\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\n\t\t       real_blocks[i]->b_size);\n\t\tset_buffer_uptodate(real_blocks[i]);\n\t\tbrelse(log_blocks[i]);\n\t}\n\t/* flush out the real blocks */\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tset_buffer_dirty(real_blocks[i]);\n\t\twrite_dirty_buffer(real_blocks[i], WRITE);\n\t}\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\twait_on_buffer(real_blocks[i]);\n\t\tif (!buffer_uptodate(real_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1226\",\n\t\t\t\t\t \"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(real_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(real_blocks[i]);\n\t}\n\tcur_dblock =\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t    ((trans_offset + get_desc_trans_len(desc) +\n\t      2) % SB_ONDISK_JOURNAL_SIZE(sb));\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"journal-1095: setting journal \" \"start to offset %ld\",\n\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\n\t/*\n\t * init starting values for the first transaction, in case\n\t * this is the last transaction to be replayed.\n\t */\n\tjournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\tjournal->j_last_flush_trans_id = trans_id;\n\tjournal->j_trans_id = trans_id + 1;\n\t/* check for trans_id overflow */\n\tif (journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tbrelse(c_bh);\n\tbrelse(d_bh);\n\tkfree(log_blocks);\n\tkfree(real_blocks);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "real_blocks"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_blocks"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "d_bh"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_debug",
          "args": [
            "sb",
            "REISERFS_DEBUG_CODE",
            "\"journal-1095: setting journal \" \"start to offset %ld\"",
            "cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb)"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "297-307",
          "snippet": "void reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "real_blocks"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_blocks"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse_array",
          "args": [
            "real_blocks + i",
            "get_desc_trans_len(desc) - i"
          ],
          "line": 2282
        },
        "resolved": true,
        "details": {
          "function_name": "brelse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2103-2109",
          "snippet": "static void brelse_array(struct buffer_head **heads, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tbrelse(heads[i]);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void brelse_array(struct buffer_head **heads, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tbrelse(heads[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1226\"",
            "\"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\""
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "real_blocks[i]"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "real_blocks[i]"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "real_blocks[i]",
            "WRITE"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "real_blocks[i]"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "real_blocks[i]->b_data",
            "log_blocks[i]->b_data",
            "real_blocks[i]->b_size"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "real_blocks"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_blocks"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1212\"",
            "\"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\""
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "get_desc_trans_len(desc)",
            "log_blocks"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "real_blocks"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_blocks"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1204\"",
            "\"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_block_in_log_or_reserved_area",
          "args": [
            "sb",
            "real_blocks[i]->b_blocknr"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1207\"",
            "\"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\""
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BLOCK_COUNT",
          "args": [
            "sb"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half])"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "le32_to_cpu(desc->j_realblock[i])"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_getblk",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb)"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_trans_half",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-1169\"",
            "\"kmalloc failed, unable to mount FS\""
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "real_blocks"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "log_blocks"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "get_desc_trans_len(desc) *\n\t\t\t      sizeof(struct buffer_head *)",
            "GFP_NOFS"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"clm-2076\"",
            "\"device is readonly, unable to replay log\""
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_len",
          "args": [
            "commit"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_id",
          "args": [
            "commit"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_compare_desc_commit",
          "args": [
            "sb",
            "desc",
            "commit"
          ],
          "line": 2168
        },
        "resolved": true,
        "details": {
          "function_name": "journal_compare_desc_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1993-2004",
          "snippet": "static int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb))"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "cur_dblock"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int journal_read_transaction(struct super_block *sb,\n\t\t\t\t    unsigned long cur_dblock,\n\t\t\t\t    unsigned long oldest_start,\n\t\t\t\t    unsigned int oldest_trans_id,\n\t\t\t\t    unsigned long newest_mount_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tunsigned int trans_id = 0;\n\tstruct buffer_head *c_bh;\n\tstruct buffer_head *d_bh;\n\tstruct buffer_head **log_blocks = NULL;\n\tstruct buffer_head **real_blocks = NULL;\n\tunsigned int trans_offset;\n\tint i;\n\tint trans_half;\n\n\td_bh = journal_bread(sb, cur_dblock);\n\tif (!d_bh)\n\t\treturn 1;\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\ttrans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1037: \"\n\t\t       \"journal_read_transaction, offset %llu, len %d mount_id %d\",\n\t\t       d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t       get_desc_trans_len(desc), get_desc_mount_id(desc));\n\tif (get_desc_trans_id(desc) < oldest_trans_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1039: \"\n\t\t\t       \"journal_read_trans skipping because %lu is too old\",\n\t\t\t       cur_dblock -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tif (get_desc_mount_id(desc) != newest_mount_id) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE, \"journal-1146: \"\n\t\t\t       \"journal_read_trans skipping because %d is != \"\n\t\t\t       \"newest_mount_id %lu\", get_desc_mount_id(desc),\n\t\t\t       newest_mount_id);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tc_bh = journal_bread(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t     ((trans_offset + get_desc_trans_len(desc) + 1) %\n\t\t\t      SB_ONDISK_JOURNAL_SIZE(sb)));\n\tif (!c_bh) {\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal_read_transaction, \"\n\t\t\t       \"commit offset %llu had bad time %d or length %d\",\n\t\t\t       c_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_commit_trans_id(commit),\n\t\t\t       get_commit_trans_len(commit));\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn 1;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\treiserfs_warning(sb, \"clm-2076\",\n\t\t\t\t \"device is readonly, unable to replay log\");\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\treturn -EROFS;\n\t}\n\n\ttrans_id = get_desc_trans_id(desc);\n\t/*\n\t * now we know we've got a good transaction, and it was\n\t * inside the valid time ranges\n\t */\n\tlog_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t     sizeof(struct buffer_head *), GFP_NOFS);\n\treal_blocks = kmalloc(get_desc_trans_len(desc) *\n\t\t\t      sizeof(struct buffer_head *), GFP_NOFS);\n\tif (!log_blocks || !real_blocks) {\n\t\tbrelse(c_bh);\n\t\tbrelse(d_bh);\n\t\tkfree(log_blocks);\n\t\tkfree(real_blocks);\n\t\treiserfs_warning(sb, \"journal-1169\",\n\t\t\t\t \"kmalloc failed, unable to mount FS\");\n\t\treturn -1;\n\t}\n\t/* get all the buffer heads */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tlog_blocks[i] =\n\t\t    journal_getblk(sb,\n\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t   (trans_offset + 1 +\n\t\t\t\t    i) % SB_ONDISK_JOURNAL_SIZE(sb));\n\t\tif (i < trans_half) {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(desc->j_realblock[i]));\n\t\t} else {\n\t\t\treal_blocks[i] =\n\t\t\t    sb_getblk(sb,\n\t\t\t\t      le32_to_cpu(commit->\n\t\t\t\t\t\t  j_realblock[i - trans_half]));\n\t\t}\n\t\tif (real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(sb)) {\n\t\t\treiserfs_warning(sb, \"journal-1207\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Block to replay is outside of \"\n\t\t\t\t\t \"filesystem\");\n\t\t\tgoto abort_replay;\n\t\t}\n\t\t/* make sure we don't try to replay onto log or reserved area */\n\t\tif (is_block_in_log_or_reserved_area\n\t\t    (sb, real_blocks[i]->b_blocknr)) {\n\t\t\treiserfs_warning(sb, \"journal-1204\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"Trying to replay onto a log block\");\nabort_replay:\n\t\t\tbrelse_array(log_blocks, i);\n\t\t\tbrelse_array(real_blocks, i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* read in the log blocks, memcpy to the corresponding real block */\n\tll_rw_block(READ, get_desc_trans_len(desc), log_blocks);\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\n\t\twait_on_buffer(log_blocks[i]);\n\t\tif (!buffer_uptodate(log_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1212\",\n\t\t\t\t\t \"REPLAY FAILURE fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(log_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse_array(real_blocks, get_desc_trans_len(desc));\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(real_blocks[i]->b_data, log_blocks[i]->b_data,\n\t\t       real_blocks[i]->b_size);\n\t\tset_buffer_uptodate(real_blocks[i]);\n\t\tbrelse(log_blocks[i]);\n\t}\n\t/* flush out the real blocks */\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\tset_buffer_dirty(real_blocks[i]);\n\t\twrite_dirty_buffer(real_blocks[i], WRITE);\n\t}\n\tfor (i = 0; i < get_desc_trans_len(desc); i++) {\n\t\twait_on_buffer(real_blocks[i]);\n\t\tif (!buffer_uptodate(real_blocks[i])) {\n\t\t\treiserfs_warning(sb, \"journal-1226\",\n\t\t\t\t\t \"REPLAY FAILURE, fsck required! \"\n\t\t\t\t\t \"buffer write failed\");\n\t\t\tbrelse_array(real_blocks + i,\n\t\t\t\t     get_desc_trans_len(desc) - i);\n\t\t\tbrelse(c_bh);\n\t\t\tbrelse(d_bh);\n\t\t\tkfree(log_blocks);\n\t\t\tkfree(real_blocks);\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(real_blocks[i]);\n\t}\n\tcur_dblock =\n\t    SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t    ((trans_offset + get_desc_trans_len(desc) +\n\t      2) % SB_ONDISK_JOURNAL_SIZE(sb));\n\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t       \"journal-1095: setting journal \" \"start to offset %ld\",\n\t\t       cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb));\n\n\t/*\n\t * init starting values for the first transaction, in case\n\t * this is the last transaction to be replayed.\n\t */\n\tjournal->j_start = cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\tjournal->j_last_flush_trans_id = trans_id;\n\tjournal->j_trans_id = trans_id + 1;\n\t/* check for trans_id overflow */\n\tif (journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tbrelse(c_bh);\n\tbrelse(d_bh);\n\tkfree(log_blocks);\n\tkfree(real_blocks);\n\treturn 0;\n}"
  },
  {
    "function_name": "brelse_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2103-2109",
    "snippet": "static void brelse_array(struct buffer_head **heads, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tbrelse(heads[i]);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "heads[i]"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void brelse_array(struct buffer_head **heads, int num)\n{\n\tint i;\n\tfor (i = 0; i < num; i++) {\n\t\tbrelse(heads[i]);\n\t}\n}"
  },
  {
    "function_name": "journal_transaction_is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "2012-2101",
    "snippet": "static int journal_transaction_is_valid(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *d_bh,\n\t\t\t\t\tunsigned int *oldest_invalid_trans_id,\n\t\t\t\t\tunsigned long *newest_mount_id)\n{\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\n\tunsigned long offset;\n\n\tif (!d_bh)\n\t\treturn 0;\n\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\tif (get_desc_trans_len(desc) > 0\n\t    && !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\n\t\tif (oldest_invalid_trans_id && *oldest_invalid_trans_id\n\t\t    && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-986: transaction \"\n\t\t\t\t       \"is valid returning because trans_id %d is greater than \"\n\t\t\t\t       \"oldest_invalid %lu\",\n\t\t\t\t       get_desc_trans_id(desc),\n\t\t\t\t       *oldest_invalid_trans_id);\n\t\t\treturn 0;\n\t\t}\n\t\tif (newest_mount_id\n\t\t    && *newest_mount_id > get_desc_mount_id(desc)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-1087: transaction \"\n\t\t\t\t       \"is valid returning because mount_id %d is less than \"\n\t\t\t\t       \"newest_mount_id %lu\",\n\t\t\t\t       get_desc_mount_id(desc),\n\t\t\t\t       *newest_mount_id);\n\t\t\treturn -1;\n\t\t}\n\t\tif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\n\t\t\treiserfs_warning(sb, \"journal-2018\",\n\t\t\t\t\t \"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\",\n\t\t\t\t\t get_desc_trans_len(desc));\n\t\t\treturn -1;\n\t\t}\n\t\toffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\n\t\t/*\n\t\t * ok, we have a journal description block,\n\t\t * let's see if the transaction was valid\n\t\t */\n\t\tc_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\tif (!c_bh)\n\t\t\treturn 0;\n\t\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\t\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal_transaction_is_valid, commit offset %ld had bad \"\n\t\t\t\t       \"time %d or length %d\",\n\t\t\t\t       c_bh->b_blocknr -\n\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t\t       get_commit_trans_id(commit),\n\t\t\t\t       get_commit_trans_len(commit));\n\t\t\tbrelse(c_bh);\n\t\t\tif (oldest_invalid_trans_id) {\n\t\t\t\t*oldest_invalid_trans_id =\n\t\t\t\t    get_desc_trans_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1004: \"\n\t\t\t\t\t       \"transaction_is_valid setting oldest invalid trans_id \"\n\t\t\t\t\t       \"to %d\",\n\t\t\t\t\t       get_desc_trans_id(desc));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(c_bh);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\",\n\t\t\t       d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_desc_trans_len(desc),\n\t\t\t       get_desc_trans_id(desc));\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_debug",
          "args": [
            "sb",
            "REISERFS_DEBUG_CODE",
            "\"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\"",
            "d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb)",
            "get_desc_trans_len(desc)",
            "get_desc_trans_id(desc)"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "297-307",
          "snippet": "void reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\n{\n#ifdef CONFIG_REISERFS_CHECK\n\tdo_reiserfs_warning(fmt);\n\tif (s)\n\t\tprintk(KERN_DEBUG \"REISERFS debug (device %s): %s\\n\",\n\t\t       s->s_id, error_buf);\n\telse\n\t\tprintk(KERN_DEBUG \"REISERFS debug: %s\\n\", error_buf);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "c_bh"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_len",
          "args": [
            "commit"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_id",
          "args": [
            "commit"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_compare_desc_commit",
          "args": [
            "sb",
            "desc",
            "commit"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "journal_compare_desc_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1993-2004",
          "snippet": "static int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_bread",
          "args": [
            "sb",
            "SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb))"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "sb"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-2018\"",
            "\"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\"",
            "get_desc_trans_len(desc)"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_mount_id",
          "args": [
            "desc"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "get_journal_desc_magic(d_bh)",
            "JOURNAL_DESC_MAGIC",
            "8"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_journal_desc_magic",
          "args": [
            "d_bh"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int journal_transaction_is_valid(struct super_block *sb,\n\t\t\t\t\tstruct buffer_head *d_bh,\n\t\t\t\t\tunsigned int *oldest_invalid_trans_id,\n\t\t\t\t\tunsigned long *newest_mount_id)\n{\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\n\tunsigned long offset;\n\n\tif (!d_bh)\n\t\treturn 0;\n\n\tdesc = (struct reiserfs_journal_desc *)d_bh->b_data;\n\tif (get_desc_trans_len(desc) > 0\n\t    && !memcmp(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8)) {\n\t\tif (oldest_invalid_trans_id && *oldest_invalid_trans_id\n\t\t    && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-986: transaction \"\n\t\t\t\t       \"is valid returning because trans_id %d is greater than \"\n\t\t\t\t       \"oldest_invalid %lu\",\n\t\t\t\t       get_desc_trans_id(desc),\n\t\t\t\t       *oldest_invalid_trans_id);\n\t\t\treturn 0;\n\t\t}\n\t\tif (newest_mount_id\n\t\t    && *newest_mount_id > get_desc_mount_id(desc)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal-1087: transaction \"\n\t\t\t\t       \"is valid returning because mount_id %d is less than \"\n\t\t\t\t       \"newest_mount_id %lu\",\n\t\t\t\t       get_desc_mount_id(desc),\n\t\t\t\t       *newest_mount_id);\n\t\t\treturn -1;\n\t\t}\n\t\tif (get_desc_trans_len(desc) > SB_JOURNAL(sb)->j_trans_max) {\n\t\t\treiserfs_warning(sb, \"journal-2018\",\n\t\t\t\t\t \"Bad transaction length %d \"\n\t\t\t\t\t \"encountered, ignoring transaction\",\n\t\t\t\t\t get_desc_trans_len(desc));\n\t\t\treturn -1;\n\t\t}\n\t\toffset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(sb);\n\n\t\t/*\n\t\t * ok, we have a journal description block,\n\t\t * let's see if the transaction was valid\n\t\t */\n\t\tc_bh =\n\t\t    journal_bread(sb,\n\t\t\t\t  SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t  ((offset + get_desc_trans_len(desc) +\n\t\t\t\t    1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\tif (!c_bh)\n\t\t\treturn 0;\n\t\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\t\tif (journal_compare_desc_commit(sb, desc, commit)) {\n\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t       \"journal_transaction_is_valid, commit offset %ld had bad \"\n\t\t\t\t       \"time %d or length %d\",\n\t\t\t\t       c_bh->b_blocknr -\n\t\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t\t       get_commit_trans_id(commit),\n\t\t\t\t       get_commit_trans_len(commit));\n\t\t\tbrelse(c_bh);\n\t\t\tif (oldest_invalid_trans_id) {\n\t\t\t\t*oldest_invalid_trans_id =\n\t\t\t\t    get_desc_trans_id(desc);\n\t\t\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t\t\t       \"journal-1004: \"\n\t\t\t\t\t       \"transaction_is_valid setting oldest invalid trans_id \"\n\t\t\t\t\t       \"to %d\",\n\t\t\t\t\t       get_desc_trans_id(desc));\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tbrelse(c_bh);\n\t\treiserfs_debug(sb, REISERFS_DEBUG_CODE,\n\t\t\t       \"journal-1006: found valid \"\n\t\t\t       \"transaction start offset %llu, len %d id %d\",\n\t\t\t       d_bh->b_blocknr -\n\t\t\t       SB_ONDISK_JOURNAL_1st_BLOCK(sb),\n\t\t\t       get_desc_trans_len(desc),\n\t\t\t       get_desc_trans_id(desc));\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "journal_compare_desc_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1993-2004",
    "snippet": "static int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_commit_trans_len",
          "args": [
            "commit"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_len",
          "args": [
            "commit"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_len",
          "args": [
            "desc"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_len",
          "args": [
            "commit"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_desc_trans_id",
          "args": [
            "desc"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commit_trans_id",
          "args": [
            "commit"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int journal_compare_desc_commit(struct super_block *sb,\n\t\t\t\t       struct reiserfs_journal_desc *desc,\n\t\t\t\t       struct reiserfs_journal_commit *commit)\n{\n\tif (get_commit_trans_id(commit) != get_desc_trans_id(desc) ||\n\t    get_commit_trans_len(commit) != get_desc_trans_len(desc) ||\n\t    get_commit_trans_len(commit) > SB_JOURNAL(sb)->j_trans_max ||\n\t    get_commit_trans_len(commit) <= 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_release_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1983-1987",
    "snippet": "int journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_release",
          "args": [
            "th",
            "sb",
            "1"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1910-1973",
          "snippet": "static int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_release_error(struct reiserfs_transaction_handle *th,\n\t\t\t  struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 1);\n}"
  },
  {
    "function_name": "journal_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1976-1980",
    "snippet": "int journal_release(struct reiserfs_transaction_handle *th,\n\t\t    struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_journal_release",
          "args": [
            "th",
            "sb",
            "0"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1910-1973",
          "snippet": "static int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_release(struct reiserfs_transaction_handle *th,\n\t\t    struct super_block *sb)\n{\n\treturn do_journal_release(th, sb, 0);\n}"
  },
  {
    "function_name": "do_journal_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1910-1973",
    "snippet": "static int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock",
          "args": [
            "sb"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_journal_ram",
          "args": [
            "sb"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "free_journal_ram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1886-1904",
          "snippet": "static void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&SB_JOURNAL(sb)->j_work"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&REISERFS_SB(sb)->old_work"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REISERFS_SB",
          "args": [
            "sb"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "REISERFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1152-1155",
          "snippet": "static inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline struct reiserfs_sb_info *REISERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock",
          "args": [
            "sb"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_journal_end",
          "args": [
            "&myth",
            "FLUSH_ALL"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3980-4385",
          "snippet": "static int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define WAIT        4\t\t/* wait for the log blocks to hit the disk */",
            "#define COMMIT_NOW  2\t\t/* end and commit this transaction */",
            "#define FLUSH_ALL   1\t\t/* flush commit and real blocks */",
            "#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */"
          ],
          "globals_used": [
            "static int do_journal_end(struct reiserfs_transaction_handle *, int flags);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define WAIT        4\t\t/* wait for the log blocks to hit the disk */\n#define COMMIT_NOW  2\t\t/* end and commit this transaction */\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n#define LIST_COMMIT_PENDING  4\t/* someone will commit this list */\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *, int flags);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic int do_journal_begin_r(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb,\n\t\t\t      unsigned long nblocks, int join);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int do_journal_end(struct reiserfs_transaction_handle *th, int flags)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *next, *jl_cn;\n\tstruct reiserfs_journal_cnode *last_cn = NULL;\n\tstruct reiserfs_journal_desc *desc;\n\tstruct reiserfs_journal_commit *commit;\n\tstruct buffer_head *c_bh;\t/* commit bh */\n\tstruct buffer_head *d_bh;\t/* desc bh */\n\tint cur_write_start = 0;\t/* start index of current log write */\n\tint old_start;\n\tint i;\n\tint flush;\n\tint wait_on_commit;\n\tstruct reiserfs_journal_list *jl, *temp_jl;\n\tstruct list_head *entry, *safe;\n\tunsigned long jindex;\n\tunsigned int commit_trans_id;\n\tint trans_half;\n\tint depth;\n\n\tBUG_ON(th->t_refcount > 1);\n\tBUG_ON(!th->t_trans_id);\n\tBUG_ON(!th->t_super);\n\n\t/*\n\t * protect flush_older_commits from doing mistakes if the\n\t * transaction ID counter gets overflowed.\n\t */\n\tif (th->t_trans_id == ~0U)\n\t\tflags |= FLUSH_ALL | COMMIT_NOW | WAIT;\n\tflush = flags & FLUSH_ALL;\n\twait_on_commit = flags & WAIT;\n\n\tcurrent->journal_info = th->t_handle_save;\n\treiserfs_check_lock_depth(sb, \"journal end\");\n\tif (journal->j_len == 0) {\n\t\treiserfs_prepare_for_journal(sb, SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t     1);\n\t\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(sb));\n\t}\n\n\tlock_journal(sb);\n\tif (journal->j_next_full_flush) {\n\t\tflags |= FLUSH_ALL;\n\t\tflush = 1;\n\t}\n\tif (journal->j_next_async_flush) {\n\t\tflags |= COMMIT_NOW | WAIT;\n\t\twait_on_commit = 1;\n\t}\n\n\t/*\n\t * check_journal_end locks the journal, and unlocks if it does\n\t * not return 1 it tells us if we should continue with the\n\t * journal_end, or just return\n\t */\n\tif (!check_journal_end(th, flags)) {\n\t\treiserfs_schedule_old_flush(sb);\n\t\twake_queued_writers(sb);\n\t\treiserfs_async_progress_wait(sb);\n\t\tgoto out;\n\t}\n\n\t/* check_journal_end might set these, check again */\n\tif (journal->j_next_full_flush) {\n\t\tflush = 1;\n\t}\n\n\t/*\n\t * j must wait means we have to flush the log blocks, and the\n\t * real blocks for this transaction\n\t */\n\tif (journal->j_must_wait > 0) {\n\t\tflush = 1;\n\t}\n#ifdef REISERFS_PREALLOCATE\n\t/*\n\t * quota ops might need to nest, setup the journal_info pointer\n\t * for them and raise the refcount so that it is > 0.\n\t */\n\tcurrent->journal_info = th;\n\tth->t_refcount++;\n\n\t/* it should not involve new blocks into the transaction */\n\treiserfs_discard_all_prealloc(th);\n\n\tth->t_refcount--;\n\tcurrent->journal_info = th->t_handle_save;\n#endif\n\n\t/* setup description block */\n\td_bh =\n\t    journal_getblk(sb,\n\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t   journal->j_start);\n\tset_buffer_uptodate(d_bh);\n\tdesc = (struct reiserfs_journal_desc *)(d_bh)->b_data;\n\tmemset(d_bh->b_data, 0, d_bh->b_size);\n\tmemcpy(get_journal_desc_magic(d_bh), JOURNAL_DESC_MAGIC, 8);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\n\t/*\n\t * setup commit block.  Don't write (keep it clean too) this one\n\t * until after everyone else is written\n\t */\n\tc_bh = journal_getblk(sb, SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t      ((journal->j_start + journal->j_len +\n\t\t\t\t1) % SB_ONDISK_JOURNAL_SIZE(sb)));\n\tcommit = (struct reiserfs_journal_commit *)c_bh->b_data;\n\tmemset(c_bh->b_data, 0, c_bh->b_size);\n\tset_commit_trans_id(commit, journal->j_trans_id);\n\tset_buffer_uptodate(c_bh);\n\n\t/* init this journal list */\n\tjl = journal->j_current_jl;\n\n\t/*\n\t * we lock the commit before doing anything because\n\t * we want to make sure nobody tries to run flush_commit_list until\n\t * the new transaction is fully setup, and we've already flushed the\n\t * ordered bh list\n\t */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, sb);\n\n\t/* save the transaction id in case we need to commit it later */\n\tcommit_trans_id = jl->j_trans_id;\n\n\tatomic_set(&jl->j_older_commits_done, 0);\n\tjl->j_trans_id = journal->j_trans_id;\n\tjl->j_timestamp = journal->j_trans_start_time;\n\tjl->j_commit_bh = c_bh;\n\tjl->j_start = journal->j_start;\n\tjl->j_len = journal->j_len;\n\tatomic_set(&jl->j_nonzerolen, journal->j_len);\n\tatomic_set(&jl->j_commit_left, journal->j_len + 2);\n\tjl->j_realblock = NULL;\n\n\t/*\n\t * The ENTIRE FOR LOOP MUST not cause schedule to occur.\n\t * for each real block, add it to the journal list hash,\n\t * copy into real block index array in the commit or desc block\n\t */\n\ttrans_half = journal_trans_half(sb->s_blocksize);\n\tfor (i = 0, cn = journal->j_first; cn; cn = cn->next, i++) {\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tjl_cn = get_cnode(sb);\n\t\t\tif (!jl_cn) {\n\t\t\t\treiserfs_panic(sb, \"journal-1676\",\n\t\t\t\t\t       \"get_cnode returned NULL\");\n\t\t\t}\n\t\t\tif (i == 0) {\n\t\t\t\tjl->j_realblock = jl_cn;\n\t\t\t}\n\t\t\tjl_cn->prev = last_cn;\n\t\t\tjl_cn->next = NULL;\n\t\t\tif (last_cn) {\n\t\t\t\tlast_cn->next = jl_cn;\n\t\t\t}\n\t\t\tlast_cn = jl_cn;\n\t\t\t/*\n\t\t\t * make sure the block we are trying to log\n\t\t\t * is not a block of journal or reserved area\n\t\t\t */\n\t\t\tif (is_block_in_log_or_reserved_area\n\t\t\t    (sb, cn->bh->b_blocknr)) {\n\t\t\t\treiserfs_panic(sb, \"journal-2332\",\n\t\t\t\t\t       \"Trying to log block %lu, \"\n\t\t\t\t\t       \"which is a log block\",\n\t\t\t\t\t       cn->bh->b_blocknr);\n\t\t\t}\n\t\t\tjl_cn->blocknr = cn->bh->b_blocknr;\n\t\t\tjl_cn->state = 0;\n\t\t\tjl_cn->sb = sb;\n\t\t\tjl_cn->bh = cn->bh;\n\t\t\tjl_cn->jlist = jl;\n\t\t\tinsert_journal_hash(journal->j_list_hash_table, jl_cn);\n\t\t\tif (i < trans_half) {\n\t\t\t\tdesc->j_realblock[i] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t} else {\n\t\t\t\tcommit->j_realblock[i - trans_half] =\n\t\t\t\t    cpu_to_le32(cn->bh->b_blocknr);\n\t\t\t}\n\t\t} else {\n\t\t\ti--;\n\t\t}\n\t}\n\tset_desc_trans_len(desc, journal->j_len);\n\tset_desc_mount_id(desc, journal->j_mount_id);\n\tset_desc_trans_id(desc, journal->j_trans_id);\n\tset_commit_trans_len(commit, journal->j_len);\n\n\t/*\n\t * special check in case all buffers in the journal\n\t * were marked for not logging\n\t */\n\tBUG_ON(journal->j_len == 0);\n\n\t/*\n\t * we're about to dirty all the log blocks, mark the description block\n\t * dirty now too.  Don't mark the commit block dirty until all the\n\t * others are on disk\n\t */\n\tmark_buffer_dirty(d_bh);\n\n\t/*\n\t * first data block is j_start + 1, so add one to\n\t * cur_write_start wherever you use it\n\t */\n\tcur_write_start = journal->j_start;\n\tcn = journal->j_first;\n\tjindex = 1;\t/* start at one so we don't get the desc again */\n\twhile (cn) {\n\t\tclear_buffer_journal_new(cn->bh);\n\t\t/* copy all the real blocks into log area.  dirty log blocks */\n\t\tif (buffer_journaled(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\tchar *addr;\n\t\t\tstruct page *page;\n\t\t\ttmp_bh =\n\t\t\t    journal_getblk(sb,\n\t\t\t\t\t   SB_ONDISK_JOURNAL_1st_BLOCK(sb) +\n\t\t\t\t\t   ((cur_write_start +\n\t\t\t\t\t     jindex) %\n\t\t\t\t\t    SB_ONDISK_JOURNAL_SIZE(sb)));\n\t\t\tset_buffer_uptodate(tmp_bh);\n\t\t\tpage = cn->bh->b_page;\n\t\t\taddr = kmap(page);\n\t\t\tmemcpy(tmp_bh->b_data,\n\t\t\t       addr + offset_in_page(cn->bh->b_data),\n\t\t\t       cn->bh->b_size);\n\t\t\tkunmap(page);\n\t\t\tmark_buffer_dirty(tmp_bh);\n\t\t\tjindex++;\n\t\t\tset_buffer_journal_dirty(cn->bh);\n\t\t\tclear_buffer_journaled(cn->bh);\n\t\t} else {\n\t\t\t/*\n\t\t\t * JDirty cleared sometime during transaction.\n\t\t\t * don't log this one\n\t\t\t */\n\t\t\treiserfs_warning(sb, \"journal-2048\",\n\t\t\t\t\t \"BAD, buffer in journal hash, \"\n\t\t\t\t\t \"but not JDirty!\");\n\t\t\tbrelse(cn->bh);\n\t\t}\n\t\tnext = cn->next;\n\t\tfree_cnode(sb, cn);\n\t\tcn = next;\n\t\treiserfs_cond_resched(sb);\n\t}\n\n\t/*\n\t * we are done with both the c_bh and d_bh, but\n\t * c_bh must be written after all other commit blocks,\n\t * so we dirty/relse c_bh in flush_commit_list, with commit_left <= 1.\n\t */\n\n\tjournal->j_current_jl = alloc_journal_list(sb);\n\n\t/* now it is safe to insert this transaction on the main list */\n\tlist_add_tail(&jl->j_list, &journal->j_journal_list);\n\tlist_add_tail(&jl->j_working_list, &journal->j_working_list);\n\tjournal->j_num_work_lists++;\n\n\t/* reset journal values for the next transaction */\n\told_start = journal->j_start;\n\tjournal->j_start =\n\t    (journal->j_start + journal->j_len +\n\t     2) % SB_ONDISK_JOURNAL_SIZE(sb);\n\tatomic_set(&journal->j_wcount, 0);\n\tjournal->j_bcount = 0;\n\tjournal->j_last = NULL;\n\tjournal->j_first = NULL;\n\tjournal->j_len = 0;\n\tjournal->j_trans_start_time = 0;\n\t/* check for trans_id overflow */\n\tif (++journal->j_trans_id == 0)\n\t\tjournal->j_trans_id = 10;\n\tjournal->j_current_jl->j_trans_id = journal->j_trans_id;\n\tjournal->j_must_wait = 0;\n\tjournal->j_len_alloc = 0;\n\tjournal->j_next_full_flush = 0;\n\tjournal->j_next_async_flush = 0;\n\tinit_journal_hash(sb);\n\n\t/*\n\t * make sure reiserfs_add_jh sees the new current_jl before we\n\t * write out the tails\n\t */\n\tsmp_mb();\n\n\t/*\n\t * tail conversion targets have to hit the disk before we end the\n\t * transaction.  Otherwise a later transaction might repack the tail\n\t * before this transaction commits, leaving the data block unflushed\n\t * and clean, if we crash before the later transaction commits, the\n\t * data block is lost.\n\t */\n\tif (!list_empty(&jl->j_tail_bh_list)) {\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\twrite_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t      journal, jl, &jl->j_tail_bh_list);\n\t\treiserfs_write_lock_nested(sb, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_tail_bh_list));\n\tmutex_unlock(&jl->j_commit_mutex);\n\n\t/*\n\t * honor the flush wishes from the caller, simple commits can\n\t * be done outside the journal lock, they are done below\n\t *\n\t * if we don't flush the commit list right now, we put it into\n\t * the work queue so the people waiting on the async progress work\n\t * queue don't wait for this proc to flush journal lists and such.\n\t */\n\tif (flush) {\n\t\tflush_commit_list(sb, jl, 1);\n\t\tflush_journal_list(sb, jl, 1);\n\t} else if (!(jl->j_state & LIST_COMMIT_PENDING)) {\n\t\t/*\n\t\t * Avoid queueing work when sb is being shut down. Transaction\n\t\t * will be flushed on journal shutdown.\n\t\t */\n\t\tif (sb->s_flags & MS_ACTIVE)\n\t\t\tqueue_delayed_work(REISERFS_SB(sb)->commit_wq,\n\t\t\t\t\t   &journal->j_work, HZ / 10);\n\t}\n\n\t/*\n\t * if the next transaction has any chance of wrapping, flush\n\t * transactions that might get overwritten.  If any journal lists\n\t * are very old flush them as well.\n\t */\nfirst_jl:\n\tlist_for_each_safe(entry, safe, &journal->j_journal_list) {\n\t\ttemp_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (journal->j_start <= temp_jl->j_start) {\n\t\t\tif ((journal->j_start + journal->j_trans_max + 1) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else if ((journal->j_start +\n\t\t\t\t    journal->j_trans_max + 1) <\n\t\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\t\t/*\n\t\t\t\t * if we don't cross into the next\n\t\t\t\t * transaction and we don't wrap, there is\n\t\t\t\t * no way we can overlap any later transactions\n\t\t\t\t * break now\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((journal->j_start +\n\t\t\t    journal->j_trans_max + 1) >\n\t\t\t   SB_ONDISK_JOURNAL_SIZE(sb)) {\n\t\t\tif (((journal->j_start + journal->j_trans_max + 1) %\n\t\t\t     SB_ONDISK_JOURNAL_SIZE(sb)) >=\n\t\t\t    temp_jl->j_start) {\n\t\t\t\tflush_used_journal_lists(sb, temp_jl);\n\t\t\t\tgoto first_jl;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t* we don't overlap anything from out start\n\t\t\t\t* to the end of the log, and our wrapped\n\t\t\t\t* portion doesn't overlap anything at\n\t\t\t\t* the start of the log.  We can break\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tjournal->j_current_jl->j_list_bitmap =\n\t    get_list_bitmap(sb, journal->j_current_jl);\n\n\tif (!(journal->j_current_jl->j_list_bitmap)) {\n\t\treiserfs_panic(sb, \"journal-1996\",\n\t\t\t       \"could not get a list bitmap\");\n\t}\n\n\tatomic_set(&journal->j_jlock, 0);\n\tunlock_journal(sb);\n\t/* wake up any body waiting to join. */\n\tclear_bit(J_WRITERS_QUEUED, &journal->j_state);\n\twake_up(&journal->j_join_wait);\n\n\tif (!flush && wait_on_commit &&\n\t    journal_list_still_alive(sb, commit_trans_id)) {\n\t\tflush_commit_list(sb, jl, 1);\n\t}\nout:\n\treiserfs_check_lock_depth(sb, \"journal end2\");\n\n\tmemset(th, 0, sizeof(*th));\n\t/*\n\t * Re-set th->t_super, so we can properly keep track of how many\n\t * persistent transactions there are. We need to do this so if this\n\t * call is part of a failed restart_transaction, we can free it later\n\t */\n\tth->t_super = sb;\n\n\treturn journal->j_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "&myth",
            "SB_BUFFER_WITH_SB(sb)"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "sb",
            "SB_BUFFER_WITH_SB(sb)",
            "1"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_join_abort",
          "args": [
            "&myth",
            "sb"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "journal_join_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3203-3215",
          "snippet": "int journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nint journal_join_abort(struct reiserfs_transaction_handle *th,\n\t\t       struct super_block *sb)\n{\n\tstruct reiserfs_transaction_handle *cur_th = current->journal_info;\n\n\t/*\n\t * this keeps do_journal_end from NULLing out the\n\t * current->journal_info pointer\n\t */\n\tth->t_handle_save = cur_th;\n\tBUG_ON(cur_th && cur_th->t_refcount > 1);\n\treturn do_journal_begin_r(th, sb, 1, JBEGIN_ABORT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&myth",
            "0",
            "sizeof(myth)"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "sb"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define FLUSH_ALL   1\t\t/* flush commit and real blocks */\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int do_journal_release(struct reiserfs_transaction_handle *th,\n\t\t\t      struct super_block *sb, int error)\n{\n\tstruct reiserfs_transaction_handle myth;\n\tint flushed = 0;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\t/*\n\t * we only want to flush out transactions if we were\n\t * called with error == 0\n\t */\n\tif (!error && !(sb->s_flags & MS_RDONLY)) {\n\t\t/* end the current trans */\n\t\tBUG_ON(!th->t_trans_id);\n\t\tdo_journal_end(th, FLUSH_ALL);\n\n\t\t/*\n\t\t * make sure something gets logged to force\n\t\t * our way into the flush code\n\t\t */\n\t\tif (!journal_join(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t\tflushed = 1;\n\t\t}\n\t}\n\n\t/* this also catches errors during the do_journal_end above */\n\tif (!error && reiserfs_is_journal_aborted(journal)) {\n\t\tmemset(&myth, 0, sizeof(myth));\n\t\tif (!journal_join_abort(&myth, sb)) {\n\t\t\treiserfs_prepare_for_journal(sb,\n\t\t\t\t\t\t     SB_BUFFER_WITH_SB(sb),\n\t\t\t\t\t\t     1);\n\t\t\tjournal_mark_dirty(&myth, SB_BUFFER_WITH_SB(sb));\n\t\t\tdo_journal_end(&myth, FLUSH_ALL);\n\t\t}\n\t}\n\n\n\t/*\n\t * We must release the write lock here because\n\t * the workqueue job (flush_async_commit) needs this lock\n\t */\n\treiserfs_write_unlock(sb);\n\n\t/*\n\t * Cancel flushing of old commits. Note that neither of these works\n\t * will be requeued because superblock is being shutdown and doesn't\n\t * have MS_ACTIVE set.\n\t */\n\tcancel_delayed_work_sync(&REISERFS_SB(sb)->old_work);\n\t/* wait for all commits to finish */\n\tcancel_delayed_work_sync(&SB_JOURNAL(sb)->j_work);\n\n\tfree_journal_ram(sb);\n\n\treiserfs_write_lock(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_journal_ram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1886-1904",
    "snippet": "static void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "journal"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_journal_dev",
          "args": [
            "sb",
            "journal"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "release_journal_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "2594-2601",
          "snippet": "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal)\n{\n\tif (journal->j_dev_bd != NULL) {\n\t\tblkdev_put(journal->j_dev_bd, journal->j_dev_mode);\n\t\tjournal->j_dev_bd = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal)\n{\n\tif (journal->j_dev_bd != NULL) {\n\t\tblkdev_put(journal->j_dev_bd, journal->j_dev_mode);\n\t\tjournal->j_dev_bd = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "journal->j_header_bh"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_bitmap_nodes",
          "args": [
            "sb"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "257-273",
          "snippet": "static int free_bitmap_nodes(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct list_head *next = journal->j_bitmap_nodes.next;\n\tstruct reiserfs_bitmap_node *bn;\n\n\twhile (next != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(next, struct reiserfs_bitmap_node, list);\n\t\tlist_del(next);\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t\tnext = journal->j_bitmap_nodes.next;\n\t\tjournal->j_free_bitmap_nodes--;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int free_bitmap_nodes(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct list_head *next = journal->j_bitmap_nodes.next;\n\tstruct reiserfs_bitmap_node *bn;\n\n\twhile (next != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(next, struct reiserfs_bitmap_node, list);\n\t\tlist_del(next);\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t\tnext = journal->j_bitmap_nodes.next;\n\t\tjournal->j_free_bitmap_nodes--;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_list_bitmaps",
          "args": [
            "sb",
            "journal->j_list_bitmap"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "free_list_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "242-255",
          "snippet": "static int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "journal->j_cnode_free_orig"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_current_jl"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_journal_ram(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tkfree(journal->j_current_jl);\n\tjournal->j_num_lists--;\n\n\tvfree(journal->j_cnode_free_orig);\n\tfree_list_bitmaps(sb, journal->j_list_bitmap);\n\tfree_bitmap_nodes(sb);\t/* must be after free_list_bitmaps */\n\tif (journal->j_header_bh) {\n\t\tbrelse(journal->j_header_bh);\n\t}\n\t/*\n\t * j_header_bh is on the journal dev, make sure\n\t * not to release the journal dev until we brelse j_header_bh\n\t */\n\trelease_journal_dev(sb, journal);\n\tvfree(journal);\n}"
  },
  {
    "function_name": "remove_journal_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1845-1884",
    "snippet": "void remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define BLOCK_FREED 2"
    ],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cur->jlist->j_nonzerolen"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BLOCK_FREED",
            "&cur->state"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_hash",
          "args": [
            "table",
            "sb",
            "block"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BLOCK_FREED 2\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nvoid remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}"
  },
  {
    "function_name": "flush_used_journal_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1790-1839",
    "snippet": "static int flush_used_journal_lists(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tunsigned long len = 0;\n\tunsigned long cur_len;\n\tint ret;\n\tint i;\n\tint limit = 256;\n\tstruct reiserfs_journal_list *tjl;\n\tstruct reiserfs_journal_list *flush_jl;\n\tunsigned int trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\n\tflush_jl = tjl = jl;\n\n\t/* in data logging mode, try harder to flush a lot of blocks */\n\tif (reiserfs_data_log(s))\n\t\tlimit = 1024;\n\t/* flush for 256 transactions or limit blocks, whichever comes first */\n\tfor (i = 0; i < 256 && len < limit; i++) {\n\t\tif (atomic_read(&tjl->j_commit_left) ||\n\t\t    tjl->j_trans_id < jl->j_trans_id) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_len = atomic_read(&tjl->j_nonzerolen);\n\t\tif (cur_len > 0) {\n\t\t\ttjl->j_state &= ~LIST_TOUCHED;\n\t\t}\n\t\tlen += cur_len;\n\t\tflush_jl = tjl;\n\t\tif (tjl->j_list.next == &journal->j_journal_list)\n\t\t\tbreak;\n\t\ttjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\n\t}\n\tget_journal_list(jl);\n\tget_journal_list(flush_jl);\n\n\t/*\n\t * try to find a group of blocks we can flush across all the\n\t * transactions, but only bother if we've actually spanned\n\t * across multiple lists\n\t */\n\tif (flush_jl != jl) {\n\t\tret = kupdate_transactions(s, jl, &tjl, &trans_id, len, i);\n\t}\n\tflush_journal_list(s, flush_jl, 1);\n\tput_journal_list(s, flush_jl);\n\tput_journal_list(s, jl);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_TOUCHED 1"
    ],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_journal_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "put_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "550-559",
          "snippet": "static inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_journal_list",
          "args": [
            "s",
            "flush_jl",
            "1"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "flush_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1348-1629",
          "snippet": "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_DIRTY   2",
            "#define BLOCK_NEEDS_FLUSH 4"
          ],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define BLOCK_NEEDS_FLUSH 4\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kupdate_transactions",
          "args": [
            "s",
            "jl",
            "&tjl",
            "&trans_id",
            "len",
            "i"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "kupdate_transactions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1720-1778",
          "snippet": "static int kupdate_transactions(struct super_block *s,\n\t\t\t\tstruct reiserfs_journal_list *jl,\n\t\t\t\tstruct reiserfs_journal_list **next_jl,\n\t\t\t\tunsigned int *next_trans_id,\n\t\t\t\tint num_blocks, int num_trans)\n{\n\tint ret = 0;\n\tint written = 0;\n\tint transactions_flushed = 0;\n\tunsigned int orig_trans_id = jl->j_trans_id;\n\tstruct buffer_chunk chunk;\n\tstruct list_head *entry;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchunk.nr = 0;\n\n\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\tif (!journal_list_still_alive(s, orig_trans_id)) {\n\t\tgoto done;\n\t}\n\n\t/*\n\t * we've got j_flush_mutex held, nobody is going to delete any\n\t * of these lists out from underneath us\n\t */\n\twhile ((num_trans && transactions_flushed < num_trans) ||\n\t       (!num_trans && written < num_blocks)) {\n\n\t\tif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\n\t\t    atomic_read(&jl->j_commit_left)\n\t\t    || !(jl->j_state & LIST_DIRTY)) {\n\t\t\tdel_from_work_list(s, jl);\n\t\t\tbreak;\n\t\t}\n\t\tret = write_one_transaction(s, jl, &chunk);\n\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\ttransactions_flushed++;\n\t\twritten += ret;\n\t\tentry = jl->j_list.next;\n\n\t\t/* did we wrap? */\n\t\tif (entry == &journal->j_journal_list) {\n\t\t\tbreak;\n\t\t}\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\n\t\t/* don't bother with older transactions */\n\t\tif (jl->j_trans_id <= orig_trans_id)\n\t\t\tbreak;\n\t}\n\tif (chunk.nr) {\n\t\twrite_chunk(&chunk);\n\t}\n\ndone:\n\tmutex_unlock(&journal->j_flush_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_DIRTY   2",
            "#define LIST_TOUCHED 1"
          ],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define LIST_TOUCHED 1\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int kupdate_transactions(struct super_block *s,\n\t\t\t\tstruct reiserfs_journal_list *jl,\n\t\t\t\tstruct reiserfs_journal_list **next_jl,\n\t\t\t\tunsigned int *next_trans_id,\n\t\t\t\tint num_blocks, int num_trans)\n{\n\tint ret = 0;\n\tint written = 0;\n\tint transactions_flushed = 0;\n\tunsigned int orig_trans_id = jl->j_trans_id;\n\tstruct buffer_chunk chunk;\n\tstruct list_head *entry;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchunk.nr = 0;\n\n\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\tif (!journal_list_still_alive(s, orig_trans_id)) {\n\t\tgoto done;\n\t}\n\n\t/*\n\t * we've got j_flush_mutex held, nobody is going to delete any\n\t * of these lists out from underneath us\n\t */\n\twhile ((num_trans && transactions_flushed < num_trans) ||\n\t       (!num_trans && written < num_blocks)) {\n\n\t\tif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\n\t\t    atomic_read(&jl->j_commit_left)\n\t\t    || !(jl->j_state & LIST_DIRTY)) {\n\t\t\tdel_from_work_list(s, jl);\n\t\t\tbreak;\n\t\t}\n\t\tret = write_one_transaction(s, jl, &chunk);\n\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\ttransactions_flushed++;\n\t\twritten += ret;\n\t\tentry = jl->j_list.next;\n\n\t\t/* did we wrap? */\n\t\tif (entry == &journal->j_journal_list) {\n\t\t\tbreak;\n\t\t}\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\n\t\t/* don't bother with older transactions */\n\t\tif (jl->j_trans_id <= orig_trans_id)\n\t\t\tbreak;\n\t}\n\tif (chunk.nr) {\n\t\twrite_chunk(&chunk);\n\t}\n\ndone:\n\tmutex_unlock(&journal->j_flush_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_journal_list",
          "args": [
            "flush_jl"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "545-548",
          "snippet": "static inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "tjl->j_list.next"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tjl->j_nonzerolen"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tjl->j_commit_left"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_data_log",
          "args": [
            "s"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_TOUCHED 1\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_used_journal_lists(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tunsigned long len = 0;\n\tunsigned long cur_len;\n\tint ret;\n\tint i;\n\tint limit = 256;\n\tstruct reiserfs_journal_list *tjl;\n\tstruct reiserfs_journal_list *flush_jl;\n\tunsigned int trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\n\tflush_jl = tjl = jl;\n\n\t/* in data logging mode, try harder to flush a lot of blocks */\n\tif (reiserfs_data_log(s))\n\t\tlimit = 1024;\n\t/* flush for 256 transactions or limit blocks, whichever comes first */\n\tfor (i = 0; i < 256 && len < limit; i++) {\n\t\tif (atomic_read(&tjl->j_commit_left) ||\n\t\t    tjl->j_trans_id < jl->j_trans_id) {\n\t\t\tbreak;\n\t\t}\n\t\tcur_len = atomic_read(&tjl->j_nonzerolen);\n\t\tif (cur_len > 0) {\n\t\t\ttjl->j_state &= ~LIST_TOUCHED;\n\t\t}\n\t\tlen += cur_len;\n\t\tflush_jl = tjl;\n\t\tif (tjl->j_list.next == &journal->j_journal_list)\n\t\t\tbreak;\n\t\ttjl = JOURNAL_LIST_ENTRY(tjl->j_list.next);\n\t}\n\tget_journal_list(jl);\n\tget_journal_list(flush_jl);\n\n\t/*\n\t * try to find a group of blocks we can flush across all the\n\t * transactions, but only bother if we've actually spanned\n\t * across multiple lists\n\t */\n\tif (flush_jl != jl) {\n\t\tret = kupdate_transactions(s, jl, &tjl, &trans_id, len, i);\n\t}\n\tflush_journal_list(s, flush_jl, 1);\n\tput_journal_list(s, flush_jl);\n\tput_journal_list(s, jl);\n\treturn 0;\n}"
  },
  {
    "function_name": "kupdate_transactions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1720-1778",
    "snippet": "static int kupdate_transactions(struct super_block *s,\n\t\t\t\tstruct reiserfs_journal_list *jl,\n\t\t\t\tstruct reiserfs_journal_list **next_jl,\n\t\t\t\tunsigned int *next_trans_id,\n\t\t\t\tint num_blocks, int num_trans)\n{\n\tint ret = 0;\n\tint written = 0;\n\tint transactions_flushed = 0;\n\tunsigned int orig_trans_id = jl->j_trans_id;\n\tstruct buffer_chunk chunk;\n\tstruct list_head *entry;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchunk.nr = 0;\n\n\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\tif (!journal_list_still_alive(s, orig_trans_id)) {\n\t\tgoto done;\n\t}\n\n\t/*\n\t * we've got j_flush_mutex held, nobody is going to delete any\n\t * of these lists out from underneath us\n\t */\n\twhile ((num_trans && transactions_flushed < num_trans) ||\n\t       (!num_trans && written < num_blocks)) {\n\n\t\tif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\n\t\t    atomic_read(&jl->j_commit_left)\n\t\t    || !(jl->j_state & LIST_DIRTY)) {\n\t\t\tdel_from_work_list(s, jl);\n\t\t\tbreak;\n\t\t}\n\t\tret = write_one_transaction(s, jl, &chunk);\n\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\ttransactions_flushed++;\n\t\twritten += ret;\n\t\tentry = jl->j_list.next;\n\n\t\t/* did we wrap? */\n\t\tif (entry == &journal->j_journal_list) {\n\t\t\tbreak;\n\t\t}\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\n\t\t/* don't bother with older transactions */\n\t\tif (jl->j_trans_id <= orig_trans_id)\n\t\t\tbreak;\n\t}\n\tif (chunk.nr) {\n\t\twrite_chunk(&chunk);\n\t}\n\ndone:\n\tmutex_unlock(&journal->j_flush_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_DIRTY   2",
      "#define LIST_TOUCHED 1"
    ],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_flush_mutex"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_chunk",
          "args": [
            "&chunk"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "write_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "676-683",
          "snippet": "static void write_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_logged_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void write_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_logged_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_one_transaction",
          "args": [
            "s",
            "jl",
            "&chunk"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1631-1680",
          "snippet": "static int write_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct buffer_chunk *chunk)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_TOUCHED;\n\tdel_from_work_list(s, jl);\n\tif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\n\t\treturn 0;\n\t}\n\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * if the blocknr == 0, this has been cleared from the hash,\n\t\t * skip it\n\t\t */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto next;\n\t\t}\n\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\t/*\n\t\t\t * we can race against journal_mark_freed when we try\n\t\t\t * to lock_buffer(cn->bh), so we have to inc the buffer\n\t\t\t * count, and recheck things after locking\n\t\t\t */\n\t\t\ttmp_bh = cn->bh;\n\t\t\tget_bh(tmp_bh);\n\t\t\tlock_buffer(tmp_bh);\n\t\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\n\t\t\t\tif (!buffer_journal_dirty(tmp_bh) ||\n\t\t\t\t    buffer_journal_prepared(tmp_bh))\n\t\t\t\t\tBUG();\n\t\t\t\tadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\t/* note, cn->bh might be null now */\n\t\t\t\tunlock_buffer(tmp_bh);\n\t\t\t}\n\t\t\tput_bh(tmp_bh);\n\t\t}\nnext:\n\t\tcn = cn->next;\n\t\tcond_resched();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_TOUCHED 1"
          ],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_TOUCHED 1\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int write_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct buffer_chunk *chunk)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_TOUCHED;\n\tdel_from_work_list(s, jl);\n\tif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\n\t\treturn 0;\n\t}\n\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * if the blocknr == 0, this has been cleared from the hash,\n\t\t * skip it\n\t\t */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto next;\n\t\t}\n\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\t/*\n\t\t\t * we can race against journal_mark_freed when we try\n\t\t\t * to lock_buffer(cn->bh), so we have to inc the buffer\n\t\t\t * count, and recheck things after locking\n\t\t\t */\n\t\t\ttmp_bh = cn->bh;\n\t\t\tget_bh(tmp_bh);\n\t\t\tlock_buffer(tmp_bh);\n\t\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\n\t\t\t\tif (!buffer_journal_dirty(tmp_bh) ||\n\t\t\t\t    buffer_journal_prepared(tmp_bh))\n\t\t\t\t\tBUG();\n\t\t\t\tadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\t/* note, cn->bh might be null now */\n\t\t\t\tunlock_buffer(tmp_bh);\n\t\t\t}\n\t\t\tput_bh(tmp_bh);\n\t\t}\nnext:\n\t\tcn = cn->next;\n\t\tcond_resched();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_from_work_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "del_from_work_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1328-1336",
          "snippet": "static void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "s",
            "orig_trans_id"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&journal->j_flush_mutex",
            "s"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define LIST_TOUCHED 1\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int kupdate_transactions(struct super_block *s,\n\t\t\t\tstruct reiserfs_journal_list *jl,\n\t\t\t\tstruct reiserfs_journal_list **next_jl,\n\t\t\t\tunsigned int *next_trans_id,\n\t\t\t\tint num_blocks, int num_trans)\n{\n\tint ret = 0;\n\tint written = 0;\n\tint transactions_flushed = 0;\n\tunsigned int orig_trans_id = jl->j_trans_id;\n\tstruct buffer_chunk chunk;\n\tstruct list_head *entry;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tchunk.nr = 0;\n\n\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\tif (!journal_list_still_alive(s, orig_trans_id)) {\n\t\tgoto done;\n\t}\n\n\t/*\n\t * we've got j_flush_mutex held, nobody is going to delete any\n\t * of these lists out from underneath us\n\t */\n\twhile ((num_trans && transactions_flushed < num_trans) ||\n\t       (!num_trans && written < num_blocks)) {\n\n\t\tif (jl->j_len == 0 || (jl->j_state & LIST_TOUCHED) ||\n\t\t    atomic_read(&jl->j_commit_left)\n\t\t    || !(jl->j_state & LIST_DIRTY)) {\n\t\t\tdel_from_work_list(s, jl);\n\t\t\tbreak;\n\t\t}\n\t\tret = write_one_transaction(s, jl, &chunk);\n\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t\ttransactions_flushed++;\n\t\twritten += ret;\n\t\tentry = jl->j_list.next;\n\n\t\t/* did we wrap? */\n\t\tif (entry == &journal->j_journal_list) {\n\t\t\tbreak;\n\t\t}\n\t\tjl = JOURNAL_LIST_ENTRY(entry);\n\n\t\t/* don't bother with older transactions */\n\t\tif (jl->j_trans_id <= orig_trans_id)\n\t\t\tbreak;\n\t}\n\tif (chunk.nr) {\n\t\twrite_chunk(&chunk);\n\t}\n\ndone:\n\tmutex_unlock(&journal->j_flush_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "dirty_one_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1683-1718",
    "snippet": "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal_list *pjl;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_DIRTY;\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * look for a more recent transaction that logged this\n\t\t * buffer.  Only the most recent transaction with a buffer in\n\t\t * it is allowed to send that buffer to disk\n\t\t */\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\tif (!pjl && cn->blocknr && cn->bh\n\t\t    && buffer_journal_dirty(cn->bh)) {\n\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t/*\n\t\t\t * if the buffer is prepared, it will either be logged\n\t\t\t * or restored.  If restored, we need to make sure\n\t\t\t * it actually gets marked dirty\n\t\t\t */\n\t\t\tclear_buffer_journal_new(cn->bh);\n\t\t\tif (buffer_journal_prepared(cn->bh)) {\n\t\t\t\tset_buffer_journal_restore_dirty(cn->bh);\n\t\t\t} else {\n\t\t\t\tset_buffer_journal_test(cn->bh);\n\t\t\t\tmark_buffer_dirty(cn->bh);\n\t\t\t}\n\t\t}\n\t\tcn = cn->next;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_DIRTY   2"
    ],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_test",
          "args": [
            "cn->bh"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_journal_restore_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_prepared",
          "args": [
            "cn->bh"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_new",
          "args": [
            "cn->bh"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!can_dirty(cn)"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_dirty",
          "args": [
            "cn"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "can_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3480-3513",
          "snippet": "static int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_newer_jl_for_cn",
          "args": [
            "cn"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "find_newer_jl_for_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1171-1186",
          "snippet": "static struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal_list *pjl;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_DIRTY;\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * look for a more recent transaction that logged this\n\t\t * buffer.  Only the most recent transaction with a buffer in\n\t\t * it is allowed to send that buffer to disk\n\t\t */\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\tif (!pjl && cn->blocknr && cn->bh\n\t\t    && buffer_journal_dirty(cn->bh)) {\n\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t/*\n\t\t\t * if the buffer is prepared, it will either be logged\n\t\t\t * or restored.  If restored, we need to make sure\n\t\t\t * it actually gets marked dirty\n\t\t\t */\n\t\t\tclear_buffer_journal_new(cn->bh);\n\t\t\tif (buffer_journal_prepared(cn->bh)) {\n\t\t\t\tset_buffer_journal_restore_dirty(cn->bh);\n\t\t\t} else {\n\t\t\t\tset_buffer_journal_test(cn->bh);\n\t\t\t\tmark_buffer_dirty(cn->bh);\n\t\t\t}\n\t\t}\n\t\tcn = cn->next;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "write_one_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1631-1680",
    "snippet": "static int write_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct buffer_chunk *chunk)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_TOUCHED;\n\tdel_from_work_list(s, jl);\n\tif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\n\t\treturn 0;\n\t}\n\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * if the blocknr == 0, this has been cleared from the hash,\n\t\t * skip it\n\t\t */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto next;\n\t\t}\n\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\t/*\n\t\t\t * we can race against journal_mark_freed when we try\n\t\t\t * to lock_buffer(cn->bh), so we have to inc the buffer\n\t\t\t * count, and recheck things after locking\n\t\t\t */\n\t\t\ttmp_bh = cn->bh;\n\t\t\tget_bh(tmp_bh);\n\t\t\tlock_buffer(tmp_bh);\n\t\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\n\t\t\t\tif (!buffer_journal_dirty(tmp_bh) ||\n\t\t\t\t    buffer_journal_prepared(tmp_bh))\n\t\t\t\t\tBUG();\n\t\t\t\tadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\t/* note, cn->bh might be null now */\n\t\t\t\tunlock_buffer(tmp_bh);\n\t\t\t}\n\t\t\tput_bh(tmp_bh);\n\t\t}\nnext:\n\t\tcn = cn->next;\n\t\tcond_resched();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_TOUCHED 1"
    ],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "tmp_bh"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "tmp_bh"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_chunk",
          "args": [
            "chunk",
            "tmp_bh",
            "NULL",
            "write_chunk"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "694-711",
          "snippet": "static int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define CHUNK_SIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define CHUNK_SIZE 32\n\nstatic int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_prepared",
          "args": [
            "tmp_bh"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "tmp_bh"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "tmp_bh"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_dirty",
          "args": [
            "cn"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "can_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3480-3513",
          "snippet": "static int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "tmp_bh"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_nonzerolen"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_from_work_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "del_from_work_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1328-1336",
          "snippet": "static void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_TOUCHED 1\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int write_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct buffer_chunk *chunk)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_TOUCHED;\n\tdel_from_work_list(s, jl);\n\tif (jl->j_len == 0 || atomic_read(&jl->j_nonzerolen) == 0) {\n\t\treturn 0;\n\t}\n\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * if the blocknr == 0, this has been cleared from the hash,\n\t\t * skip it\n\t\t */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto next;\n\t\t}\n\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(cn->bh)) {\n\t\t\tstruct buffer_head *tmp_bh;\n\t\t\t/*\n\t\t\t * we can race against journal_mark_freed when we try\n\t\t\t * to lock_buffer(cn->bh), so we have to inc the buffer\n\t\t\t * count, and recheck things after locking\n\t\t\t */\n\t\t\ttmp_bh = cn->bh;\n\t\t\tget_bh(tmp_bh);\n\t\t\tlock_buffer(tmp_bh);\n\t\t\tif (cn->bh && can_dirty(cn) && buffer_dirty(tmp_bh)) {\n\t\t\t\tif (!buffer_journal_dirty(tmp_bh) ||\n\t\t\t\t    buffer_journal_prepared(tmp_bh))\n\t\t\t\t\tBUG();\n\t\t\t\tadd_to_chunk(chunk, tmp_bh, NULL, write_chunk);\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\t/* note, cn->bh might be null now */\n\t\t\t\tunlock_buffer(tmp_bh);\n\t\t\t}\n\t\t\tput_bh(tmp_bh);\n\t\t}\nnext:\n\t\tcn = cn->next;\n\t\tcond_resched();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "flush_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1348-1629",
    "snippet": "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define LIST_DIRTY   2",
      "#define BLOCK_NEEDS_FLUSH 4"
    ],
    "globals_used": [
      "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
      "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void flush_async_commits(struct work_struct *work);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_flush_mutex"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_journal_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "put_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "550-559",
          "snippet": "static inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_nonzerolen",
            "0"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"clm-2201\"",
            "\"last flush %lu, current %lu\"",
            "journal->j_last_flush_id",
            "jl->j_trans_id"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_from_work_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "del_from_work_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1328-1336",
          "snippet": "static void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jl->j_list"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_all_from_journal_list",
          "args": [
            "s",
            "jl",
            "0"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "remove_all_from_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1199-1228",
          "snippet": "static void remove_all_from_journal_list(struct super_block *sb,\n\t\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t\t int debug)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tcn = jl->j_realblock;\n\n\t/*\n\t * which is better, to lock once around the whole loop, or\n\t * to lock for each call to remove_journal_hash?\n\t */\n\twhile (cn) {\n\t\tif (cn->blocknr != 0) {\n\t\t\tif (debug) {\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2201\",\n\t\t\t\t\t\t \"block %u, bh is %d, state %ld\",\n\t\t\t\t\t\t cn->blocknr, cn->bh ? 1 : 0,\n\t\t\t\t\t\t cn->state);\n\t\t\t}\n\t\t\tcn->state = 0;\n\t\t\tremove_journal_hash(sb, journal->j_list_hash_table,\n\t\t\t\t\t    jl, cn->blocknr, 1);\n\t\t}\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tfree_cnode(sb, last);\n\t}\n\tjl->j_realblock = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void remove_all_from_journal_list(struct super_block *sb,\n\t\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t\t int debug)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tcn = jl->j_realblock;\n\n\t/*\n\t * which is better, to lock once around the whole loop, or\n\t * to lock for each call to remove_journal_hash?\n\t */\n\twhile (cn) {\n\t\tif (cn->blocknr != 0) {\n\t\t\tif (debug) {\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2201\",\n\t\t\t\t\t\t \"block %u, bh is %d, state %ld\",\n\t\t\t\t\t\t cn->blocknr, cn->bh ? 1 : 0,\n\t\t\t\t\t\t cn->state);\n\t\t\t}\n\t\t\tcn->state = 0;\n\t\t\tremove_journal_hash(sb, journal->j_list_hash_table,\n\t\t\t\t\t    jl, cn->blocknr, 1);\n\t\t}\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tfree_cnode(sb, last);\n\t}\n\tjl->j_realblock = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_abort",
          "args": [
            "s",
            "-EIO",
            "\"Write error while updating journal header in %s\"",
            "__func__"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "399-416",
          "snippet": "void reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tif (reiserfs_error_panic(sb)) {\n\t\tpanic(KERN_CRIT \"REISERFS panic (device %s): %s\\n\", sb->s_id,\n\t\t      error_buf);\n\t}\n\n\tif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"REISERFS abort (device %s): %s\\n\", sb->s_id,\n\t       error_buf);\n\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, errno);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tif (reiserfs_error_panic(sb)) {\n\t\tpanic(KERN_CRIT \"REISERFS panic (device %s): %s\\n\", sb->s_id,\n\t\t      error_buf);\n\t}\n\n\tif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"REISERFS abort (device %s): %s\\n\", sb->s_id,\n\t       error_buf);\n\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_journal_header_block",
          "args": [
            "s",
            "(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s)",
            "jl->j_trans_id"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "update_journal_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1288-1293",
          "snippet": "static int update_journal_header_block(struct super_block *sb,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       unsigned int trans_id)\n{\n\treturn _update_journal_header_block(sb, offset, trans_id);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int update_journal_header_block(struct super_block *sb,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       unsigned int trans_id)\n{\n\treturn _update_journal_header_block(sb, offset, trans_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "s"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_older_journal_lists",
          "args": [
            "s",
            "jl"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "flush_older_journal_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1299-1326",
          "snippet": "static int flush_older_journal_lists(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct list_head *entry;\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned int trans_id = jl->j_trans_id;\n\n\t/*\n\t * we know we are the only ones flushing things, no extra race\n\t * protection is required.\n\t */\nrestart:\n\tentry = journal->j_journal_list.next;\n\t/* Did we wrap? */\n\tif (entry == &journal->j_journal_list)\n\t\treturn 0;\n\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\tif (other_jl->j_trans_id < trans_id) {\n\t\tBUG_ON(other_jl->j_refcount <= 0);\n\t\t/* do not flush all */\n\t\tflush_journal_list(sb, other_jl, 0);\n\n\t\t/* other_jl is now deleted from the list */\n\t\tgoto restart;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_older_journal_lists(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct list_head *entry;\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned int trans_id = jl->j_trans_id;\n\n\t/*\n\t * we know we are the only ones flushing things, no extra race\n\t * protection is required.\n\t */\nrestart:\n\tentry = journal->j_journal_list.next;\n\t/* Did we wrap? */\n\tif (entry == &journal->j_journal_list)\n\t\treturn 0;\n\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\tif (other_jl->j_trans_id < trans_id) {\n\t\tBUG_ON(other_jl->j_refcount <= 0);\n\t\t/* do not flush all */\n\t\tflush_journal_list(sb, other_jl, 0);\n\n\t\t/* other_jl is now deleted from the list */\n\t\tgoto restart;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "cn->bh"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "604-617",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "cn->bh"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh)"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_journal_dirty",
          "args": [
            "cn->bh"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"journal-949\"",
            "\"buffer write failed\""
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(cn->bh)"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "cn->bh"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"journal-1012\"",
            "\"cn->bh is NULL\""
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "cn->bh"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"journal-1011\"",
            "\"cn->bh is NULL\""
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BLOCK_NEEDS_FLUSH",
            "&cn->state"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"journal-945\"",
            "\"saved_bh->b_count < 0\""
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&saved_bh->b_count"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "saved_bh"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "saved_bh"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_logged_buffer",
          "args": [
            "saved_bh"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "submit_logged_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "647-658",
          "snippet": "static void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "saved_bh"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cn->blocknr != saved_bh->b_blocknr"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BLOCK_NEEDS_FLUSH",
            "&cn->state"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "saved_bh"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "saved_bh"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "s",
            "pjl",
            "1"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pjl->j_commit_left"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_dirty",
          "args": [
            "cn"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "can_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3480-3513",
          "snippet": "static int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\tstruct reiserfs_journal_cnode *cur = cn->hprev;\n\tint can_dirty = 1;\n\n\t/*\n\t * first test hprev.  These are all newer than cn, so any node here\n\t * with the same block number and dev means this node can't be sent\n\t * to disk right now.\n\t */\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->bh && cur->blocknr && cur->sb == sb &&\n\t\t    cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hprev;\n\t}\n\t/*\n\t * then test hnext.  These are all older than cn.  As long as they\n\t * are committed to the log, it is safe to write cn to disk\n\t */\n\tcur = cn->hnext;\n\twhile (cur && can_dirty) {\n\t\tif (cur->jlist && cur->jlist->j_len > 0 &&\n\t\t    atomic_read(&cur->jlist->j_commit_left) > 0 && cur->bh &&\n\t\t    cur->blocknr && cur->sb == sb && cur->blocknr == blocknr) {\n\t\t\tcan_dirty = 0;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n\treturn can_dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!can_dirty(cn)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journal_dirty",
          "args": [
            "saved_bh"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "saved_bh"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_newer_jl_for_cn",
          "args": [
            "cn"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "find_newer_jl_for_cn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1171-1186",
          "snippet": "static struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"journal-844\"",
            "\"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_nonzerolen"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_nonzerolen"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"journal-715\"",
            "\"length is %lu, trans id %lu\"",
            "j_len_saved",
            "jl->j_trans_id"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&journal->j_flush_mutex"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&journal->j_flush_mutex",
            "s"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_wcount"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "j_len_saved <= 0"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define BLOCK_NEEDS_FLUSH 4\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "del_from_work_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1328-1336",
    "snippet": "static void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jl->j_working_list"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jl->j_working_list"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void del_from_work_list(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tif (!list_empty(&jl->j_working_list)) {\n\t\tlist_del_init(&jl->j_working_list);\n\t\tjournal->j_num_work_lists--;\n\t}\n}"
  },
  {
    "function_name": "flush_older_journal_lists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1299-1326",
    "snippet": "static int flush_older_journal_lists(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct list_head *entry;\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned int trans_id = jl->j_trans_id;\n\n\t/*\n\t * we know we are the only ones flushing things, no extra race\n\t * protection is required.\n\t */\nrestart:\n\tentry = journal->j_journal_list.next;\n\t/* Did we wrap? */\n\tif (entry == &journal->j_journal_list)\n\t\treturn 0;\n\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\tif (other_jl->j_trans_id < trans_id) {\n\t\tBUG_ON(other_jl->j_refcount <= 0);\n\t\t/* do not flush all */\n\t\tflush_journal_list(sb, other_jl, 0);\n\n\t\t/* other_jl is now deleted from the list */\n\t\tgoto restart;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_journal_list",
          "args": [
            "sb",
            "other_jl",
            "0"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "flush_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1348-1629",
          "snippet": "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_DIRTY   2",
            "#define BLOCK_NEEDS_FLUSH 4"
          ],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void flush_async_commits(struct work_struct *work);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n#define BLOCK_NEEDS_FLUSH 4\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void flush_async_commits(struct work_struct *work);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall)\n{\n\tstruct reiserfs_journal_list *pjl;\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tint count;\n\tint was_jwait = 0;\n\tint was_dirty = 0;\n\tstruct buffer_head *saved_bh;\n\tunsigned long j_len_saved = jl->j_len;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint err = 0;\n\tint depth;\n\n\tBUG_ON(j_len_saved <= 0);\n\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_warning(s, \"clm-2048\", \"called with wcount %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t}\n\n\t/* if flushall == 0, the lock is already held */\n\tif (flushall) {\n\t\treiserfs_mutex_lock_safe(&journal->j_flush_mutex, s);\n\t} else if (mutex_trylock(&journal->j_flush_mutex)) {\n\t\tBUG();\n\t}\n\n\tcount = 0;\n\tif (j_len_saved > journal->j_trans_max) {\n\t\treiserfs_panic(s, \"journal-715\", \"length is %lu, trans id %lu\",\n\t\t\t       j_len_saved, jl->j_trans_id);\n\t\treturn 0;\n\t}\n\n\t/* if all the work is already done, get out of here */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * start by putting the commit list on disk.  This will also flush\n\t * the commit lists of any olders transactions\n\t */\n\tflush_commit_list(s, jl, 1);\n\n\tif (!(jl->j_state & LIST_DIRTY)\n\t    && !reiserfs_is_journal_aborted(journal))\n\t\tBUG();\n\n\t/* are we done now? */\n\tif (atomic_read(&jl->j_nonzerolen) <= 0 &&\n\t    atomic_read(&jl->j_commit_left) <= 0) {\n\t\tgoto flush_older_and_return;\n\t}\n\n\t/*\n\t * loop through each cnode, see if we need to write it,\n\t * or wait on a more recent transaction, or just ignore it\n\t */\n\tif (atomic_read(&journal->j_wcount) != 0) {\n\t\treiserfs_panic(s, \"journal-844\", \"journal list is flushing, \"\n\t\t\t       \"wcount is not 0\");\n\t}\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\twas_jwait = 0;\n\t\twas_dirty = 0;\n\t\tsaved_bh = NULL;\n\t\t/* blocknr of 0 is no longer in the hash, ignore it */\n\t\tif (cn->blocknr == 0) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * This transaction failed commit.\n\t\t * Don't write out to the disk\n\t\t */\n\t\tif (!(jl->j_state & LIST_DIRTY))\n\t\t\tgoto free_cnode;\n\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\t/*\n\t\t * the order is important here.  We check pjl to make sure we\n\t\t * don't clear BH_JDirty_wait if we aren't the one writing this\n\t\t * block to disk\n\t\t */\n\t\tif (!pjl && cn->bh) {\n\t\t\tsaved_bh = cn->bh;\n\n\t\t\t/*\n\t\t\t * we do this to make sure nobody releases the\n\t\t\t * buffer while we are working with it\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\n\t\t\tif (buffer_journal_dirty(saved_bh)) {\n\t\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t\twas_jwait = 1;\n\t\t\t\twas_dirty = 1;\n\t\t\t} else if (can_dirty(cn)) {\n\t\t\t\t/*\n\t\t\t\t * everything with !pjl && jwait\n\t\t\t\t * should be writable\n\t\t\t\t */\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if someone has this block in a newer transaction, just make\n\t\t * sure they are committed, and don't try writing it to disk\n\t\t */\n\t\tif (pjl) {\n\t\t\tif (atomic_read(&pjl->j_commit_left))\n\t\t\t\tflush_commit_list(s, pjl, 1);\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * bh == NULL when the block got to disk on its own, OR,\n\t\t * the block got freed in a future transaction\n\t\t */\n\t\tif (saved_bh == NULL) {\n\t\t\tgoto free_cnode;\n\t\t}\n\n\t\t/*\n\t\t * this should never happen.  kupdate_one_transaction has\n\t\t * this list locked while it works, so we should never see a\n\t\t * buffer here that is not marked JDirty_wait\n\t\t */\n\t\tif ((!was_jwait) && !buffer_locked(saved_bh)) {\n\t\t\treiserfs_warning(s, \"journal-813\",\n\t\t\t\t\t \"BAD! buffer %llu %cdirty %cjwait, \"\n\t\t\t\t\t \"not in a newer tranasction\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, was_dirty ? ' ' : '!',\n\t\t\t\t\t was_jwait ? ' ' : '!');\n\t\t}\n\t\tif (was_dirty) {\n\t\t\t/*\n\t\t\t * we inc again because saved_bh gets decremented\n\t\t\t * at free_cnode\n\t\t\t */\n\t\t\tget_bh(saved_bh);\n\t\t\tset_bit(BLOCK_NEEDS_FLUSH, &cn->state);\n\t\t\tlock_buffer(saved_bh);\n\t\t\tBUG_ON(cn->blocknr != saved_bh->b_blocknr);\n\t\t\tif (buffer_dirty(saved_bh))\n\t\t\t\tsubmit_logged_buffer(saved_bh);\n\t\t\telse\n\t\t\t\tunlock_buffer(saved_bh);\n\t\t\tcount++;\n\t\t} else {\n\t\t\treiserfs_warning(s, \"clm-2082\",\n\t\t\t\t\t \"Unable to flush buffer %llu in %s\",\n\t\t\t\t\t (unsigned long long)saved_bh->\n\t\t\t\t\t b_blocknr, __func__);\n\t\t}\nfree_cnode:\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tif (saved_bh) {\n\t\t\t/*\n\t\t\t * we incremented this to keep others from\n\t\t\t * taking the buffer head away\n\t\t\t */\n\t\t\tput_bh(saved_bh);\n\t\t\tif (atomic_read(&saved_bh->b_count) < 0) {\n\t\t\t\treiserfs_warning(s, \"journal-945\",\n\t\t\t\t\t\t \"saved_bh->b_count < 0\");\n\t\t\t}\n\t\t}\n\t}\n\tif (count > 0) {\n\t\tcn = jl->j_realblock;\n\t\twhile (cn) {\n\t\t\tif (test_bit(BLOCK_NEEDS_FLUSH, &cn->state)) {\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1011\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\n\t\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\t\t__wait_on_buffer(cn->bh);\n\t\t\t\treiserfs_write_lock_nested(s, depth);\n\n\t\t\t\tif (!cn->bh) {\n\t\t\t\t\treiserfs_panic(s, \"journal-1012\",\n\t\t\t\t\t\t       \"cn->bh is NULL\");\n\t\t\t\t}\n\t\t\t\tif (unlikely(!buffer_uptodate(cn->bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\t\treiserfs_warning(s, \"journal-949\",\n\t\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\t\terr = -EIO;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * note, we must clear the JDirty_wait bit\n\t\t\t\t * after the up to date check, otherwise we\n\t\t\t\t * race against our flushpage routine\n\t\t\t\t */\n\t\t\t\tBUG_ON(!test_clear_buffer_journal_dirty\n\t\t\t\t       (cn->bh));\n\n\t\t\t\t/* drop one ref for us */\n\t\t\t\tput_bh(cn->bh);\n\t\t\t\t/* drop one ref for journal_mark_dirty */\n\t\t\t\trelease_buffer_page(cn->bh);\n\t\t\t}\n\t\t\tcn = cn->next;\n\t\t}\n\t}\n\n\tif (err)\n\t\treiserfs_abort(s, -EIO,\n\t\t\t       \"Write error while pushing transaction to disk in %s\",\n\t\t\t       __func__);\nflush_older_and_return:\n\n\t/*\n\t * before we can update the journal header block, we _must_ flush all\n\t * real blocks from all older transactions to disk.  This is because\n\t * once the header block is updated, this transaction will not be\n\t * replayed after a crash\n\t */\n\tif (flushall) {\n\t\tflush_older_journal_lists(s, jl);\n\t}\n\n\terr = journal->j_errno;\n\t/*\n\t * before we can remove everything from the hash tables for this\n\t * transaction, we must make sure it can never be replayed\n\t *\n\t * since we are only called from do_journal_end, we know for sure there\n\t * are no allocations going on while we are flushing journal lists.  So,\n\t * we only need to update the journal header block for the last list\n\t * being flushed\n\t */\n\tif (!err && flushall) {\n\t\terr =\n\t\t    update_journal_header_block(s,\n\t\t\t\t\t\t(jl->j_start + jl->j_len +\n\t\t\t\t\t\t 2) % SB_ONDISK_JOURNAL_SIZE(s),\n\t\t\t\t\t\tjl->j_trans_id);\n\t\tif (err)\n\t\t\treiserfs_abort(s, -EIO,\n\t\t\t\t       \"Write error while updating journal header in %s\",\n\t\t\t\t       __func__);\n\t}\n\tremove_all_from_journal_list(s, jl, 0);\n\tlist_del_init(&jl->j_list);\n\tjournal->j_num_lists--;\n\tdel_from_work_list(s, jl);\n\n\tif (journal->j_last_flush_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_flush_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2201\", \"last flush %lu, current %lu\",\n\t\t\t\t journal->j_last_flush_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_flush_id = jl->j_trans_id;\n\n\t/*\n\t * not strictly required since we are freeing the list, but it should\n\t * help find code using dead lists later on\n\t */\n\tjl->j_len = 0;\n\tatomic_set(&jl->j_nonzerolen, 0);\n\tjl->j_start = 0;\n\tjl->j_realblock = NULL;\n\tjl->j_commit_bh = NULL;\n\tjl->j_trans_id = 0;\n\tjl->j_state = 0;\n\tput_journal_list(s, jl);\n\tif (flushall)\n\t\tmutex_unlock(&journal->j_flush_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "other_jl->j_refcount <= 0"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_older_journal_lists(struct super_block *sb,\n\t\t\t\t     struct reiserfs_journal_list *jl)\n{\n\tstruct list_head *entry;\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tunsigned int trans_id = jl->j_trans_id;\n\n\t/*\n\t * we know we are the only ones flushing things, no extra race\n\t * protection is required.\n\t */\nrestart:\n\tentry = journal->j_journal_list.next;\n\t/* Did we wrap? */\n\tif (entry == &journal->j_journal_list)\n\t\treturn 0;\n\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\tif (other_jl->j_trans_id < trans_id) {\n\t\tBUG_ON(other_jl->j_refcount <= 0);\n\t\t/* do not flush all */\n\t\tflush_journal_list(sb, other_jl, 0);\n\n\t\t/* other_jl is now deleted from the list */\n\t\tgoto restart;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "update_journal_header_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1288-1293",
    "snippet": "static int update_journal_header_block(struct super_block *sb,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       unsigned int trans_id)\n{\n\treturn _update_journal_header_block(sb, offset, trans_id);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_update_journal_header_block",
          "args": [
            "sb",
            "offset",
            "trans_id"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "_update_journal_header_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1238-1286",
          "snippet": "static int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int update_journal_header_block(struct super_block *sb,\n\t\t\t\t       unsigned long offset,\n\t\t\t\t       unsigned int trans_id)\n{\n\treturn _update_journal_header_block(sb, offset, trans_id);\n}"
  },
  {
    "function_name": "_update_journal_header_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1238-1286",
    "snippet": "static int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-837\"",
            "\"IO error during journal replay\""
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "journal->j_header_bh"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "sb",
            "depth"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "journal->j_header_bh"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "journal->j_header_bh",
            "WRITE_FLUSH_FUA"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3133-3150",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_barrier_flush",
          "args": [
            "sb"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "sb"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "journal->j_header_bh"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "journal->j_mount_id"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "offset"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "trans_id"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"journal-699\"",
            "\"buffer write failed\""
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(journal->j_header_bh)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "journal->j_header_bh"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "(journal->j_header_bh)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int _update_journal_header_block(struct super_block *sb,\n\t\t\t\t\tunsigned long offset,\n\t\t\t\t\tunsigned int trans_id)\n{\n\tstruct reiserfs_journal_header *jh;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tint depth;\n\n\tif (reiserfs_is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tif (trans_id >= journal->j_last_flush_trans_id) {\n\t\tif (buffer_locked((journal->j_header_bh))) {\n\t\t\tdepth = reiserfs_write_unlock_nested(sb);\n\t\t\t__wait_on_buffer(journal->j_header_bh);\n\t\t\treiserfs_write_lock_nested(sb, depth);\n\t\t\tif (unlikely(!buffer_uptodate(journal->j_header_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\t\treiserfs_warning(sb, \"journal-699\",\n\t\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tjournal->j_last_flush_trans_id = trans_id;\n\t\tjournal->j_first_unflushed_offset = offset;\n\t\tjh = (struct reiserfs_journal_header *)(journal->j_header_bh->\n\t\t\t\t\t\t\tb_data);\n\t\tjh->j_last_flush_trans_id = cpu_to_le32(trans_id);\n\t\tjh->j_first_unflushed_offset = cpu_to_le32(offset);\n\t\tjh->j_mount_id = cpu_to_le32(journal->j_mount_id);\n\n\t\tset_buffer_dirty(journal->j_header_bh);\n\t\tdepth = reiserfs_write_unlock_nested(sb);\n\n\t\tif (reiserfs_barrier_flush(sb))\n\t\t\t__sync_dirty_buffer(journal->j_header_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(journal->j_header_bh);\n\n\t\treiserfs_write_lock_nested(sb, depth);\n\t\tif (!buffer_uptodate(journal->j_header_bh)) {\n\t\t\treiserfs_warning(sb, \"journal-837\",\n\t\t\t\t\t \"IO error during journal replay\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "remove_all_from_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1199-1228",
    "snippet": "static void remove_all_from_journal_list(struct super_block *sb,\n\t\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t\t int debug)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tcn = jl->j_realblock;\n\n\t/*\n\t * which is better, to lock once around the whole loop, or\n\t * to lock for each call to remove_journal_hash?\n\t */\n\twhile (cn) {\n\t\tif (cn->blocknr != 0) {\n\t\t\tif (debug) {\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2201\",\n\t\t\t\t\t\t \"block %u, bh is %d, state %ld\",\n\t\t\t\t\t\t cn->blocknr, cn->bh ? 1 : 0,\n\t\t\t\t\t\t cn->state);\n\t\t\t}\n\t\t\tcn->state = 0;\n\t\t\tremove_journal_hash(sb, journal->j_list_hash_table,\n\t\t\t\t\t    jl, cn->blocknr, 1);\n\t\t}\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tfree_cnode(sb, last);\n\t}\n\tjl->j_realblock = NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cnode",
          "args": [
            "sb",
            "last"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "free_cnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "394-410",
          "snippet": "static void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_journal_hash",
          "args": [
            "sb",
            "journal->j_list_hash_table",
            "jl",
            "cn->blocknr",
            "1"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "remove_journal_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1845-1884",
          "snippet": "void remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define BLOCK_FREED 2"
          ],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define BLOCK_FREED 2\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nvoid remove_journal_hash(struct super_block *sb,\n\t\t\t struct reiserfs_journal_cnode **table,\n\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t unsigned long block, int remove_freed)\n{\n\tstruct reiserfs_journal_cnode *cur;\n\tstruct reiserfs_journal_cnode **head;\n\n\thead = &(journal_hash(table, sb, block));\n\tif (!head) {\n\t\treturn;\n\t}\n\tcur = *head;\n\twhile (cur) {\n\t\tif (cur->blocknr == block && cur->sb == sb\n\t\t    && (jl == NULL || jl == cur->jlist)\n\t\t    && (!test_bit(BLOCK_FREED, &cur->state) || remove_freed)) {\n\t\t\tif (cur->hnext) {\n\t\t\t\tcur->hnext->hprev = cur->hprev;\n\t\t\t}\n\t\t\tif (cur->hprev) {\n\t\t\t\tcur->hprev->hnext = cur->hnext;\n\t\t\t} else {\n\t\t\t\t*head = cur->hnext;\n\t\t\t}\n\t\t\tcur->blocknr = 0;\n\t\t\tcur->sb = NULL;\n\t\t\tcur->state = 0;\n\t\t\t/*\n\t\t\t * anybody who clears the cur->bh will also\n\t\t\t * dec the nonzerolen\n\t\t\t */\n\t\t\tif (cur->bh && cur->jlist)\n\t\t\t\tatomic_dec(&cur->jlist->j_nonzerolen);\n\t\t\tcur->bh = NULL;\n\t\t\tcur->jlist = NULL;\n\t\t}\n\t\tcur = cur->hnext;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"reiserfs-2201\"",
            "\"block %u, bh is %d, state %ld\"",
            "cn->blocknr",
            "cn->bh ? 1 : 0",
            "cn->state"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void remove_all_from_journal_list(struct super_block *sb,\n\t\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t\t int debug)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn, *last;\n\tcn = jl->j_realblock;\n\n\t/*\n\t * which is better, to lock once around the whole loop, or\n\t * to lock for each call to remove_journal_hash?\n\t */\n\twhile (cn) {\n\t\tif (cn->blocknr != 0) {\n\t\t\tif (debug) {\n\t\t\t\treiserfs_warning(sb, \"reiserfs-2201\",\n\t\t\t\t\t\t \"block %u, bh is %d, state %ld\",\n\t\t\t\t\t\t cn->blocknr, cn->bh ? 1 : 0,\n\t\t\t\t\t\t cn->state);\n\t\t\t}\n\t\t\tcn->state = 0;\n\t\t\tremove_journal_hash(sb, journal->j_list_hash_table,\n\t\t\t\t\t    jl, cn->blocknr, 1);\n\t\t}\n\t\tlast = cn;\n\t\tcn = cn->next;\n\t\tfree_cnode(sb, last);\n\t}\n\tjl->j_realblock = NULL;\n}"
  },
  {
    "function_name": "find_newer_jl_for_cn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "1171-1186",
    "snippet": "static struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_journal_list *find_newer_jl_for_cn(struct\n\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t  *cn)\n{\n\tstruct super_block *sb = cn->sb;\n\tb_blocknr_t blocknr = cn->blocknr;\n\n\tcn = cn->hprev;\n\twhile (cn) {\n\t\tif (cn->sb == sb && cn->blocknr == blocknr && cn->jlist) {\n\t\t\treturn cn->jlist;\n\t\t}\n\t\tcn = cn->hprev;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "flush_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "975-1165",
    "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
      "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_abort",
          "args": [
            "s",
            "retval",
            "\"Journal write error in %s\"",
            "__func__"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "399-416",
          "snippet": "void reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tif (reiserfs_error_panic(sb)) {\n\t\tpanic(KERN_CRIT \"REISERFS panic (device %s): %s\\n\", sb->s_id,\n\t\t      error_buf);\n\t}\n\n\tif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"REISERFS abort (device %s): %s\\n\", sb->s_id,\n\t       error_buf);\n\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, errno);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tif (reiserfs_error_panic(sb)) {\n\t\tpanic(KERN_CRIT \"REISERFS panic (device %s): %s\\n\", sb->s_id,\n\t\t      error_buf);\n\t}\n\n\tif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"REISERFS abort (device %s): %s\\n\", sb->s_id,\n\t       error_buf);\n\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_journal_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "put_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "550-559",
          "snippet": "static inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jl->j_commit_mutex"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_older_commits_done",
            "1"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty_one_transaction",
          "args": [
            "s",
            "jl"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "dirty_one_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "1683-1718",
          "snippet": "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal_list *pjl;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_DIRTY;\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * look for a more recent transaction that logged this\n\t\t * buffer.  Only the most recent transaction with a buffer in\n\t\t * it is allowed to send that buffer to disk\n\t\t */\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\tif (!pjl && cn->blocknr && cn->bh\n\t\t    && buffer_journal_dirty(cn->bh)) {\n\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t/*\n\t\t\t * if the buffer is prepared, it will either be logged\n\t\t\t * or restored.  If restored, we need to make sure\n\t\t\t * it actually gets marked dirty\n\t\t\t */\n\t\t\tclear_buffer_journal_new(cn->bh);\n\t\t\tif (buffer_journal_prepared(cn->bh)) {\n\t\t\t\tset_buffer_journal_restore_dirty(cn->bh);\n\t\t\t} else {\n\t\t\t\tset_buffer_journal_test(cn->bh);\n\t\t\t\tmark_buffer_dirty(cn->bh);\n\t\t\t}\n\t\t}\n\t\tcn = cn->next;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define LIST_DIRTY   2"
          ],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define LIST_DIRTY   2\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal_list *pjl;\n\tint ret = 0;\n\n\tjl->j_state |= LIST_DIRTY;\n\tcn = jl->j_realblock;\n\twhile (cn) {\n\t\t/*\n\t\t * look for a more recent transaction that logged this\n\t\t * buffer.  Only the most recent transaction with a buffer in\n\t\t * it is allowed to send that buffer to disk\n\t\t */\n\t\tpjl = find_newer_jl_for_cn(cn);\n\t\tif (!pjl && cn->blocknr && cn->bh\n\t\t    && buffer_journal_dirty(cn->bh)) {\n\t\t\tBUG_ON(!can_dirty(cn));\n\t\t\t/*\n\t\t\t * if the buffer is prepared, it will either be logged\n\t\t\t * or restored.  If restored, we need to make sure\n\t\t\t * it actually gets marked dirty\n\t\t\t */\n\t\t\tclear_buffer_journal_new(cn->bh);\n\t\t\tif (buffer_journal_prepared(cn->bh)) {\n\t\t\t\tset_buffer_journal_restore_dirty(cn->bh);\n\t\t\t} else {\n\t\t\t\tset_buffer_journal_test(cn->bh);\n\t\t\t\tmark_buffer_dirty(cn->bh);\n\t\t\t}\n\t\t}\n\t\tcn = cn->next;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_freed_for_journal_list",
          "args": [
            "s",
            "jl"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_freed_for_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "566-576",
          "snippet": "static void cleanup_freed_for_journal_list(struct super_block *sb,\n\t\t\t\t\t   struct reiserfs_journal_list *jl)\n{\n\n\tstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\n\tif (jb) {\n\t\tcleanup_bitmap_list(sb, jb);\n\t}\n\tjl->j_list_bitmap->journal_list = NULL;\n\tjl->j_list_bitmap = NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void cleanup_freed_for_journal_list(struct super_block *sb,\n\t\t\t\t\t   struct reiserfs_journal_list *jl)\n{\n\n\tstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\n\tif (jb) {\n\t\tcleanup_bitmap_list(sb, jb);\n\t}\n\tjl->j_list_bitmap->journal_list = NULL;\n\tjl->j_list_bitmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"clm-2200\"",
            "\"last commit %lu, current %lu\"",
            "journal->j_last_commit_id",
            "jl->j_trans_id"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "jl->j_commit_bh"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"journal-615\"",
            "\"buffer write failed\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(jl->j_commit_bh)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "jl->j_commit_bh"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "jl->j_commit_bh"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sync_dirty_buffer",
          "args": [
            "jl->j_commit_bh",
            "WRITE_FLUSH_FUA"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3133-3150",
          "snippet": "int __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __sync_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tint ret = 0;\n\n\tWARN_ON(atomic_read(&bh->b_count) < 1);\n\tlock_buffer(bh);\n\tif (test_clear_buffer_dirty(bh)) {\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_write_sync;\n\t\tret = submit_bh(rw, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!ret && !buffer_uptodate(bh))\n\t\t\tret = -EIO;\n\t} else {\n\t\tunlock_buffer(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_barrier_flush",
          "args": [
            "s"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "jl->j_commit_bh"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!retval && !reiserfs_is_journal_aborted (journal)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&jl->j_commit_left) != 1"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "tbh"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "tbh"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"journal-601\"",
            "\"buffer write failed\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(tbh)"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wait_on_buffer",
          "args": [
            "tbh"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_find_get_block",
          "args": [
            "s",
            "bn"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "s"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "s"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&journal->j_async_throttle"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "tbh"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "WRITE",
            "1",
            "&tbh"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_find_get_block",
          "args": [
            "s",
            "bn"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_SIZE",
          "args": [
            "s"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_ONDISK_JOURNAL_1st_BLOCK",
          "args": [
            "s"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&journal->j_async_throttle"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&jl->j_bh_list)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&jl->j_bh_list"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_ordered_buffers",
          "args": [
            "&journal->j_dirty_buffers_lock",
            "journal",
            "jl",
            "&jl->j_bh_list"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "write_ordered_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "794-883",
          "snippet": "static int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jl->j_commit_mutex"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&jl->j_older_commits_done",
            "1"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_commit_left"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "jl->j_trans_id == 0"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jl->j_commit_mutex"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "s",
            "trans_id"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&jl->j_commit_mutex",
            "s"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_older_commits",
          "args": [
            "s",
            "jl"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "flush_older_commits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "885-951",
          "snippet": "static int flush_older_commits(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal_list *first_jl;\n\tstruct list_head *entry;\n\tunsigned int trans_id = jl->j_trans_id;\n\tunsigned int other_trans_id;\n\tunsigned int first_trans_id;\n\nfind_first:\n\t/*\n\t * first we walk backwards to find the oldest uncommitted transation\n\t */\n\tfirst_jl = jl;\n\tentry = jl->j_list.prev;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (entry == &journal->j_journal_list ||\n\t\t    atomic_read(&other_jl->j_older_commits_done))\n\t\t\tbreak;\n\n\t\tfirst_jl = other_jl;\n\t\tentry = other_jl->j_list.prev;\n\t}\n\n\t/* if we didn't find any older uncommitted transactions, return now */\n\tif (first_jl == jl) {\n\t\treturn 0;\n\t}\n\n\tfirst_trans_id = first_jl->j_trans_id;\n\n\tentry = &first_jl->j_list;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tother_trans_id = other_jl->j_trans_id;\n\n\t\tif (other_trans_id < trans_id) {\n\t\t\tif (atomic_read(&other_jl->j_commit_left) != 0) {\n\t\t\t\tflush_commit_list(s, other_jl, 0);\n\n\t\t\t\t/* list we were called with is gone, return */\n\t\t\t\tif (!journal_list_still_alive(s, trans_id))\n\t\t\t\t\treturn 1;\n\n\t\t\t\t/*\n\t\t\t\t * the one we just flushed is gone, this means\n\t\t\t\t * all older lists are also gone, so first_jl\n\t\t\t\t * is no longer valid either.  Go back to the\n\t\t\t\t * beginning.\n\t\t\t\t */\n\t\t\t\tif (!journal_list_still_alive\n\t\t\t\t    (s, other_trans_id)) {\n\t\t\t\t\tgoto find_first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->next;\n\t\t\tif (entry == &journal->j_journal_list)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_older_commits(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal_list *first_jl;\n\tstruct list_head *entry;\n\tunsigned int trans_id = jl->j_trans_id;\n\tunsigned int other_trans_id;\n\tunsigned int first_trans_id;\n\nfind_first:\n\t/*\n\t * first we walk backwards to find the oldest uncommitted transation\n\t */\n\tfirst_jl = jl;\n\tentry = jl->j_list.prev;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (entry == &journal->j_journal_list ||\n\t\t    atomic_read(&other_jl->j_older_commits_done))\n\t\t\tbreak;\n\n\t\tfirst_jl = other_jl;\n\t\tentry = other_jl->j_list.prev;\n\t}\n\n\t/* if we didn't find any older uncommitted transactions, return now */\n\tif (first_jl == jl) {\n\t\treturn 0;\n\t}\n\n\tfirst_trans_id = first_jl->j_trans_id;\n\n\tentry = &first_jl->j_list;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tother_trans_id = other_jl->j_trans_id;\n\n\t\tif (other_trans_id < trans_id) {\n\t\t\tif (atomic_read(&other_jl->j_commit_left) != 0) {\n\t\t\t\tflush_commit_list(s, other_jl, 0);\n\n\t\t\t\t/* list we were called with is gone, return */\n\t\t\t\tif (!journal_list_still_alive(s, trans_id))\n\t\t\t\t\treturn 1;\n\n\t\t\t\t/*\n\t\t\t\t * the one we just flushed is gone, this means\n\t\t\t\t * all older lists are also gone, so first_jl\n\t\t\t\t * is no longer valid either.  Go back to the\n\t\t\t\t * beginning.\n\t\t\t\t */\n\t\t\t\tif (!journal_list_still_alive\n\t\t\t\t    (s, other_trans_id)) {\n\t\t\t\t\tgoto find_first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->next;\n\t\t\tif (entry == &journal->j_journal_list)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_journal_list",
          "args": [
            "jl"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "545-548",
          "snippet": "static inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "trans_id == journal->j_trans_id"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "jl->j_len <= 0"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&jl->j_older_commits_done"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "s",
            "\"flush_commit_list\""
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
  },
  {
    "function_name": "reiserfs_async_progress_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "953-966",
    "snippet": "static int reiserfs_async_progress_wait(struct super_block *s)\n{\n\tstruct reiserfs_journal *j = SB_JOURNAL(s);\n\n\tif (atomic_read(&j->j_async_throttle)) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ / 10);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_write_lock_nested",
          "args": [
            "s",
            "depth"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "69-80",
          "snippet": "void reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\t/* this can happen when the lock isn't always held */\n\tif (depth == -1)\n\t\treturn;\n\n\tmutex_lock(&sb_i->lock);\n\tsb_i->lock_owner = current;\n\tsb_i->lock_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ / 10"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_write_unlock_nested",
          "args": [
            "s"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&j->j_async_throttle"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstatic int reiserfs_async_progress_wait(struct super_block *s)\n{\n\tstruct reiserfs_journal *j = SB_JOURNAL(s);\n\n\tif (atomic_read(&j->j_async_throttle)) {\n\t\tint depth;\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ / 10);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_older_commits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "885-951",
    "snippet": "static int flush_older_commits(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal_list *first_jl;\n\tstruct list_head *entry;\n\tunsigned int trans_id = jl->j_trans_id;\n\tunsigned int other_trans_id;\n\tunsigned int first_trans_id;\n\nfind_first:\n\t/*\n\t * first we walk backwards to find the oldest uncommitted transation\n\t */\n\tfirst_jl = jl;\n\tentry = jl->j_list.prev;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (entry == &journal->j_journal_list ||\n\t\t    atomic_read(&other_jl->j_older_commits_done))\n\t\t\tbreak;\n\n\t\tfirst_jl = other_jl;\n\t\tentry = other_jl->j_list.prev;\n\t}\n\n\t/* if we didn't find any older uncommitted transactions, return now */\n\tif (first_jl == jl) {\n\t\treturn 0;\n\t}\n\n\tfirst_trans_id = first_jl->j_trans_id;\n\n\tentry = &first_jl->j_list;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tother_trans_id = other_jl->j_trans_id;\n\n\t\tif (other_trans_id < trans_id) {\n\t\t\tif (atomic_read(&other_jl->j_commit_left) != 0) {\n\t\t\t\tflush_commit_list(s, other_jl, 0);\n\n\t\t\t\t/* list we were called with is gone, return */\n\t\t\t\tif (!journal_list_still_alive(s, trans_id))\n\t\t\t\t\treturn 1;\n\n\t\t\t\t/*\n\t\t\t\t * the one we just flushed is gone, this means\n\t\t\t\t * all older lists are also gone, so first_jl\n\t\t\t\t * is no longer valid either.  Go back to the\n\t\t\t\t * beginning.\n\t\t\t\t */\n\t\t\t\tif (!journal_list_still_alive\n\t\t\t\t    (s, other_trans_id)) {\n\t\t\t\t\tgoto find_first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->next;\n\t\t\tif (entry == &journal->j_journal_list)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_list_still_alive",
          "args": [
            "s",
            "other_trans_id"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "journal_list_still_alive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "578-592",
          "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "s",
            "other_jl",
            "0"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&other_jl->j_commit_left"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&other_jl->j_older_commits_done"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_older_commits(struct super_block *s,\n\t\t\t       struct reiserfs_journal_list *jl)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct reiserfs_journal_list *other_jl;\n\tstruct reiserfs_journal_list *first_jl;\n\tstruct list_head *entry;\n\tunsigned int trans_id = jl->j_trans_id;\n\tunsigned int other_trans_id;\n\tunsigned int first_trans_id;\n\nfind_first:\n\t/*\n\t * first we walk backwards to find the oldest uncommitted transation\n\t */\n\tfirst_jl = jl;\n\tentry = jl->j_list.prev;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tif (entry == &journal->j_journal_list ||\n\t\t    atomic_read(&other_jl->j_older_commits_done))\n\t\t\tbreak;\n\n\t\tfirst_jl = other_jl;\n\t\tentry = other_jl->j_list.prev;\n\t}\n\n\t/* if we didn't find any older uncommitted transactions, return now */\n\tif (first_jl == jl) {\n\t\treturn 0;\n\t}\n\n\tfirst_trans_id = first_jl->j_trans_id;\n\n\tentry = &first_jl->j_list;\n\twhile (1) {\n\t\tother_jl = JOURNAL_LIST_ENTRY(entry);\n\t\tother_trans_id = other_jl->j_trans_id;\n\n\t\tif (other_trans_id < trans_id) {\n\t\t\tif (atomic_read(&other_jl->j_commit_left) != 0) {\n\t\t\t\tflush_commit_list(s, other_jl, 0);\n\n\t\t\t\t/* list we were called with is gone, return */\n\t\t\t\tif (!journal_list_still_alive(s, trans_id))\n\t\t\t\t\treturn 1;\n\n\t\t\t\t/*\n\t\t\t\t * the one we just flushed is gone, this means\n\t\t\t\t * all older lists are also gone, so first_jl\n\t\t\t\t * is no longer valid either.  Go back to the\n\t\t\t\t * beginning.\n\t\t\t\t */\n\t\t\t\tif (!journal_list_still_alive\n\t\t\t\t    (s, other_trans_id)) {\n\t\t\t\t\tgoto find_first;\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry = entry->next;\n\t\t\tif (entry == &journal->j_journal_list)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "write_ordered_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "794-883",
    "snippet": "static int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "lock"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "WRITE",
            "1",
            "&bh"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bh->b_page->mapping == NULL"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_free_jh",
          "args": [
            "bh"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_free_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "731-746",
          "snippet": "void reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JH_ENTRY",
          "args": [
            "tmp.prev"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_ordered_chunk",
          "args": [
            "&chunk"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "write_ordered_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "685-692",
          "snippet": "static void write_ordered_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_ordered_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void write_ordered_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_ordered_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "lock"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_chunk",
          "args": [
            "&chunk",
            "bh",
            "lock",
            "write_ordered_chunk"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "694-711",
          "snippet": "static int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define CHUNK_SIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define CHUNK_SIZE 32\n\nstatic int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&jh->list",
            "&tmp"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&jh->list",
            "&tmp"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_buffer",
          "args": [
            "bh"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JH_ENTRY",
          "args": [
            "list->next"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tmp"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int write_ordered_buffers(spinlock_t * lock,\n\t\t\t\t struct reiserfs_journal *j,\n\t\t\t\t struct reiserfs_journal_list *jl,\n\t\t\t\t struct list_head *list)\n{\n\tstruct buffer_head *bh;\n\tstruct reiserfs_jh *jh;\n\tint ret = j->j_errno;\n\tstruct buffer_chunk chunk;\n\tstruct list_head tmp;\n\tINIT_LIST_HEAD(&tmp);\n\n\tchunk.nr = 0;\n\tspin_lock(lock);\n\twhile (!list_empty(list)) {\n\t\tjh = JH_ENTRY(list->next);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\tif (!trylock_buffer(bh)) {\n\t\t\tif (!buffer_dirty(bh)) {\n\t\t\t\tlist_move(&jh->list, &tmp);\n\t\t\t\tgoto loop_next;\n\t\t\t}\n\t\t\tspin_unlock(lock);\n\t\t\tif (chunk.nr)\n\t\t\t\twrite_ordered_chunk(&chunk);\n\t\t\twait_on_buffer(bh);\n\t\t\tcond_resched();\n\t\t\tspin_lock(lock);\n\t\t\tgoto loop_next;\n\t\t}\n\t\t/*\n\t\t * in theory, dirty non-uptodate buffers should never get here,\n\t\t * but the upper layer io error paths still have a few quirks.\n\t\t * Handle them here as gracefully as we can\n\t\t */\n\t\tif (!buffer_uptodate(bh) && buffer_dirty(bh)) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tret = -EIO;\n\t\t}\n\t\tif (buffer_dirty(bh)) {\n\t\t\tlist_move(&jh->list, &tmp);\n\t\t\tadd_to_chunk(&chunk, bh, lock, write_ordered_chunk);\n\t\t} else {\n\t\t\treiserfs_free_jh(bh);\n\t\t\tunlock_buffer(bh);\n\t\t}\nloop_next:\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tif (chunk.nr) {\n\t\tspin_unlock(lock);\n\t\twrite_ordered_chunk(&chunk);\n\t\tspin_lock(lock);\n\t}\n\twhile (!list_empty(&tmp)) {\n\t\tjh = JH_ENTRY(tmp.prev);\n\t\tbh = jh->bh;\n\t\tget_bh(bh);\n\t\treiserfs_free_jh(bh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(lock);\n\t\t\twait_on_buffer(bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tret = -EIO;\n\t\t}\n\t\t/*\n\t\t * ugly interaction with invalidatepage here.\n\t\t * reiserfs_invalidate_page will pin any buffer that has a\n\t\t * valid journal head from an older transaction.  If someone\n\t\t * else sets our buffer dirty after we write it in the first\n\t\t * loop, and then someone truncates the page away, nobody\n\t\t * will ever write the buffer. We're safe if we write the\n\t\t * page one last time after freeing the journal header.\n\t\t */\n\t\tif (buffer_dirty(bh) && unlikely(bh->b_page->mapping == NULL)) {\n\t\t\tspin_unlock(lock);\n\t\t\tll_rw_block(WRITE, 1, &bh);\n\t\t\tspin_lock(lock);\n\t\t}\n\t\tput_bh(bh);\n\t\tcond_resched_lock(lock);\n\t}\n\tspin_unlock(lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "reiserfs_add_ordered_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "788-791",
    "snippet": "int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_jh",
          "args": [
            "SB_JOURNAL(inode->i_sb)",
            "bh",
            "0"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "__add_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "748-782",
          "snippet": "static inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\n\nstatic inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nint reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);\n}"
  },
  {
    "function_name": "reiserfs_add_tail_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "784-787",
    "snippet": "int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_jh",
          "args": [
            "SB_JOURNAL(inode->i_sb)",
            "bh",
            "1"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__add_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "748-782",
          "snippet": "static inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\n\nstatic inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "inode->i_sb"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nint reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)\n{\n\treturn __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);\n}"
  },
  {
    "function_name": "__add_jh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "748-782",
    "snippet": "static inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jh->list",
            "&jh->jl->j_bh_list"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&jh->list",
            "&jh->jl->j_tail_bh_list"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh->b_private"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&j->j_dirty_buffers_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_jh",
          "args": [],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_jh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "714-725",
          "snippet": "static struct reiserfs_jh *alloc_jh(void)\n{\n\tstruct reiserfs_jh *jh;\n\twhile (1) {\n\t\tjh = kmalloc(sizeof(*jh), GFP_NOFS);\n\t\tif (jh) {\n\t\t\tatomic_inc(&nr_reiserfs_jh);\n\t\t\treturn jh;\n\t\t}\n\t\tyield();\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nstatic struct reiserfs_jh *alloc_jh(void)\n{\n\tstruct reiserfs_jh *jh;\n\twhile (1) {\n\t\tjh = kmalloc(sizeof(*jh), GFP_NOFS);\n\t\tif (jh) {\n\t\t\tatomic_inc(&nr_reiserfs_jh);\n\t\t\treturn jh;\n\t\t}\n\t\tyield();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jh->list"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\n\nstatic inline int __add_jh(struct reiserfs_journal *j, struct buffer_head *bh,\n\t\t\t   int tail)\n{\n\tstruct reiserfs_jh *jh;\n\n\tif (bh->b_private) {\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\tif (!bh->b_private) {\n\t\t\tspin_unlock(&j->j_dirty_buffers_lock);\n\t\t\tgoto no_jh;\n\t\t}\n\t\tjh = bh->b_private;\n\t\tlist_del_init(&jh->list);\n\t} else {\nno_jh:\n\t\tget_bh(bh);\n\t\tjh = alloc_jh();\n\t\tspin_lock(&j->j_dirty_buffers_lock);\n\t\t/*\n\t\t * buffer must be locked for __add_jh, should be able to have\n\t\t * two adds at the same time\n\t\t */\n\t\tBUG_ON(bh->b_private);\n\t\tjh->bh = bh;\n\t\tbh->b_private = jh;\n\t}\n\tjh->jl = j->j_current_jl;\n\tif (tail)\n\t\tlist_add_tail(&jh->list, &jh->jl->j_tail_bh_list);\n\telse {\n\t\tlist_add_tail(&jh->list, &jh->jl->j_bh_list);\n\t}\n\tspin_unlock(&j->j_dirty_buffers_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_free_jh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "731-746",
    "snippet": "void reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&nr_reiserfs_jh"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_reiserfs_jh"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jh"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&jh->list"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nvoid reiserfs_free_jh(struct buffer_head *bh)\n{\n\tstruct reiserfs_jh *jh;\n\n\tjh = bh->b_private;\n\tif (jh) {\n\t\tbh->b_private = NULL;\n\t\tjh->bh = NULL;\n\t\tlist_del_init(&jh->list);\n\t\tkfree(jh);\n\t\tif (atomic_read(&nr_reiserfs_jh) <= 0)\n\t\t\tBUG();\n\t\tatomic_dec(&nr_reiserfs_jh);\n\t\tput_bh(bh);\n\t}\n}"
  },
  {
    "function_name": "alloc_jh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "714-725",
    "snippet": "static struct reiserfs_jh *alloc_jh(void)\n{\n\tstruct reiserfs_jh *jh;\n\twhile (1) {\n\t\tjh = kmalloc(sizeof(*jh), GFP_NOFS);\n\t\tif (jh) {\n\t\t\tatomic_inc(&nr_reiserfs_jh);\n\t\t\treturn jh;\n\t\t}\n\t\tyield();\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&nr_reiserfs_jh"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*jh)",
            "GFP_NOFS"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic atomic_t nr_reiserfs_jh = ATOMIC_INIT(0);\n\nstatic struct reiserfs_jh *alloc_jh(void)\n{\n\tstruct reiserfs_jh *jh;\n\twhile (1) {\n\t\tjh = kmalloc(sizeof(*jh), GFP_NOFS);\n\t\tif (jh) {\n\t\t\tatomic_inc(&nr_reiserfs_jh);\n\t\t\treturn jh;\n\t\t}\n\t\tyield();\n\t}\n}"
  },
  {
    "function_name": "add_to_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "694-711",
    "snippet": "static int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define CHUNK_SIZE 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "chunk"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_writeback_workfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1073-1112",
          "snippet": "void bdi_writeback_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(BDI_registered, &bdi->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @bdi until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @bdi is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&bdi->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(&bdi->wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&bdi->work_list))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\tbdi_wakeup_thread_delayed(bdi);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid bdi_writeback_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tstruct backing_dev_info *bdi = wb->bdi;\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(BDI_registered, &bdi->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @bdi until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @bdi is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&bdi->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(&bdi->wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&bdi->work_list))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\tbdi_wakeup_thread_delayed(bdi);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lock"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lock"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "chunk->nr >= CHUNK_SIZE"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\n#define CHUNK_SIZE 32\n\nstatic int add_to_chunk(struct buffer_chunk *chunk, struct buffer_head *bh,\n\t\t\tspinlock_t * lock, void (fn) (struct buffer_chunk *))\n{\n\tint ret = 0;\n\tBUG_ON(chunk->nr >= CHUNK_SIZE);\n\tchunk->bh[chunk->nr++] = bh;\n\tif (chunk->nr >= CHUNK_SIZE) {\n\t\tret = 1;\n\t\tif (lock) {\n\t\t\tspin_unlock(lock);\n\t\t\tfn(chunk);\n\t\t\tspin_lock(lock);\n\t\t} else {\n\t\t\tfn(chunk);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "write_ordered_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "685-692",
    "snippet": "static void write_ordered_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_ordered_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_ordered_buffer",
          "args": [
            "chunk->bh[i]"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "submit_ordered_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "660-668",
          "snippet": "static void submit_ordered_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_ordered_io;\n\tclear_buffer_dirty(bh);\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void submit_ordered_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_ordered_io;\n\tclear_buffer_dirty(bh);\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void write_ordered_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_ordered_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}"
  },
  {
    "function_name": "write_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "676-683",
    "snippet": "static void write_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_logged_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_logged_buffer",
          "args": [
            "chunk->bh[i]"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "submit_logged_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "647-658",
          "snippet": "static void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void write_chunk(struct buffer_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->nr; i++) {\n\t\tsubmit_logged_buffer(chunk->bh[i]);\n\t}\n\tchunk->nr = 0;\n}"
  },
  {
    "function_name": "submit_ordered_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "660-668",
    "snippet": "static void submit_ordered_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_ordered_io;\n\tclear_buffer_dirty(bh);\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "bh"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void submit_ordered_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_ordered_io;\n\tclear_buffer_dirty(bh);\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}"
  },
  {
    "function_name": "submit_logged_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "647-658",
    "snippet": "static void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "bh"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_clear_buffer_journal_test",
          "args": [
            "bh"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_new",
          "args": [
            "bh"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void submit_logged_buffer(struct buffer_head *bh)\n{\n\tget_bh(bh);\n\tbh->b_end_io = reiserfs_end_buffer_io_sync;\n\tclear_buffer_journal_new(bh);\n\tclear_buffer_dirty(bh);\n\tif (!test_clear_buffer_journal_test(bh))\n\t\tBUG();\n\tif (!buffer_uptodate(bh))\n\t\tBUG();\n\tsubmit_bh(WRITE, bh);\n}"
  },
  {
    "function_name": "reiserfs_end_ordered_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "637-645",
    "snippet": "static void reiserfs_end_ordered_io(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void reiserfs_end_ordered_io(struct buffer_head *bh, int uptodate)\n{\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "reiserfs_end_buffer_io_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "619-635",
    "snippet": "static void reiserfs_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (buffer_journaled(bh)) {\n\t\treiserfs_warning(NULL, \"clm-2084\",\n\t\t\t\t \"pinned buffer %lu:%s sent to disk\",\n\t\t\t\t bh->b_blocknr, bdevname(bh->b_bdev, b));\n\t}\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\n\tunlock_buffer(bh);\n\trelease_buffer_page(bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void queue_log_writer(struct super_block *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_buffer_page",
          "args": [
            "bh"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "release_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "604-617",
          "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "NULL",
            "\"clm-2084\"",
            "\"pinned buffer %lu:%s sent to disk\"",
            "bh->b_blocknr",
            "bdevname(bh->b_bdev, b)"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "266-277",
          "snippet": "void __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\n\t\t\t const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS warning (device %s): %s%s%s: \"\n\t\t       \"%s\\n\", sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t       function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS warning: %s%s%s: %s\\n\",\n\t\t       id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bh->b_bdev",
            "b"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_journaled",
          "args": [
            "bh"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void queue_log_writer(struct super_block *s);\n\nstatic void reiserfs_end_buffer_io_sync(struct buffer_head *bh, int uptodate)\n{\n\tchar b[BDEVNAME_SIZE];\n\n\tif (buffer_journaled(bh)) {\n\t\treiserfs_warning(NULL, \"clm-2084\",\n\t\t\t\t \"pinned buffer %lu:%s sent to disk\",\n\t\t\t\t bh->b_blocknr, bdevname(bh->b_bdev, b));\n\t}\n\tif (uptodate)\n\t\tset_buffer_uptodate(bh);\n\telse\n\t\tclear_buffer_uptodate(bh);\n\n\tunlock_buffer(bh);\n\trelease_buffer_page(bh);\n}"
  },
  {
    "function_name": "release_buffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "604-617",
    "snippet": "static void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_buffer_page(struct buffer_head *bh)\n{\n\tstruct page *page = bh->b_page;\n\tif (!page->mapping && trylock_page(page)) {\n\t\tpage_cache_get(page);\n\t\tput_bh(bh);\n\t\tif (!page->mapping)\n\t\t\ttry_to_free_buffers(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t} else {\n\t\tput_bh(bh);\n\t}\n}"
  },
  {
    "function_name": "journal_list_still_alive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "578-592",
    "snippet": "static int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JOURNAL_LIST_ENTRY",
          "args": [
            "entry->next"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "entry"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "s"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int journal_list_still_alive(struct super_block *s,\n\t\t\t\t    unsigned int trans_id)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tstruct list_head *entry = &journal->j_journal_list;\n\tstruct reiserfs_journal_list *jl;\n\n\tif (!list_empty(entry)) {\n\t\tjl = JOURNAL_LIST_ENTRY(entry->next);\n\t\tif (jl->j_trans_id <= trans_id) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_freed_for_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "566-576",
    "snippet": "static void cleanup_freed_for_journal_list(struct super_block *sb,\n\t\t\t\t\t   struct reiserfs_journal_list *jl)\n{\n\n\tstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\n\tif (jb) {\n\t\tcleanup_bitmap_list(sb, jb);\n\t}\n\tjl->j_list_bitmap->journal_list = NULL;\n\tjl->j_list_bitmap = NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_bitmap_list",
          "args": [
            "sb",
            "jb"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_bitmap_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "224-237",
          "snippet": "static void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic void cleanup_freed_for_journal_list(struct super_block *sb,\n\t\t\t\t\t   struct reiserfs_journal_list *jl)\n{\n\n\tstruct reiserfs_list_bitmap *jb = jl->j_list_bitmap;\n\tif (jb) {\n\t\tcleanup_bitmap_list(sb, jb);\n\t}\n\tjl->j_list_bitmap->journal_list = NULL;\n\tjl->j_list_bitmap = NULL;\n}"
  },
  {
    "function_name": "put_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "550-559",
    "snippet": "static inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void queue_log_writer(struct super_block *s);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jl"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"journal-2\"",
            "\"trans id %u, refcount at %d\"",
            "jl->j_trans_id",
            "jl->j_refcount"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void put_journal_list(struct super_block *s,\n\t\t\t\t    struct reiserfs_journal_list *jl)\n{\n\tif (jl->j_refcount < 1) {\n\t\treiserfs_panic(s, \"journal-2\", \"trans id %u, refcount at %d\",\n\t\t\t       jl->j_trans_id, jl->j_refcount);\n\t}\n\tif (--jl->j_refcount == 0)\n\t\tkfree(jl);\n}"
  },
  {
    "function_name": "get_journal_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "545-548",
    "snippet": "static inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic inline void get_journal_list(struct reiserfs_journal_list *jl)\n{\n\tjl->j_refcount++;\n}"
  },
  {
    "function_name": "unlock_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "540-543",
    "snippet": "static inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&SB_JOURNAL(sb)->j_mutex"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void unlock_journal(struct super_block *sb)\n{\n\tmutex_unlock(&SB_JOURNAL(sb)->j_mutex);\n}"
  },
  {
    "function_name": "lock_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "532-537",
    "snippet": "static inline void lock_journal(struct super_block *sb)\n{\n\tPROC_INFO_INC(sb, journal.lock_journal);\n\n\treiserfs_mutex_lock_safe(&SB_JOURNAL(sb)->j_mutex, sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_mutex_lock_safe",
          "args": [
            "&SB_JOURNAL(sb)->j_mutex",
            "sb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_mutex_lock_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "809-817",
          "snippet": "static inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_write_lock(struct super_block *s);",
            "void reiserfs_write_unlock(struct super_block *s);",
            "int __must_check reiserfs_write_unlock_nested(struct super_block *s);",
            "void reiserfs_write_lock_nested(struct super_block *s, int depth);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "void reiserfs_wait_on_write_block(struct super_block *s);",
            "void reiserfs_allow_writes(struct super_block *s);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "void reiserfs_schedule_old_flush(struct super_block *s);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "void print_objectid_map(struct super_block *s);",
            "void print_statistics(struct super_block *s);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "void reiserfs_init_alloc_options(struct super_block *s);",
            "void show_alloc_options(struct seq_file *seq, struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_write_lock(struct super_block *s);\nvoid reiserfs_write_unlock(struct super_block *s);\nint __must_check reiserfs_write_unlock_nested(struct super_block *s);\nvoid reiserfs_write_lock_nested(struct super_block *s, int depth);\nvoid reiserfs_flush_old_commits(struct super_block *);\nvoid reiserfs_wait_on_write_block(struct super_block *s);\nvoid reiserfs_allow_writes(struct super_block *s);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nvoid reiserfs_schedule_old_flush(struct super_block *s);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nvoid print_objectid_map(struct super_block *s);\nvoid print_statistics(struct super_block *s);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nvoid reiserfs_init_alloc_options(struct super_block *s);\nvoid show_alloc_options(struct seq_file *seq, struct super_block *s);\n\nstatic inline void reiserfs_mutex_lock_safe(struct mutex *m,\n\t\t\t\t\t    struct super_block *s)\n{\n\tint depth;\n\n\tdepth = reiserfs_write_unlock_nested(s);\n\tmutex_lock(m);\n\treiserfs_write_lock_nested(s, depth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.lock_journal"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic inline void lock_journal(struct super_block *sb)\n{\n\tPROC_INFO_INC(sb, journal.lock_journal);\n\n\treiserfs_mutex_lock_safe(&SB_JOURNAL(sb)->j_mutex, sb);\n}"
  },
  {
    "function_name": "insert_journal_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "517-529",
    "snippet": "static inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_hash",
          "args": [
            "table",
            "cn->sb",
            "cn->blocknr"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline void insert_journal_hash(struct reiserfs_journal_cnode **table,\n\t\t\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal_cnode *cn_orig;\n\n\tcn_orig = journal_hash(table, cn->sb, cn->blocknr);\n\tcn->hnext = cn_orig;\n\tcn->hprev = NULL;\n\tif (cn_orig) {\n\t\tcn_orig->hprev = cn;\n\t}\n\tjournal_hash(table, cn->sb, cn->blocknr) = cn;\n}"
  },
  {
    "function_name": "reiserfs_in_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "459-514",
    "snippet": "int reiserfs_in_journal(struct super_block *sb,\n\t\t\tunsigned int bmap_nr, int bit_nr, int search_all,\n\t\t\tb_blocknr_t * next_zero_bit)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_list_bitmap *jb;\n\tint i;\n\tunsigned long bl;\n\n\t*next_zero_bit = 0;\t/* always start this at zero. */\n\n\tPROC_INFO_INC(sb, journal.in_journal);\n\t/*\n\t * If we aren't doing a search_all, this is a metablock, and it\n\t * will be logged before use.  if we crash before the transaction\n\t * that freed it commits,  this transaction won't have committed\n\t * either, and the block will never be written\n\t */\n\tif (search_all) {\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tPROC_INFO_INC(sb, journal.in_journal_bitmap);\n\t\t\tjb = journal->j_list_bitmap + i;\n\t\t\tif (jb->journal_list && jb->bitmaps[bmap_nr] &&\n\t\t\t    test_bit(bit_nr,\n\t\t\t\t     (unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data)) {\n\t\t\t\t*next_zero_bit =\n\t\t\t\t    find_next_zero_bit((unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata),\n\t\t\t\t\t\t       sb->s_blocksize << 3,\n\t\t\t\t\t\t       bit_nr + 1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\n\t/* is it in any old transactions? */\n\tif (search_all\n\t    && (cn =\n\t\tget_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\n\t\treturn 1;\n\t}\n\n\t/* is it in the current transaction.  This should never happen */\n\tif ((cn = get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tPROC_INFO_INC(sb, journal.in_journal_reusable);\n\t/* safe for reuse */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.in_journal_reusable"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_journal_hash_dev",
          "args": [
            "sb",
            "journal->j_hash_table",
            "bl"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "(unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata)",
            "sb->s_blocksize << 3",
            "bit_nr + 1"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit_nr",
            "(unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.in_journal_bitmap"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "sb",
            "journal.in_journal"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_in_journal(struct super_block *sb,\n\t\t\tunsigned int bmap_nr, int bit_nr, int search_all,\n\t\t\tb_blocknr_t * next_zero_bit)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_list_bitmap *jb;\n\tint i;\n\tunsigned long bl;\n\n\t*next_zero_bit = 0;\t/* always start this at zero. */\n\n\tPROC_INFO_INC(sb, journal.in_journal);\n\t/*\n\t * If we aren't doing a search_all, this is a metablock, and it\n\t * will be logged before use.  if we crash before the transaction\n\t * that freed it commits,  this transaction won't have committed\n\t * either, and the block will never be written\n\t */\n\tif (search_all) {\n\t\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\t\tPROC_INFO_INC(sb, journal.in_journal_bitmap);\n\t\t\tjb = journal->j_list_bitmap + i;\n\t\t\tif (jb->journal_list && jb->bitmaps[bmap_nr] &&\n\t\t\t    test_bit(bit_nr,\n\t\t\t\t     (unsigned long *)jb->bitmaps[bmap_nr]->\n\t\t\t\t     data)) {\n\t\t\t\t*next_zero_bit =\n\t\t\t\t    find_next_zero_bit((unsigned long *)\n\t\t\t\t\t\t       (jb->bitmaps[bmap_nr]->\n\t\t\t\t\t\t\tdata),\n\t\t\t\t\t\t       sb->s_blocksize << 3,\n\t\t\t\t\t\t       bit_nr + 1);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbl = bmap_nr * (sb->s_blocksize << 3) + bit_nr;\n\t/* is it in any old transactions? */\n\tif (search_all\n\t    && (cn =\n\t\tget_journal_hash_dev(sb, journal->j_list_hash_table, bl))) {\n\t\treturn 1;\n\t}\n\n\t/* is it in the current transaction.  This should never happen */\n\tif ((cn = get_journal_hash_dev(sb, journal->j_hash_table, bl))) {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tPROC_INFO_INC(sb, journal.in_journal_reusable);\n\t/* safe for reuse */\n\treturn 0;\n}"
  },
  {
    "function_name": "get_journal_hash_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "422-438",
    "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_hash",
          "args": [
            "table",
            "sb",
            "bl"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "get_journal_hash_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "422-438",
          "snippet": "static inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic inline struct reiserfs_journal_cnode *get_journal_hash_dev(struct\n\t\t\t\t\t\t\t\t  super_block\n\t\t\t\t\t\t\t\t  *sb,\n\t\t\t\t\t\t\t\t  struct\n\t\t\t\t\t\t\t\t  reiserfs_journal_cnode\n\t\t\t\t\t\t\t\t  **table,\n\t\t\t\t\t\t\t\t  long bl)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tcn = journal_hash(table, sb, bl);\n\twhile (cn) {\n\t\tif (cn->blocknr == bl && cn->sb == sb)\n\t\t\treturn cn;\n\t\tcn = cn->hnext;\n\t}\n\treturn (struct reiserfs_journal_cnode *)0;\n}"
  },
  {
    "function_name": "clear_prepared_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "412-416",
    "snippet": "static void clear_prepared_bits(struct buffer_head *bh)\n{\n\tclear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_journal_restore_dirty",
          "args": [
            "bh"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_journal_prepared",
          "args": [
            "bh"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic void clear_prepared_bits(struct buffer_head *bh)\n{\n\tclear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n}"
  },
  {
    "function_name": "free_cnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "394-410",
    "snippet": "static void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "sb",
            "\"free_cnode\""
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void free_cnode(struct super_block *sb,\n\t\t       struct reiserfs_journal_cnode *cn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"free_cnode\");\n\n\tjournal->j_cnode_used--;\n\tjournal->j_cnode_free++;\n\t/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */\n\tcn->next = journal->j_cnode_free_list;\n\tif (journal->j_cnode_free_list) {\n\t\tjournal->j_cnode_free_list->prev = cn;\n\t}\n\tcn->prev = NULL;\t/* not needed with the memset, but I might kill the memset, and forget to do this */\n\tjournal->j_cnode_free_list = cn;\n}"
  },
  {
    "function_name": "get_cnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "367-389",
    "snippet": "static struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int can_dirty(struct reiserfs_journal_cnode *cn);",
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cn",
            "0",
            "sizeof(struct reiserfs_journal_cnode)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_check_lock_depth",
          "args": [
            "sb",
            "\"get_cnode\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_check_lock_depth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "86-91",
          "snippet": "void reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_check_lock_depth(struct super_block *sb, char *caller)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(sb);\n\n\tWARN_ON(sb_i->lock_depth < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic struct reiserfs_journal_cnode *get_cnode(struct super_block *sb)\n{\n\tstruct reiserfs_journal_cnode *cn;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\n\treiserfs_check_lock_depth(sb, \"get_cnode\");\n\n\tif (journal->j_cnode_free <= 0) {\n\t\treturn NULL;\n\t}\n\tjournal->j_cnode_used++;\n\tjournal->j_cnode_free--;\n\tcn = journal->j_cnode_free_list;\n\tif (!cn) {\n\t\treturn cn;\n\t}\n\tif (cn->next) {\n\t\tcn->next->prev = NULL;\n\t}\n\tjournal->j_cnode_free_list = cn->next;\n\tmemset(cn, 0, sizeof(struct reiserfs_journal_cnode));\n\treturn cn;\n}"
  },
  {
    "function_name": "allocate_cnodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "345-364",
    "snippet": "static struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\n{\n\tstruct reiserfs_journal_cnode *head;\n\tint i;\n\tif (num_cnodes <= 0) {\n\t\treturn NULL;\n\t}\n\thead = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));\n\tif (!head) {\n\t\treturn NULL;\n\t}\n\thead[0].prev = NULL;\n\thead[0].next = head + 1;\n\tfor (i = 1; i < num_cnodes; i++) {\n\t\thead[i].prev = head + (i - 1);\n\t\thead[i].next = head + (i + 1);\t/* if last one, overwrite it after the if */\n\t}\n\thead[num_cnodes - 1].next = NULL;\n\treturn head;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "num_cnodes * sizeof(struct reiserfs_journal_cnode)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)\n{\n\tstruct reiserfs_journal_cnode *head;\n\tint i;\n\tif (num_cnodes <= 0) {\n\t\treturn NULL;\n\t}\n\thead = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));\n\tif (!head) {\n\t\treturn NULL;\n\t}\n\thead[0].prev = NULL;\n\thead[0].next = head + 1;\n\tfor (i = 1; i < num_cnodes; i++) {\n\t\thead[i].prev = head + (i - 1);\n\t\thead[i].next = head + (i + 1);\t/* if last one, overwrite it after the if */\n\t}\n\thead[num_cnodes - 1].next = NULL;\n\treturn head;\n}"
  },
  {
    "function_name": "get_list_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "310-338",
    "snippet": "static struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
      "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
      "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_commit_list",
          "args": [
            "sb",
            "journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list",
            "1"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "flush_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "975-1165",
          "snippet": "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);",
            "static int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);",
            "static int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);",
            "static void queue_log_writer(struct super_block *s);",
            "static void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int flush_journal_list(struct super_block *s,\n\t\t\t      struct reiserfs_journal_list *jl, int flushall);\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void queue_log_writer(struct super_block *s);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic int flush_commit_list(struct super_block *s,\n\t\t\t     struct reiserfs_journal_list *jl, int flushall)\n{\n\tint i;\n\tb_blocknr_t bn;\n\tstruct buffer_head *tbh = NULL;\n\tunsigned int trans_id = jl->j_trans_id;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(s);\n\tint retval = 0;\n\tint write_len;\n\tint depth;\n\n\treiserfs_check_lock_depth(s, \"flush_commit_list\");\n\n\tif (atomic_read(&jl->j_older_commits_done)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * before we can put our commit blocks on disk, we have to make\n\t * sure everyone older than us is on disk too\n\t */\n\tBUG_ON(jl->j_len <= 0);\n\tBUG_ON(trans_id == journal->j_trans_id);\n\n\tget_journal_list(jl);\n\tif (flushall) {\n\t\tif (flush_older_commits(s, jl) == 1) {\n\t\t\t/*\n\t\t\t * list disappeared during flush_older_commits.\n\t\t\t * return\n\t\t\t */\n\t\t\tgoto put_jl;\n\t\t}\n\t}\n\n\t/* make sure nobody is trying to flush this one at the same time */\n\treiserfs_mutex_lock_safe(&jl->j_commit_mutex, s);\n\n\tif (!journal_list_still_alive(s, trans_id)) {\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\tBUG_ON(jl->j_trans_id == 0);\n\n\t/* this commit is done, exit */\n\tif (atomic_read(&jl->j_commit_left) <= 0) {\n\t\tif (flushall) {\n\t\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t\t}\n\t\tmutex_unlock(&jl->j_commit_mutex);\n\t\tgoto put_jl;\n\t}\n\n\tif (!list_empty(&jl->j_bh_list)) {\n\t\tint ret;\n\n\t\t/*\n\t\t * We might sleep in numerous places inside\n\t\t * write_ordered_buffers. Relax the write lock.\n\t\t */\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tret = write_ordered_buffers(&journal->j_dirty_buffers_lock,\n\t\t\t\t\t    journal, jl, &jl->j_bh_list);\n\t\tif (ret < 0 && retval == 0)\n\t\t\tretval = ret;\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\tBUG_ON(!list_empty(&jl->j_bh_list));\n\t/*\n\t * for the description block and all the log blocks, submit any buffers\n\t * that haven't already reached the disk.  Try to write at least 256\n\t * log blocks. later on, we will only wait on blocks that correspond\n\t * to this transaction, but while we're unplugging we might as well\n\t * get a chunk of data on there.\n\t */\n\tatomic_inc(&journal->j_async_throttle);\n\twrite_len = jl->j_len + 1;\n\tif (write_len < 256)\n\t\twrite_len = 256;\n\tfor (i = 0 ; i < write_len ; i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) + (jl->j_start + i) %\n\t\t    SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\t\tif (tbh) {\n\t\t\tif (buffer_dirty(tbh)) {\n\t\t            depth = reiserfs_write_unlock_nested(s);\n\t\t\t    ll_rw_block(WRITE, 1, &tbh);\n\t\t\t    reiserfs_write_lock_nested(s, depth);\n\t\t\t}\n\t\t\tput_bh(tbh) ;\n\t\t}\n\t}\n\tatomic_dec(&journal->j_async_throttle);\n\n\tfor (i = 0; i < (jl->j_len + 1); i++) {\n\t\tbn = SB_ONDISK_JOURNAL_1st_BLOCK(s) +\n\t\t    (jl->j_start + i) % SB_ONDISK_JOURNAL_SIZE(s);\n\t\ttbh = journal_find_get_block(s, bn);\n\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t__wait_on_buffer(tbh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t\t/*\n\t\t * since we're using ll_rw_blk above, it might have skipped\n\t\t * over a locked buffer.  Double check here\n\t\t */\n\t\t/* redundant, sync_dirty_buffer() checks */\n\t\tif (buffer_dirty(tbh)) {\n\t\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\t\tsync_dirty_buffer(tbh);\n\t\t\treiserfs_write_lock_nested(s, depth);\n\t\t}\n\t\tif (unlikely(!buffer_uptodate(tbh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\t\treiserfs_warning(s, \"journal-601\",\n\t\t\t\t\t \"buffer write failed\");\n#endif\n\t\t\tretval = -EIO;\n\t\t}\n\t\t/* once for journal_find_get_block */\n\t\tput_bh(tbh);\n\t\t/* once due to original getblk in do_journal_end */\n\t\tput_bh(tbh);\n\t\tatomic_dec(&jl->j_commit_left);\n\t}\n\n\tBUG_ON(atomic_read(&jl->j_commit_left) != 1);\n\n\t/*\n\t * If there was a write error in the journal - we can't commit\n\t * this transaction - it will be invalid and, if successful,\n\t * will just end up propagating the write error out to\n\t * the file system.\n\t */\n\tif (likely(!retval && !reiserfs_is_journal_aborted (journal))) {\n\t\tif (buffer_dirty(jl->j_commit_bh))\n\t\t\tBUG();\n\t\tmark_buffer_dirty(jl->j_commit_bh) ;\n\t\tdepth = reiserfs_write_unlock_nested(s);\n\t\tif (reiserfs_barrier_flush(s))\n\t\t\t__sync_dirty_buffer(jl->j_commit_bh, WRITE_FLUSH_FUA);\n\t\telse\n\t\t\tsync_dirty_buffer(jl->j_commit_bh);\n\t\treiserfs_write_lock_nested(s, depth);\n\t}\n\n\t/*\n\t * If there was a write error in the journal - we can't commit this\n\t * transaction - it will be invalid and, if successful, will just end\n\t * up propagating the write error out to the filesystem.\n\t */\n\tif (unlikely(!buffer_uptodate(jl->j_commit_bh))) {\n#ifdef CONFIG_REISERFS_CHECK\n\t\treiserfs_warning(s, \"journal-615\", \"buffer write failed\");\n#endif\n\t\tretval = -EIO;\n\t}\n\tbforget(jl->j_commit_bh);\n\tif (journal->j_last_commit_id != 0 &&\n\t    (jl->j_trans_id - journal->j_last_commit_id) != 1) {\n\t\treiserfs_warning(s, \"clm-2200\", \"last commit %lu, current %lu\",\n\t\t\t\t journal->j_last_commit_id, jl->j_trans_id);\n\t}\n\tjournal->j_last_commit_id = jl->j_trans_id;\n\n\t/*\n\t * now, every commit block is on the disk.  It is safe to allow\n\t * blocks freed during this transaction to be reallocated\n\t */\n\tcleanup_freed_for_journal_list(s, jl);\n\n\tretval = retval ? retval : journal->j_errno;\n\n\t/* mark the metadata dirty */\n\tif (!retval)\n\t\tdirty_one_transaction(s, jl);\n\tatomic_dec(&jl->j_commit_left);\n\n\tif (flushall) {\n\t\tatomic_set(&jl->j_older_commits_done, 1);\n\t}\n\tmutex_unlock(&jl->j_commit_mutex);\nput_jl:\n\tput_journal_list(s, jl);\n\n\tif (retval)\n\t\treiserfs_abort(s, retval, \"Journal write error in %s\",\n\t\t\t       __func__);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\nstatic int dirty_one_transaction(struct super_block *s,\n\t\t\t\t struct reiserfs_journal_list *jl);\nstatic void remove_journal_hash(struct super_block *,\n\t\t\t\tstruct reiserfs_journal_cnode **,\n\t\t\t\tstruct reiserfs_journal_list *, unsigned long,\n\t\t\t\tint);\n\nstatic struct reiserfs_list_bitmap *get_list_bitmap(struct super_block *sb,\n\t\t\t\t\t\t    struct reiserfs_journal_list\n\t\t\t\t\t\t    *jl)\n{\n\tint i, j;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_list_bitmap *jb = NULL;\n\n\tfor (j = 0; j < (JOURNAL_NUM_BITMAPS * 3); j++) {\n\t\ti = journal->j_list_bitmap_index;\n\t\tjournal->j_list_bitmap_index = (i + 1) % JOURNAL_NUM_BITMAPS;\n\t\tjb = journal->j_list_bitmap + i;\n\t\tif (journal->j_list_bitmap[i].journal_list) {\n\t\t\tflush_commit_list(sb,\n\t\t\t\t\t  journal->j_list_bitmap[i].\n\t\t\t\t\t  journal_list, 1);\n\t\t\tif (!journal->j_list_bitmap[i].journal_list) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* double check to make sure if flushed correctly */\n\tif (jb->journal_list)\n\t\treturn NULL;\n\tjb->journal_list = jl;\n\treturn jb;\n}"
  },
  {
    "function_name": "reiserfs_allocate_list_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "279-304",
    "snippet": "int reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_list_bitmaps",
          "args": [
            "sb",
            "jb_array"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "free_list_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "242-255",
          "snippet": "static int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "sb",
            "\"clm-2000\"",
            "\"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "mem"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_allocate_list_bitmaps(struct super_block *sb,\n\t\t\t\t   struct reiserfs_list_bitmap *jb_array,\n\t\t\t\t   unsigned int bmap_nr)\n{\n\tint i;\n\tint failed = 0;\n\tstruct reiserfs_list_bitmap *jb;\n\tint mem = bmap_nr * sizeof(struct reiserfs_bitmap_node *);\n\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tjb->bitmaps = vzalloc(mem);\n\t\tif (!jb->bitmaps) {\n\t\t\treiserfs_warning(sb, \"clm-2000\", \"unable to \"\n\t\t\t\t\t \"allocate bitmaps for journal lists\");\n\t\t\tfailed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (failed) {\n\t\tfree_list_bitmaps(sb, jb_array);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_bitmap_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "257-273",
    "snippet": "static int free_bitmap_nodes(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct list_head *next = journal->j_bitmap_nodes.next;\n\tstruct reiserfs_bitmap_node *bn;\n\n\twhile (next != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(next, struct reiserfs_bitmap_node, list);\n\t\tlist_del(next);\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t\tnext = journal->j_bitmap_nodes.next;\n\t\tjournal->j_free_bitmap_nodes--;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bn"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bn->data"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "next"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structreiserfs_bitmap_node",
            "list"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic int free_bitmap_nodes(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct list_head *next = journal->j_bitmap_nodes.next;\n\tstruct reiserfs_bitmap_node *bn;\n\n\twhile (next != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(next, struct reiserfs_bitmap_node, list);\n\t\tlist_del(next);\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t\tnext = journal->j_bitmap_nodes.next;\n\t\tjournal->j_free_bitmap_nodes--;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_list_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "242-255",
    "snippet": "static int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "jb->bitmaps"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_bitmap_list",
          "args": [
            "sb",
            "jb"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_bitmap_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "224-237",
          "snippet": "static void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int free_list_bitmaps(struct super_block *sb,\n\t\t\t     struct reiserfs_list_bitmap *jb_array)\n{\n\tint i;\n\tstruct reiserfs_list_bitmap *jb;\n\tfor (i = 0; i < JOURNAL_NUM_BITMAPS; i++) {\n\t\tjb = jb_array + i;\n\t\tjb->journal_list = NULL;\n\t\tcleanup_bitmap_list(sb, jb);\n\t\tvfree(jb->bitmaps);\n\t\tjb->bitmaps = NULL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_bitmap_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "224-237",
    "snippet": "static void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_bitmap_node",
          "args": [
            "sb",
            "jb->bitmaps[i]"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "free_bitmap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "179-191",
          "snippet": "static inline void free_bitmap_node(struct super_block *sb,\n\t\t\t\t    struct reiserfs_bitmap_node *bn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tjournal->j_used_bitmap_nodes--;\n\tif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t} else {\n\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\tjournal->j_free_bitmap_nodes++;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic inline void free_bitmap_node(struct super_block *sb,\n\t\t\t\t    struct reiserfs_bitmap_node *bn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tjournal->j_used_bitmap_nodes--;\n\tif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t} else {\n\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\tjournal->j_free_bitmap_nodes++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_bmap_count",
          "args": [
            "sb"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_bmap_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "1161-1164",
          "snippet": "static inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int reiserfs_resize(struct super_block *, unsigned long);",
            "void reiserfs_flush_old_commits(struct super_block *);",
            "int journal_release(struct reiserfs_transaction_handle *, struct super_block *);",
            "int journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);",
            "int journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);",
            "int journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);",
            "int reiserfs_convert_objectid_map_v1(struct super_block *);",
            "const struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);",
            "int reiserfs_parse_alloc_options(struct super_block *, char *);",
            "int reiserfs_init_bitmap_cache(struct super_block *sb);",
            "void reiserfs_free_bitmap_cache(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nint reiserfs_resize(struct super_block *, unsigned long);\nvoid reiserfs_flush_old_commits(struct super_block *);\nint journal_release(struct reiserfs_transaction_handle *, struct super_block *);\nint journal_release_error(struct reiserfs_transaction_handle *,\n\t\t\t  struct super_block *);\nint journal_begin(struct reiserfs_transaction_handle *,\n\t\t  struct super_block *sb, unsigned long);\nint journal_join_abort(struct reiserfs_transaction_handle *,\n\t\t       struct super_block *sb);\nint reiserfs_convert_objectid_map_v1(struct super_block *);\nconst struct reiserfs_key *get_rkey(const struct treepath *chk_path,\n\t\t\t\t    const struct super_block *sb);\nint reiserfs_parse_alloc_options(struct super_block *, char *);\nint reiserfs_init_bitmap_cache(struct super_block *sb);\nvoid reiserfs_free_bitmap_cache(struct super_block *sb);\n\nstatic inline __u32 reiserfs_bmap_count(struct super_block *sb)\n{\n\treturn (SB_BLOCK_COUNT(sb) - 1) / (sb->s_blocksize * 8) + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic void cleanup_bitmap_list(struct super_block *sb,\n\t\t\t\tstruct reiserfs_list_bitmap *jb)\n{\n\tint i;\n\tif (jb->bitmaps == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < reiserfs_bmap_count(sb); i++) {\n\t\tif (jb->bitmaps[i]) {\n\t\t\tfree_bitmap_node(sb, jb->bitmaps[i]);\n\t\t\tjb->bitmaps[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "set_bit_in_list_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "210-222",
    "snippet": "static int set_bit_in_list_bitmap(struct super_block *sb,\n\t\t\t\t  b_blocknr_t block,\n\t\t\t\t  struct reiserfs_list_bitmap *jb)\n{\n\tunsigned int bmap_nr = block / (sb->s_blocksize << 3);\n\tunsigned int bit_nr = block % (sb->s_blocksize << 3);\n\n\tif (!jb->bitmaps[bmap_nr]) {\n\t\tjb->bitmaps[bmap_nr] = get_bitmap_node(sb);\n\t}\n\tset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit_nr",
            "(unsigned long *)jb->bitmaps[bmap_nr]->data"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bitmap_node",
          "args": [
            "sb"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "get_bitmap_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "156-178",
          "snippet": "static struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tstruct list_head *entry = journal->j_bitmap_nodes.next;\n\n\tjournal->j_used_bitmap_nodes++;\nrepeat:\n\n\tif (entry != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(entry, struct reiserfs_bitmap_node, list);\n\t\tlist_del(entry);\n\t\tmemset(bn->data, 0, sb->s_blocksize);\n\t\tjournal->j_free_bitmap_nodes--;\n\t\treturn bn;\n\t}\n\tbn = allocate_bitmap_node(sb);\n\tif (!bn) {\n\t\tyield();\n\t\tgoto repeat;\n\t}\n\treturn bn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tstruct list_head *entry = journal->j_bitmap_nodes.next;\n\n\tjournal->j_used_bitmap_nodes++;\nrepeat:\n\n\tif (entry != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(entry, struct reiserfs_bitmap_node, list);\n\t\tlist_del(entry);\n\t\tmemset(bn->data, 0, sb->s_blocksize);\n\t\tjournal->j_free_bitmap_nodes--;\n\t\treturn bn;\n\t}\n\tbn = allocate_bitmap_node(sb);\n\tif (!bn) {\n\t\tyield();\n\t\tgoto repeat;\n\t}\n\treturn bn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic int set_bit_in_list_bitmap(struct super_block *sb,\n\t\t\t\t  b_blocknr_t block,\n\t\t\t\t  struct reiserfs_list_bitmap *jb)\n{\n\tunsigned int bmap_nr = block / (sb->s_blocksize << 3);\n\tunsigned int bit_nr = block % (sb->s_blocksize << 3);\n\n\tif (!jb->bitmaps[bmap_nr]) {\n\t\tjb->bitmaps[bmap_nr] = get_bitmap_node(sb);\n\t}\n\tset_bit(bit_nr, (unsigned long *)jb->bitmaps[bmap_nr]->data);\n\treturn 0;\n}"
  },
  {
    "function_name": "allocate_bitmap_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "193-208",
    "snippet": "static void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bn->list",
            "&journal->j_bitmap_nodes"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate_bitmap_node",
          "args": [
            "sb"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_bitmap_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "193-208",
          "snippet": "static void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_bitmap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "179-191",
    "snippet": "static inline void free_bitmap_node(struct super_block *sb,\n\t\t\t\t    struct reiserfs_bitmap_node *bn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tjournal->j_used_bitmap_nodes--;\n\tif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t} else {\n\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\tjournal->j_free_bitmap_nodes++;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bn->list",
            "&journal->j_bitmap_nodes"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bn"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bn->data"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic inline void free_bitmap_node(struct super_block *sb,\n\t\t\t\t    struct reiserfs_bitmap_node *bn)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tjournal->j_used_bitmap_nodes--;\n\tif (journal->j_free_bitmap_nodes > REISERFS_MAX_BITMAP_NODES) {\n\t\tkfree(bn->data);\n\t\tkfree(bn);\n\t} else {\n\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\tjournal->j_free_bitmap_nodes++;\n\t}\n}"
  },
  {
    "function_name": "get_bitmap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "156-178",
    "snippet": "static struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tstruct list_head *entry = journal->j_bitmap_nodes.next;\n\n\tjournal->j_used_bitmap_nodes++;\nrepeat:\n\n\tif (entry != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(entry, struct reiserfs_bitmap_node, list);\n\t\tlist_del(entry);\n\t\tmemset(bn->data, 0, sb->s_blocksize);\n\t\tjournal->j_free_bitmap_nodes--;\n\t\treturn bn;\n\t}\n\tbn = allocate_bitmap_node(sb);\n\tif (!bn) {\n\t\tyield();\n\t\tgoto repeat;\n\t}\n\treturn bn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_bitmap_node",
          "args": [
            "sb"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_bitmap_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "193-208",
          "snippet": "static void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void allocate_bitmap_nodes(struct super_block *sb)\n{\n\tint i;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tfor (i = 0; i < REISERFS_MIN_BITMAP_NODES; i++) {\n\t\tbn = allocate_bitmap_node(sb);\n\t\tif (bn) {\n\t\t\tlist_add(&bn->list, &journal->j_bitmap_nodes);\n\t\t\tjournal->j_free_bitmap_nodes++;\n\t\t} else {\n\t\t\t/* this is ok, we'll try again when more are needed */\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bn->data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "entry"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "entry",
            "structreiserfs_bitmap_node",
            "list"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic struct reiserfs_bitmap_node *get_bitmap_node(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_bitmap_node *bn = NULL;\n\tstruct list_head *entry = journal->j_bitmap_nodes.next;\n\n\tjournal->j_used_bitmap_nodes++;\nrepeat:\n\n\tif (entry != &journal->j_bitmap_nodes) {\n\t\tbn = list_entry(entry, struct reiserfs_bitmap_node, list);\n\t\tlist_del(entry);\n\t\tmemset(bn->data, 0, sb->s_blocksize);\n\t\tjournal->j_free_bitmap_nodes--;\n\t\treturn bn;\n\t}\n\tbn = allocate_bitmap_node(sb);\n\tif (!bn) {\n\t\tyield();\n\t\tgoto repeat;\n\t}\n\treturn bn;\n}"
  },
  {
    "function_name": "allocate_bitmap_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "136-154",
    "snippet": "static struct reiserfs_bitmap_node *allocate_bitmap_node(struct super_block\n\t\t\t\t\t\t\t *sb)\n{\n\tstruct reiserfs_bitmap_node *bn;\n\tstatic int id;\n\n\tbn = kmalloc(sizeof(struct reiserfs_bitmap_node), GFP_NOFS);\n\tif (!bn) {\n\t\treturn NULL;\n\t}\n\tbn->data = kzalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!bn->data) {\n\t\tkfree(bn);\n\t\treturn NULL;\n\t}\n\tbn->id = id++;\n\tINIT_LIST_HEAD(&bn->list);\n\treturn bn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bn->list"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bn"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct reiserfs_bitmap_node)",
            "GFP_NOFS"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\n\nstatic struct reiserfs_bitmap_node *allocate_bitmap_node(struct super_block\n\t\t\t\t\t\t\t *sb)\n{\n\tstruct reiserfs_bitmap_node *bn;\n\tstatic int id;\n\n\tbn = kmalloc(sizeof(struct reiserfs_bitmap_node), GFP_NOFS);\n\tif (!bn) {\n\t\treturn NULL;\n\t}\n\tbn->data = kzalloc(sb->s_blocksize, GFP_NOFS);\n\tif (!bn->data) {\n\t\tkfree(bn);\n\t\treturn NULL;\n\t}\n\tbn->id = id++;\n\tINIT_LIST_HEAD(&bn->list);\n\treturn bn;\n}"
  },
  {
    "function_name": "reiserfs_clean_and_file_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "127-134",
    "snippet": "static int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\n{\n\tif (bh) {\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_journal_test",
          "args": [
            "bh"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int reiserfs_clean_and_file_buffer(struct buffer_head *bh)\n{\n\tif (bh) {\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_journal_test(bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "init_journal_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
    "lines": "114-119",
    "snippet": "static void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
      "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "journal->j_hash_table",
            "0",
            "JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_JOURNAL",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nstatic void init_journal_hash(struct super_block *sb)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tmemset(journal->j_hash_table, 0,\n\t       JOURNAL_HASH_SIZE * sizeof(struct reiserfs_journal_cnode *));\n}"
  }
]