[
  {
    "function_name": "befs_check_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/super.c",
    "lines": "59-112",
    "snippet": "int\nbefs_check_sb(struct super_block *sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check magic headers of super block */\n\tif ((befs_sb->magic1 != BEFS_SUPER_MAGIC1)\n\t    || (befs_sb->magic2 != BEFS_SUPER_MAGIC2)\n\t    || (befs_sb->magic3 != BEFS_SUPER_MAGIC3)) {\n\t\tbefs_error(sb, \"invalid magic header\");\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t * Check blocksize of BEFS.\n\t *\n\t * Blocksize of BEFS is 1024, 2048, 4096 or 8192.\n\t */\n\n\tif ((befs_sb->block_size != 1024)\n\t    && (befs_sb->block_size != 2048)\n\t    && (befs_sb->block_size != 4096)\n\t    && (befs_sb->block_size != 8192)) {\n\t\tbefs_error(sb, \"invalid blocksize: %u\", befs_sb->block_size);\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->block_size > PAGE_SIZE) {\n\t\tbefs_error(sb, \"blocksize(%u) cannot be larger\"\n\t\t\t   \"than system pagesize(%lu)\", befs_sb->block_size,\n\t\t\t   PAGE_SIZE);\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t   * block_shift and block_size encode the same information\n\t   * in different ways as a consistency check.\n\t */\n\n\tif ((1 << befs_sb->block_shift) != befs_sb->block_size) {\n\t\tbefs_error(sb, \"block_shift disagrees with block_size. \"\n\t\t\t   \"Corruption likely.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->log_start != befs_sb->log_end) {\n\t\tbefs_error(sb, \"Filesystem not clean! There are blocks in the \"\n\t\t\t   \"journal. You must boot into BeOS and mount this volume \"\n\t\t\t   \"to make it clean.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\treturn BEFS_OK;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include \"befs.h\"",
      "#include <asm/page.h> /* for PAGE_SIZE */",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "befs_error",
          "args": [
            "sb",
            "\"Filesystem not clean! There are blocks in the \"\n\t\t\t   \"journal. You must boot into BeOS and mount this volume \"\n\t\t\t   \"to make it clean.\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "befs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "27-38",
          "snippet": "void\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_error(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_err(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include \"befs.h\"\n#include <asm/page.h> /* for PAGE_SIZE */\n#include <linux/fs.h>\n\nint\nbefs_check_sb(struct super_block *sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check magic headers of super block */\n\tif ((befs_sb->magic1 != BEFS_SUPER_MAGIC1)\n\t    || (befs_sb->magic2 != BEFS_SUPER_MAGIC2)\n\t    || (befs_sb->magic3 != BEFS_SUPER_MAGIC3)) {\n\t\tbefs_error(sb, \"invalid magic header\");\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t * Check blocksize of BEFS.\n\t *\n\t * Blocksize of BEFS is 1024, 2048, 4096 or 8192.\n\t */\n\n\tif ((befs_sb->block_size != 1024)\n\t    && (befs_sb->block_size != 2048)\n\t    && (befs_sb->block_size != 4096)\n\t    && (befs_sb->block_size != 8192)) {\n\t\tbefs_error(sb, \"invalid blocksize: %u\", befs_sb->block_size);\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->block_size > PAGE_SIZE) {\n\t\tbefs_error(sb, \"blocksize(%u) cannot be larger\"\n\t\t\t   \"than system pagesize(%lu)\", befs_sb->block_size,\n\t\t\t   PAGE_SIZE);\n\t\treturn BEFS_ERR;\n\t}\n\n\t/*\n\t   * block_shift and block_size encode the same information\n\t   * in different ways as a consistency check.\n\t */\n\n\tif ((1 << befs_sb->block_shift) != befs_sb->block_size) {\n\t\tbefs_error(sb, \"block_shift disagrees with block_size. \"\n\t\t\t   \"Corruption likely.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\tif (befs_sb->log_start != befs_sb->log_end) {\n\t\tbefs_error(sb, \"Filesystem not clean! There are blocks in the \"\n\t\t\t   \"journal. You must boot into BeOS and mount this volume \"\n\t\t\t   \"to make it clean.\");\n\t\treturn BEFS_ERR;\n\t}\n\n\treturn BEFS_OK;\n}"
  },
  {
    "function_name": "befs_load_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/super.c",
    "lines": "24-57",
    "snippet": "int\nbefs_load_sb(struct super_block *sb, befs_super_block * disk_sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check the byte order of the filesystem */\n\tif (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_LE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_LE;\n\telse if (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_BE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_BE;\n\n\tbefs_sb->magic1 = fs32_to_cpu(sb, disk_sb->magic1);\n\tbefs_sb->magic2 = fs32_to_cpu(sb, disk_sb->magic2);\n\tbefs_sb->magic3 = fs32_to_cpu(sb, disk_sb->magic3);\n\tbefs_sb->block_size = fs32_to_cpu(sb, disk_sb->block_size);\n\tbefs_sb->block_shift = fs32_to_cpu(sb, disk_sb->block_shift);\n\tbefs_sb->num_blocks = fs64_to_cpu(sb, disk_sb->num_blocks);\n\tbefs_sb->used_blocks = fs64_to_cpu(sb, disk_sb->used_blocks);\n\tbefs_sb->inode_size = fs32_to_cpu(sb, disk_sb->inode_size);\n\n\tbefs_sb->blocks_per_ag = fs32_to_cpu(sb, disk_sb->blocks_per_ag);\n\tbefs_sb->ag_shift = fs32_to_cpu(sb, disk_sb->ag_shift);\n\tbefs_sb->num_ags = fs32_to_cpu(sb, disk_sb->num_ags);\n\n\tbefs_sb->log_blocks = fsrun_to_cpu(sb, disk_sb->log_blocks);\n\tbefs_sb->log_start = fs64_to_cpu(sb, disk_sb->log_start);\n\tbefs_sb->log_end = fs64_to_cpu(sb, disk_sb->log_end);\n\n\tbefs_sb->root_dir = fsrun_to_cpu(sb, disk_sb->root_dir);\n\tbefs_sb->indices = fsrun_to_cpu(sb, disk_sb->indices);\n\tbefs_sb->nls = NULL;\n\n\treturn BEFS_OK;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include \"befs.h\"",
      "#include <asm/page.h> /* for PAGE_SIZE */",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsrun_to_cpu",
          "args": [
            "sb",
            "disk_sb->indices"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "fsrun_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "70-85",
          "snippet": "static inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline befs_block_run\nfsrun_to_cpu(const struct super_block *sb, befs_disk_block_run n)\n{\n\tbefs_block_run run;\n\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE) {\n\t\trun.allocation_group = le32_to_cpu((__force __le32)n.allocation_group);\n\t\trun.start = le16_to_cpu((__force __le16)n.start);\n\t\trun.len = le16_to_cpu((__force __le16)n.len);\n\t} else {\n\t\trun.allocation_group = be32_to_cpu((__force __be32)n.allocation_group);\n\t\trun.start = be16_to_cpu((__force __be16)n.start);\n\t\trun.len = be16_to_cpu((__force __be16)n.len);\n\t}\n\treturn run;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs64_to_cpu",
          "args": [
            "sb",
            "disk_sb->log_end"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "fs64_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "14-21",
          "snippet": "static inline u64\nfs64_to_cpu(const struct super_block *sb, fs64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline u64\nfs64_to_cpu(const struct super_block *sb, fs64 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le64_to_cpu((__force __le64)n);\n\telse\n\t\treturn be64_to_cpu((__force __be64)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "disk_sb->num_ags"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/endian.h",
          "lines": "32-39",
          "snippet": "static inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/byteorder.h>\n\nstatic inline u32\nfs32_to_cpu(const struct super_block *sb, fs32 n)\n{\n\tif (BEFS_SB(sb)->byte_order == BEFS_BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BEFS_SB",
          "args": [
            "sb"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "BEFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/befs.h",
          "lines": "108-112",
          "snippet": "static inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"befs_fs_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"befs_fs_types.h\"\n\nstatic inline befs_sb_info *\nBEFS_SB(const struct super_block *super)\n{\n\treturn (befs_sb_info *) super->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include \"befs.h\"\n#include <asm/page.h> /* for PAGE_SIZE */\n#include <linux/fs.h>\n\nint\nbefs_load_sb(struct super_block *sb, befs_super_block * disk_sb)\n{\n\tbefs_sb_info *befs_sb = BEFS_SB(sb);\n\n\t/* Check the byte order of the filesystem */\n\tif (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_LE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_LE;\n\telse if (disk_sb->fs_byte_order == BEFS_BYTEORDER_NATIVE_BE)\n\t    befs_sb->byte_order = BEFS_BYTESEX_BE;\n\n\tbefs_sb->magic1 = fs32_to_cpu(sb, disk_sb->magic1);\n\tbefs_sb->magic2 = fs32_to_cpu(sb, disk_sb->magic2);\n\tbefs_sb->magic3 = fs32_to_cpu(sb, disk_sb->magic3);\n\tbefs_sb->block_size = fs32_to_cpu(sb, disk_sb->block_size);\n\tbefs_sb->block_shift = fs32_to_cpu(sb, disk_sb->block_shift);\n\tbefs_sb->num_blocks = fs64_to_cpu(sb, disk_sb->num_blocks);\n\tbefs_sb->used_blocks = fs64_to_cpu(sb, disk_sb->used_blocks);\n\tbefs_sb->inode_size = fs32_to_cpu(sb, disk_sb->inode_size);\n\n\tbefs_sb->blocks_per_ag = fs32_to_cpu(sb, disk_sb->blocks_per_ag);\n\tbefs_sb->ag_shift = fs32_to_cpu(sb, disk_sb->ag_shift);\n\tbefs_sb->num_ags = fs32_to_cpu(sb, disk_sb->num_ags);\n\n\tbefs_sb->log_blocks = fsrun_to_cpu(sb, disk_sb->log_blocks);\n\tbefs_sb->log_start = fs64_to_cpu(sb, disk_sb->log_start);\n\tbefs_sb->log_end = fs64_to_cpu(sb, disk_sb->log_end);\n\n\tbefs_sb->root_dir = fsrun_to_cpu(sb, disk_sb->root_dir);\n\tbefs_sb->indices = fsrun_to_cpu(sb, disk_sb->indices);\n\tbefs_sb->nls = NULL;\n\n\treturn BEFS_OK;\n}"
  }
]