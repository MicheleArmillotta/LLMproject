[
  {
    "function_name": "e_space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "721-730",
    "snippet": "fs_get_free_space(struct ubifs_info *c)\n{\n\tlong long free;\n\n\tspin_lock(&c->space_lock);\n\tfree = ubifs_get_free_space_nolock(c);\n\tspin_unlock(&c->space_lock);\n\n\treturn free;\n}",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\n\treturn f"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_space_nolock(c);\n\tspin_un",
          "args": [
            "o"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tfree = ub"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nfs_get_free_space(struct ubifs_info *c)\n{\n\tlong long free;\n\n\tspin_lock(&c->space_lock);\n\tfree = ubifs_get_free_space_nolock(c);\n\tspin_unlock(&c->space_lock);\n\n\treturn free;\n}"
  },
  {
    "function_name": "e_space_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "678-712",
    "snippet": "fs_get_free_space_nolock(struct ubifs_info *c)\n{\n\tint rsvd_idx_lebs, lebs;\n\tlong long available, outstanding, free;\n\n\tubifs_assert(c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\n\t/*\n\t * When reporting free space to user-space, UBIFS guarantees that it is\n\t * possible to write a file of free space size. This means that for\n\t * empty LEBs we may use more precise calculations than\n\t * 'ubifs_calc_available()' is using. Namely, we know that in empty\n\t * LEBs we would waste only @c->leb_overhead bytes, not @c->dark_wm.\n\t * Thus, amend the available space.\n\t *\n\t * Note, the calculations below are similar to what we have in\n\t * 'do_budget_space()', so refer there for comments.\n\t */\n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tlebs -= rsvd_idx_lebs;\n\tavailable += lebs * (c->dark_wm - c->leb_overhead);\n\n\tif (available > outstanding)\n\t\tfree = ubifs_reported_space(c, available - outstanding);\n\telse\n\t\tfree = 0;\n\treturn free;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_space(c, available",
          "args": [
            "-",
            "utstanding);\n\telse\n\t\tfr"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailable(c, c->bi.min",
          "args": [
            "i",
            "_lebs);\n\n\t/*\n\t * W"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.min_id",
          "args": [
            "_lebs == ubifs_calc_min_idx_lebs(c));\n\toutstandi"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c));\n\toutsta",
          "args": [
            "d"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nfs_get_free_space_nolock(struct ubifs_info *c)\n{\n\tint rsvd_idx_lebs, lebs;\n\tlong long available, outstanding, free;\n\n\tubifs_assert(c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\tavailable = ubifs_calc_available(c, c->bi.min_idx_lebs);\n\n\t/*\n\t * When reporting free space to user-space, UBIFS guarantees that it is\n\t * possible to write a file of free space size. This means that for\n\t * empty LEBs we may use more precise calculations than\n\t * 'ubifs_calc_available()' is using. Namely, we know that in empty\n\t * LEBs we would waste only @c->leb_overhead bytes, not @c->dark_wm.\n\t * Thus, amend the available space.\n\t *\n\t * Note, the calculations below are similar to what we have in\n\t * 'do_budget_space()', so refer there for comments.\n\t */\n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tlebs -= rsvd_idx_lebs;\n\tavailable += lebs * (c->dark_wm - c->leb_overhead);\n\n\tif (available > outstanding)\n\t\tfree = ubifs_reported_space(c, available - outstanding);\n\telse\n\t\tfree = 0;\n\treturn free;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "d_space(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "637-660",
    "snippet": "fs_reported_space(const struct ubifs_info *c, long long free)\n{\n\tint divisor, factor, f;\n\n\t/*\n\t * Reported space size is @free * X, where X is UBIFS block size\n\t * divided by UBIFS block size + all overhead one data block\n\t * introduces. The overhead is the node header + indexing overhead.\n\t *\n\t * Indexing overhead calculations are based on the following formula:\n\t * I = N/(f - 1) + 1, where I - number of indexing nodes, N - number\n\t * of data nodes, f - fanout. Because effective UBIFS fanout is twice\n\t * as less than maximum fanout, we assume that each data node\n\t * introduces 3 * @c->max_idx_node_sz / (@c->fanout/2 - 1) bytes.\n\t * Note, the multiplier 3 is because UBIFS reserves thrice as more space\n\t * for the index.\n\t */\n\tf = c->fanout > 3 ? c->fanout >> 1 : 2;\n\tfactor = UBIFS_BLOCK_SIZE;\n\tdivisor = UBIFS_MAX_DATA_NODE_SZ;\n\tdivisor += (c->max_idx_node_sz * 3) / (f - 1);\n\tfree *= factor;\n\treturn div_u64(free, divisor);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diviso",
          "args": [
            ");\n}",
            "/**\n *"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nfs_reported_space(const struct ubifs_info *c, long long free)\n{\n\tint divisor, factor, f;\n\n\t/*\n\t * Reported space size is @free * X, where X is UBIFS block size\n\t * divided by UBIFS block size + all overhead one data block\n\t * introduces. The overhead is the node header + indexing overhead.\n\t *\n\t * Indexing overhead calculations are based on the following formula:\n\t * I = N/(f - 1) + 1, where I - number of indexing nodes, N - number\n\t * of data nodes, f - fanout. Because effective UBIFS fanout is twice\n\t * as less than maximum fanout, we assume that each data node\n\t * introduces 3 * @c->max_idx_node_sz / (@c->fanout/2 - 1) bytes.\n\t * Note, the multiplier 3 is because UBIFS reserves thrice as more space\n\t * for the index.\n\t */\n\tf = c->fanout > 3 ? c->fanout >> 1 : 2;\n\tfactor = UBIFS_BLOCK_SIZE;\n\tdivisor = UBIFS_MAX_DATA_NODE_SZ;\n\tdivisor += (c->max_idx_node_sz * 3) / (f - 1);\n\tfree *= factor;\n\treturn div_u64(free, divisor);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_dirty_inode_budget(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "606-615",
    "snippet": "lease_dirty_inode_budget(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_inode *ui)\n{\n\tstruct ubifs_budget_req req;\n\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\t/* The \"no space\" flags will be cleared because dd_growth is > 0 */\n\treq.dd_growth = c->bi.inode_budget + ALIGN(ui->data_len, 8);\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n}",
          "args": [
            "/",
            "*"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_len",
          "args": [
            "8);\n\tubifs_",
            "l"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, siz",
          "args": [
            "of(s",
            "u",
            "ubifs_budget_req));\n\t/* The \"n"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlease_dirty_inode_budget(struct ubifs_info *c,\n\t\t\t\t      struct ubifs_inode *ui)\n{\n\tstruct ubifs_budget_req req;\n\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\t/* The \"no space\" flags will be cleared because dd_growth is > 0 */\n\treq.dd_growth = c->bi.inode_budget + ALIGN(ui->data_len, 8);\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_page_budget(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "583-595",
    "snippet": "nvert_page_budget(struct ubifs_info *c)\n{\n\tspin_lock(&c->space_lock);\n\t/* Release the index growth reservation */\n\tc->bi.idx_growth -= c->max_idx_node_sz << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\t/* Release the data growth reservation */\n\tc->bi.data_growth -= c->bi.page_budget;\n\t/* Increase the dirty data growth reservation instead */\n\tc->bi.dd_growth += c->bi.page_budget;\n\t/* And re-calculate the indexing space reservation */\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n}\n\n/**\n *"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\tspin_un",
          "args": [
            "o"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t/* Releas"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nnvert_page_budget(struct ubifs_info *c)\n{\n\tspin_lock(&c->space_lock);\n\t/* Release the index growth reservation */\n\tc->bi.idx_growth -= c->max_idx_node_sz << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\t/* Release the data growth reservation */\n\tc->bi.data_growth -= c->bi.page_budget;\n\t/* Increase the dirty data growth reservation instead */\n\tc->bi.dd_growth += c->bi.page_budget;\n\t/* And re-calculate the indexing space reservation */\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_budget(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "527-572",
    "snippet": "lease_budget(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tubifs_assert(req->new_page <= 1);\n\tubifs_assert(req->dirtied_page <= 1);\n\tubifs_assert(req->new_dent <= 1);\n\tubifs_assert(req->mod_dent <= 1);\n\tubifs_assert(req->new_ino <= 1);\n\tubifs_assert(req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(req->dirtied_ino <= 4);\n\tubifs_assert(req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(!(req->new_ino_d & 7));\n\tubifs_assert(!(req->dirtied_ino_d & 7));\n\tif (!req->recalculate) {\n\t\tubifs_assert(req->idx_growth >= 0);\n\t\tubifs_assert(req->data_growth >= 0);\n\t\tubifs_assert(req->dd_growth >= 0);\n\t}\n\n\tif (req->recalculate) {\n\t\treq->data_growth = calc_data_growth(c, req);\n\t\treq->dd_growth = calc_dd_growth(c, req);\n\t\treq->idx_growth = calc_idx_growth(c, req);\n\t}\n\n\tif (!req->data_growth && !req->dd_growth)\n\t\treturn;\n\n\tc->bi.nospace = c->bi.nospace_rp = 0;\n\tsmp_wmb();\n\n\tspin_lock(&c->space_lock);\n\tc->bi.idx_growth -= req->idx_growth;\n\tc->bi.uncommitted_idx += req->idx_growth;\n\tc->bi.data_growth -= req->data_growth;\n\tc->bi.dd_growth -= req->dd_growth;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\tubifs_assert(c->bi.idx_growth >= 0);\n\tubifs_assert(c->bi.data_growth >= 0);\n\tubifs_assert(c->bi.dd_growth >= 0);\n\tubifs_assert(c->bi.min_idx_lebs < c->main_lebs);\n\tubifs_assert(!(c->bi.idx_growth & 7));\n\tubifs_assert(!(c->bi.data_growth & 7));\n\tubifs_assert(!(c->bi.dd_growth & 7));\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n}\n\n/**\n *"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->bi.dd_g",
          "args": [
            "owth & 7));\n\tspin_unlo"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->bi.data",
          "args": [
            "growth & 7));\n\tubifs_ass"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(c->bi.idx_",
          "args": [
            "rowth & 7));\n\tubifs_ass"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.min_id",
          "args": [
            "_lebs < c->main_lebs);\n\tubifs_ass"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.dd_gro",
          "args": [
            "th >= 0);\n\tubifs_ass"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.data_g",
          "args": [
            "owth >= 0);\n\tubifs_ass"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.idx_gr",
          "args": [
            "wth >= 0);\n\tubifs_ass"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\n\tubifs_",
          "args": [
            "s"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tc->bi.idx"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lo",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "th(c, req);\n\t}",
          "args": [
            "(!"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, req);\n\t\tr",
          "args": [
            "q",
            "idx"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wth(c, req);\n\t\tr",
          "args": [
            "q",
            "dd_"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dd_grow",
          "args": [
            "h >= 0);\n\t}\n\n\tif (r"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->data_gr",
          "args": [
            "wth >= 0);\n\t\tubifs_as"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->idx_gro",
          "args": [
            "th >= 0);\n\t\tubifs_as"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(req->dirti",
          "args": [
            "d_ino_d & 7));\n\tif (!req-"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(req->new_i",
          "args": [
            "o_d & 7));\n\tubifs_ass"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_ass"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "ino <= 4);\n\tubifs_ass"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_ino",
          "args": [
            "d <= UBIFS_MAX_INO_DATA);\n\tubifs_ass"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_ino",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->mod_den",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_den",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "page <= 1);\n\tubifs_ass"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_pag",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlease_budget(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tubifs_assert(req->new_page <= 1);\n\tubifs_assert(req->dirtied_page <= 1);\n\tubifs_assert(req->new_dent <= 1);\n\tubifs_assert(req->mod_dent <= 1);\n\tubifs_assert(req->new_ino <= 1);\n\tubifs_assert(req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(req->dirtied_ino <= 4);\n\tubifs_assert(req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(!(req->new_ino_d & 7));\n\tubifs_assert(!(req->dirtied_ino_d & 7));\n\tif (!req->recalculate) {\n\t\tubifs_assert(req->idx_growth >= 0);\n\t\tubifs_assert(req->data_growth >= 0);\n\t\tubifs_assert(req->dd_growth >= 0);\n\t}\n\n\tif (req->recalculate) {\n\t\treq->data_growth = calc_data_growth(c, req);\n\t\treq->dd_growth = calc_dd_growth(c, req);\n\t\treq->idx_growth = calc_idx_growth(c, req);\n\t}\n\n\tif (!req->data_growth && !req->dd_growth)\n\t\treturn;\n\n\tc->bi.nospace = c->bi.nospace_rp = 0;\n\tsmp_wmb();\n\n\tspin_lock(&c->space_lock);\n\tc->bi.idx_growth -= req->idx_growth;\n\tc->bi.uncommitted_idx += req->idx_growth;\n\tc->bi.data_growth -= req->data_growth;\n\tc->bi.dd_growth -= req->dd_growth;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\tubifs_assert(c->bi.idx_growth >= 0);\n\tubifs_assert(c->bi.data_growth >= 0);\n\tubifs_assert(c->bi.dd_growth >= 0);\n\tubifs_assert(c->bi.min_idx_lebs < c->main_lebs);\n\tubifs_assert(!(c->bi.idx_growth & 7));\n\tubifs_assert(!(c->bi.data_growth & 7));\n\tubifs_assert(!(c->bi.dd_growth & 7));\n\tspin_unlock(&c->space_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "438-514",
    "snippet": "get_space(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tint err, idx_growth, data_growth, dd_growth, retried = 0;\n\n\tubifs_assert(req->new_page <= 1);\n\tubifs_assert(req->dirtied_page <= 1);\n\tubifs_assert(req->new_dent <= 1);\n\tubifs_assert(req->mod_dent <= 1);\n\tubifs_assert(req->new_ino <= 1);\n\tubifs_assert(req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(req->dirtied_ino <= 4);\n\tubifs_assert(req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(!(req->new_ino_d & 7));\n\tubifs_assert(!(req->dirtied_ino_d & 7));\n\n\tdata_growth = calc_data_growth(c, req);\n\tdd_growth = calc_dd_growth(c, req);\n\tif (!data_growth && !dd_growth)\n\t\treturn 0;\n\tidx_growth = calc_idx_growth(c, req);\n\nagain:\n\tspin_lock(&c->space_lock);\n\tubifs_assert(c->bi.idx_growth >= 0);\n\tubifs_assert(c->bi.data_growth >= 0);\n\tubifs_assert(c->bi.dd_growth >= 0);\n\n\tif (unlikely(c->bi.nospace) && (c->bi.nospace_rp || !can_use_rp(c))) {\n\t\tdbg_budg(\"no space\");\n\t\tspin_unlock(&c->space_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tc->bi.idx_growth += idx_growth;\n\tc->bi.data_growth += data_growth;\n\tc->bi.dd_growth += dd_growth;\n\n\terr = do_budget_space(c);\n\tif (likely(!err)) {\n\t\treq->idx_growth = idx_growth;\n\t\treq->data_growth = data_growth;\n\t\treq->dd_growth = dd_growth;\n\t\tspin_unlock(&c->space_lock);\n\t\treturn 0;\n\t}\n\n\t/* Restore the old values */\n\tc->bi.idx_growth -= idx_growth;\n\tc->bi.data_growth -= data_growth;\n\tc->bi.dd_growth -= dd_growth;\n\tspin_unlock(&c->space_lock);\n\n\tif (req->fast) {\n\t\tdbg_budg(\"no space for fast budgeting\");\n\t\treturn err;\n\t}\n\n\terr = make_free_space(c);\n\tcond_resched();\n\tif (err == -EAGAIN) {\n\t\tdbg_budg(\"try again\");\n\t\tgoto again;\n\t} else if (err == -ENOSPC) {\n\t\tif (!retried) {\n\t\t\tretried = 1;\n\t\t\tdbg_budg(\"-ENOSPC, but anyway try once again\");\n\t\t\tgoto again;\n\t\t}\n\t\tdbg_budg(\"FS is full, -ENOSPC\");\n\t\tc->bi.nospace = 1;\n\t\tif (can_use_rp(c) || c->rp_size == 0)\n\t\t\tc->bi.nospace_rp = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tubifs_err(\"cannot budget space, error %d\", err);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nnot budg",
          "args": [
            "t space, error %d\", err);\n\tretu",
            "er"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "else",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "|| c->rp_",
          "args": [
            "i"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is full,",
          "args": [
            "-ENOSPC\");\n\t\tc->bi.no"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OSPC, bu",
          "args": [
            "anyway try once again\");\n\t\t\tgoto ag"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "again\")",
          "args": [
            "goto aga"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(c);\n\tcond_re",
          "args": [
            "c"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space fo",
          "args": [
            "fast budgeting\");\n\t\treturn e"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\n\tif (req-"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\t\treturn 0"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n\t\tr",
          "args": [
            "q->i"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce(c);\n\tif (lik",
          "args": [
            "l"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\t\treturn -"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space\");",
          "args": [
            "spin_unl"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {\n\t\tdbg",
          "args": [
            "b"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.nospac",
          "args": [
            ") && (c->bi.n"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.dd_gro",
          "args": [
            "th >= 0);\n\n\tif (unli"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.data_g",
          "args": [
            "owth >= 0);\n\tubifs_ass"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.idx_gr",
          "args": [
            "wth >= 0);\n\tubifs_ass"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tubifs_ass"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "th(c, req);\n\nag",
          "args": [
            "i",
            "s"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h(c, req);\n\tif",
          "args": [
            "(",
            "ata"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wth(c, req);\n\tdd",
          "args": [
            "g",
            "wth"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(req->dirti",
          "args": [
            "d_ino_d & 7));\n\n\tdata_gro"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(req->new_i",
          "args": [
            "o_d & 7));\n\tubifs_ass"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_ass"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "ino <= 4);\n\tubifs_ass"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_ino",
          "args": [
            "d <= UBIFS_MAX_INO_DATA);\n\tubifs_ass"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_ino",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->mod_den",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_den",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->dirtied",
          "args": [
            "page <= 1);\n\tubifs_ass"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req->new_pag",
          "args": [
            "<= 1);\n\tubifs_ass"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nget_space(struct ubifs_info *c, struct ubifs_budget_req *req)\n{\n\tint err, idx_growth, data_growth, dd_growth, retried = 0;\n\n\tubifs_assert(req->new_page <= 1);\n\tubifs_assert(req->dirtied_page <= 1);\n\tubifs_assert(req->new_dent <= 1);\n\tubifs_assert(req->mod_dent <= 1);\n\tubifs_assert(req->new_ino <= 1);\n\tubifs_assert(req->new_ino_d <= UBIFS_MAX_INO_DATA);\n\tubifs_assert(req->dirtied_ino <= 4);\n\tubifs_assert(req->dirtied_ino_d <= UBIFS_MAX_INO_DATA * 4);\n\tubifs_assert(!(req->new_ino_d & 7));\n\tubifs_assert(!(req->dirtied_ino_d & 7));\n\n\tdata_growth = calc_data_growth(c, req);\n\tdd_growth = calc_dd_growth(c, req);\n\tif (!data_growth && !dd_growth)\n\t\treturn 0;\n\tidx_growth = calc_idx_growth(c, req);\n\nagain:\n\tspin_lock(&c->space_lock);\n\tubifs_assert(c->bi.idx_growth >= 0);\n\tubifs_assert(c->bi.data_growth >= 0);\n\tubifs_assert(c->bi.dd_growth >= 0);\n\n\tif (unlikely(c->bi.nospace) && (c->bi.nospace_rp || !can_use_rp(c))) {\n\t\tdbg_budg(\"no space\");\n\t\tspin_unlock(&c->space_lock);\n\t\treturn -ENOSPC;\n\t}\n\n\tc->bi.idx_growth += idx_growth;\n\tc->bi.data_growth += data_growth;\n\tc->bi.dd_growth += dd_growth;\n\n\terr = do_budget_space(c);\n\tif (likely(!err)) {\n\t\treq->idx_growth = idx_growth;\n\t\treq->data_growth = data_growth;\n\t\treq->dd_growth = dd_growth;\n\t\tspin_unlock(&c->space_lock);\n\t\treturn 0;\n\t}\n\n\t/* Restore the old values */\n\tc->bi.idx_growth -= idx_growth;\n\tc->bi.data_growth -= data_growth;\n\tc->bi.dd_growth -= dd_growth;\n\tspin_unlock(&c->space_lock);\n\n\tif (req->fast) {\n\t\tdbg_budg(\"no space for fast budgeting\");\n\t\treturn err;\n\t}\n\n\terr = make_free_space(c);\n\tcond_resched();\n\tif (err == -EAGAIN) {\n\t\tdbg_budg(\"try again\");\n\t\tgoto again;\n\t} else if (err == -ENOSPC) {\n\t\tif (!retried) {\n\t\t\tretried = 1;\n\t\t\tdbg_budg(\"-ENOSPC, but anyway try once again\");\n\t\t\tgoto again;\n\t\t}\n\t\tdbg_budg(\"FS is full, -ENOSPC\");\n\t\tc->bi.nospace = 1;\n\t\tif (can_use_rp(c) || c->rp_size == 0)\n\t\t\tc->bi.nospace_rp = 1;\n\t\tsmp_wmb();\n\t} else\n\t\tubifs_err(\"cannot budget space, error %d\", err);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "h(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "410-423",
    "snippet": "lc_dd_growth(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_budget_req *req)\n{\n\tint dd_growth;\n\n\tdd_growth = req->dirtied_page ? c->bi.page_budget : 0;\n\n\tif (req->dirtied_ino)\n\t\tdd_growth += c->bi.inode_budget << (req->dirtied_ino - 1);\n\tif (req->mod_dent)\n\t\tdd_growth += c->bi.dent_budget;\n\tdd_growth += req->dirtied_ino_d;\n\treturn dd_growth;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_dd_growth(const struct ubifs_info *c,\n\t\t\t  const struct ubifs_budget_req *req)\n{\n\tint dd_growth;\n\n\tdd_growth = req->dirtied_page ? c->bi.page_budget : 0;\n\n\tif (req->dirtied_ino)\n\t\tdd_growth += c->bi.inode_budget << (req->dirtied_ino - 1);\n\tif (req->mod_dent)\n\t\tdd_growth += c->bi.dent_budget;\n\tdd_growth += req->dirtied_ino_d;\n\treturn dd_growth;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "wth(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "390-402",
    "snippet": "lc_data_growth(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_budget_req *req)\n{\n\tint data_growth;\n\n\tdata_growth = req->new_ino  ? c->bi.inode_budget : 0;\n\tif (req->new_page)\n\t\tdata_growth += c->bi.page_budget;\n\tif (req->new_dent)\n\t\tdata_growth += c->bi.dent_budget;\n\tdata_growth += req->new_ino_d;\n\treturn data_growth;\n}\n\n/**\n * calc",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_data_growth(const struct ubifs_info *c,\n\t\t\t    const struct ubifs_budget_req *req)\n{\n\tint data_growth;\n\n\tdata_growth = req->new_ino  ? c->bi.inode_budget : 0;\n\tif (req->new_page)\n\t\tdata_growth += c->bi.page_budget;\n\tif (req->new_dent)\n\t\tdata_growth += c->bi.dent_budget;\n\tdata_growth += req->new_ino_d;\n\treturn data_growth;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "th(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "374-382",
    "snippet": "lc_idx_growth(const struct ubifs_info *c,\n\t\t\t   const struct ubifs_budget_req *req)\n{\n\tint znodes;\n\n\tznodes = req->new_ino + (req->new_page << UBIFS_BLOCKS_PER_PAGE_SHIFT) +\n\t\t req->new_dent;\n\treturn znodes * c->max_idx_node_sz;\n}\n\n/**\n * calc",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlc_idx_growth(const struct ubifs_info *c,\n\t\t\t   const struct ubifs_budget_req *req)\n{\n\tint znodes;\n\n\tznodes = req->new_ino + (req->new_page << UBIFS_BLOCKS_PER_PAGE_SHIFT) +\n\t\t req->new_dent;\n\treturn znodes * c->max_idx_node_sz;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "ce(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "306-364",
    "snippet": "_budget_space(struct ubifs_info *c)\n{\n\tlong long outstanding, available;\n\tint lebs, rsvd_idx_lebs, min_idx_lebs;\n\n\t/* First budget index space */\n\tmin_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\t/* Now 'min_idx_lebs' contains number of LEBs to reserve */\n\tif (min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\n\t/*\n\t * The number of LEBs that are available to be used by the index is:\n\t *\n\t *    @c->lst.empty_lebs + @c->freeable_cnt + @c->idx_gc_cnt -\n\t *    @c->lst.taken_empty_lebs\n\t *\n\t * @c->lst.empty_lebs are available because they are empty.\n\t * @c->freeable_cnt are available because they contain only free and\n\t * dirty space, @c->idx_gc_cnt are available because they are index\n\t * LEBs that have been garbage collected and are awaiting the commit\n\t * before they can be used. And the in-the-gaps method will grab these\n\t * if it needs them. @c->lst.taken_empty_lebs are empty LEBs that have\n\t * already been allocated for some purpose.\n\t *\n\t * Note, @c->idx_gc_cnt is included to both @c->lst.empty_lebs (because\n\t * these LEBs are empty) and to @c->lst.taken_empty_lebs (because they\n\t * are taken until after the commit).\n\t *\n\t * Note, @c->lst.taken_empty_lebs may temporarily be higher by one\n\t * because of the way we serialize LEB allocations and budgeting. See a\n\t * comment in 'ubifs_find_free_space()'.\n\t */\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (unlikely(rsvd_idx_lebs > lebs)) {\n\t\tdbg_budg(\"out of indexing space: min_idx_lebs %d (old %d), rsvd_idx_lebs %d\",\n\t\t\t min_idx_lebs, c->bi.min_idx_lebs, rsvd_idx_lebs);\n\t\treturn -ENOSPC;\n\t}\n\n\tavailable = ubifs_calc_available(c, min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\n\tif (unlikely(available < outstanding)) {\n\t\tdbg_budg(\"out of data space: available %lld, outstanding %lld\",\n\t\t\t available, outstanding);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (available - outstanding <= c->rp_size && !can_use_rp(c))\n\t\treturn -ENOSPC;\n\n\tc->bi.min_idx_lebs = min_idx_lebs;\n\treturn 0;\n}\n\n/**\n * calc",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ")\n\t\treturn",
          "args": [
            "-"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of data",
          "args": [
            "space: available %lld, outstanding %lld\",\n\t\t\t availab",
            "tstanding",
            "return -"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lable <",
          "args": [
            "utstanding)) {\n\t\tdbg_bu"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ailable(c, min_idx_l",
          "args": [
            "b",
            ";\n\toutstandi"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of inde",
          "args": [
            "ing space: min_idx_lebs %d (old %d), rsvd_idx_lebs %d\",\n\t\t\t min_idx",
            "c->bi.min_i",
            "_lebs, rsvd_idx_le",
            ");\n\t\treturn -"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx_leb",
          "args": [
            "> lebs)) {\n\t\tdbg_bu"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "n_idx_lebs(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
          "lines": "178-200",
          "snippet": "c_min_idx_lebs(struct ubifs_info *c)\n{\n\tint idx_lebs;\n\tlong long idx_size;\n\n\tidx_size = c->bi.old_idx_sz + c->bi.idx_growth + c->bi.uncommitted_idx;\n\t/* And make sure we have thrice the index size of space reserved */\n\tidx_size += idx_size << 1;\n\t/*\n\t * We do not maintain 'old_idx_size' as 'old_idx_lebs'/'old_idx_bytes'\n\t * pair, nor similarly the two variables for the new index size, so we\n\t * have to do this costly 64-bit division on fast-path.\n\t */\n\tidx_lebs = div_u64(idx_size + c->idx_leb_size - 1, c->idx_leb_size);\n\t/*\n\t * The index head is not available for the in-the-gaps method, so add an\n\t * extra LEB to compensate.\n\t */\n\tidx_lebs += 1;\n\tif (idx_lebs < MIN_INDEX_LEBS)\n\t\tidx_lebs = MIN_INDEX_LEBS;\n\treturn idx_lebs;\n}\n\n/**\n * ubif",
          "includes": [
            "ux/math64.h>\n\n/*\n * When p",
            "ux/writeback.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nc_min_idx_lebs(struct ubifs_info *c)\n{\n\tint idx_lebs;\n\tlong long idx_size;\n\n\tidx_size = c->bi.old_idx_sz + c->bi.idx_growth + c->bi.uncommitted_idx;\n\t/* And make sure we have thrice the index size of space reserved */\n\tidx_size += idx_size << 1;\n\t/*\n\t * We do not maintain 'old_idx_size' as 'old_idx_lebs'/'old_idx_bytes'\n\t * pair, nor similarly the two variables for the new index size, so we\n\t * have to do this costly 64-bit division on fast-path.\n\t */\n\tidx_lebs = div_u64(idx_size + c->idx_leb_size - 1, c->idx_leb_size);\n\t/*\n\t * The index head is not available for the in-the-gaps method, so add an\n\t * extra LEB to compensate.\n\t */\n\tidx_lebs += 1;\n\tif (idx_lebs < MIN_INDEX_LEBS)\n\t\tidx_lebs = MIN_INDEX_LEBS;\n\treturn idx_lebs;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\n\t/* Now",
          "args": [
            "'"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_budget_space(struct ubifs_info *c)\n{\n\tlong long outstanding, available;\n\tint lebs, rsvd_idx_lebs, min_idx_lebs;\n\n\t/* First budget index space */\n\tmin_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\n\t/* Now 'min_idx_lebs' contains number of LEBs to reserve */\n\tif (min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = min_idx_lebs - c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\n\t/*\n\t * The number of LEBs that are available to be used by the index is:\n\t *\n\t *    @c->lst.empty_lebs + @c->freeable_cnt + @c->idx_gc_cnt -\n\t *    @c->lst.taken_empty_lebs\n\t *\n\t * @c->lst.empty_lebs are available because they are empty.\n\t * @c->freeable_cnt are available because they contain only free and\n\t * dirty space, @c->idx_gc_cnt are available because they are index\n\t * LEBs that have been garbage collected and are awaiting the commit\n\t * before they can be used. And the in-the-gaps method will grab these\n\t * if it needs them. @c->lst.taken_empty_lebs are empty LEBs that have\n\t * already been allocated for some purpose.\n\t *\n\t * Note, @c->idx_gc_cnt is included to both @c->lst.empty_lebs (because\n\t * these LEBs are empty) and to @c->lst.taken_empty_lebs (because they\n\t * are taken until after the commit).\n\t *\n\t * Note, @c->lst.taken_empty_lebs may temporarily be higher by one\n\t * because of the way we serialize LEB allocations and budgeting. See a\n\t * comment in 'ubifs_find_free_space()'.\n\t */\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (unlikely(rsvd_idx_lebs > lebs)) {\n\t\tdbg_budg(\"out of indexing space: min_idx_lebs %d (old %d), rsvd_idx_lebs %d\",\n\t\t\t min_idx_lebs, c->bi.min_idx_lebs, rsvd_idx_lebs);\n\t\treturn -ENOSPC;\n\t}\n\n\tavailable = ubifs_calc_available(c, min_idx_lebs);\n\toutstanding = c->bi.data_growth + c->bi.dd_growth;\n\n\tif (unlikely(available < outstanding)) {\n\t\tdbg_budg(\"out of data space: available %lld, outstanding %lld\",\n\t\t\t available, outstanding);\n\t\treturn -ENOSPC;\n\t}\n\n\tif (available - outstanding <= c->rp_size && !can_use_rp(c))\n\t\treturn -ENOSPC;\n\n\tc->bi.min_idx_lebs = min_idx_lebs;\n\treturn 0;\n}\n\n/**\n * calc"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "273-279",
    "snippet": "n_use_rp(struct ubifs_info *c)\n{\n\tif (uid_eq(current_fsuid(), c->rp_uid) || capable(CAP_SYS_RESOURCE) ||\n\t    (!gid_eq(c->rp_gid, GLOBAL_ROOT_GID) && in_group_p(c->rp_gid)))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * do_b",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ">rp_gid)))",
          "args": [
            "return"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid, G",
          "args": [
            "OBAL_ROOT",
            "ID) && in_group"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "YS_RESO",
          "args": [
            "RCE) ||\n\t    (!g"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_fsui",
          "args": [
            "(), c->rp_uid)",
            "capable("
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(), c->rp_uid",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nn_use_rp(struct ubifs_info *c)\n{\n\tif (uid_eq(current_fsuid(), c->rp_uid) || capable(CAP_SYS_RESOURCE) ||\n\t    (!gid_eq(c->rp_gid, GLOBAL_ROOT_GID) && in_group_p(c->rp_gid)))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * do_b"
  },
  {
    "function_name": "ailable(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "209-262",
    "snippet": "fs_calc_available(const struct ubifs_info *c, int min_idx_lebs)\n{\n\tint subtract_lebs;\n\tlong long available;\n\n\tavailable = c->main_bytes - c->lst.total_used;\n\n\t/*\n\t * Now 'available' contains theoretically available flash space\n\t * assuming there is no index, so we have to subtract the space which\n\t * is reserved for the index.\n\t */\n\tsubtract_lebs = min_idx_lebs;\n\n\t/* Take into account that GC reserves one LEB for its own needs */\n\tsubtract_lebs += 1;\n\n\t/*\n\t * The GC journal head LEB is not really accessible. And since\n\t * different write types go to different heads, we may count only on\n\t * one head's space.\n\t */\n\tsubtract_lebs += c->jhead_cnt - 1;\n\n\t/* We also reserve one LEB for deletions, which bypass budgeting */\n\tsubtract_lebs += 1;\n\n\tavailable -= (long long)subtract_lebs * c->leb_size;\n\n\t/* Subtract the dead space which is not available for use */\n\tavailable -= c->lst.total_dead;\n\n\t/*\n\t * Subtract dark space, which might or might not be usable - it depends\n\t * on the data which we have on the media and which will be written. If\n\t * this is a lot of uncompressed or not-compressible data, the dark\n\t * space cannot be used.\n\t */\n\tavailable -= c->lst.total_dark;\n\n\t/*\n\t * However, there is more dark space. The index may be bigger than\n\t * @min_idx_lebs. Those extra LEBs are assumed to be available, but\n\t * their dark space is not included in total_dark, so it is subtracted\n\t * here.\n\t */\n\tif (c->lst.idx_lebs > min_idx_lebs) {\n\t\tsubtract_lebs = c->lst.idx_lebs - min_idx_lebs;\n\t\tavailable -= subtract_lebs * c->dark_wm;\n\t}\n\n\t/* The calculations are rough and may end up with a negative number */\n\treturn available > 0 ? available : 0;\n}\n\n/**\n * can_",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nfs_calc_available(const struct ubifs_info *c, int min_idx_lebs)\n{\n\tint subtract_lebs;\n\tlong long available;\n\n\tavailable = c->main_bytes - c->lst.total_used;\n\n\t/*\n\t * Now 'available' contains theoretically available flash space\n\t * assuming there is no index, so we have to subtract the space which\n\t * is reserved for the index.\n\t */\n\tsubtract_lebs = min_idx_lebs;\n\n\t/* Take into account that GC reserves one LEB for its own needs */\n\tsubtract_lebs += 1;\n\n\t/*\n\t * The GC journal head LEB is not really accessible. And since\n\t * different write types go to different heads, we may count only on\n\t * one head's space.\n\t */\n\tsubtract_lebs += c->jhead_cnt - 1;\n\n\t/* We also reserve one LEB for deletions, which bypass budgeting */\n\tsubtract_lebs += 1;\n\n\tavailable -= (long long)subtract_lebs * c->leb_size;\n\n\t/* Subtract the dead space which is not available for use */\n\tavailable -= c->lst.total_dead;\n\n\t/*\n\t * Subtract dark space, which might or might not be usable - it depends\n\t * on the data which we have on the media and which will be written. If\n\t * this is a lot of uncompressed or not-compressible data, the dark\n\t * space cannot be used.\n\t */\n\tavailable -= c->lst.total_dark;\n\n\t/*\n\t * However, there is more dark space. The index may be bigger than\n\t * @min_idx_lebs. Those extra LEBs are assumed to be available, but\n\t * their dark space is not included in total_dark, so it is subtracted\n\t * here.\n\t */\n\tif (c->lst.idx_lebs > min_idx_lebs) {\n\t\tsubtract_lebs = c->lst.idx_lebs - min_idx_lebs;\n\t\tavailable -= subtract_lebs * c->dark_wm;\n\t}\n\n\t/* The calculations are rough and may end up with a negative number */\n\treturn available > 0 ? available : 0;\n}\n\n/**\n * can_"
  },
  {
    "function_name": "n_idx_lebs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "178-200",
    "snippet": "c_min_idx_lebs(struct ubifs_info *c)\n{\n\tint idx_lebs;\n\tlong long idx_size;\n\n\tidx_size = c->bi.old_idx_sz + c->bi.idx_growth + c->bi.uncommitted_idx;\n\t/* And make sure we have thrice the index size of space reserved */\n\tidx_size += idx_size << 1;\n\t/*\n\t * We do not maintain 'old_idx_size' as 'old_idx_lebs'/'old_idx_bytes'\n\t * pair, nor similarly the two variables for the new index size, so we\n\t * have to do this costly 64-bit division on fast-path.\n\t */\n\tidx_lebs = div_u64(idx_size + c->idx_leb_size - 1, c->idx_leb_size);\n\t/*\n\t * The index head is not available for the in-the-gaps method, so add an\n\t * extra LEB to compensate.\n\t */\n\tidx_lebs += 1;\n\tif (idx_lebs < MIN_INDEX_LEBS)\n\t\tidx_lebs = MIN_INDEX_LEBS;\n\treturn idx_lebs;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ize + c",
          "args": [
            ">idx_leb_size - 1, c->idx_leb_",
            "ze);\n\t/*\n\t * Th"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nc_min_idx_lebs(struct ubifs_info *c)\n{\n\tint idx_lebs;\n\tlong long idx_size;\n\n\tidx_size = c->bi.old_idx_sz + c->bi.idx_growth + c->bi.uncommitted_idx;\n\t/* And make sure we have thrice the index size of space reserved */\n\tidx_size += idx_size << 1;\n\t/*\n\t * We do not maintain 'old_idx_size' as 'old_idx_lebs'/'old_idx_bytes'\n\t * pair, nor similarly the two variables for the new index size, so we\n\t * have to do this costly 64-bit division on fast-path.\n\t */\n\tidx_lebs = div_u64(idx_size + c->idx_leb_size - 1, c->idx_leb_size);\n\t/*\n\t * The index head is not available for the in-the-gaps method, so add an\n\t * extra LEB to compensate.\n\t */\n\tidx_lebs += 1;\n\tif (idx_lebs < MIN_INDEX_LEBS)\n\t\tidx_lebs = MIN_INDEX_LEBS;\n\treturn idx_lebs;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ce(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "132-169",
    "snippet": "ke_free_space(struct ubifs_info *c)\n{\n\tint err, retries = 0;\n\tlong long liab1, liab2;\n\n\tdo {\n\t\tliab1 = get_liability(c);\n\t\t/*\n\t\t * We probably have some dirty pages or inodes (liability), try\n\t\t * to write them back.\n\t\t */\n\t\tdbg_budg(\"liability %lld, run write-back\", liab1);\n\t\tshrink_liability(c, NR_TO_WRITE);\n\n\t\tliab2 = get_liability(c);\n\t\tif (liab2 < liab1)\n\t\t\treturn -EAGAIN;\n\n\t\tdbg_budg(\"new liability %lld (not shrunk)\", liab2);\n\n\t\t/* Liability did not shrink again, try GC */\n\t\tdbg_budg(\"Run GC\");\n\t\terr = run_gc(c);\n\t\tif (!err)\n\t\t\treturn -EAGAIN;\n\n\t\tif (err != -EAGAIN && err != -ENOSPC)\n\t\t\t/* Some real error happened */\n\t\t\treturn err;\n\n\t\tdbg_budg(\"Run commit (retries %d)\", retries);\n\t\terr = ubifs_run_commit(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (retries++ < MAX_MKSPC_RETRIES);\n\n\treturn -ENOSPC;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mit(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit",
          "args": [
            "retries %d)\", retries);",
            "rr = ub"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "t_commit(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "507-532",
          "snippet": "_post_commit(struct ubifs_info *c, int old_ltail_lnum)\n{\n\tint lnum, err = 0;\n\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\terr = ubifs_return_leb(c, bud->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tmutex_lock(&c->log_mutex);\n\tfor (lnum = old_ltail_lnum; lnum != c->ltail_lnum;\n\t     lnum = ubifs_next_log_lnum(c, lnum)) {\n\t\tdbg_log(\"unmap log LEB %d\", lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * stru",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\n_post_commit(struct ubifs_info *c, int old_ltail_lnum)\n{\n\tint lnum, err = 0;\n\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\terr = ubifs_return_leb(c, bud->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tmutex_lock(&c->log_mutex);\n\tfor (lnum = old_ltail_lnum; lnum != c->ltail_lnum;\n\t     lnum = ubifs_next_log_lnum(c, lnum)) {\n\t\tdbg_log(\"unmap log LEB %d\", lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * stru"
        }
      },
      {
        "call_info": {
          "callee": "if (!e",
          "args": [
            "r"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GC\");",
          "args": [
            "err = ru"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "liabili",
          "args": [
            "y %lld (not shrunk)\", liab2);",
            "Liab"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t\tif (li",
          "args": [
            "b"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ity(c, NR_TO_WRI",
          "args": [
            "E",
            "liab2 ="
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bility %",
          "args": [
            "ld, run write-back\", liab1);\n\t\ts",
            "ink_l"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\n\t\t/*",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nke_free_space(struct ubifs_info *c)\n{\n\tint err, retries = 0;\n\tlong long liab1, liab2;\n\n\tdo {\n\t\tliab1 = get_liability(c);\n\t\t/*\n\t\t * We probably have some dirty pages or inodes (liability), try\n\t\t * to write them back.\n\t\t */\n\t\tdbg_budg(\"liability %lld, run write-back\", liab1);\n\t\tshrink_liability(c, NR_TO_WRITE);\n\n\t\tliab2 = get_liability(c);\n\t\tif (liab2 < liab1)\n\t\t\treturn -EAGAIN;\n\n\t\tdbg_budg(\"new liability %lld (not shrunk)\", liab2);\n\n\t\t/* Liability did not shrink again, try GC */\n\t\tdbg_budg(\"Run GC\");\n\t\terr = run_gc(c);\n\t\tif (!err)\n\t\t\treturn -EAGAIN;\n\n\t\tif (err != -EAGAIN && err != -ENOSPC)\n\t\t\t/* Some real error happened */\n\t\t\treturn err;\n\n\t\tdbg_budg(\"Run commit (retries %d)\", retries);\n\t\terr = ubifs_run_commit(c);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (retries++ < MAX_MKSPC_RETRIES);\n\n\treturn -ENOSPC;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "104-112",
    "snippet": "ong get_liability(struct ubifs_info *c)\n{\n\tlong long liab;\n\n\tspin_lock(&c->space_lock);\n\tliab = c->bi.idx_growth + c->bi.data_growth + c->bi.dd_growth;\n\tspin_unlock(&c->space_lock);\n\treturn liab;\n}\n\n/**\n * make",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\treturn li"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tliab = c-"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nong get_liability(struct ubifs_info *c)\n{\n\tlong long liab;\n\n\tspin_lock(&c->space_lock);\n\tliab = c->bi.idx_growth + c->bi.data_growth + c->bi.dd_growth;\n\tspin_unlock(&c->space_lock);\n\treturn liab;\n}\n\n/**\n * make"
  },
  {
    "function_name": "ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "78-95",
    "snippet": "n_gc(struct ubifs_info *c)\n{\n\tint err, lnum;\n\n\t/* Make some free space by garbage-collecting dirty space */\n\tdown_read(&c->commit_sem);\n\tlnum = ubifs_garbage_collect(c, 1);\n\tup_read(&c->commit_sem);\n\tif (lnum < 0)\n\t\treturn lnum;\n\n\t/* GC freed one LEB, return it to lprops */\n\tdbg_budg(\"GC freed LEB %d\", lnum);\n\terr = ubifs_return_leb(c, lnum);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n/**\n * get_",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leb(c, lnum);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freed LE",
          "args": [
            "%d\", lnum);\n\terr",
            "ubi"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ommit_s",
          "args": [
            "m);\n\tif (lnum"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_collect(c, 1);\n\tup_r",
          "args": [
            "a",
            "&"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">commit_s",
          "args": [
            "m);\n\tlnum = ub"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nn_gc(struct ubifs_info *c)\n{\n\tint err, lnum;\n\n\t/* Make some free space by garbage-collecting dirty space */\n\tdown_read(&c->commit_sem);\n\tlnum = ubifs_garbage_collect(c, 1);\n\tup_read(&c->commit_sem);\n\tif (lnum < 0)\n\t\treturn lnum;\n\n\t/* GC freed one LEB, return it to lprops */\n\tdbg_budg(\"GC freed LEB %d\", lnum);\n\terr = ubifs_return_leb(c, lnum);\n\tif (err)\n\t\treturn err;\n\treturn 0;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "ity(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/budget.c",
    "lines": "63-68",
    "snippet": "hrink_liability(struct ubifs_info *c, int nr_to_write)\n{\n\tdown_read(&c->vfs_sb->s_umount);\n\twriteback_inodes_sb(c->vfs_sb, WB_REASON_FS_FREE_SPACE);\n\tup_read(&c->vfs_sb->s_umount);\n}\n\n/**\n * run_",
    "includes": [
      "ux/math64.h>\n\n/*\n * When p",
      "ux/writeback.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_sb->",
          "args": [
            "_umount);\n}\n\n/**\n *"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_sb_will_flip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nilfs2/the_nilfs.h",
          "lines": "280-284",
          "snippet": "static inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/types.h>\n\nstatic inline int nilfs_sb_will_flip(struct the_nilfs *nilfs)\n{\n\tint flip_bits = nilfs->ns_sbwcount & 0x0FL;\n\treturn (flip_bits != 0x08 && flip_bits != 0x0F);\n}"
        }
      },
      {
        "call_info": {
          "callee": "des_sb(c->vfs_sb, W",
          "args": [
            "_REASON_F",
            "FREE_SPACE);\n\tup_read(&"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">vfs_sb->",
          "args": [
            "_umount);\n\twriteback"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/math64.h>\n\n/*\n * When p\nux/writeback.h>\n#include <lin\nfs.h\"\n#include <lin\n\nhrink_liability(struct ubifs_info *c, int nr_to_write)\n{\n\tdown_read(&c->vfs_sb->s_umount);\n\twriteback_inodes_sb(c->vfs_sb, WB_REASON_FS_FREE_SPACE);\n\tup_read(&c->vfs_sb->s_umount);\n}\n\n/**\n * run_"
  }
]