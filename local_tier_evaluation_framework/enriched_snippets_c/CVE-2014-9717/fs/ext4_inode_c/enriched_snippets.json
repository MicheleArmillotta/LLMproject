[
  {
    "function_name": "ext4_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "5079-5165",
    "snippet": "int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\t/* Delalloc case is easy... */\n\tif (test_opt(inode->i_sb, DELALLOC) &&\n\t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = __block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_write;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_CACHE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\nout_ret:\n\tret = block_page_mkwrite_return(ret);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_page_mkwrite_return",
          "args": [
            "ret"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 5158
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_JDATA"
          ],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "0",
            "PAGE_CACHE_SIZE",
            "NULL",
            "do_journal_get_write_access"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_page_mkwrite",
          "args": [
            "vma",
            "vmf",
            "get_block"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "__block_page_mkwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2402-2438",
          "snippet": "int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\t get_block_t get_block)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tunsigned long end;\n\tloff_t size;\n\tint ret;\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\tif ((page->mapping != inode->i_mapping) ||\n\t    (page_offset(page) > size)) {\n\t\t/* We overload EFAULT to mean page got truncated */\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t/* page is wholly or partially inside EOF */\n\tif (((page->index + 1) << PAGE_CACHE_SHIFT) > size)\n\t\tend = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tend = PAGE_CACHE_SIZE;\n\n\tret = __block_write_begin(page, 0, end, get_block);\n\tif (!ret)\n\t\tret = block_commit_write(page, 0, end);\n\n\tif (unlikely(ret < 0))\n\t\tgoto out_unlock;\n\tset_page_dirty(page);\n\twait_for_stable_page(page);\n\treturn 0;\nout_unlock:\n\tunlock_page(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "ext4_writepage_trans_blocks(inode)"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 5135
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 5123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_nonda_switch",
          "args": [
            "inode->i_sb"
          ],
          "line": 5097
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_nonda_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2463-2495",
          "snippet": "static int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DELALLOC"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "inode->i_sb"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 5086
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nint ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\t/* Delalloc case is easy... */\n\tif (test_opt(inode->i_sb, DELALLOC) &&\n\t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = __block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_write;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = __block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_CACHE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\nout_ret:\n\tret = block_page_mkwrite_return(ret);\nout:\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_bh_unmapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "5074-5077",
    "snippet": "static int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}"
  },
  {
    "function_name": "ext4_change_inode_journal_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4997-5072",
    "snippet": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 5069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 5066
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "1"
          ],
          "line": 5062
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_resume_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 5058
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2830-2834",
          "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 5057
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_aops",
          "args": [
            "inode"
          ],
          "line": 5055
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3187-3206",
          "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_JOURNAL_DATA"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal"
          ],
          "line": 5047
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_JOURNAL_DATA"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_block_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 5031
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_block_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2825-2829",
          "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_alloc_da_blocks",
          "args": [
            "inode"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_alloc_da_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2704-2743",
          "snippet": "int ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DELALLOC"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 5013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_pin_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4975-4994",
    "snippet": "static int ext4_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext4_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = jbd2_journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "iloc.bh"
          ],
          "line": 4986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_write_access",
          "args": [
            "handle",
            "iloc.bh"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1013-1024",
          "snippet": "int jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "iloc.bh",
            "\"get_write_access\""
          ],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 4981
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext4_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = jbd2_journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_dirty_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4950-4965",
    "snippet": "void ext4_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *handle;\n\n\tif (flags == I_DIRTY_TIME)\n\t\treturn;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\n\text4_mark_inode_dirty(handle, inode);\n\n\text4_journal_stop(handle);\nout:\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 4960
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "2"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *handle;\n\n\tif (flags == I_DIRTY_TIME)\n\t\treturn;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\n\text4_mark_inode_dirty(handle, inode);\n\n\text4_journal_stop(handle);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "ext4_mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4887-4930",
    "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 4928
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sbi->s_es->s_mnt_count"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\"",
            "inode->i_ino"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 4913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_expand_extra_isize",
          "args": [
            "inode",
            "sbi->s_want_extra_isize",
            "iloc",
            "handle"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_expand_extra_isize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4845-4872",
          "snippet": "static int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_extend",
          "args": [
            "handle",
            "EXT4_DATA_TRANS_BLOCKS(inode->i_sb)"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "547-605",
          "snippet": "int jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DATA_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4898
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mark_inode_dirty",
          "args": [
            "inode",
            "_RET_IP_"
          ],
          "line": 4895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_expand_extra_isize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4845-4872",
    "snippet": "static int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_expand_extra_isize_ea",
          "args": [
            "inode",
            "new_extra_isize",
            "raw_inode",
            "handle"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_expand_extra_isize_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1258-1477",
          "snippet": "int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry, *last, *first;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t min_offs, free;\n\tint total_ino;\n\tvoid *base, *start, *end;\n\tint extra_isize = 0, error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_min_extra_isize);\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\nretry:\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\treturn 0;\n\t}\n\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/*\n\t * Check if enough free space is available in the inode to shift the\n\t * entries ahead by new_extra_isize.\n\t */\n\n\tbase = start = entry;\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\tlast = entry;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header);\n\n\tfree = ext4_xattr_free_space(last, &min_offs, base, &total_ino);\n\tif (free >= new_extra_isize) {\n\t\tentry = IFIRST(header);\n\t\text4_xattr_shift_entries(entry,\tEXT4_I(inode)->i_extra_isize\n\t\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t\t(void *)header, total_ino,\n\t\t\t\tinode->i_sb->s_blocksize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\terror = 0;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Enough free space isn't available in the inode, check if\n\t * EA block can hold new_extra_isize bytes.\n\t */\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tif (ext4_xattr_check_block(inode, bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tfirst = BFIRST(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tfree = ext4_xattr_free_space(first, &min_offs, base, NULL);\n\t\tif (free < new_extra_isize) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tfree = inode->i_sb->s_blocksize;\n\t}\n\n\twhile (new_extra_isize > 0) {\n\t\tsize_t offs, size, entry_size;\n\t\tstruct ext4_xattr_entry *small_entry = NULL;\n\t\tstruct ext4_xattr_info i = {\n\t\t\t.value = NULL,\n\t\t\t.value_len = 0,\n\t\t};\n\t\tunsigned int total_size;  /* EA entry size + value size */\n\t\tunsigned int shift_bytes; /* No. of bytes to shift EAs by? */\n\t\tunsigned int min_total_size = ~0U;\n\n\t\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\t\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\t\tif (!is || !bs) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tis->s.not_found = -ENODATA;\n\t\tbs->s.not_found = -ENODATA;\n\t\tis->iloc.bh = NULL;\n\t\tbs->bh = NULL;\n\n\t\tlast = IFIRST(header);\n\t\t/* Find the entry best suited to be pushed into EA block */\n\t\tentry = NULL;\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size =\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(last->e_value_size)) +\n\t\t\t\t\tEXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (total_size <= free && total_size < min_total_size) {\n\t\t\t\tif (total_size < new_extra_isize) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry) {\n\t\t\t\tentry = small_entry;\n\t\t\t} else {\n\t\t\t\tif (!tried_min_extra_isize &&\n\t\t\t\t    s_min_extra_isize) {\n\t\t\t\t\ttried_min_extra_isize++;\n\t\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\t\tkfree(is); is = NULL;\n\t\t\t\t\tkfree(bs); bs = NULL;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\terror = -1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\toffs = le16_to_cpu(entry->e_value_offs);\n\t\tsize = le32_to_cpu(entry->e_value_size);\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ti.name_index = entry->e_name_index,\n\t\tbuffer = kmalloc(EXT4_XATTR_SIZE(size), GFP_NOFS);\n\t\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\t\tif (!buffer || !b_entry_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Save the entry name and the entry value */\n\t\tmemcpy(buffer, (void *)IFIRST(header) + offs,\n\t\t       EXT4_XATTR_SIZE(size));\n\t\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\t\tb_entry_name[entry->e_name_len] = '\\0';\n\t\ti.name = b_entry_name;\n\n\t\terror = ext4_get_inode_loc(inode, &is->iloc);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\terror = ext4_xattr_ibody_find(inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Remove the chosen entry from the inode */\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\tentry = IFIRST(header);\n\t\tif (entry_size + EXT4_XATTR_SIZE(size) >= new_extra_isize)\n\t\t\tshift_bytes = new_extra_isize;\n\t\telse\n\t\t\tshift_bytes = entry_size + size;\n\t\t/* Adjust the offsets and shift the remaining entries ahead */\n\t\text4_xattr_shift_entries(entry, EXT4_I(inode)->i_extra_isize -\n\t\t\tshift_bytes, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + extra_isize + shift_bytes,\n\t\t\t(void *)header, total_ino - entry_size,\n\t\t\tinode->i_sb->s_blocksize);\n\n\t\textra_isize += shift_bytes;\n\t\tnew_extra_isize -= shift_bytes;\n\t\tEXT4_I(inode)->i_extra_isize = extra_isize;\n\n\t\ti.name = b_entry_name;\n\t\ti.value = buffer;\n\t\ti.value_len = size;\n\t\terror = ext4_xattr_block_find(inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Add entry which was removed from the inode into the block */\n\t\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tkfree(b_entry_name);\n\t\tkfree(buffer);\n\t\tb_entry_name = NULL;\n\t\tbuffer = NULL;\n\t\tbrelse(is->iloc.bh);\n\t\tkfree(is);\n\t\tkfree(bs);\n\t}\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn 0;\n\ncleanup:\n\tkfree(b_entry_name);\n\tkfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tkfree(is);\n\tkfree(bs);\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nint ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry, *last, *first;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t min_offs, free;\n\tint total_ino;\n\tvoid *base, *start, *end;\n\tint extra_isize = 0, error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_min_extra_isize);\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\nretry:\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\treturn 0;\n\t}\n\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/*\n\t * Check if enough free space is available in the inode to shift the\n\t * entries ahead by new_extra_isize.\n\t */\n\n\tbase = start = entry;\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\tlast = entry;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header);\n\n\tfree = ext4_xattr_free_space(last, &min_offs, base, &total_ino);\n\tif (free >= new_extra_isize) {\n\t\tentry = IFIRST(header);\n\t\text4_xattr_shift_entries(entry,\tEXT4_I(inode)->i_extra_isize\n\t\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t\t(void *)header, total_ino,\n\t\t\t\tinode->i_sb->s_blocksize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\terror = 0;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Enough free space isn't available in the inode, check if\n\t * EA block can hold new_extra_isize bytes.\n\t */\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tif (ext4_xattr_check_block(inode, bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tfirst = BFIRST(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tfree = ext4_xattr_free_space(first, &min_offs, base, NULL);\n\t\tif (free < new_extra_isize) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tfree = inode->i_sb->s_blocksize;\n\t}\n\n\twhile (new_extra_isize > 0) {\n\t\tsize_t offs, size, entry_size;\n\t\tstruct ext4_xattr_entry *small_entry = NULL;\n\t\tstruct ext4_xattr_info i = {\n\t\t\t.value = NULL,\n\t\t\t.value_len = 0,\n\t\t};\n\t\tunsigned int total_size;  /* EA entry size + value size */\n\t\tunsigned int shift_bytes; /* No. of bytes to shift EAs by? */\n\t\tunsigned int min_total_size = ~0U;\n\n\t\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\t\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\t\tif (!is || !bs) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tis->s.not_found = -ENODATA;\n\t\tbs->s.not_found = -ENODATA;\n\t\tis->iloc.bh = NULL;\n\t\tbs->bh = NULL;\n\n\t\tlast = IFIRST(header);\n\t\t/* Find the entry best suited to be pushed into EA block */\n\t\tentry = NULL;\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size =\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(last->e_value_size)) +\n\t\t\t\t\tEXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (total_size <= free && total_size < min_total_size) {\n\t\t\t\tif (total_size < new_extra_isize) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry) {\n\t\t\t\tentry = small_entry;\n\t\t\t} else {\n\t\t\t\tif (!tried_min_extra_isize &&\n\t\t\t\t    s_min_extra_isize) {\n\t\t\t\t\ttried_min_extra_isize++;\n\t\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\t\tkfree(is); is = NULL;\n\t\t\t\t\tkfree(bs); bs = NULL;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\terror = -1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\toffs = le16_to_cpu(entry->e_value_offs);\n\t\tsize = le32_to_cpu(entry->e_value_size);\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ti.name_index = entry->e_name_index,\n\t\tbuffer = kmalloc(EXT4_XATTR_SIZE(size), GFP_NOFS);\n\t\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\t\tif (!buffer || !b_entry_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Save the entry name and the entry value */\n\t\tmemcpy(buffer, (void *)IFIRST(header) + offs,\n\t\t       EXT4_XATTR_SIZE(size));\n\t\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\t\tb_entry_name[entry->e_name_len] = '\\0';\n\t\ti.name = b_entry_name;\n\n\t\terror = ext4_get_inode_loc(inode, &is->iloc);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\terror = ext4_xattr_ibody_find(inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Remove the chosen entry from the inode */\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\tentry = IFIRST(header);\n\t\tif (entry_size + EXT4_XATTR_SIZE(size) >= new_extra_isize)\n\t\t\tshift_bytes = new_extra_isize;\n\t\telse\n\t\t\tshift_bytes = entry_size + size;\n\t\t/* Adjust the offsets and shift the remaining entries ahead */\n\t\text4_xattr_shift_entries(entry, EXT4_I(inode)->i_extra_isize -\n\t\t\tshift_bytes, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + extra_isize + shift_bytes,\n\t\t\t(void *)header, total_ino - entry_size,\n\t\t\tinode->i_sb->s_blocksize);\n\n\t\textra_isize += shift_bytes;\n\t\tnew_extra_isize -= shift_bytes;\n\t\tEXT4_I(inode)->i_extra_isize = extra_isize;\n\n\t\ti.name = b_entry_name;\n\t\ti.value = buffer;\n\t\ti.value_len = size;\n\t\terror = ext4_xattr_block_find(inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Add entry which was removed from the inode into the block */\n\t\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tkfree(b_entry_name);\n\t\tkfree(buffer);\n\t\tb_entry_name = NULL;\n\t\tbuffer = NULL;\n\t\tbrelse(is->iloc.bh);\n\t\tkfree(is);\n\t\tkfree(bs);\n\t}\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn 0;\n\ncleanup:\n\tkfree(b_entry_name);\n\tkfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tkfree(is);\n\tkfree(bs);\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4865
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE",
            "0",
            "new_extra_isize"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 4856
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}"
  },
  {
    "function_name": "ext4_reserve_inode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4822-4839",
    "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc->bh"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "iloc->bh"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "iloc->bh",
            "\"get_write_access\""
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "iloc"
          ],
          "line": 4828
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_mark_iloc_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4800-4815",
    "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "iloc->bh"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_do_update_inode",
          "args": [
            "handle",
            "inode",
            "iloc"
          ],
          "line": 4812
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_do_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4250-4379",
          "snippet": "static int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\tEXT4_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t   EXT4_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\tEXT4_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t   EXT4_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "iloc->bh"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 4806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_chunk_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4791-4794",
    "snippet": "int ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_meta_trans_blocks",
          "args": [
            "inode",
            "nrblocks",
            "1"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4723-4757",
          "snippet": "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}"
  },
  {
    "function_name": "ext4_writepage_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4769-4780",
    "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 4777
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_meta_trans_blocks",
          "args": [
            "inode",
            "bpp",
            "bpp"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4723-4757",
          "snippet": "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_blocks_per_page",
          "args": [
            "inode"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_blocks_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "350-355",
          "snippet": "static inline int ext4_journal_blocks_per_page(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) != NULL)\n\t\treturn jbd2_journal_blocks_per_page(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_blocks_per_page(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) != NULL)\n\t\treturn jbd2_journal_blocks_per_page(inode);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_meta_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4723-4757",
    "snippet": "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_META_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_index_trans_blocks",
          "args": [
            "inode",
            "lblocks",
            "pextents"
          ],
          "line": 4735
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_index_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4704-4710",
          "snippet": "static int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "inode->i_sb"
          ],
          "line": 4726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_index_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4704-4710",
    "snippet": "static int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_ext_index_trans_blocks",
          "args": [
            "inode",
            "pextents"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_index_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "2452-2469",
          "snippet": "int ext4_ext_index_trans_blocks(struct inode *inode, int extents)\n{\n\tint index;\n\tint depth;\n\n\t/* If we are converting the inline data, only one is needed here. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 1;\n\n\tdepth = ext_depth(inode);\n\n\tif (extents <= 1)\n\t\tindex = depth * 2;\n\telse\n\t\tindex = depth * 3;\n\n\treturn index;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_index_trans_blocks(struct inode *inode, int extents)\n{\n\tint index;\n\tint depth;\n\n\t/* If we are converting the inline data, only one is needed here. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 1;\n\n\tdepth = ext_depth(inode);\n\n\tif (extents <= 1)\n\t\tindex = depth * 2;\n\telse\n\t\tindex = depth * 3;\n\n\treturn index;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ind_trans_blocks",
          "args": [
            "inode",
            "lblocks"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "790-798",
          "snippet": "int ext4_ind_trans_blocks(struct inode *inode, int nrblocks)\n{\n\t/*\n\t * With N contiguous data blocks, we need at most\n\t * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,\n\t * 2 dindirect blocks, and 1 tindirect block\n\t */\n\treturn DIV_ROUND_UP(nrblocks, EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_trans_blocks(struct inode *inode, int nrblocks)\n{\n\t/*\n\t * With N contiguous data blocks, we need at most\n\t * N/EXT4_ADDR_PER_BLOCK(inode->i_sb) + 1 indirect blocks,\n\t * 2 dindirect blocks, and 1 tindirect block\n\t */\n\treturn DIV_ROUND_UP(nrblocks, EXT4_ADDR_PER_BLOCK(inode->i_sb)) + 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}"
  },
  {
    "function_name": "ext4_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4670-4702",
    "snippet": "int ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode;\n\tunsigned long long delalloc_blocks;\n\n\tinode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\n\t/*\n\t * If there is inline data in the inode, the inode will normally not\n\t * have data blocks allocated (it may have an external xattr block).\n\t * Report at least one sector for such files, so tools like tar, rsync,\n\t * others doen't incorrectly think the file is completely sparse.\n\t */\n\tif (unlikely(ext4_has_inline_data(inode)))\n\t\tstat->blocks += (stat->size + 511) >> 9;\n\n\t/*\n\t * We can't update i_blocks if the block allocation is delayed\n\t * otherwise in the case of system crash before the real block\n\t * allocation is done, we will have i_blocks inconsistent with\n\t * on-disk file blocks.\n\t * We always keep i_blocks updated together with real\n\t * allocation. But to not confuse with user, stat\n\t * will return the blocks that include the delayed allocation\n\t * blocks for this file.\n\t */\n\tdelalloc_blocks = EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\t\t   EXT4_I(inode)->i_reserved_data_blocks);\n\tstat->blocks += delalloc_blocks << (inode->i_sb->s_blocksize_bits - 9);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "EXT4_I(inode)->i_reserved_data_blocks"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ext4_has_inline_data(inode)"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 4677
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode;\n\tunsigned long long delalloc_blocks;\n\n\tinode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\n\t/*\n\t * If there is inline data in the inode, the inode will normally not\n\t * have data blocks allocated (it may have an external xattr block).\n\t * Report at least one sector for such files, so tools like tar, rsync,\n\t * others doen't incorrectly think the file is completely sparse.\n\t */\n\tif (unlikely(ext4_has_inline_data(inode)))\n\t\tstat->blocks += (stat->size + 511) >> 9;\n\n\t/*\n\t * We can't update i_blocks if the block allocation is delayed\n\t * otherwise in the case of system crash before the real block\n\t * allocation is done, we will have i_blocks inconsistent with\n\t * on-disk file blocks.\n\t * We always keep i_blocks updated together with real\n\t * allocation. But to not confuse with user, stat\n\t * will return the blocks that include the delayed allocation\n\t * blocks for this file.\n\t */\n\tdelalloc_blocks = EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\t\t   EXT4_I(inode)->i_reserved_data_blocks);\n\tstat->blocks += delalloc_blocks << (inode->i_sb->s_blocksize_bits - 9);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4526-4668",
    "snippet": "int ext4_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error, rc = 0;\n\tint orphan = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +\n\t\t\t EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\n\t\thandle_t *handle;\n\n\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\t\tif (attr->ia_size > sbi->s_bitmap_maxbytes)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\n\t\tif (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)\n\t\t\tinode_inc_iversion(inode);\n\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    (attr->ia_size < inode->i_size)) {\n\t\t\tif (ext4_should_order_data(inode)) {\n\t\t\t\terror = ext4_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t    attr->ia_size);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terror = PTR_ERR(handle);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ext4_handle_valid(handle)) {\n\t\t\t\terror = ext4_orphan_add(handle, inode);\n\t\t\t\torphan = 1;\n\t\t\t}\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tEXT4_I(inode)->i_disksize = attr->ia_size;\n\t\t\trc = ext4_mark_inode_dirty(handle, inode);\n\t\t\tif (!error)\n\t\t\t\terror = rc;\n\t\t\t/*\n\t\t\t * We have to update i_size under i_data_sem together\n\t\t\t * with i_disksize to avoid races with writeback code\n\t\t\t * running ext4_wb_update_i_disksize().\n\t\t\t */\n\t\t\tif (!error)\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\text4_journal_stop(handle);\n\t\t\tif (error) {\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else {\n\t\t\tloff_t oldsize = inode->i_size;\n\n\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tpagecache_isize_extended(inode, oldsize, inode->i_size);\n\t\t}\n\n\t\t/*\n\t\t * Blocks are going to be removed from the inode. Wait\n\t\t * for dio in flight.  Temporarily disable\n\t\t * dioread_nolock to prevent livelock.\n\t\t */\n\t\tif (orphan) {\n\t\t\tif (!ext4_should_journal_data(inode)) {\n\t\t\t\text4_inode_block_unlocked_dio(inode);\n\t\t\t\tinode_dio_wait(inode);\n\t\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\t} else\n\t\t\t\text4_wait_for_tail_page_commit(inode);\n\t\t}\n\t\t/*\n\t\t * Truncate pagecache after we've waited for commit\n\t\t * in data=journal mode to make pages freeable.\n\t\t */\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t}\n\t/*\n\t * We want to call ext4_truncate() even if attr->ia_size ==\n\t * inode->i_size for cases like truncation of fallocated space\n\t */\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\text4_truncate(inode);\n\n\tif (!rc) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\t/*\n\t * If the call to ext4_truncate failed to get a transaction handle at\n\t * all, we need to clean up the in-core orphan list manually.\n\t */\n\tif (orphan && inode->i_nlink)\n\t\text4_orphan_del(NULL, inode);\n\n\tif (!rc && (ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text4_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "error"
          ],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 4661
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 4658
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 4650
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate",
          "args": [
            "inode"
          ],
          "line": 4646
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3577-3671",
          "snippet": "void ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_wait_for_tail_page_commit",
          "args": [
            "inode"
          ],
          "line": 4633
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_wait_for_tail_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4465-4500",
          "snippet": "static void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_CACHE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_CACHE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_CACHE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_CACHE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_CACHE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_CACHE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_resume_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 4631
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2830-2834",
          "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_block_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_block_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2825-2829",
          "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 4628
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "oldsize",
            "inode->i_size"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 4610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4609
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "3"
          ],
          "line": 4588
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_begin_ordered_truncate",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_begin_ordered_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "117-132",
          "snippet": "static inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_order_data",
          "args": [
            "inode"
          ],
          "line": 4582
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "418-421",
          "snippet": "static inline int ext4_should_order_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */\n\nstatic inline int ext4_should_order_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_inc_iversion",
          "args": [
            "inode"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 4577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4571
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 4554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_transfer",
          "args": [
            "inode",
            "attr"
          ],
          "line": 4552
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1933-1950",
          "snippet": "int dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nint dquot_transfer(struct inode *inode, struct iattr *iattr)\n{\n\tstruct dquot *transfer_to[MAXQUOTAS] = {};\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tif (!dquot_active(inode))\n\t\treturn 0;\n\n\tif (iattr->ia_valid & ATTR_UID && !uid_eq(iattr->ia_uid, inode->i_uid))\n\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(iattr->ia_uid));\n\tif (iattr->ia_valid & ATTR_GID && !gid_eq(iattr->ia_gid, inode->i_gid))\n\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(iattr->ia_gid));\n\n\tret = __dquot_transfer(inode, transfer_to);\n\tdqput_all(transfer_to);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_DEL_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MAXQUOTAS_INIT_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "inode->i_uid"
          ],
          "line": 4539
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 4538
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_quota_modification",
          "args": [
            "inode",
            "attr"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 4533
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error, rc = 0;\n\tint orphan = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +\n\t\t\t EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE && attr->ia_size != inode->i_size) {\n\t\thandle_t *handle;\n\n\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\t\tif (attr->ia_size > sbi->s_bitmap_maxbytes)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\n\t\tif (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)\n\t\t\tinode_inc_iversion(inode);\n\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    (attr->ia_size < inode->i_size)) {\n\t\t\tif (ext4_should_order_data(inode)) {\n\t\t\t\terror = ext4_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t    attr->ia_size);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terror = PTR_ERR(handle);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ext4_handle_valid(handle)) {\n\t\t\t\terror = ext4_orphan_add(handle, inode);\n\t\t\t\torphan = 1;\n\t\t\t}\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tEXT4_I(inode)->i_disksize = attr->ia_size;\n\t\t\trc = ext4_mark_inode_dirty(handle, inode);\n\t\t\tif (!error)\n\t\t\t\terror = rc;\n\t\t\t/*\n\t\t\t * We have to update i_size under i_data_sem together\n\t\t\t * with i_disksize to avoid races with writeback code\n\t\t\t * running ext4_wb_update_i_disksize().\n\t\t\t */\n\t\t\tif (!error)\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\text4_journal_stop(handle);\n\t\t\tif (error) {\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else {\n\t\t\tloff_t oldsize = inode->i_size;\n\n\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tpagecache_isize_extended(inode, oldsize, inode->i_size);\n\t\t}\n\n\t\t/*\n\t\t * Blocks are going to be removed from the inode. Wait\n\t\t * for dio in flight.  Temporarily disable\n\t\t * dioread_nolock to prevent livelock.\n\t\t */\n\t\tif (orphan) {\n\t\t\tif (!ext4_should_journal_data(inode)) {\n\t\t\t\text4_inode_block_unlocked_dio(inode);\n\t\t\t\tinode_dio_wait(inode);\n\t\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\t} else\n\t\t\t\text4_wait_for_tail_page_commit(inode);\n\t\t}\n\t\t/*\n\t\t * Truncate pagecache after we've waited for commit\n\t\t * in data=journal mode to make pages freeable.\n\t\t */\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t}\n\t/*\n\t * We want to call ext4_truncate() even if attr->ia_size ==\n\t * inode->i_size for cases like truncation of fallocated space\n\t */\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\text4_truncate(inode);\n\n\tif (!rc) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\t/*\n\t * If the call to ext4_truncate failed to get a transaction handle at\n\t * all, we need to clean up the in-core orphan list manually.\n\t */\n\tif (orphan && inode->i_nlink)\n\t\text4_orphan_del(NULL, inode);\n\n\tif (!rc && (ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text4_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_wait_for_tail_page_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4465-4500",
    "snippet": "static void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_CACHE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_CACHE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_CACHE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 4498
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_journalled_invalidatepage",
          "args": [
            "page",
            "offset",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 4486
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journalled_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2854-2869",
          "snippet": "static int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "inode->i_size >> PAGE_CACHE_SHIFT"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_CACHE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_CACHE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_CACHE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_CACHE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_CACHE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}"
  },
  {
    "function_name": "ext4_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4415-4458",
    "snippet": "int ext4_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_journal) {\n\t\tif (ext4_journal_current_handle()) {\n\t\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\t\tdump_stack();\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t\t * ext4_sync_fs() will force the commit after everything is\n\t\t * written.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\t\treturn 0;\n\n\t\terr = ext4_force_commit(inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc;\n\n\t\terr = __ext4_get_inode_loc(inode, &iloc, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * sync(2) will flush the whole buffer cache. No need to do\n\t\t * it here separately for each inode.\n\t\t */\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync)\n\t\t\tsync_dirty_buffer(iloc.bh);\n\t\tif (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,\n\t\t\t\t\t \"IO error syncing inode\");\n\t\t\terr = -EIO;\n\t\t}\n\t\tbrelse(iloc.bh);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE_BLOCK",
          "args": [
            "inode",
            "iloc.bh->b_blocknr",
            "\"IO error syncing inode\""
          ],
          "line": 4451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "iloc.bh"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "iloc.bh"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "iloc.bh"
          ],
          "line": 4449
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc",
            "0"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3679-3814",
          "snippet": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_force_commit",
          "args": [
            "inode->i_sb"
          ],
          "line": 4437
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "4707-4716",
          "snippet": "int ext4_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\treturn ext4_journal_force_commit(journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nint ext4_force_commit(struct super_block *sb)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\treturn ext4_journal_force_commit(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"called recursively, non-PF_MEMALLOC!\\n\""
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->flags & PF_MEMALLOC"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_journal) {\n\t\tif (ext4_journal_current_handle()) {\n\t\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\t\tdump_stack();\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t\t * ext4_sync_fs() will force the commit after everything is\n\t\t * written.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\t\treturn 0;\n\n\t\terr = ext4_force_commit(inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc;\n\n\t\terr = __ext4_get_inode_loc(inode, &iloc, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * sync(2) will flush the whole buffer cache. No need to do\n\t\t * it here separately for each inode.\n\t\t */\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync)\n\t\t\tsync_dirty_buffer(iloc.bh);\n\t\tif (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,\n\t\t\t\t\t \"IO error syncing inode\");\n\t\t\terr = -EIO;\n\t\t}\n\t\tbrelse(iloc.bh);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_do_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4250-4379",
    "snippet": "static int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\tEXT4_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t   EXT4_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "err"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 4376
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "need_datasync"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "371-382",
          "snippet": "static inline void ext4_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int datasync)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t\t int datasync)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (ext4_handle_valid(handle)) {\n\t\tei->i_sync_tid = handle->h_transaction->t_tid;\n\t\tif (datasync)\n\t\t\tei->i_datasync_tid = handle->h_transaction->t_tid;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SET_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_dynamic_rev",
          "args": [
            "sb"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_dynamic_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "679-702",
          "snippet": "void ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "EXT4_SB(sb)->s_sbh"
          ],
          "line": 4365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "EXT4_SB(sb)->s_sbh",
            "\"get write access\""
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NEW"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 4358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_other_inodes_time",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "bh->b_data"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_update_other_inodes_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4225-4241",
          "snippet": "static void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\tino = orig_ino & ~(inodes_per_block - 1);\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\tino = orig_ino & ~(inodes_per_block - 1);\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ei->i_raw_lock"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_csum_set",
          "args": [
            "inode",
            "raw_inode",
            "ei"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "100-115",
          "snippet": "static void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ei->i_extra_isize"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_version >> 32"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw_inode",
            "ei",
            "i_version_hi"
          ],
          "line": 4345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_version"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!test_opt2(inode->i_sb, HURD_COMPAT)"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "inode->i_sb",
            "HURD_COMPAT"
          ],
          "line": 4342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(inode->i_rdev)"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "old_encode_dev(inode->i_rdev)"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 4329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_generation"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_GOOD_OLD_REV"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_isize_set",
          "args": [
            "raw_inode",
            "ei->i_disksize"
          ],
          "line": 4315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_isize",
          "args": [
            "raw_inode"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_file_acl"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ei->i_file_acl >> 32"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!test_opt2(inode->i_sb, HURD_COMPAT)"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "inode->i_sb",
            "HURD_COMPAT"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_flags & 0xFFFFFFFF"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ei->i_dtime"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_blocks_set",
          "args": [
            "handle",
            "raw_inode",
            "ei"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_blocks_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4145-4182",
          "snippet": "static int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_EINODE_SET_XTIME",
          "args": [
            "i_crtime",
            "ei",
            "raw_inode"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_atime",
            "inode",
            "raw_inode"
          ],
          "line": 4300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_mtime",
            "inode",
            "raw_inode"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_ctime",
            "inode",
            "raw_inode"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_nlink"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowgid(i_gid)"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowgid",
          "args": [
            "i_gid"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "fs_high2lowuid(i_uid)"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowuid",
          "args": [
            "i_uid"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(i_gid)"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "i_gid"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "high_16_bits(i_uid)"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "high_16_bits",
          "args": [
            "i_uid"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(i_gid)"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "i_gid"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "low_16_bits(i_uid)"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "low_16_bits",
          "args": [
            "i_uid"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_UID32"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3845-3867",
          "snippet": "void ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "EXT4_SB(inode->i_sb)->s_inode_size"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NEW"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ei->i_raw_lock"
          ],
          "line": 4263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4255
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "iloc"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\tEXT4_SET_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t   EXT4_FEATURE_RO_COMPAT_LARGE_FILE);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_update_other_inodes_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4225-4241",
    "snippet": "static void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\tino = orig_ino & ~(inodes_per_block - 1);\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_inode_nowait",
          "args": [
            "sb",
            "ino",
            "other_inode_match",
            "&oi"
          ],
          "line": 4239
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1296-1320",
          "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 4231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4230
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\tino = orig_ino & ~(inodes_per_block - 1);\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}"
  },
  {
    "function_name": "other_inode_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4189-4219",
    "snippet": "static int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_other_inode_update_time",
          "args": [
            "inode",
            "oi->orig_ino"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_csum_set",
          "args": [
            "inode",
            "oi->raw_inode",
            "ei"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "100-115",
          "snippet": "static void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_atime",
            "inode",
            "oi->raw_inode"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_mtime",
            "inode",
            "oi->raw_inode"
          ],
          "line": 4210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SET_XTIME",
          "args": [
            "i_ctime",
            "inode",
            "oi->raw_inode"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ei->i_raw_lock"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}"
  },
  {
    "function_name": "ext4_inode_blocks_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4145-4182",
    "snippet": "static int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i_blocks >> 32"
          ],
          "line": 4179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_blocks"
          ],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_HUGE_FILE"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_HUGE_FILE"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "i_blocks >> 32"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_blocks"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_HUGE_FILE"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_HUGE_FILE"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_blocks"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_iget_normal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "4138-4143",
    "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_normal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4138-4143",
          "snippet": "struct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EIO);\n\treturn ext4_iget(sb, ino);\n}"
  },
  {
    "function_name": "ext4_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3905-4136",
    "snippet": "struct inode *ext4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT4_I(inode);\n\tiloc.bh = NULL;\n\n\tret = __ext4_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT4_INODE_SIZE(inode->i_sb)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize (%u != %u)\",\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize,\n\t\t\t\tEXT4_INODE_SIZE(inode->i_sb));\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = raw_inode->i_generation;\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\tif (!ext4_inode_csum_verify(inode, raw_inode, ei)) {\n\t\tEXT4_ERROR_INODE(inode, \"checksum invalid\");\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\n\text4_clear_state_flags(ei);\t/* Only relevant on 32-bit archs */\n\tei->i_inline_off = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif ((inode->i_mode == 0 ||\n\t\t     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&\n\t\t    ino != EXT4_BOOT_LOADER_INO) {\n\t\t\t/* this inode is deleted */\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those.\n\t\t * OR it is the EXT4_BOOT_LOADER_INO which is\n\t\t * not initialized on a new filesystem. */\n\t}\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tinode->i_blocks = ext4_inode_blocks(raw_inode, ei);\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT))\n\t\tei->i_file_acl |=\n\t\t\t((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;\n\tinode->i_size = ext4_isize(raw_inode);\n\tei->i_disksize = inode->i_size;\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\tei->i_last_alloc_group = ~0;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tei->i_sync_tid = tid;\n\t\tei->i_datasync_tid = tid;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t    EXT4_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\text4_iget_extra_inode(inode, raw_inode, ei);\n\t\t}\n\t}\n\n\tEXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\tinode->i_version = le32_to_cpu(raw_inode->i_disk_version);\n\t\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\tinode->i_version |=\n\t\t    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (ei->i_file_acl &&\n\t    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extended attribute block %llu\",\n\t\t\t\t ei->i_file_acl);\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\t\tif ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t    (S_ISLNK(inode->i_mode) &&\n\t\t\t     !ext4_inode_is_fast_symlink(inode))))\n\t\t\t\t/* Validate extent which is part of inode */\n\t\t\t\tret = ext4_ext_check_inode(inode);\n\t\t} else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t   (S_ISLNK(inode->i_mode) &&\n\t\t\t    !ext4_inode_is_fast_symlink(inode))) {\n\t\t\t/* Validate block references which are part of inode */\n\t\t\tret = ext4_ind_check_inode(inode);\n\t\t}\n\t}\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext4_dir_inode_operations;\n\t\tinode->i_fop = &ext4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext4_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t}\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t} else if (ino == EXT4_BOOT_LOADER_INO) {\n\t\tmake_bad_inode(inode);\n\t} else {\n\t\tret = -EIO;\n\t\tEXT4_ERROR_INODE(inode, \"bogus i_mode (%o)\", inode->i_mode);\n\t\tgoto bad_inode;\n\t}\n\tbrelse(iloc.bh);\n\text4_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tbrelse(iloc.bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3823-3842",
          "snippet": "void ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bogus i_mode (%o)\"",
            "inode->i_mode"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "new_decode_dev(le32_to_cpu(raw_inode->i_block[1]))"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[1])"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_block[1]"
          ],
          "line": 4119
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "le32_to_cpu(raw_inode->i_block[0])"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "inode->i_mode"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_aops",
          "args": [
            "inode"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3187-3206",
          "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nd_terminate_link",
          "args": [
            "ei->i_data",
            "inode->i_size",
            "sizeof(ei->i_data) - 1"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "144-153",
          "snippet": "static int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_check_inode",
          "args": [
            "inode"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ext_check_inode",
          "args": [
            "inode"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_check_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "493-496",
          "snippet": "int ext4_ext_check_inode(struct inode *inode)\n{\n\treturn ext4_ext_check(inode, ext_inode_hdr(inode), ext_depth(inode), 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_check_inode(struct inode *inode)\n{\n\treturn ext4_ext_check(inode, ext_inode_hdr(inode), ext_depth(inode), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad extended attribute block %llu\"",
            "ei->i_file_acl"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "EXT4_SB(sb)",
            "ei->i_file_acl",
            "1"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "le32_to_cpu(raw_inode->i_version_hi)"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw_inode",
            "ei",
            "i_version_hi"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!test_opt2(inode->i_sb, HURD_COMPAT)"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt2",
          "args": [
            "inode->i_sb",
            "HURD_COMPAT"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_EINODE_GET_XTIME",
          "args": [
            "i_crtime",
            "ei",
            "raw_inode"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_GET_XTIME",
          "args": [
            "i_atime",
            "inode",
            "raw_inode"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_GET_XTIME",
          "args": [
            "i_mtime",
            "inode",
            "raw_inode"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_GET_XTIME",
          "args": [
            "i_ctime",
            "inode",
            "raw_inode"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_iget_extra_inode",
          "args": [
            "inode",
            "raw_inode",
            "ei"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_iget_extra_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3892-3903",
          "snippet": "static inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ei->i_orphan"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_isize",
          "args": [
            "raw_inode"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_file_acl_high"
          ],
          "line": 4002
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_blocks",
          "args": [
            "raw_inode",
            "ei"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3869-3890",
          "snippet": "static blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_state_flags",
          "args": [
            "ei"
          ],
          "line": 3973
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_state_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1457-1460",
          "snippet": "static inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_clear_state_flags(struct ext4_inode_info *ei)\n{\n\t/* We depend on the fact that callers will set i_flags */\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le16_to_cpu(raw_inode->i_links_count)"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "i_gid"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "i_uid"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_UID32"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"checksum invalid\""
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_csum_verify",
          "args": [
            "inode",
            "raw_inode",
            "ei"
          ],
          "line": 3956
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "79-98",
          "snippet": "static int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "csum",
            "(__u8 *)&gen",
            "sizeof(gen)"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ino"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "sb"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad extra_isize (%u != %u)\"",
            "EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize",
            "EXT4_INODE_SIZE(inode->i_sb)"
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 3934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc",
            "0"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3679-3814",
          "snippet": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstruct inode *ext4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT4_I(inode);\n\tiloc.bh = NULL;\n\n\tret = __ext4_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT4_INODE_SIZE(inode->i_sb)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize (%u != %u)\",\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize,\n\t\t\t\tEXT4_INODE_SIZE(inode->i_sb));\n\t\t\tret = -EIO;\n\t\t\tgoto bad_inode;\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = raw_inode->i_generation;\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\tif (!ext4_inode_csum_verify(inode, raw_inode, ei)) {\n\t\tEXT4_ERROR_INODE(inode, \"checksum invalid\");\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\n\text4_clear_state_flags(ei);\t/* Only relevant on 32-bit archs */\n\tei->i_inline_off = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif ((inode->i_mode == 0 ||\n\t\t     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&\n\t\t    ino != EXT4_BOOT_LOADER_INO) {\n\t\t\t/* this inode is deleted */\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those.\n\t\t * OR it is the EXT4_BOOT_LOADER_INO which is\n\t\t * not initialized on a new filesystem. */\n\t}\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tinode->i_blocks = ext4_inode_blocks(raw_inode, ei);\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT))\n\t\tei->i_file_acl |=\n\t\t\t((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;\n\tinode->i_size = ext4_isize(raw_inode);\n\tei->i_disksize = inode->i_size;\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\tei->i_last_alloc_group = ~0;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tei->i_sync_tid = tid;\n\t\tei->i_datasync_tid = tid;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t    EXT4_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\text4_iget_extra_inode(inode, raw_inode, ei);\n\t\t}\n\t}\n\n\tEXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\tinode->i_version = le32_to_cpu(raw_inode->i_disk_version);\n\t\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\tinode->i_version |=\n\t\t    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (ei->i_file_acl &&\n\t    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extended attribute block %llu\",\n\t\t\t\t ei->i_file_acl);\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\t\tif ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t    (S_ISLNK(inode->i_mode) &&\n\t\t\t     !ext4_inode_is_fast_symlink(inode))))\n\t\t\t\t/* Validate extent which is part of inode */\n\t\t\t\tret = ext4_ext_check_inode(inode);\n\t\t} else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t   (S_ISLNK(inode->i_mode) &&\n\t\t\t    !ext4_inode_is_fast_symlink(inode))) {\n\t\t\t/* Validate block references which are part of inode */\n\t\t\tret = ext4_ind_check_inode(inode);\n\t\t}\n\t}\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX))\n\t\t\tinode->i_fop = &ext4_dax_file_operations;\n\t\telse\n\t\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext4_dir_inode_operations;\n\t\tinode->i_fop = &ext4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext4_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t}\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t} else if (ino == EXT4_BOOT_LOADER_INO) {\n\t\tmake_bad_inode(inode);\n\t} else {\n\t\tret = -EIO;\n\t\tEXT4_ERROR_INODE(inode, \"bogus i_mode (%o)\", inode->i_mode);\n\t\tgoto bad_inode;\n\t}\n\tbrelse(iloc.bh);\n\text4_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tbrelse(iloc.bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "ext4_iget_extra_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3892-3903",
    "snippet": "static inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_inline_data_nolock",
          "args": [
            "inode"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_inline_data_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "128-160",
          "snippet": "int ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nint ext4_find_inline_data_nolock(struct inode *inode)\n{\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\n\tif (!is.s.not_found) {\n\t\tEXT4_I(inode)->i_inline_off = (u16)((void *)is.s.here -\n\t\t\t\t\t(void *)ext4_raw_inode(&is.iloc));\n\t\tEXT4_I(inode)->i_inline_size = EXT4_MIN_INLINE_DATA_SIZE +\n\t\t\t\tle32_to_cpu(is.s.here->e_value_size);\n\t\text4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\n\t}\nout:\n\tbrelse(is.iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 3899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}"
  },
  {
    "function_name": "ext4_inode_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3869-3890",
    "snippet": "static blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "raw_inode->i_blocks_lo"
          ],
          "line": 3888
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_HUGE_FILE"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw_inode->i_blocks_high"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_RO_COMPAT_HUGE_FILE"
          ],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}"
  },
  {
    "function_name": "ext4_get_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3845-3867",
    "snippet": "void ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&ei->i_flags",
            "old_fl",
            "new_fl"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}"
  },
  {
    "function_name": "ext4_set_inode_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3823-3842",
    "snippet": "void ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_set_flags",
          "args": [
            "inode",
            "new_fl",
            "S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1979-1990",
          "snippet": "void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = ACCESS_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DAX"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3825
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}"
  },
  {
    "function_name": "ext4_get_inode_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3816-3821",
    "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext4_get_inode_loc",
          "args": [
            "inode",
            "iloc",
            "!ext4_test_inode_state(inode, EXT4_STATE_XATTR)"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3679-3814",
          "snippet": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
  },
  {
    "function_name": "__ext4_get_inode_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3679-3814",
    "snippet": "static int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE_BLOCK",
          "args": [
            "inode",
            "block",
            "\"unable to read itable block\""
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "bh"
          ],
          "line": 3802
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_load_inode",
          "args": [
            "inode"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_breadahead",
          "args": [
            "sb",
            "b++"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_itable_unused_count",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3786
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_itable_unused_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "227-233",
          "snippet": "__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_itable_unused_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_group_desc_csum",
          "args": [
            "sb"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3776
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "bh->b_size"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_bit",
          "args": [
            "i",
            "bitmap_bh->b_data"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bitmap_bh"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "ext4_inode_bitmap(sb, gdp)"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "iloc->block_group",
            "NULL"
          ],
          "line": 3693
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_valid_inum",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_valid_inum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1371-1381",
          "snippet": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */",
            "#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */",
            "#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */",
            "#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */",
            "#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */",
            "#define EXT4_ROOT_INO\t\t 2\t/* Root inode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_JOURNAL_INO\t 8\t/* Journal inode */\n#define EXT4_RESIZE_INO\t\t 7\t/* Reserved group descriptors inode */\n#define EXT4_BOOT_LOADER_INO\t 5\t/* Boot loader inode */\n#define EXT4_GRP_QUOTA_INO\t 4\t/* Group quota inode */\n#define EXT4_USR_QUOTA_INO\t 3\t/* User quota inode */\n#define EXT4_ROOT_INO\t\t 2\t/* Root inode */\n\nstatic inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EIO;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3577-3671",
    "snippet": "void ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_truncate_exit",
          "args": [
            "inode"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 3666
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 3653
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ei->i_data_sem"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_truncate",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3648
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1202-1302",
          "snippet": "void ext4_ind_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n = 0;\n\text4_lblk_t last_block, max_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tif (last_block != max_block) {\n\t\tn = ext4_block_to_path(inode, last_block, offsets, NULL);\n\t\tif (n == 0)\n\t\t\treturn;\n\t}\n\n\text4_es_remove_extent(inode, last_block, EXT_MAX_BLOCKS - last_block);\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext4 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\tif (last_block == max_block) {\n\t\t/*\n\t\t * It is unnecessary to free any data blocks if last_block is\n\t\t * equal to the indirect block limit.\n\t\t */\n\t\treturn;\n\t} else if (n == 1) {\t\t/* direct blocks */\n\t\text4_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text4_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nvoid ext4_ind_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\t__le32 nr = 0;\n\tint n = 0;\n\text4_lblk_t last_block, max_block;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tlast_block = (inode->i_size + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\n\tif (last_block != max_block) {\n\t\tn = ext4_block_to_path(inode, last_block, offsets, NULL);\n\t\tif (n == 0)\n\t\t\treturn;\n\t}\n\n\text4_es_remove_extent(inode, last_block, EXT_MAX_BLOCKS - last_block);\n\n\t/*\n\t * The orphan list entry will now protect us from any crash which\n\t * occurs before the truncate completes, so it is now safe to propagate\n\t * the new, shorter inode size (held for now in i_size) into the\n\t * on-disk inode. We do this via i_disksize, which is the value which\n\t * ext4 *really* writes onto the disk inode.\n\t */\n\tei->i_disksize = inode->i_size;\n\n\tif (last_block == max_block) {\n\t\t/*\n\t\t * It is unnecessary to free any data blocks if last_block is\n\t\t * equal to the indirect block limit.\n\t\t */\n\t\treturn;\n\t} else if (n == 1) {\t\t/* direct blocks */\n\t\text4_free_data(handle, inode, NULL, i_data+offsets[0],\n\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\tgoto do_indirects;\n\t}\n\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t/* Kill the top of shared branch (not detached) */\n\tif (nr) {\n\t\tif (partial == chain) {\n\t\t\t/* Shared branch grows from the inode */\n\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t*partial->p = 0;\n\t\t\t/*\n\t\t\t * We mark the inode dirty prior to restart,\n\t\t\t * and prior to stop.  No need for it here.\n\t\t\t */\n\t\t} else {\n\t\t\t/* Shared branch grows from an indirect block */\n\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t}\n\t}\n\t/* Clear the ends of indirect blocks on the shared branch */\n\twhile (partial > chain) {\n\t\text4_free_branches(handle, inode, partial->bh, partial->p + 1,\n\t\t\t\t   (__le32*)partial->bh->b_data+addr_per_block,\n\t\t\t\t   (chain+n-1) - partial);\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_truncate",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4638-4670",
          "snippet": "void ext4_ext_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\tint err = 0;\n\n\t/*\n\t * TODO: optimization is possible here.\n\t * Probably we need not scan at all,\n\t * because page truncation is enough.\n\t */\n\n\t/* we have to know where to truncate from in crash case */\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\text4_mark_inode_dirty(handle, inode);\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\nretry:\n\terr = ext4_es_remove_extent(inode, last_block,\n\t\t\t\t    EXT_MAX_BLOCKS - last_block);\n\tif (err == -ENOMEM) {\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\tif (err) {\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn;\n\t}\n\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n\text4_std_error(inode->i_sb, err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_ext_truncate(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t last_block;\n\tint err = 0;\n\n\t/*\n\t * TODO: optimization is possible here.\n\t * Probably we need not scan at all,\n\t * because page truncation is enough.\n\t */\n\n\t/* we have to know where to truncate from in crash case */\n\tEXT4_I(inode)->i_disksize = inode->i_size;\n\text4_mark_inode_dirty(handle, inode);\n\n\tlast_block = (inode->i_size + sb->s_blocksize - 1)\n\t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\nretry:\n\terr = ext4_es_remove_extent(inode, last_block,\n\t\t\t\t    EXT_MAX_BLOCKS - last_block);\n\tif (err == -ENOMEM) {\n\t\tcond_resched();\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry;\n\t}\n\tif (err) {\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn;\n\t}\n\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n\text4_std_error(inode->i_sb, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_truncate_page",
          "args": [
            "handle",
            "mapping",
            "inode->i_size"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3323-3335",
          "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "PTR_ERR(handle)"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_TRUNCATE",
            "credits"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 3618
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_attach_jinode",
          "args": [
            "inode"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_attach_jinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3524-3547",
          "snippet": "int ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inline_data_truncate",
          "args": [
            "inode",
            "&has_inline"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inline_data_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1889-1979",
          "snippet": "void ext4_inline_data_truncate(struct inode *inode, int *has_inline)\n{\n\thandle_t *handle;\n\tint inline_size, value_len, needed_blocks;\n\tsize_t i_size;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\text4_journal_stop(handle);\n\t\treturn;\n\t}\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out;\n\n\tif (ext4_get_inode_loc(inode, &is.iloc))\n\t\tgoto out;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\ti_size = inode->i_size;\n\tinline_size = ext4_get_inline_size(inode);\n\tEXT4_I(inode)->i_disksize = i_size;\n\n\tif (i_size < inline_size) {\n\t\t/* Clear the content in the xattr space. */\n\t\tif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tif (ext4_xattr_ibody_find(inode, &i, &is))\n\t\t\t\tgoto out_error;\n\n\t\t\tBUG_ON(is.s.not_found);\n\n\t\t\tvalue_len = le32_to_cpu(is.s.here->e_value_size);\n\t\t\tvalue = kmalloc(value_len, GFP_NOFS);\n\t\t\tif (!value)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t\t\tvalue, value_len))\n\t\t\t\tgoto out_error;\n\n\t\t\ti.value = value;\n\t\t\ti.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\ti_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\n\t\t\tif (ext4_xattr_ibody_inline_set(handle, inode, &i, &is))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Clear the content within i_blocks. */\n\t\tif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\n\t\t\tmemset(p + i_size, 0,\n\t\t\t       EXT4_MIN_INLINE_DATA_SIZE - i_size);\n\t\t}\n\n\t\tEXT4_I(inode)->i_inline_size = i_size <\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE : i_size;\n\t}\n\nout_error:\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\tbrelse(is.iloc.bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tkfree(value);\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\n\treturn;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))",
            "#define EXT4_XATTR_SYSTEM_DATA\t\"data\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n#define EXT4_XATTR_SYSTEM_DATA\t\"data\"\n\nvoid ext4_inline_data_truncate(struct inode *inode, int *has_inline)\n{\n\thandle_t *handle;\n\tint inline_size, value_len, needed_blocks;\n\tsize_t i_size;\n\tvoid *value = NULL;\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t};\n\n\n\tneeded_blocks = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, needed_blocks);\n\tif (IS_ERR(handle))\n\t\treturn;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\t*has_inline = 0;\n\t\text4_journal_stop(handle);\n\t\treturn;\n\t}\n\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out;\n\n\tif (ext4_get_inode_loc(inode, &is.iloc))\n\t\tgoto out;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\ti_size = inode->i_size;\n\tinline_size = ext4_get_inline_size(inode);\n\tEXT4_I(inode)->i_disksize = i_size;\n\n\tif (i_size < inline_size) {\n\t\t/* Clear the content in the xattr space. */\n\t\tif (inline_size > EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tif (ext4_xattr_ibody_find(inode, &i, &is))\n\t\t\t\tgoto out_error;\n\n\t\t\tBUG_ON(is.s.not_found);\n\n\t\t\tvalue_len = le32_to_cpu(is.s.here->e_value_size);\n\t\t\tvalue = kmalloc(value_len, GFP_NOFS);\n\t\t\tif (!value)\n\t\t\t\tgoto out_error;\n\n\t\t\tif (ext4_xattr_ibody_get(inode, i.name_index, i.name,\n\t\t\t\t\t\tvalue, value_len))\n\t\t\t\tgoto out_error;\n\n\t\t\ti.value = value;\n\t\t\ti.value_len = i_size > EXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\ti_size - EXT4_MIN_INLINE_DATA_SIZE : 0;\n\t\t\tif (ext4_xattr_ibody_inline_set(handle, inode, &i, &is))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\t/* Clear the content within i_blocks. */\n\t\tif (i_size < EXT4_MIN_INLINE_DATA_SIZE) {\n\t\t\tvoid *p = (void *) ext4_raw_inode(&is.iloc)->i_block;\n\t\t\tmemset(p + i_size, 0,\n\t\t\t       EXT4_MIN_INLINE_DATA_SIZE - i_size);\n\t\t}\n\n\t\tEXT4_I(inode)->i_inline_size = i_size <\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE ?\n\t\t\t\t\tEXT4_MIN_INLINE_DATA_SIZE : i_size;\n\t}\n\nout_error:\n\tup_write(&EXT4_I(inode)->i_data_sem);\nout:\n\tbrelse(is.iloc.bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tkfree(value);\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\text4_journal_stop(handle);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DA_ALLOC_CLOSE"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "NO_AUTO_DA_ALLOC"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EOFBLOCKS"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_can_truncate",
          "args": [
            "inode"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3375-3384",
          "snippet": "int ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_truncate_enter",
          "args": [
            "inode"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&inode->i_mutex)"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}"
  },
  {
    "function_name": "ext4_inode_attach_jinode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3524-3547",
    "snippet": "int ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_free_inode",
          "args": [
            "jinode"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "jinode != NULL"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_jbd_inode",
          "args": [
            "ei->jinode",
            "inode"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_jbd_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2525-2532",
          "snippet": "void jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_alloc_inode",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_punch_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3397-3522",
    "snippet": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\t/* Now release the pages again to reduce race window */\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_resume_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2830-2834",
          "snippet": "static inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb();\n\text4_clear_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3514
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "first_block_offset",
            "last_block_offset"
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3504
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ind_remove_space",
          "args": [
            "handle",
            "inode",
            "first_block",
            "stop_block"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_remove_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "1314-1557",
          "snippet": "int ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t  ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4], offsets2[4];\n\tIndirect chain[4], chain2[4];\n\tIndirect *partial, *partial2;\n\text4_lblk_t max_block;\n\t__le32 nr = 0, nr2 = 0;\n\tint n = 0, n2 = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tif (end >= max_block)\n\t\tend = max_block;\n\tif ((start >= end) || (start > max_block))\n\t\treturn 0;\n\n\tn = ext4_block_to_path(inode, start, offsets, NULL);\n\tn2 = ext4_block_to_path(inode, end, offsets2, NULL);\n\n\tBUG_ON(n > n2);\n\n\tif ((n == 1) && (n == n2)) {\n\t\t/* We're punching only within direct block range */\n\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t       i_data + offsets2[0]);\n\t\treturn 0;\n\t} else if (n2 > n) {\n\t\t/*\n\t\t * Start and end are on a different levels so we're going to\n\t\t * free partial block at start, and partial block at end of\n\t\t * the range. If there are some levels in between then\n\t\t * do_indirects label will take care of that.\n\t\t */\n\n\t\tif (n == 1) {\n\t\t\t/*\n\t\t\t * Start is at the direct block level, free\n\t\t\t * everything to the end of the level.\n\t\t\t */\n\t\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\t\tgoto end_range;\n\t\t}\n\n\n\t\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t\tif (nr) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the start of the range\n\t\t */\n\t\twhile (partial > chain) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\tpartial->p + 1,\n\t\t\t\t(__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t(chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\nend_range:\n\t\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\t\tif (nr2) {\n\t\t\tif (partial2 == chain2) {\n\t\t\t\t/*\n\t\t\t\t * Remember, end is exclusive so here we're at\n\t\t\t\t * the start of the next level we're not going\n\t\t\t\t * to free. Everything was covered by the start\n\t\t\t\t * of the range.\n\t\t\t\t */\n\t\t\t\tgoto do_indirects;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * ext4_find_shared returns Indirect structure which\n\t\t\t * points to the last element which should not be\n\t\t\t * removed by truncate. But this is end of the range\n\t\t\t * in punch_hole so we need to point to the next element\n\t\t\t */\n\t\t\tpartial2->p++;\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the end of the range\n\t\t */\n\t\twhile (partial2 > chain2) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t\tgoto do_indirects;\n\t}\n\n\t/* Punch happened within the same level (n == n2) */\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\n\t/* Free top, but only if partial2 isn't its subtree. */\n\tif (nr) {\n\t\tint level = min(partial - chain, partial2 - chain2);\n\t\tint i;\n\t\tint subtree = 1;\n\n\t\tfor (i = 0; i <= level; i++) {\n\t\t\tif (offsets[i] != offsets2[i]) {\n\t\t\t\tsubtree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!subtree) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t\t   &nr, &nr+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t\t   partial->p,\n\t\t\t\t\t\t   partial->p+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nr2) {\n\t\t/*\n\t\t * ext4_find_shared returns Indirect structure which\n\t\t * points to the last element which should not be\n\t\t * removed by truncate. But this is end of the range\n\t\t * in punch_hole so we need to point to the next element\n\t\t */\n\t\tpartial2->p++;\n\t}\n\n\twhile (partial > chain || partial2 > chain2) {\n\t\tint depth = (chain+n-1) - partial;\n\t\tint depth2 = (chain2+n2-1) - partial2;\n\n\t\tif (partial > chain && partial2 > chain2 &&\n\t\t    partial->bh->b_blocknr == partial2->bh->b_blocknr) {\n\t\t\t/*\n\t\t\t * We've converged on the same block. Clear the range,\n\t\t\t * then we're done.\n\t\t\t */\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * The start and end partial branches may not be at the same\n\t\t * level even though the punch happened within one level. So, we\n\t\t * give them a chance to arrive at the same level, then walk\n\t\t * them in step with each other until we converge on the same\n\t\t * block.\n\t\t */\n\t\tif (partial > chain && depth <= depth2) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   (__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tif (partial2 > chain2 && depth2 <= depth) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t}\n\treturn 0;\n\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_remove_space(handle_t *handle, struct inode *inode,\n\t\t\t  ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t__le32 *i_data = ei->i_data;\n\tint addr_per_block = EXT4_ADDR_PER_BLOCK(inode->i_sb);\n\text4_lblk_t offsets[4], offsets2[4];\n\tIndirect chain[4], chain2[4];\n\tIndirect *partial, *partial2;\n\text4_lblk_t max_block;\n\t__le32 nr = 0, nr2 = 0;\n\tint n = 0, n2 = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\n\tmax_block = (EXT4_SB(inode->i_sb)->s_bitmap_maxbytes + blocksize-1)\n\t\t\t\t\t>> EXT4_BLOCK_SIZE_BITS(inode->i_sb);\n\tif (end >= max_block)\n\t\tend = max_block;\n\tif ((start >= end) || (start > max_block))\n\t\treturn 0;\n\n\tn = ext4_block_to_path(inode, start, offsets, NULL);\n\tn2 = ext4_block_to_path(inode, end, offsets2, NULL);\n\n\tBUG_ON(n > n2);\n\n\tif ((n == 1) && (n == n2)) {\n\t\t/* We're punching only within direct block range */\n\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t       i_data + offsets2[0]);\n\t\treturn 0;\n\t} else if (n2 > n) {\n\t\t/*\n\t\t * Start and end are on a different levels so we're going to\n\t\t * free partial block at start, and partial block at end of\n\t\t * the range. If there are some levels in between then\n\t\t * do_indirects label will take care of that.\n\t\t */\n\n\t\tif (n == 1) {\n\t\t\t/*\n\t\t\t * Start is at the direct block level, free\n\t\t\t * everything to the end of the level.\n\t\t\t */\n\t\t\text4_free_data(handle, inode, NULL, i_data + offsets[0],\n\t\t\t\t       i_data + EXT4_NDIR_BLOCKS);\n\t\t\tgoto end_range;\n\t\t}\n\n\n\t\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\t\tif (nr) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t   &nr, &nr+1, (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\tpartial->p,\n\t\t\t\t\tpartial->p+1, (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the start of the range\n\t\t */\n\t\twhile (partial > chain) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\tpartial->p + 1,\n\t\t\t\t(__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t(chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\nend_range:\n\t\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\t\tif (nr2) {\n\t\t\tif (partial2 == chain2) {\n\t\t\t\t/*\n\t\t\t\t * Remember, end is exclusive so here we're at\n\t\t\t\t * the start of the next level we're not going\n\t\t\t\t * to free. Everything was covered by the start\n\t\t\t\t * of the range.\n\t\t\t\t */\n\t\t\t\tgoto do_indirects;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * ext4_find_shared returns Indirect structure which\n\t\t\t * points to the last element which should not be\n\t\t\t * removed by truncate. But this is end of the range\n\t\t\t * in punch_hole so we need to point to the next element\n\t\t\t */\n\t\t\tpartial2->p++;\n\t\t}\n\n\t\t/*\n\t\t * Clear the ends of indirect blocks on the shared branch\n\t\t * at the end of the range\n\t\t */\n\t\twhile (partial2 > chain2) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t\tgoto do_indirects;\n\t}\n\n\t/* Punch happened within the same level (n == n2) */\n\tpartial = ext4_find_shared(inode, n, offsets, chain, &nr);\n\tpartial2 = ext4_find_shared(inode, n2, offsets2, chain2, &nr2);\n\n\t/* Free top, but only if partial2 isn't its subtree. */\n\tif (nr) {\n\t\tint level = min(partial - chain, partial2 - chain2);\n\t\tint i;\n\t\tint subtree = 1;\n\n\t\tfor (i = 0; i <= level; i++) {\n\t\t\tif (offsets[i] != offsets2[i]) {\n\t\t\t\tsubtree = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!subtree) {\n\t\t\tif (partial == chain) {\n\t\t\t\t/* Shared branch grows from the inode */\n\t\t\t\text4_free_branches(handle, inode, NULL,\n\t\t\t\t\t\t   &nr, &nr+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t\t*partial->p = 0;\n\t\t\t} else {\n\t\t\t\t/* Shared branch grows from an indirect block */\n\t\t\t\tBUFFER_TRACE(partial->bh, \"get_write_access\");\n\t\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t\t   partial->p,\n\t\t\t\t\t\t   partial->p+1,\n\t\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!nr2) {\n\t\t/*\n\t\t * ext4_find_shared returns Indirect structure which\n\t\t * points to the last element which should not be\n\t\t * removed by truncate. But this is end of the range\n\t\t * in punch_hole so we need to point to the next element\n\t\t */\n\t\tpartial2->p++;\n\t}\n\n\twhile (partial > chain || partial2 > chain2) {\n\t\tint depth = (chain+n-1) - partial;\n\t\tint depth2 = (chain2+n2-1) - partial2;\n\n\t\tif (partial > chain && partial2 > chain2 &&\n\t\t    partial->bh->b_blocknr == partial2->bh->b_blocknr) {\n\t\t\t/*\n\t\t\t * We've converged on the same block. Clear the range,\n\t\t\t * then we're done.\n\t\t\t */\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * The start and end partial branches may not be at the same\n\t\t * level even though the punch happened within one level. So, we\n\t\t * give them a chance to arrive at the same level, then walk\n\t\t * them in step with each other until we converge on the same\n\t\t * block.\n\t\t */\n\t\tif (partial > chain && depth <= depth2) {\n\t\t\text4_free_branches(handle, inode, partial->bh,\n\t\t\t\t\t   partial->p + 1,\n\t\t\t\t\t   (__le32 *)partial->bh->b_data+addr_per_block,\n\t\t\t\t\t   (chain+n-1) - partial);\n\t\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\t\tbrelse(partial->bh);\n\t\t\tpartial--;\n\t\t}\n\t\tif (partial2 > chain2 && depth2 <= depth) {\n\t\t\text4_free_branches(handle, inode, partial2->bh,\n\t\t\t\t\t   (__le32 *)partial2->bh->b_data,\n\t\t\t\t\t   partial2->p,\n\t\t\t\t\t   (chain2+n2-1) - partial2);\n\t\t\tBUFFER_TRACE(partial2->bh, \"call brelse\");\n\t\t\tbrelse(partial2->bh);\n\t\t\tpartial2--;\n\t\t}\n\t}\n\treturn 0;\n\ndo_indirects:\n\t/* Kill the remaining (whole) subtrees */\n\tswitch (offsets[0]) {\n\tdefault:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_IND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 1);\n\t\t\ti_data[EXT4_IND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_IND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_DIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 2);\n\t\t\ti_data[EXT4_DIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_DIND_BLOCK:\n\t\tif (++n >= n2)\n\t\t\treturn 0;\n\t\tnr = i_data[EXT4_TIND_BLOCK];\n\t\tif (nr) {\n\t\t\text4_free_branches(handle, inode, NULL, &nr, &nr+1, 3);\n\t\t\ti_data[EXT4_TIND_BLOCK] = 0;\n\t\t}\n\tcase EXT4_TIND_BLOCK:\n\t\t;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_remove_space",
          "args": [
            "inode",
            "first_block",
            "stop_block - 1"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_remove_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "2803-3051",
          "snippet": "int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t  ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tlong long partial_cluster = 0;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\text_debug(\"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, depth + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\ttrace_ext4_ext_remove_space(inode, start, end, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block, ex_end, lblk;\n\t\text4_fsblk_t pblk;\n\n\t\t/* find extent for or closest extent to this block */\n\t\tpath = ext4_find_extent(inode, end, NULL, EXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tex_end = ee_block + ext4_ext_get_actual_len(ex) - 1;\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block && end < ex_end) {\n\n\t\t\t/*\n\t\t\t * If we're going to split the extent, note that\n\t\t\t * the cluster containing the block after 'end' is\n\t\t\t * in use to avoid freeing it when removing blocks.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex) + end - ee_block + 2;\n\t\t\t\tpartial_cluster =\n\t\t\t\t\t-(long long) EXT4_B2C(sbi, pblk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent. Also we should not\n\t\t\t * fail removing space due to ENOSPC so try to use\n\t\t\t * reserved block if that happens.\n\t\t\t */\n\t\t\terr = ext4_force_split_extent_at(handle, inode, &path,\n\t\t\t\t\t\t\t end + 1, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t} else if (sbi->s_cluster_ratio > 1 && end >= ex_end) {\n\t\t\t/*\n\t\t\t * If there's an extent to the right its first cluster\n\t\t\t * contains the immediate right boundary of the\n\t\t\t * truncated/punched region.  Set partial_cluster to\n\t\t\t * its negative value so it won't be freed if shared\n\t\t\t * with the current extent.  The end < ee_block case\n\t\t\t * is handled in ext4_ext_rm_leaf().\n\t\t\t */\n\t\t\tlblk = ex_end + 1;\n\t\t\terr = ext4_ext_search_right(inode, path, &lblk, &pblk,\n\t\t\t\t\t\t    &ex);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (pblk)\n\t\t\t\tpartial_cluster =\n\t\t\t\t\t-(long long) EXT4_B2C(sbi, pblk);\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t\t       GFP_NOFS);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_maxdepth = path[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n\t\t\t\t\t       &partial_cluster, start,\n\t\t\t\t\t       end);\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* this is index block */\n\t\tif (!path[i].p_hdr) {\n\t\t\text_debug(\"initialize header\\n\");\n\t\t\tpath[i].p_hdr = ext_block_hdr(path[i].p_bh);\n\t\t}\n\n\t\tif (!path[i].p_idx) {\n\t\t\t/* this level hasn't been touched yet */\n\t\t\tpath[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;\n\t\t\text_debug(\"init index ptr: hdr 0x%p, num %d\\n\",\n\t\t\t\t  path[i].p_hdr,\n\t\t\t\t  le16_to_cpu(path[i].p_hdr->eh_entries));\n\t\t} else {\n\t\t\t/* we were already here, see at next index */\n\t\t\tpath[i].p_idx--;\n\t\t}\n\n\t\text_debug(\"level %d - index, first 0x%p, cur 0x%p\\n\",\n\t\t\t\ti, EXT_FIRST_INDEX(path[i].p_hdr),\n\t\t\t\tpath[i].p_idx);\n\t\tif (ext4_ext_more_to_rm(path + i)) {\n\t\t\tstruct buffer_head *bh;\n\t\t\t/* go to the next level */\n\t\t\text_debug(\"move to level %d (block %llu)\\n\",\n\t\t\t\t  i + 1, ext4_idx_pblock(path[i].p_idx));\n\t\t\tmemset(path + i + 1, 0, sizeof(*path));\n\t\t\tbh = read_extent_tree_block(inode,\n\t\t\t\text4_idx_pblock(path[i].p_idx), depth - i - 1,\n\t\t\t\tEXT4_EX_NOCACHE);\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\t/* should we reset i_size? */\n\t\t\t\terr = PTR_ERR(bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yield here to deal with large extent trees.\n\t\t\t * Should be a no-op if we did IO above. */\n\t\t\tcond_resched();\n\t\t\tif (WARN_ON(i + 1 > depth)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath[i + 1].p_bh = bh;\n\n\t\t\t/* save actual number of indexes since this\n\t\t\t * number is changed at the next iteration */\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries);\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* we finished processing this index, go up */\n\t\t\tif (path[i].p_hdr->eh_entries == 0 && i > 0) {\n\t\t\t\t/* index is empty, remove it;\n\t\t\t\t * handle must be already prepared by the\n\t\t\t\t * truncatei_leaf() */\n\t\t\t\terr = ext4_ext_rm_idx(handle, inode, path, i);\n\t\t\t}\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\text_debug(\"return to level %d\\n\", i);\n\t\t}\n\t}\n\n\ttrace_ext4_ext_remove_space_done(inode, start, end, depth,\n\t\t\tpartial_cluster, path->p_hdr->eh_entries);\n\n\t/*\n\t * If we still have something in the partial cluster and we have removed\n\t * even the first extent, then we should free the blocks in the partial\n\t * cluster as well.  (This code will only run when there are no leaves\n\t * to the immediate left of the truncated/punched region.)\n\t */\n\tif (partial_cluster > 0 && err == 0) {\n\t\t/* don't zero partial_cluster since it's not used afterwards */\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_C2B(sbi, partial_cluster),\n\t\t\t\t sbi->s_cluster_ratio,\n\t\t\t\t get_default_free_blocks_flags(inode));\n\t}\n\n\t/* TODO: flexible tree reduction should be here */\n\tif (path->p_hdr->eh_entries == 0) {\n\t\t/*\n\t\t * truncate to zero freed all the tree,\n\t\t * so we need to correct eh_depth\n\t\t */\n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err == 0) {\n\t\t\text_inode_hdr(inode)->eh_depth = 0;\n\t\t\text_inode_hdr(inode)->eh_max =\n\t\t\t\tcpu_to_le16(ext4_ext_space_root(inode, 0));\n\t\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tpath = NULL;\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\text4_journal_stop(handle);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t  ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tlong long partial_cluster = 0;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\text_debug(\"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, depth + 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\ttrace_ext4_ext_remove_space(inode, start, end, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block, ex_end, lblk;\n\t\text4_fsblk_t pblk;\n\n\t\t/* find extent for or closest extent to this block */\n\t\tpath = ext4_find_extent(inode, end, NULL, EXT4_EX_NOCACHE);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EIO;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tex_end = ee_block + ext4_ext_get_actual_len(ex) - 1;\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block && end < ex_end) {\n\n\t\t\t/*\n\t\t\t * If we're going to split the extent, note that\n\t\t\t * the cluster containing the block after 'end' is\n\t\t\t * in use to avoid freeing it when removing blocks.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex) + end - ee_block + 2;\n\t\t\t\tpartial_cluster =\n\t\t\t\t\t-(long long) EXT4_B2C(sbi, pblk);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent. Also we should not\n\t\t\t * fail removing space due to ENOSPC so try to use\n\t\t\t * reserved block if that happens.\n\t\t\t */\n\t\t\terr = ext4_force_split_extent_at(handle, inode, &path,\n\t\t\t\t\t\t\t end + 1, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t} else if (sbi->s_cluster_ratio > 1 && end >= ex_end) {\n\t\t\t/*\n\t\t\t * If there's an extent to the right its first cluster\n\t\t\t * contains the immediate right boundary of the\n\t\t\t * truncated/punched region.  Set partial_cluster to\n\t\t\t * its negative value so it won't be freed if shared\n\t\t\t * with the current extent.  The end < ee_block case\n\t\t\t * is handled in ext4_ext_rm_leaf().\n\t\t\t */\n\t\t\tlblk = ex_end + 1;\n\t\t\terr = ext4_ext_search_right(inode, path, &lblk, &pblk,\n\t\t\t\t\t\t    &ex);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tif (pblk)\n\t\t\t\tpartial_cluster =\n\t\t\t\t\t-(long long) EXT4_B2C(sbi, pblk);\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kzalloc(sizeof(struct ext4_ext_path) * (depth + 1),\n\t\t\t       GFP_NOFS);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_maxdepth = path[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n\t\t\t\t\t       &partial_cluster, start,\n\t\t\t\t\t       end);\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* this is index block */\n\t\tif (!path[i].p_hdr) {\n\t\t\text_debug(\"initialize header\\n\");\n\t\t\tpath[i].p_hdr = ext_block_hdr(path[i].p_bh);\n\t\t}\n\n\t\tif (!path[i].p_idx) {\n\t\t\t/* this level hasn't been touched yet */\n\t\t\tpath[i].p_idx = EXT_LAST_INDEX(path[i].p_hdr);\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries)+1;\n\t\t\text_debug(\"init index ptr: hdr 0x%p, num %d\\n\",\n\t\t\t\t  path[i].p_hdr,\n\t\t\t\t  le16_to_cpu(path[i].p_hdr->eh_entries));\n\t\t} else {\n\t\t\t/* we were already here, see at next index */\n\t\t\tpath[i].p_idx--;\n\t\t}\n\n\t\text_debug(\"level %d - index, first 0x%p, cur 0x%p\\n\",\n\t\t\t\ti, EXT_FIRST_INDEX(path[i].p_hdr),\n\t\t\t\tpath[i].p_idx);\n\t\tif (ext4_ext_more_to_rm(path + i)) {\n\t\t\tstruct buffer_head *bh;\n\t\t\t/* go to the next level */\n\t\t\text_debug(\"move to level %d (block %llu)\\n\",\n\t\t\t\t  i + 1, ext4_idx_pblock(path[i].p_idx));\n\t\t\tmemset(path + i + 1, 0, sizeof(*path));\n\t\t\tbh = read_extent_tree_block(inode,\n\t\t\t\text4_idx_pblock(path[i].p_idx), depth - i - 1,\n\t\t\t\tEXT4_EX_NOCACHE);\n\t\t\tif (IS_ERR(bh)) {\n\t\t\t\t/* should we reset i_size? */\n\t\t\t\terr = PTR_ERR(bh);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yield here to deal with large extent trees.\n\t\t\t * Should be a no-op if we did IO above. */\n\t\t\tcond_resched();\n\t\t\tif (WARN_ON(i + 1 > depth)) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath[i + 1].p_bh = bh;\n\n\t\t\t/* save actual number of indexes since this\n\t\t\t * number is changed at the next iteration */\n\t\t\tpath[i].p_block = le16_to_cpu(path[i].p_hdr->eh_entries);\n\t\t\ti++;\n\t\t} else {\n\t\t\t/* we finished processing this index, go up */\n\t\t\tif (path[i].p_hdr->eh_entries == 0 && i > 0) {\n\t\t\t\t/* index is empty, remove it;\n\t\t\t\t * handle must be already prepared by the\n\t\t\t\t * truncatei_leaf() */\n\t\t\t\terr = ext4_ext_rm_idx(handle, inode, path, i);\n\t\t\t}\n\t\t\t/* root level has p_bh == NULL, brelse() eats this */\n\t\t\tbrelse(path[i].p_bh);\n\t\t\tpath[i].p_bh = NULL;\n\t\t\ti--;\n\t\t\text_debug(\"return to level %d\\n\", i);\n\t\t}\n\t}\n\n\ttrace_ext4_ext_remove_space_done(inode, start, end, depth,\n\t\t\tpartial_cluster, path->p_hdr->eh_entries);\n\n\t/*\n\t * If we still have something in the partial cluster and we have removed\n\t * even the first extent, then we should free the blocks in the partial\n\t * cluster as well.  (This code will only run when there are no leaves\n\t * to the immediate left of the truncated/punched region.)\n\t */\n\tif (partial_cluster > 0 && err == 0) {\n\t\t/* don't zero partial_cluster since it's not used afterwards */\n\t\text4_free_blocks(handle, inode, NULL,\n\t\t\t\t EXT4_C2B(sbi, partial_cluster),\n\t\t\t\t sbi->s_cluster_ratio,\n\t\t\t\t get_default_free_blocks_flags(inode));\n\t}\n\n\t/* TODO: flexible tree reduction should be here */\n\tif (path->p_hdr->eh_entries == 0) {\n\t\t/*\n\t\t * truncate to zero freed all the tree,\n\t\t * so we need to correct eh_depth\n\t\t */\n\t\terr = ext4_ext_get_access(handle, inode, path);\n\t\tif (err == 0) {\n\t\t\text_inode_hdr(inode)->eh_depth = 0;\n\t\t\text_inode_hdr(inode)->eh_max =\n\t\t\t\tcpu_to_le16(ext4_ext_space_root(inode, 0));\n\t\t\terr = ext4_ext_dirty(handle, inode, path);\n\t\t}\n\t}\nout:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\tpath = NULL;\n\tif (err == -EAGAIN)\n\t\tgoto again;\n\text4_journal_stop(handle);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode",
            "first_block",
            "stop_block - first_block"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_zero_partial_blocks",
          "args": [
            "handle",
            "inode",
            "offset",
            "length"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_zero_partial_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3337-3373",
          "snippet": "int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nint ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "ret"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_TRUNCATE",
            "credits"
          ],
          "line": 3467
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_block_unlocked_dio",
          "args": [
            "inode"
          ],
          "line": 3460
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_block_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2825-2829",
          "snippet": "static inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_block_unlocked_dio(struct inode *inode)\n{\n\text4_set_inode_state(inode, EXT4_STATE_DIOREAD_LOCK);\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "inode",
            "first_block_offset",
            "last_block_offset"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "(offset + length)",
            "sb->s_blocksize"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset",
            "sb->s_blocksize"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_attach_jinode",
          "args": [
            "inode"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_attach_jinode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3524-3547",
          "snippet": "int ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "offset",
            "offset + length - 1"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_punch_hole",
          "args": [
            "inode",
            "offset",
            "length",
            "0"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nint ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_CACHE_SIZE - (inode->i_size & (PAGE_CACHE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\t/* Now release the pages again to reduce race window */\n\tif (last_block_offset > first_block_offset)\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_can_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3375-3384",
    "snippet": "int ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_inode_is_fast_symlink",
          "args": [
            "inode"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "144-153",
          "snippet": "static int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_zero_partial_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3337-3373",
    "snippet": "int ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_block_zero_page_range",
          "args": [
            "handle",
            "mapping",
            "byte_end - partial_end",
            "partial_end + 1"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3297-3315",
          "snippet": "static int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nint ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_block_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3323-3335",
    "snippet": "static int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_block_zero_page_range",
          "args": [
            "handle",
            "mapping",
            "from",
            "length"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3297-3315",
          "snippet": "static int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}"
  },
  {
    "function_name": "ext4_block_zero_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3297-3315",
    "snippet": "static int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ext4_block_zero_page_range",
          "args": [
            "handle",
            "mapping",
            "from",
            "length"
          ],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_block_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3208-3288",
          "snippet": "static int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_CACHE_SHIFT,\n\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);",
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_CACHE_SHIFT,\n\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_zero_page_range",
          "args": [
            "inode",
            "from",
            "length",
            "ext4_get_block"
          ],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "dax_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "484-511",
          "snippet": "int dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}"
  },
  {
    "function_name": "__ext4_block_zero_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3208-3288",
    "snippet": "static int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_CACHE_SHIFT,\n\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);",
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_jbd2_file_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "364-369",
          "snippet": "static inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_ORDERED_MODE"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"zeroed end of block\""
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get write access\""
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"still unmapped\""
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "0"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_block_write_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2908-2915",
          "snippet": "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"unmapped\""
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"freed: skip\""
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "from >> PAGE_CACHE_SHIFT",
            "mapping_gfp_mask(mapping) & ~__GFP_FS"
          ],
          "line": 3220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_CACHE_SHIFT,\n\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_set_aops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3187-3206",
    "snippet": "void ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
      "static const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
      "static const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DELALLOC"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_ORDERED_MODE"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_ORDERED_MODE"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_journal_mode",
          "args": [
            "inode"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_journal_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "394-411",
          "snippet": "static inline int ext4_inode_journal_mode(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) == NULL)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t/* writeback */\n\t/* We do not support data journalling with delayed allocation */\n\tif (!S_ISREG(inode->i_mode) ||\n\t    test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\treturn EXT4_INODE_JOURNAL_DATA_MODE;\t/* journal data */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA) &&\n\t    !test_opt(inode->i_sb, DELALLOC))\n\t\treturn EXT4_INODE_JOURNAL_DATA_MODE;\t/* journal data */\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\treturn EXT4_INODE_ORDERED_DATA_MODE;\t/* ordered */\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t/* writeback */\n\telse\n\t\tBUG();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_WRITEBACK_DATA_MODE\t0x04 /* writeback data mode */",
            "#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */",
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_WRITEBACK_DATA_MODE\t0x04 /* writeback data mode */\n#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_inode_journal_mode(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) == NULL)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t/* writeback */\n\t/* We do not support data journalling with delayed allocation */\n\tif (!S_ISREG(inode->i_mode) ||\n\t    test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\treturn EXT4_INODE_JOURNAL_DATA_MODE;\t/* journal data */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA) &&\n\t    !test_opt(inode->i_sb, DELALLOC))\n\t\treturn EXT4_INODE_JOURNAL_DATA_MODE;\t/* journal data */\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\treturn EXT4_INODE_ORDERED_DATA_MODE;\t/* ordered */\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)\n\t\treturn EXT4_INODE_WRITEBACK_DATA_MODE;\t/* writeback */\n\telse\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}"
  },
  {
    "function_name": "ext4_journalled_set_page_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3133-3137",
    "snippet": "static int ext4_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}"
  },
  {
    "function_name": "ext4_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "3093-3118",
    "snippet": "static ssize_t ext4_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\t/*\n\t * If we are doing data journalling we don't support O_DIRECT\n\t */\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\n\t/* Let buffer I/O handle the inline data case. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\ttrace_ext4_direct_IO_enter(inode, offset, count, rw);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_direct_IO(rw, iocb, iter, offset);\n\telse\n\t\tret = ext4_ind_direct_IO(rw, iocb, iter, offset);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, rw, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_direct_IO_exit",
          "args": [
            "inode",
            "offset",
            "count",
            "rw",
            "ret"
          ],
          "line": 3116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_direct_IO",
          "args": [
            "rw",
            "iocb",
            "iter",
            "offset"
          ],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "645-758",
          "snippet": "ssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_direct_IO",
          "args": [
            "rw",
            "iocb",
            "iter",
            "offset"
          ],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2956-3091",
          "snippet": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\text4_io_end_t *io_end = NULL;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (rw != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(rw, iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (rw == WRITE)\n\t\tatomic_inc(&inode->i_dio_count);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite) {\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as\n\t * unwritten to prevent parallel buffered read to expose\n\t * the stale data before DIO complete the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will\n\t * just simply mark the buffer mapped but still keep the\n\t * extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents\n\t * to written after return back from blockdev_direct_IO.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\text4_inode_aio_set(inode, NULL);\n\tif (!is_sync_kiocb(iocb)) {\n\t\tio_end = ext4_init_io_end(inode, GFP_NOFS);\n\t\tif (!io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto retake_lock;\n\t\t}\n\t\t/*\n\t\t * Grab reference for DIO. Will be dropped in ext4_end_io_dio()\n\t\t */\n\t\tiocb->private = ext4_get_io_end(io_end);\n\t\t/*\n\t\t * we save the io structure for current async direct\n\t\t * IO, so that later ext4_map_blocks() could flag the\n\t\t * io structure whether there is a unwritten extents\n\t\t * needs to be converted when IO is completed.\n\t\t */\n\t\text4_inode_aio_set(inode, io_end);\n\t}\n\n\tif (overwrite) {\n\t\tget_block_func = ext4_get_block_write_nolock;\n\t} else {\n\t\tget_block_func = ext4_get_block_write;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\t/*\n\t * Put our reference to io_end. This can free the io_end structure e.g.\n\t * in sync IO case or in case of error. It can even perform extent\n\t * conversion if all bios we submitted finished before we got here.\n\t * Note that in that case iocb->private can be already set to NULL\n\t * here.\n\t */\n\tif (io_end) {\n\t\text4_inode_aio_set(inode, NULL);\n\t\text4_put_io_end(io_end);\n\t\t/*\n\t\t * When no IO was submitted ext4_end_io_dio() was not\n\t\t * called so we have to put iocb's reference.\n\t\t */\n\t\tif (ret <= 0 && ret != -EIOCBQUEUED && iocb->private) {\n\t\t\tWARN_ON(iocb->private != io_end);\n\t\t\tWARN_ON(io_end->flag & EXT4_IO_END_UNWRITTEN);\n\t\t\text4_put_io_end(io_end);\n\t\t\tiocb->private = NULL;\n\t\t}\n\t}\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\nretake_lock:\n\tif (rw == WRITE)\n\t\tinode_dio_done(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite) {\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\text4_io_end_t *io_end = NULL;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (rw != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(rw, iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (rw == WRITE)\n\t\tatomic_inc(&inode->i_dio_count);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite) {\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as\n\t * unwritten to prevent parallel buffered read to expose\n\t * the stale data before DIO complete the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will\n\t * just simply mark the buffer mapped but still keep the\n\t * extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents\n\t * to written after return back from blockdev_direct_IO.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\text4_inode_aio_set(inode, NULL);\n\tif (!is_sync_kiocb(iocb)) {\n\t\tio_end = ext4_init_io_end(inode, GFP_NOFS);\n\t\tif (!io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto retake_lock;\n\t\t}\n\t\t/*\n\t\t * Grab reference for DIO. Will be dropped in ext4_end_io_dio()\n\t\t */\n\t\tiocb->private = ext4_get_io_end(io_end);\n\t\t/*\n\t\t * we save the io structure for current async direct\n\t\t * IO, so that later ext4_map_blocks() could flag the\n\t\t * io structure whether there is a unwritten extents\n\t\t * needs to be converted when IO is completed.\n\t\t */\n\t\text4_inode_aio_set(inode, io_end);\n\t}\n\n\tif (overwrite) {\n\t\tget_block_func = ext4_get_block_write_nolock;\n\t} else {\n\t\tget_block_func = ext4_get_block_write;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\t/*\n\t * Put our reference to io_end. This can free the io_end structure e.g.\n\t * in sync IO case or in case of error. It can even perform extent\n\t * conversion if all bios we submitted finished before we got here.\n\t * Note that in that case iocb->private can be already set to NULL\n\t * here.\n\t */\n\tif (io_end) {\n\t\text4_inode_aio_set(inode, NULL);\n\t\text4_put_io_end(io_end);\n\t\t/*\n\t\t * When no IO was submitted ext4_end_io_dio() was not\n\t\t * called so we have to put iocb's reference.\n\t\t */\n\t\tif (ret <= 0 && ret != -EIOCBQUEUED && iocb->private) {\n\t\t\tWARN_ON(iocb->private != io_end);\n\t\t\tWARN_ON(io_end->flag & EXT4_IO_END_UNWRITTEN);\n\t\t\text4_put_io_end(io_end);\n\t\t\tiocb->private = NULL;\n\t\t}\n\t}\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\nretake_lock:\n\tif (rw == WRITE)\n\t\tinode_dio_done(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite) {\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_direct_IO_enter",
          "args": [
            "inode",
            "offset",
            "count",
            "rw"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 3108
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic ssize_t ext4_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n\t/*\n\t * If we are doing data journalling we don't support O_DIRECT\n\t */\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\n\t/* Let buffer I/O handle the inline data case. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\ttrace_ext4_direct_IO_enter(inode, offset, count, rw);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_direct_IO(rw, iocb, iter, offset);\n\telse\n\t\tret = ext4_ind_direct_IO(rw, iocb, iter, offset);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, rw, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_ext_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2956-3091",
    "snippet": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\text4_io_end_t *io_end = NULL;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (rw != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(rw, iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (rw == WRITE)\n\t\tatomic_inc(&inode->i_dio_count);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite) {\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as\n\t * unwritten to prevent parallel buffered read to expose\n\t * the stale data before DIO complete the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will\n\t * just simply mark the buffer mapped but still keep the\n\t * extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents\n\t * to written after return back from blockdev_direct_IO.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\text4_inode_aio_set(inode, NULL);\n\tif (!is_sync_kiocb(iocb)) {\n\t\tio_end = ext4_init_io_end(inode, GFP_NOFS);\n\t\tif (!io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto retake_lock;\n\t\t}\n\t\t/*\n\t\t * Grab reference for DIO. Will be dropped in ext4_end_io_dio()\n\t\t */\n\t\tiocb->private = ext4_get_io_end(io_end);\n\t\t/*\n\t\t * we save the io structure for current async direct\n\t\t * IO, so that later ext4_map_blocks() could flag the\n\t\t * io structure whether there is a unwritten extents\n\t\t * needs to be converted when IO is completed.\n\t\t */\n\t\text4_inode_aio_set(inode, io_end);\n\t}\n\n\tif (overwrite) {\n\t\tget_block_func = ext4_get_block_write_nolock;\n\t} else {\n\t\tget_block_func = ext4_get_block_write;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\t/*\n\t * Put our reference to io_end. This can free the io_end structure e.g.\n\t * in sync IO case or in case of error. It can even perform extent\n\t * conversion if all bios we submitted finished before we got here.\n\t * Note that in that case iocb->private can be already set to NULL\n\t * here.\n\t */\n\tif (io_end) {\n\t\text4_inode_aio_set(inode, NULL);\n\t\text4_put_io_end(io_end);\n\t\t/*\n\t\t * When no IO was submitted ext4_end_io_dio() was not\n\t\t * called so we have to put iocb's reference.\n\t\t */\n\t\tif (ret <= 0 && ret != -EIOCBQUEUED && iocb->private) {\n\t\t\tWARN_ON(iocb->private != io_end);\n\t\t\tWARN_ON(io_end->flag & EXT4_IO_END_UNWRITTEN);\n\t\t\text4_put_io_end(io_end);\n\t\t\tiocb->private = NULL;\n\t\t}\n\t}\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\nretake_lock:\n\tif (rw == WRITE)\n\t\tinode_dio_done(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite) {\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3086
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_done",
          "args": [
            "inode"
          ],
          "line": 3083
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1955-1959",
          "snippet": "void inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DIO_UNWRITTEN"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_convert_unwritten_extents",
          "args": [
            "NULL",
            "inode",
            "offset",
            "ret"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4998-5059",
          "snippet": "int ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t   loff_t offset, ssize_t len)\n{\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\t/*\n\t * We can't just convert len to max_blocks because\n\t * If blocksize = 4096 offset = 3072 and len = 2048\n\t */\n\tmax_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -\n\t\t      map.m_lblk);\n\t/*\n\t * This is somewhat ugly but the idea is clear: When transaction is\n\t * reserved, everything goes into it. Otherwise we rather start several\n\t * smaller transactions for conversion of each extent separately.\n\t */\n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tcredits = 0;\n\t} else {\n\t\t/*\n\t\t * credits to insert 1 extent into extent tree\n\t\t */\n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\tif (credits) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t\t    credits);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0)\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"inode #%lu: block %u: len %u: \"\n\t\t\t\t     \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t     inode->i_ino, map.m_lblk,\n\t\t\t\t     map.m_len, ret);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tif (credits)\n\t\t\tret2 = ext4_journal_stop(handle);\n\t\tif (ret <= 0 || ret2)\n\t\t\tbreak;\n\t}\n\tif (!credits)\n\t\tret2 = ext4_journal_stop(handle);\n\treturn ret > 0 ? ret2 : ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t   loff_t offset, ssize_t len)\n{\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\t/*\n\t * We can't just convert len to max_blocks because\n\t * If blocksize = 4096 offset = 3072 and len = 2048\n\t */\n\tmax_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -\n\t\t      map.m_lblk);\n\t/*\n\t * This is somewhat ugly but the idea is clear: When transaction is\n\t * reserved, everything goes into it. Otherwise we rather start several\n\t * smaller transactions for conversion of each extent separately.\n\t */\n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tcredits = 0;\n\t} else {\n\t\t/*\n\t\t * credits to insert 1 extent into extent tree\n\t\t */\n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\tif (credits) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t\t    credits);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0)\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"inode #%lu: block %u: len %u: \"\n\t\t\t\t     \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t     inode->i_ino, map.m_lblk,\n\t\t\t\t     map.m_len, ret);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tif (credits)\n\t\t\tret2 = ext4_journal_stop(handle);\n\t\tif (ret <= 0 || ret2)\n\t\t\tbreak;\n\t}\n\tif (!credits)\n\t\tret2 = ext4_journal_stop(handle);\n\treturn ret > 0 ? ret2 : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_DIO_UNWRITTEN"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_put_io_end",
          "args": [
            "io_end"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_put_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "274-289",
          "snippet": "int ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "io_end->flag & EXT4_IO_END_UNWRITTEN"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "iocb->private != io_end"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_aio_set",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_aio_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1397-1400",
          "snippet": "static inline void ext4_inode_aio_set(struct inode *inode, ext4_io_end_t *io)\n{\n\tinode->i_private = io;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_inode_aio_set(struct inode *inode, ext4_io_end_t *io)\n{\n\tinode->i_private = io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "inode->i_sb->s_bdev",
            "iter",
            "offset",
            "get_block_func",
            "ext4_end_io_dio",
            "NULL",
            "dio_flags"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "__blockdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "1304-1324",
          "snippet": "ssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_do_io",
          "args": [
            "rw",
            "iocb",
            "inode",
            "iter",
            "offset",
            "get_block_func",
            "ext4_end_io_dio",
            "dio_flags"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "dax_do_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "192-226",
          "snippet": "ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_io_end",
          "args": [
            "io_end"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "291-295",
          "snippet": "ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end)\n{\n\tatomic_inc(&io_end->count);\n\treturn io_end;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\next4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end)\n{\n\tatomic_inc(&io_end->count);\n\treturn io_end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_io_end",
          "args": [
            "inode",
            "GFP_NOFS"
          ],
          "line": 3013
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "251-261",
          "snippet": "ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\next4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "iocb->private == NULL"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_direct_IO",
          "args": [
            "rw",
            "iocb",
            "iter",
            "offset"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "645-758",
          "snippet": "ssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t   struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\thandle_t *handle;\n\tssize_t ret;\n\tint orphan = 0;\n\tsize_t count = iov_iter_count(iter);\n\tint retries = 0;\n\n\tif (rw == WRITE) {\n\t\tloff_t final_size = offset + count;\n\n\t\tif (final_size > inode->i_size) {\n\t\t\t/* Credits for sb + inode write */\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ext4_orphan_add(handle, inode);\n\t\t\tif (ret) {\n\t\t\t\text4_journal_stop(handle);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\torphan = 1;\n\t\t\tei->i_disksize = inode->i_size;\n\t\t\text4_journal_stop(handle);\n\t\t}\n\t}\n\nretry:\n\tif (rw == READ && ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * Nolock dioread optimization may be dynamically disabled\n\t\t * via ext4_inode_block_unlocked_dio(). Check inode's state\n\t\t * while holding extra i_dio_count ref.\n\t\t */\n\t\tatomic_inc(&inode->i_dio_count);\n\t\tsmp_mb();\n\t\tif (unlikely(ext4_test_inode_state(inode,\n\t\t\t\t\t\t    EXT4_STATE_DIOREAD_LOCK))) {\n\t\t\tinode_dio_done(inode);\n\t\t\tgoto locked;\n\t\t}\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, 0);\n\t\telse\n\t\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\tinode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\text4_get_block, NULL, NULL, 0);\n\t\tinode_dio_done(inode);\n\t} else {\nlocked:\n\t\tif (IS_DAX(inode))\n\t\t\tret = dax_do_io(rw, iocb, inode, iter, offset,\n\t\t\t\t\text4_get_block, NULL, DIO_LOCKING);\n\t\telse\n\t\t\tret = blockdev_direct_IO(rw, iocb, inode, iter,\n\t\t\t\t\toffset, ext4_get_block);\n\n\t\tif (unlikely((rw & WRITE) && ret < 0)) {\n\t\t\tloff_t isize = i_size_read(inode);\n\t\t\tloff_t end = offset + count;\n\n\t\t\tif (end > isize)\n\t\t\t\text4_truncate_failed_write(inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\n\tif (orphan) {\n\t\tint err;\n\n\t\t/* Credits for sb + inode write */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\t\tif (IS_ERR(handle)) {\n\t\t\t/* This is really bad luck. We've written the data\n\t\t\t * but cannot extend i_size. Bail out and pretend\n\t\t\t * the write failed... */\n\t\t\tret = PTR_ERR(handle);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\n\t\t\tgoto out;\n\t\t}\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(handle, inode);\n\t\tif (ret > 0) {\n\t\t\tloff_t end = offset + ret;\n\t\t\tif (end > inode->i_size) {\n\t\t\t\tei->i_disksize = end;\n\t\t\t\ti_size_write(inode, end);\n\t\t\t\t/*\n\t\t\t\t * We're going to return a positive `ret'\n\t\t\t\t * here due to non-zero-length I/O, so there's\n\t\t\t\t * no way of reporting error returns from\n\t\t\t\t * ext4_mark_inode_dirty() to userspace.  So\n\t\t\t\t * ignore it.\n\t\t\t\t */\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t}\n\t\t}\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      struct iov_iter *iter, loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\text4_io_end_t *io_end = NULL;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (rw != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(rw, iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (rw == WRITE)\n\t\tatomic_inc(&inode->i_dio_count);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite) {\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as\n\t * unwritten to prevent parallel buffered read to expose\n\t * the stale data before DIO complete the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will\n\t * just simply mark the buffer mapped but still keep the\n\t * extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents\n\t * to written after return back from blockdev_direct_IO.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\text4_inode_aio_set(inode, NULL);\n\tif (!is_sync_kiocb(iocb)) {\n\t\tio_end = ext4_init_io_end(inode, GFP_NOFS);\n\t\tif (!io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto retake_lock;\n\t\t}\n\t\t/*\n\t\t * Grab reference for DIO. Will be dropped in ext4_end_io_dio()\n\t\t */\n\t\tiocb->private = ext4_get_io_end(io_end);\n\t\t/*\n\t\t * we save the io structure for current async direct\n\t\t * IO, so that later ext4_map_blocks() could flag the\n\t\t * io structure whether there is a unwritten extents\n\t\t * needs to be converted when IO is completed.\n\t\t */\n\t\text4_inode_aio_set(inode, io_end);\n\t}\n\n\tif (overwrite) {\n\t\tget_block_func = ext4_get_block_write_nolock;\n\t} else {\n\t\tget_block_func = ext4_get_block_write;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(rw, iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\t/*\n\t * Put our reference to io_end. This can free the io_end structure e.g.\n\t * in sync IO case or in case of error. It can even perform extent\n\t * conversion if all bios we submitted finished before we got here.\n\t * Note that in that case iocb->private can be already set to NULL\n\t * here.\n\t */\n\tif (io_end) {\n\t\text4_inode_aio_set(inode, NULL);\n\t\text4_put_io_end(io_end);\n\t\t/*\n\t\t * When no IO was submitted ext4_end_io_dio() was not\n\t\t * called so we have to put iocb's reference.\n\t\t */\n\t\tif (ret <= 0 && ret != -EIOCBQUEUED && iocb->private) {\n\t\t\tWARN_ON(iocb->private != io_end);\n\t\t\tWARN_ON(io_end->flag & EXT4_IO_END_UNWRITTEN);\n\t\t\text4_put_io_end(io_end);\n\t\t\tiocb->private = NULL;\n\t\t}\n\t}\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\nretake_lock:\n\tif (rw == WRITE)\n\t\tinode_dio_done(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite) {\n\t\tup_read(&EXT4_I(inode)->i_data_sem);\n\t\tmutex_lock(&inode->i_mutex);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_end_io_dio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2917-2935",
    "snippet": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\n\t/* if not async direct IO just return */\n\tif (!io_end)\n\t\treturn;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\n\tiocb->private = NULL;\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_put_io_end",
          "args": [
            "io_end"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_put_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "274-289",
          "snippet": "int ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_debug",
          "args": [
            "\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\"",
            "iocb->private",
            "io_end->inode->i_ino",
            "iocb",
            "offset",
            "size"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\n\t/* if not async direct IO just return */\n\tif (!io_end)\n\t\treturn;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\n\tiocb->private = NULL;\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n}"
  },
  {
    "function_name": "ext4_get_block_write_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2908-2915",
    "snippet": "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ext4_get_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "EXT4_GET_BLOCKS_NO_LOCK"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "_ext4_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "675-722",
          "snippet": "static int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DIO_MAX_BLOCKS 4096"
          ],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\"",
            "inode->i_ino",
            "create"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write_nolock: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_NO_LOCK);\n}"
  },
  {
    "function_name": "ext4_get_block_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2899-2906",
    "snippet": "int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_IO_CREATE_EXT);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ext4_get_block",
          "args": [
            "inode",
            "iblock",
            "bh_result",
            "EXT4_GET_BLOCKS_IO_CREATE_EXT"
          ],
          "line": 2904
        },
        "resolved": true,
        "details": {
          "function_name": "_ext4_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "675-722",
          "snippet": "static int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DIO_MAX_BLOCKS 4096"
          ],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"ext4_get_block_write: inode %lu, create flag %d\\n\"",
            "inode->i_ino",
            "create"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_IO_CREATE_EXT);\n}"
  },
  {
    "function_name": "ext4_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2879-2892",
    "snippet": "static int ext4_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_releasepage(page);\n\n\t/* Page has dirty journalled data -> cannot release */\n\tif (PageChecked(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page, wait);\n\telse\n\t\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_try_to_free_buffers",
          "args": [
            "journal",
            "page",
            "wait"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1871-1906",
          "snippet": "int jbd2_journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_try_to_free_buffers(journal_t *journal,\n\t\t\t\tstruct page *page, gfp_t gfp_mask)\n{\n\tstruct buffer_head *head;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tJ_ASSERT(PageLocked(page));\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tstruct journal_head *jh;\n\n\t\t/*\n\t\t * We take our own ref against the journal_head here to avoid\n\t\t * having to add tons of locking around each instance of\n\t\t * jbd2_journal_put_journal_head().\n\t\t */\n\t\tjh = jbd2_journal_grab_journal_head(bh);\n\t\tif (!jh)\n\t\t\tcontinue;\n\n\t\tjbd_lock_bh_state(bh);\n\t\t__journal_try_to_free_buffer(journal, bh);\n\t\tjbd2_journal_put_journal_head(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (buffer_jbd(bh))\n\t\t\tgoto busy;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tret = try_to_free_buffers(page);\n\nbusy:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_releasepage",
          "args": [
            "page"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "page->mapping->host"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_releasepage(page);\n\n\t/* Page has dirty journalled data -> cannot release */\n\tif (PageChecked(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page, wait);\n\telse\n\t\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "ext4_journalled_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2872-2877",
    "snippet": "static void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "__ext4_journalled_invalidatepage(page, offset, length) < 0"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_journalled_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journalled_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2854-2869",
          "snippet": "static int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}"
  },
  {
    "function_name": "__ext4_journalled_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2854-2869",
    "snippet": "static int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_invalidatepage",
          "args": [
            "journal",
            "page",
            "offset",
            "length"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2164-2214",
          "snippet": "int jbd2_journal_invalidatepage(journal_t *journal,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\tint ret = 0;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn 0;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tret = journal_unmap_buffer(journal, bh, partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tmay_free &= ret;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_invalidatepage(journal_t *journal,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int stop = offset + length;\n\tunsigned int curr_off = 0;\n\tint partial_page = (offset || length < PAGE_CACHE_SIZE);\n\tint may_free = 1;\n\tint ret = 0;\n\n\tif (!PageLocked(page))\n\t\tBUG();\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\t/* We will potentially be playing with lists other than just the\n\t * data lists (especially for journaled data mode), so be\n\t * cautious in our locking. */\n\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\tif (next_off > stop)\n\t\t\treturn 0;\n\n\t\tif (offset <= curr_off) {\n\t\t\t/* This block is wholly outside the truncation point */\n\t\t\tlock_buffer(bh);\n\t\t\tret = journal_unmap_buffer(journal, bh, partial_page);\n\t\t\tunlock_buffer(bh);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tmay_free &= ret;\n\t\t}\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\n\t} while (bh != head);\n\n\tif (!partial_page) {\n\t\tif (may_free && try_to_free_buffers(page))\n\t\t\tJ_ASSERT(!page_has_buffers(page));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_journalled_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "page->mapping->host"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_CACHE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}"
  },
  {
    "function_name": "ext4_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2843-2852",
    "snippet": "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "block_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1509-1555",
          "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_has_buffers(page) && buffer_jbd(page_buffers(page))"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "page_buffers(page)"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}"
  },
  {
    "function_name": "ext4_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2830-2841",
    "snippet": "static int\next4_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* If the file has inline data, no need to do readpages. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn mpage_readpages(mapping, pages, nr_pages, ext4_get_block);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "ext4_get_block"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int\next4_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* If the file has inline data, no need to do readpages. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn mpage_readpages(mapping, pages, nr_pages, ext4_get_block);\n}"
  },
  {
    "function_name": "ext4_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2814-2828",
    "snippet": "static int ext4_readpage(struct file *file, struct page *page)\n{\n\tint ret = -EAGAIN;\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_ext4_readpage(page);\n\n\tif (ext4_has_inline_data(inode))\n\t\tret = ext4_readpage_inline(inode, page);\n\n\tif (ret == -EAGAIN)\n\t\treturn mpage_readpage(page, ext4_get_block);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpage",
          "args": [
            "page",
            "ext4_get_block"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "392-406",
          "snippet": "int mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint mpage_readpage(struct page *page, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tbio = do_mpage_readpage(bio, page, 1, &last_block_in_bio,\n\t\t\t&map_bh, &first_logical_block, get_block);\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_readpage_inline",
          "args": [
            "inode",
            "page"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_readpage_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "492-517",
          "snippet": "int ext4_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret = 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Current inline data can only exist in the 1st page,\n\t * So for all the other pages, just set them uptodate.\n\t */\n\tif (!page->index)\n\t\tret = ext4_read_inline_page(inode, page);\n\telse if (!PageUptodate(page)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tunlock_page(page);\n\treturn ret >= 0 ? 0 : ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_readpage_inline(struct inode *inode, struct page *page)\n{\n\tint ret = 0;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\treturn -EAGAIN;\n\t}\n\n\t/*\n\t * Current inline data can only exist in the 1st page,\n\t * So for all the other pages, just set them uptodate.\n\t */\n\tif (!page->index)\n\t\tret = ext4_read_inline_page(inode, page);\n\telse if (!PageUptodate(page)) {\n\t\tzero_user_segment(page, 0, PAGE_CACHE_SIZE);\n\t\tSetPageUptodate(page);\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tunlock_page(page);\n\treturn ret >= 0 ? 0 : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_readpage",
          "args": [
            "page"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_readpage(struct file *file, struct page *page)\n{\n\tint ret = -EAGAIN;\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_ext4_readpage(page);\n\n\tif (ext4_has_inline_data(inode))\n\t\tret = ext4_readpage_inline(inode, page);\n\n\tif (ret == -EAGAIN)\n\t\treturn mpage_readpage(page, ext4_get_block);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2759-2812",
    "snippet": "static sector_t ext4_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\t/*\n\t * We can get here for an inline file via the FIBMAP ioctl\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) &&\n\t\t\ttest_opt(inode->i_sb, DELALLOC)) {\n\t\t/*\n\t\t * With delalloc we want to sync the file\n\t\t * so that we can make sure we allocate\n\t\t * blocks for file\n\t\t */\n\t\tfilemap_write_and_wait(mapping);\n\t}\n\n\tif (EXT4_JOURNAL(inode) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT4_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text4_clear_inode_state(inode, EXT4_STATE_JDATA);\n\t\tjournal = EXT4_JOURNAL(inode);\n\t\tjbd2_journal_lock_updates(journal);\n\t\terr = jbd2_journal_flush(journal);\n\t\tjbd2_journal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping, block, ext4_get_block);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "ext4_get_block"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_JDATA"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_JDATA"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "mapping"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "DELALLOC"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic sector_t ext4_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\t/*\n\t * We can get here for an inline file via the FIBMAP ioctl\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) &&\n\t\t\ttest_opt(inode->i_sb, DELALLOC)) {\n\t\t/*\n\t\t * With delalloc we want to sync the file\n\t\t * so that we can make sure we allocate\n\t\t * blocks for file\n\t\t */\n\t\tfilemap_write_and_wait(mapping);\n\t}\n\n\tif (EXT4_JOURNAL(inode) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT4_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text4_clear_inode_state(inode, EXT4_STATE_JDATA);\n\t\tjournal = EXT4_JOURNAL(inode);\n\t\tjbd2_journal_lock_updates(journal);\n\t\terr = jbd2_journal_flush(journal);\n\t\tjbd2_journal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping, block, ext4_get_block);\n}"
  },
  {
    "function_name": "ext4_alloc_da_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2704-2743",
    "snippet": "int ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "inode->i_mapping"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_alloc_da_blocks",
          "args": [
            "inode"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}"
  },
  {
    "function_name": "ext4_da_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2683-2699",
    "snippet": "static void ext4_da_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t   unsigned int length)\n{\n\t/*\n\t * Drop reserved blocks\n\t */\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\text4_da_page_release_reservation(page, offset, length);\n\nout:\n\text4_invalidatepage(page, offset, length);\n\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_invalidatepage",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2843-2852",
          "snippet": "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_da_page_release_reservation",
          "args": [
            "page",
            "offset",
            "length"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_page_release_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1245-1292",
          "snippet": "static void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tclear_buffer_delay(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (to_release) {\n\t\tlblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, lblk, to_release);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);",
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tclear_buffer_delay(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (to_release) {\n\t\tlblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, lblk, to_release);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic void ext4_da_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t   unsigned int length)\n{\n\t/*\n\t * Drop reserved blocks\n\t */\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\text4_da_page_release_reservation(page, offset, length);\n\nout:\n\text4_invalidatepage(page, offset, length);\n\n\treturn;\n}"
  },
  {
    "function_name": "ext4_da_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2626-2681",
    "snippet": "static int ext4_da_write_end(struct file *file,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t     struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0, ret2;\n\thandle_t *handle = ext4_journal_current_handle();\n\tloff_t new_i_size;\n\tunsigned long start, end;\n\tint write_mode = (int)(unsigned long)fsdata;\n\n\tif (write_mode == FALL_BACK_TO_NONDELALLOC)\n\t\treturn ext4_write_end(file, mapping, pos,\n\t\t\t\t      len, copied, page, fsdata);\n\n\ttrace_ext4_da_write_end(inode, pos, len, copied);\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\tend = start + copied - 1;\n\n\t/*\n\t * generic_write_end() will run mark_inode_dirty() if i_size\n\t * changes.  So let's piggyback the i_disksize mark_inode_dirty\n\t * into that.\n\t */\n\tnew_i_size = pos + copied;\n\tif (copied && new_i_size > EXT4_I(inode)->i_disksize) {\n\t\tif (ext4_has_inline_data(inode) ||\n\t\t    ext4_da_should_update_i_disksize(page, end)) {\n\t\t\text4_update_i_disksize(inode, new_i_size);\n\t\t\t/* We need to mark inode dirty even if\n\t\t\t * new_i_size is less that inode->i_size\n\t\t\t * bu greater than i_disksize.(hint delalloc)\n\t\t\t */\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\n\tif (write_mode != CONVERT_INLINE_DATA &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA) &&\n\t    ext4_has_inline_data(inode))\n\t\tret2 = ext4_da_write_inline_data_end(inode, pos, len, copied,\n\t\t\t\t\t\t     page);\n\telse\n\t\tret2 = generic_write_end(file, mapping, pos, len, copied,\n\t\t\t\t\t\t\tpage, fsdata);\n\n\tcopied = ret2;\n\tif (ret2 < 0)\n\t\tret = ret2;\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "generic_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2067-2104",
          "snippet": "int generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint i_size_changed = 0;\n\n\tcopied = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_da_write_inline_data_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied",
            "page"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "928-960",
          "snippet": "int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t  unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tint i_size_changed = 0;\n\n\tcopied = ext4_write_inline_data_end(inode, pos, len, copied, page);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,\n\t\t\t\t  unsigned len, unsigned copied,\n\t\t\t\t  struct page *page)\n{\n\tint i_size_changed = 0;\n\n\tcopied = ext4_write_inline_data_end(inode, pos, len, copied, page);\n\n\t/*\n\t * No need to use i_size_read() here, the i_size\n\t * cannot change under us because we hold i_mutex.\n\t *\n\t * But it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\tif (pos+copied > inode->i_size) {\n\t\ti_size_write(inode, pos+copied);\n\t\ti_size_changed = 1;\n\t}\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\tmark_inode_dirty(inode);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_i_disksize",
          "args": [
            "inode",
            "new_i_size"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_should_update_i_disksize",
          "args": [
            "page",
            "end"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_should_update_i_disksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2607-2624",
          "snippet": "static int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1020-1092",
          "snippet": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_da_write_end(struct file *file,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t     struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0, ret2;\n\thandle_t *handle = ext4_journal_current_handle();\n\tloff_t new_i_size;\n\tunsigned long start, end;\n\tint write_mode = (int)(unsigned long)fsdata;\n\n\tif (write_mode == FALL_BACK_TO_NONDELALLOC)\n\t\treturn ext4_write_end(file, mapping, pos,\n\t\t\t\t      len, copied, page, fsdata);\n\n\ttrace_ext4_da_write_end(inode, pos, len, copied);\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\tend = start + copied - 1;\n\n\t/*\n\t * generic_write_end() will run mark_inode_dirty() if i_size\n\t * changes.  So let's piggyback the i_disksize mark_inode_dirty\n\t * into that.\n\t */\n\tnew_i_size = pos + copied;\n\tif (copied && new_i_size > EXT4_I(inode)->i_disksize) {\n\t\tif (ext4_has_inline_data(inode) ||\n\t\t    ext4_da_should_update_i_disksize(page, end)) {\n\t\t\text4_update_i_disksize(inode, new_i_size);\n\t\t\t/* We need to mark inode dirty even if\n\t\t\t * new_i_size is less that inode->i_size\n\t\t\t * bu greater than i_disksize.(hint delalloc)\n\t\t\t */\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\n\tif (write_mode != CONVERT_INLINE_DATA &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA) &&\n\t    ext4_has_inline_data(inode))\n\t\tret2 = ext4_da_write_inline_data_end(inode, pos, len, copied,\n\t\t\t\t\t\t     page);\n\telse\n\t\tret2 = generic_write_end(file, mapping, pos, len, copied,\n\t\t\t\t\t\t\tpage, fsdata);\n\n\tcopied = ret2;\n\tif (ret2 < 0)\n\t\tret = ret2;\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "ext4_da_should_update_i_disksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2607-2624",
    "snippet": "static int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_da_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2511-2601",
    "snippet": "static int ext4_da_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t       loff_t pos, unsigned len, unsigned flags,\n\t\t\t       struct page **pagep, void **fsdata)\n{\n\tint ret, retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct inode *inode = mapping->host;\n\thandle_t *handle;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\n\tif (ext4_nonda_switch(inode->i_sb)) {\n\t\t*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;\n\t\treturn ext4_write_begin(file, mapping, pos,\n\t\t\t\t\tlen, flags, pagep, fsdata);\n\t}\n\t*fsdata = (void *)0;\n\ttrace_ext4_da_write_begin(inode, pos, len, flags);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_da_write_inline_data_begin(mapping, inode,\n\t\t\t\t\t\t      pos, len, flags,\n\t\t\t\t\t\t      pagep, fsdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\n\t/*\n\t * With delayed allocation, we don't log the i_disksize update\n\t * if there is delayed block allocation. But we still need\n\t * to journalling the i_disksize update if writes to the end\n\t * of file which has an already mapped buffer.\n\t */\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_da_write_credits(inode, pos, len));\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);\n\tif (ret < 0) {\n\t\tunlock_page(page);\n\t\text4_journal_stop(handle);\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t */\n\t\tif (pos + len > inode->i_size)\n\t\t\text4_truncate_failed_write(inode);\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\n\t*pagep = page;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 2589
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "ext4_da_get_block_prep"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "ext4_da_write_credits(inode, pos, len)"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_da_write_credits",
          "args": [
            "inode",
            "pos",
            "len"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_write_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2498-2509",
          "snippet": "static int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_write_inline_data_begin",
          "args": [
            "mapping",
            "inode",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_write_inline_data_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "843-926",
          "snippet": "int ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    unsigned flags,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\text4_journal_stop(handle);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_da_write_inline_data_begin(struct address_space *mapping,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    loff_t pos, unsigned len,\n\t\t\t\t    unsigned flags,\n\t\t\t\t    struct page **pagep,\n\t\t\t\t    void **fsdata)\n{\n\tint ret, inline_size;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\tint retries;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_max_inline_size(inode);\n\n\tret = -ENOSPC;\n\tif (inline_size >= pos + len) {\n\t\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\t\tif (ret && ret != -ENOSPC)\n\t\t\tgoto out_journal;\n\t}\n\n\t/*\n\t * We cannot recurse into the filesystem as the transaction\n\t * is already started.\n\t */\n\tflags |= AOP_FLAG_NOFS;\n\n\tif (ret == -ENOSPC) {\n\t\tret = ext4_da_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t\t    inode,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    fsdata);\n\t\text4_journal_stop(handle);\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tgoto out;\n\t}\n\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_journal;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tgoto out_release_page;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_release_page;\n\t}\n\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\t*pagep = page;\n\tbrelse(iloc.bh);\n\treturn 1;\nout_release_page:\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_journal:\n\text4_journal_stop(handle);\nout:\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_write_begin",
          "args": [
            "inode",
            "pos",
            "len",
            "flags"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_begin",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "fsdata"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "891-998",
          "snippet": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_nonda_switch",
          "args": [
            "inode->i_sb"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_nonda_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2463-2495",
          "snippet": "static int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_da_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t       loff_t pos, unsigned len, unsigned flags,\n\t\t\t       struct page **pagep, void **fsdata)\n{\n\tint ret, retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct inode *inode = mapping->host;\n\thandle_t *handle;\n\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\n\tif (ext4_nonda_switch(inode->i_sb)) {\n\t\t*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;\n\t\treturn ext4_write_begin(file, mapping, pos,\n\t\t\t\t\tlen, flags, pagep, fsdata);\n\t}\n\t*fsdata = (void *)0;\n\ttrace_ext4_da_write_begin(inode, pos, len, flags);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_da_write_inline_data_begin(mapping, inode,\n\t\t\t\t\t\t      pos, len, flags,\n\t\t\t\t\t\t      pagep, fsdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\n\t/*\n\t * With delayed allocation, we don't log the i_disksize update\n\t * if there is delayed block allocation. But we still need\n\t * to journalling the i_disksize update if writes to the end\n\t * of file which has an already mapped buffer.\n\t */\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_da_write_credits(inode, pos, len));\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);\n\tif (ret < 0) {\n\t\tunlock_page(page);\n\t\text4_journal_stop(handle);\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t */\n\t\tif (pos + len > inode->i_size)\n\t\t\text4_truncate_failed_write(inode);\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\n\t*pagep = page;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_da_write_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2498-2509",
    "snippet": "static int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE)"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_RO_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_RO_COMPAT_LARGE_FILE"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_LARGE_FILE)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}"
  },
  {
    "function_name": "ext4_nonda_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2463-2495",
    "snippet": "static int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_writeback_inodes_sb",
          "args": [
            "sb",
            "WB_REASON_FS_FREE_SPACE"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_writeback_inodes_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1421-1424",
          "snippet": "int try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn try_to_writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn try_to_writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2274-2461",
    "snippet": "static int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_CACHE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_writepages_result",
          "args": [
            "inode",
            "wbc",
            "ret",
            "nr_to_write - wbc->nr_to_write"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_force_commit_nested",
          "args": [
            "sbi->s_journal"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_force_commit_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "595-601",
          "snippet": "int jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_put_io_end",
          "args": [
            "mpd.io_submit.io_end"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_put_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "274-289",
          "snippet": "int ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_put_io_end(ext4_io_end_t *io_end)\n{\n\tint err = 0;\n\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (io_end->flag & EXT4_IO_END_UNWRITTEN) {\n\t\t\terr = ext4_convert_unwritten_extents(io_end->handle,\n\t\t\t\t\t\tio_end->inode, io_end->offset,\n\t\t\t\t\t\tio_end->size);\n\t\t\tio_end->handle = NULL;\n\t\t\text4_clear_io_unwritten_flag(io_end);\n\t\t}\n\t\text4_release_io_end(io_end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_release_unused_pages",
          "args": [
            "&mpd",
            "give_up_on_write"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_release_unused_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1314-1356",
          "snippet": "static void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_io_submit",
          "args": [
            "&mpd.io_submit"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_io_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "340-351",
          "snippet": "void ext4_io_submit(struct ext4_io_submit *io)\n{\n\tstruct bio *bio = io->io_bio;\n\n\tif (bio) {\n\t\tbio_get(io->io_bio);\n\t\tsubmit_bio(io->io_op, io->io_bio);\n\t\tBUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));\n\t\tbio_put(io->io_bio);\n\t}\n\tio->io_bio = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_io_submit(struct ext4_io_submit *io)\n{\n\tstruct bio *bio = io->io_bio;\n\n\tif (bio) {\n\t\tbio_get(io->io_bio);\n\t\tsubmit_bio(io->io_op, io->io_bio);\n\t\tBUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));\n\t\tbio_put(io->io_bio);\n\t}\n\tio->io_bio = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_map_and_submit_extent",
          "args": [
            "handle",
            "&mpd",
            "&give_up_on_write"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_map_and_submit_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2051-2133",
          "snippet": "static int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_CACHE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_CACHE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_prepare_extent_to_map",
          "args": [
            "&mpd"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_prepare_extent_to_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2168-2263",
          "snippet": "static int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_CACHE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_CACHE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_write_pages",
          "args": [
            "inode",
            "mpd.first_page",
            "mpd.wbc"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "inode->i_sb",
            "KERN_CRIT",
            "\"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\"",
            "__func__",
            "wbc->nr_to_write",
            "inode->i_ino",
            "ret"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start_with_reserve",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "needed_blocks",
            "rsv_blocks"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_writepages_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_writepages_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2142-2148",
          "snippet": "static int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_WRITEPAGES_EXTENT_LEN 2048"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n\nstatic int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext4_should_journal_data(inode)"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_init_io_end",
          "args": [
            "inode",
            "GFP_KERNEL"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "251-261",
          "snippet": "ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\next4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "mpd.first_page",
            "mpd.last_page"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_io_submit_init",
          "args": [
            "&mpd.io_submit",
            "wbc"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_io_submit_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "353-359",
          "snippet": "void ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t struct writeback_control *wbc)\n{\n\tio->io_op = (wbc->sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);\n\tio->io_bio = NULL;\n\tio->io_end = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t struct writeback_control *wbc)\n{\n\tio->io_op = (wbc->sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);\n\tio->io_bio = NULL;\n\tio->io_end = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_destroy_inline_data",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_destroy_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1801-1810",
          "snippet": "int ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_destroy_inline_data(handle_t *handle, struct inode *inode)\n{\n\tint ret;\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tret = ext4_destroy_inline_data_nolock(handle, inode);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA)"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_INODE",
            "1"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbi->s_mount_flags & EXT4_MF_FS_ABORTED"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "__writepage",
            "mapping"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_writepages",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "mapping->host->i_sb"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstatic int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_CACHE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "__writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2265-2272",
    "snippet": "static int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = ext4_writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "ret"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_writepage",
          "args": [
            "page",
            "wbc"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "2274-2461",
          "snippet": "static int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_CACHE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstatic int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_CACHE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = ext4_writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "mpage_prepare_extent_to_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2168-2263",
    "snippet": "static int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_CACHE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_process_page_bufs",
          "args": [
            "mpd",
            "head",
            "head",
            "lblk"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_process_page_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1849-1877",
          "snippet": "static int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "tag",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_CACHE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_da_writepages_trans_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2142-2148",
    "snippet": "static int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_WRITEPAGES_EXTENT_LEN 2048"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_meta_trans_blocks",
          "args": [
            "inode",
            "MAX_WRITEPAGES_EXTENT_LEN + bpp - 1",
            "bpp"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_meta_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4723-4757",
          "snippet": "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_blocks_per_page",
          "args": [
            "inode"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_blocks_per_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "350-355",
          "snippet": "static inline int ext4_journal_blocks_per_page(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) != NULL)\n\t\treturn jbd2_journal_blocks_per_page(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_blocks_per_page(struct inode *inode)\n{\n\tif (EXT4_JOURNAL(inode) != NULL)\n\t\treturn jbd2_journal_blocks_per_page(inode);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n\nstatic int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}"
  },
  {
    "function_name": "mpage_map_and_submit_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "2051-2133",
    "snippet": "static int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_CACHE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "inode->i_sb",
            "\"Failed to mark inode %lu dirty\"",
            "inode->i_ino"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_map_and_submit_buffers",
          "args": [
            "mpd"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_map_and_submit_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1893-1975",
          "snippet": "static int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_CACHE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_CACHE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_CACHE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_CACHE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_print_free_blocks",
          "args": [
            "inode"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_print_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1358-1378",
          "snippet": "static void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\""
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_count_free_clusters",
          "args": [
            "sb"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "658-717",
          "snippet": "ext4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_map_one_extent",
          "args": [
            "handle",
            "mpd"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_map_one_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1977-2029",
          "snippet": "static int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_CACHE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "mpage_map_one_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1977-2029",
    "snippet": "static int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bdev",
            "map->m_pblk + i"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "map->m_len == 0"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_io_unwritten_flag",
          "args": [
            "inode",
            "mpd->io_submit.io_end"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_io_unwritten_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1383-1390",
          "snippet": "static inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define\tEXT4_IO_END_UNWRITTEN\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define\tEXT4_IO_END_UNWRITTEN\t0x0001\n\nstatic inline void ext4_set_io_unwritten_flag(struct inode *inode,\n\t\t\t\t\t      struct ext4_io_end *io_end)\n{\n\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {\n\t\tio_end->flag |= EXT4_IO_END_UNWRITTEN;\n\t\tatomic_inc(&EXT4_I(inode)->i_unwritten);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "handle",
            "inode",
            "map",
            "get_blocks_flags"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_write_pages_extent",
          "args": [
            "inode",
            "map"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mpage_map_and_submit_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1893-1975",
    "snippet": "static int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_CACHE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_CACHE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_submit_page",
          "args": [
            "mpd",
            "page"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_submit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1755-1773",
          "snippet": "static int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpage_process_page_bufs",
          "args": [
            "mpd",
            "head",
            "bh",
            "lblk"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_process_page_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1849-1877",
          "snippet": "static int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1923
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->index != start"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "inode->i_mapping",
            "start",
            "PAGEVEC_SIZE"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_CACHE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_CACHE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "mpage_process_page_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1849-1877",
    "snippet": "static int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_submit_page",
          "args": [
            "mpd",
            "head->b_page"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_submit_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1755-1773",
          "snippet": "static int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpage_add_bh_to_extent",
          "args": [
            "mpd",
            "lblk",
            "bh"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_add_bh_to_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1798-1831",
          "snippet": "static bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define MAX_WRITEPAGES_EXTENT_LEN 2048",
            "#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))"
          ],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_locked(bh)"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}"
  },
  {
    "function_name": "mpage_add_bh_to_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1798-1831",
    "snippet": "static bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MAX_WRITEPAGES_EXTENT_LEN 2048",
      "#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))"
    ],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "mpage_submit_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1755-1773",
    "snippet": "static int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_bio_write_page",
          "args": [
            "&mpd->io_submit",
            "page",
            "len",
            "mpd->wbc",
            "false"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bio_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "401-497",
          "snippet": "int ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\tstruct page *page,\n\t\t\tint len,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tbool keep_towrite)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, blocksize;\n\tstruct buffer_head *bh, *head;\n\tint ret = 0;\n\tint nr_submitted = 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (keep_towrite)\n\t\tset_page_writeback_keepwrite(page);\n\telse\n\t\tset_page_writeback(page);\n\tClearPageError(page);\n\n\t/*\n\t * Comments copied from block_write_full_page:\n\t *\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t/*\n\t * In the first loop we prepare and mark buffers to submit. We have to\n\t * mark all buffers in the page before submitting so that\n\t * end_page_writeback() cannot be called from ext4_bio_end_io() when IO\n\t * on the first buffer finishes and we are still working on submitting\n\t * the second buffer.\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_start = bh_offset(bh);\n\t\tif (block_start >= len) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_dirty(bh) || buffer_delay(bh) ||\n\t\t    !buffer_mapped(bh) || buffer_unwritten(bh)) {\n\t\t\t/* A hole? We can safely clear the dirty bit */\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\tif (io->io_bio)\n\t\t\t\text4_io_submit(io);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh)) {\n\t\t\tclear_buffer_new(bh);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\t\tset_buffer_async_write(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Now submit buffers to write */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (!buffer_async_write(bh))\n\t\t\tcontinue;\n\t\tret = io_submit_add_bh(io, inode, bh);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We only get here on ENOMEM.  Not much else\n\t\t\t * we can do but mark the page as dirty, and\n\t\t\t * better luck next time.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tbreak;\n\t\t}\n\t\tnr_submitted++;\n\t\tclear_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Error stopped previous loop? Clean up buffers... */\n\tif (ret) {\n\t\tdo {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tunlock_page(page);\n\t/* Nothing submitted - we have to end page writeback */\n\tif (!nr_submitted)\n\t\tend_page_writeback(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\tstruct page *page,\n\t\t\tint len,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tbool keep_towrite)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, blocksize;\n\tstruct buffer_head *bh, *head;\n\tint ret = 0;\n\tint nr_submitted = 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (keep_towrite)\n\t\tset_page_writeback_keepwrite(page);\n\telse\n\t\tset_page_writeback(page);\n\tClearPageError(page);\n\n\t/*\n\t * Comments copied from block_write_full_page:\n\t *\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t/*\n\t * In the first loop we prepare and mark buffers to submit. We have to\n\t * mark all buffers in the page before submitting so that\n\t * end_page_writeback() cannot be called from ext4_bio_end_io() when IO\n\t * on the first buffer finishes and we are still working on submitting\n\t * the second buffer.\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_start = bh_offset(bh);\n\t\tif (block_start >= len) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_dirty(bh) || buffer_delay(bh) ||\n\t\t    !buffer_mapped(bh) || buffer_unwritten(bh)) {\n\t\t\t/* A hole? We can safely clear the dirty bit */\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\tif (io->io_bio)\n\t\t\t\text4_io_submit(io);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh)) {\n\t\t\tclear_buffer_new(bh);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\t\tset_buffer_async_write(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Now submit buffers to write */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (!buffer_async_write(bh))\n\t\t\tcontinue;\n\t\tret = io_submit_add_bh(io, inode, bh);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We only get here on ENOMEM.  Not much else\n\t\t\t * we can do but mark the page as dirty, and\n\t\t\t * better luck next time.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tbreak;\n\t\t}\n\t\tnr_submitted++;\n\t\tclear_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Error stopped previous loop? Clean up buffers... */\n\tif (ret) {\n\t\tdo {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tunlock_page(page);\n\t/* Nothing submitted - we have to end page writeback */\n\tif (!nr_submitted)\n\t\tend_page_writeback(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->index != mpd->first_page"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mpd->inode"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1691-1753",
    "snippet": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs = NULL;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_io_submit io_submit;\n\tbool keep_towrite = false;\n\n\ttrace_ext4_writepage(page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tpage_bufs = page_buffers(page);\n\t/*\n\t * We cannot do block allocation or other extent handling in this\n\t * function. If there are buffers needing that, we have to redirty\n\t * the page. But we may reach here when we do a journal commit via\n\t * journal_submit_inode_data_buffers() and in that case we must write\n\t * allocated buffers to achieve data=ordered mode guarantees.\n\t */\n\tif (ext4_walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t   ext4_bh_delay_or_unwritten)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tif (current->flags & PF_MEMALLOC) {\n\t\t\t/*\n\t\t\t * For memory cleaning there's no point in writing only\n\t\t\t * some buffers. So just bail out. Warn if we came here\n\t\t\t * from direct reclaim.\n\t\t\t */\n\t\t\tWARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))\n\t\t\t\t\t\t\t== PF_MEMALLOC);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tkeep_towrite = true;\n\t}\n\n\tif (PageChecked(page) && ext4_should_journal_data(inode))\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\treturn __ext4_journalled_writepage(page, len);\n\n\text4_io_submit_init(&io_submit, wbc);\n\tio_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);\n\tif (!io_submit.io_end) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn -ENOMEM;\n\t}\n\tret = ext4_bio_write_page(&io_submit, page, len, wbc, keep_towrite);\n\text4_io_submit(&io_submit);\n\t/* Drop io_end reference we got from init */\n\text4_put_io_end_defer(io_submit.io_end);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_put_io_end_defer",
          "args": [
            "io_submit.io_end"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_put_io_end_defer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "263-272",
          "snippet": "void ext4_put_io_end_defer(ext4_io_end_t *io_end)\n{\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN) || !io_end->size) {\n\t\t\text4_release_io_end(io_end);\n\t\t\treturn;\n\t\t}\n\t\text4_add_complete_io(io_end);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_put_io_end_defer(ext4_io_end_t *io_end)\n{\n\tif (atomic_dec_and_test(&io_end->count)) {\n\t\tif (!(io_end->flag & EXT4_IO_END_UNWRITTEN) || !io_end->size) {\n\t\t\text4_release_io_end(io_end);\n\t\t\treturn;\n\t\t}\n\t\text4_add_complete_io(io_end);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_io_submit",
          "args": [
            "&io_submit"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_io_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "340-351",
          "snippet": "void ext4_io_submit(struct ext4_io_submit *io)\n{\n\tstruct bio *bio = io->io_bio;\n\n\tif (bio) {\n\t\tbio_get(io->io_bio);\n\t\tsubmit_bio(io->io_op, io->io_bio);\n\t\tBUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));\n\t\tbio_put(io->io_bio);\n\t}\n\tio->io_bio = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_io_submit(struct ext4_io_submit *io)\n{\n\tstruct bio *bio = io->io_bio;\n\n\tif (bio) {\n\t\tbio_get(io->io_bio);\n\t\tsubmit_bio(io->io_op, io->io_bio);\n\t\tBUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));\n\t\tbio_put(io->io_bio);\n\t}\n\tio->io_bio = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_bio_write_page",
          "args": [
            "&io_submit",
            "page",
            "len",
            "wbc",
            "keep_towrite"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bio_write_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "401-497",
          "snippet": "int ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\tstruct page *page,\n\t\t\tint len,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tbool keep_towrite)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, blocksize;\n\tstruct buffer_head *bh, *head;\n\tint ret = 0;\n\tint nr_submitted = 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (keep_towrite)\n\t\tset_page_writeback_keepwrite(page);\n\telse\n\t\tset_page_writeback(page);\n\tClearPageError(page);\n\n\t/*\n\t * Comments copied from block_write_full_page:\n\t *\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t/*\n\t * In the first loop we prepare and mark buffers to submit. We have to\n\t * mark all buffers in the page before submitting so that\n\t * end_page_writeback() cannot be called from ext4_bio_end_io() when IO\n\t * on the first buffer finishes and we are still working on submitting\n\t * the second buffer.\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_start = bh_offset(bh);\n\t\tif (block_start >= len) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_dirty(bh) || buffer_delay(bh) ||\n\t\t    !buffer_mapped(bh) || buffer_unwritten(bh)) {\n\t\t\t/* A hole? We can safely clear the dirty bit */\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\tif (io->io_bio)\n\t\t\t\text4_io_submit(io);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh)) {\n\t\t\tclear_buffer_new(bh);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\t\tset_buffer_async_write(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Now submit buffers to write */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (!buffer_async_write(bh))\n\t\t\tcontinue;\n\t\tret = io_submit_add_bh(io, inode, bh);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We only get here on ENOMEM.  Not much else\n\t\t\t * we can do but mark the page as dirty, and\n\t\t\t * better luck next time.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tbreak;\n\t\t}\n\t\tnr_submitted++;\n\t\tclear_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Error stopped previous loop? Clean up buffers... */\n\tif (ret) {\n\t\tdo {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tunlock_page(page);\n\t/* Nothing submitted - we have to end page writeback */\n\tif (!nr_submitted)\n\t\tend_page_writeback(page);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_bio_write_page(struct ext4_io_submit *io,\n\t\t\tstruct page *page,\n\t\t\tint len,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tbool keep_towrite)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, blocksize;\n\tstruct buffer_head *bh, *head;\n\tint ret = 0;\n\tint nr_submitted = 0;\n\n\tblocksize = 1 << inode->i_blkbits;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\n\tif (keep_towrite)\n\t\tset_page_writeback_keepwrite(page);\n\telse\n\t\tset_page_writeback(page);\n\tClearPageError(page);\n\n\t/*\n\t * Comments copied from block_write_full_page:\n\t *\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tif (len < PAGE_CACHE_SIZE)\n\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t/*\n\t * In the first loop we prepare and mark buffers to submit. We have to\n\t * mark all buffers in the page before submitting so that\n\t * end_page_writeback() cannot be called from ext4_bio_end_io() when IO\n\t * on the first buffer finishes and we are still working on submitting\n\t * the second buffer.\n\t */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_start = bh_offset(bh);\n\t\tif (block_start >= len) {\n\t\t\tclear_buffer_dirty(bh);\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_dirty(bh) || buffer_delay(bh) ||\n\t\t    !buffer_mapped(bh) || buffer_unwritten(bh)) {\n\t\t\t/* A hole? We can safely clear the dirty bit */\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\tif (io->io_bio)\n\t\t\t\text4_io_submit(io);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh)) {\n\t\t\tclear_buffer_new(bh);\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t}\n\t\tset_buffer_async_write(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Now submit buffers to write */\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tif (!buffer_async_write(bh))\n\t\t\tcontinue;\n\t\tret = io_submit_add_bh(io, inode, bh);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * We only get here on ENOMEM.  Not much else\n\t\t\t * we can do but mark the page as dirty, and\n\t\t\t * better luck next time.\n\t\t\t */\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tbreak;\n\t\t}\n\t\tnr_submitted++;\n\t\tclear_buffer_dirty(bh);\n\t} while ((bh = bh->b_this_page) != head);\n\n\t/* Error stopped previous loop? Clean up buffers... */\n\tif (ret) {\n\t\tdo {\n\t\t\tclear_buffer_async_write(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tunlock_page(page);\n\t/* Nothing submitted - we have to end page writeback */\n\tif (!nr_submitted)\n\t\tend_page_writeback(page);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_init_io_end",
          "args": [
            "inode",
            "GFP_NOFS"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_init_io_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "251-261",
          "snippet": "ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *io_end_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *io_end_cachep;\n\next4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = kmem_cache_zalloc(io_end_cachep, flags);\n\tif (io) {\n\t\tatomic_inc(&EXT4_I(inode)->i_ioend_count);\n\t\tio->inode = inode;\n\t\tINIT_LIST_HEAD(&io->list);\n\t\tatomic_set(&io->count, 1);\n\t}\n\treturn io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_io_submit_init",
          "args": [
            "&io_submit",
            "wbc"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_io_submit_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/page-io.c",
          "lines": "353-359",
          "snippet": "void ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t struct writeback_control *wbc)\n{\n\tio->io_op = (wbc->sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);\n\tio->io_bio = NULL;\n\tio->io_end = NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/ratelimit.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_io_submit_init(struct ext4_io_submit *io,\n\t\t\t struct writeback_control *wbc)\n{\n\tio->io_op = (wbc->sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);\n\tio->io_bio = NULL;\n\tio->io_end = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ext4_journalled_writepage",
          "args": [
            "page",
            "len"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journalled_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1580-1648",
          "snippet": "static int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/* As soon as we unlock the page, it can go away, but we have\n\t * references to buffers so we are safe */\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tbrelse(inode_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/* As soon as we unlock the page, it can go away, but we have\n\t * references to buffers so we are safe */\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tbrelse(inode_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(current->flags & (PF_MEMALLOC|PF_KSWAPD))\n\t\t\t\t\t\t\t== PF_MEMALLOC"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "NULL",
            "page_bufs",
            "0",
            "len",
            "NULL",
            "ext4_bh_delay_or_unwritten"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_writepage",
          "args": [
            "page"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs = NULL;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_io_submit io_submit;\n\tbool keep_towrite = false;\n\n\ttrace_ext4_writepage(page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\n\tpage_bufs = page_buffers(page);\n\t/*\n\t * We cannot do block allocation or other extent handling in this\n\t * function. If there are buffers needing that, we have to redirty\n\t * the page. But we may reach here when we do a journal commit via\n\t * journal_submit_inode_data_buffers() and in that case we must write\n\t * allocated buffers to achieve data=ordered mode guarantees.\n\t */\n\tif (ext4_walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t   ext4_bh_delay_or_unwritten)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tif (current->flags & PF_MEMALLOC) {\n\t\t\t/*\n\t\t\t * For memory cleaning there's no point in writing only\n\t\t\t * some buffers. So just bail out. Warn if we came here\n\t\t\t * from direct reclaim.\n\t\t\t */\n\t\t\tWARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))\n\t\t\t\t\t\t\t== PF_MEMALLOC);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tkeep_towrite = true;\n\t}\n\n\tif (PageChecked(page) && ext4_should_journal_data(inode))\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\treturn __ext4_journalled_writepage(page, len);\n\n\text4_io_submit_init(&io_submit, wbc);\n\tio_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);\n\tif (!io_submit.io_end) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn -ENOMEM;\n\t}\n\tret = ext4_bio_write_page(&io_submit, page, len, wbc, keep_towrite);\n\text4_io_submit(&io_submit);\n\t/* Drop io_end reference we got from init */\n\text4_put_io_end_defer(io_submit.io_end);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ext4_journalled_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1580-1648",
    "snippet": "static int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/* As soon as we unlock the page, it can go away, but we have\n\t * references to buffers so we are safe */\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tbrelse(inode_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "inode_bh"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_JDATA"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "NULL",
            "page_bufs",
            "0",
            "len",
            "NULL",
            "bput_one"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "inode_bh"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "inode_bh"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "inode_bh",
            "\"get write access\""
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_handle_valid(handle)"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "ext4_writepage_trans_blocks(inode)"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journalled_write_inline_data",
          "args": [
            "inode",
            "len",
            "page"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journalled_write_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "752-774",
          "snippet": "struct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\treturn NULL;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, 0, len);\n\tkunmap_atomic(kaddr);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn iloc.bh;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nstruct buffer_head *\next4_journalled_write_inline_data(struct inode *inode,\n\t\t\t\t  unsigned len,\n\t\t\t\t  struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\treturn NULL;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, 0, len);\n\tkunmap_atomic(kaddr);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\n\treturn iloc.bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > ext4_get_max_inline_size(inode)"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_max_inline_size",
          "args": [
            "inode"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_max_inline_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "95-121",
          "snippet": "int ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_MIN_INLINE_DATA_SIZE\t((sizeof(__le32) * EXT4_N_BLOCKS))\n\nint ext4_get_max_inline_size(struct inode *inode)\n{\n\tint error, max_inline_size;\n\tstruct ext4_iloc iloc;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error) {\n\t\text4_error_inode(inode, __func__, __LINE__, 0,\n\t\t\t\t \"can't get inode location %lu\",\n\t\t\t\t inode->i_ino);\n\t\treturn 0;\n\t}\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tmax_inline_size = get_max_inline_xattr_value_size(inode, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\n\tbrelse(iloc.bh);\n\n\tif (!max_inline_size)\n\t\treturn 0;\n\n\treturn max_inline_size + EXT4_MIN_INLINE_DATA_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->index != 0"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "page"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/* As soon as we unlock the page, it can go away, but we have\n\t * references to buffers so we are safe */\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tbrelse(inode_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "bput_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1574-1578",
    "snippet": "static int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "bget_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1568-1572",
    "snippet": "static int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_da_get_block_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1531-1566",
    "snippet": "int ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tBUG_ON(create == 0);\n\tBUG_ON(bh->b_size != inode->i_sb->s_blocksize);\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = 1;\n\n\t/*\n\t * first, we need to know whether the block is allocated already\n\t * preallocated blocks are unmapped but should treated\n\t * the same as allocated blocks.\n\t */\n\tret = ext4_da_map_blocks(inode, iblock, &map, bh);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\n\tif (buffer_unwritten(bh)) {\n\t\t/* A delayed write to unwritten bh should be marked\n\t\t * new and mapped.  Mapped ensures that we don't do\n\t\t * get_block multiple times when we write to the same\n\t\t * offset and new ensures that we do proper zero out\n\t\t * for partial write.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_mapped(bh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "map.m_pblk"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_map_blocks",
          "args": [
            "inode",
            "iblock",
            "&map",
            "bh"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1391-1517",
          "snippet": "static int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio <= 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode, iblock);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio <= 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode, iblock);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh->b_size != inode->i_sb->s_blocksize"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "create == 0"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tBUG_ON(create == 0);\n\tBUG_ON(bh->b_size != inode->i_sb->s_blocksize);\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = 1;\n\n\t/*\n\t * first, we need to know whether the block is allocated already\n\t * preallocated blocks are unmapped but should treated\n\t * the same as allocated blocks.\n\t */\n\tret = ext4_da_map_blocks(inode, iblock, &map, bh);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\n\tif (buffer_unwritten(bh)) {\n\t\t/* A delayed write to unwritten bh should be marked\n\t\t * new and mapped.  Mapped ensures that we don't do\n\t\t * get_block multiple times when we write to the same\n\t\t * offset and new ensures that we do proper zero out\n\t\t * for partial write.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_mapped(bh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_da_map_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1391-1517",
    "snippet": "static int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio <= 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode, iblock);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_insert_extent",
          "args": [
            "inode",
            "map->m_lblk",
            "map->m_len",
            "map->m_pblk",
            "status"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "692-733",
          "snippet": "int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\"",
            "inode->i_ino",
            "retval",
            "map->m_len"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != map->m_len"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "invalid_block"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_reserve_space",
          "args": [
            "inode",
            "iblock"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_reserve_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1170-1208",
          "snippet": "static int ext4_da_reserve_space(struct inode *inode, ext4_lblk_t lblock)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int md_needed;\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * recalculate the amount of metadata blocks to reserve\n\t * in order to allocate nrblocks\n\t * worse case is one extent per block\n\t */\n\tspin_lock(&ei->i_block_reservation_lock);\n\t/*\n\t * ext4_calc_metadata_amount() has side effects, which we have\n\t * to be prepared undo if we fail to claim space.\n\t */\n\tmd_needed = 0;\n\ttrace_ext4_da_reserve_space(inode, 0);\n\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_da_reserve_space(struct inode *inode, ext4_lblk_t lblock)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int md_needed;\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * recalculate the amount of metadata blocks to reserve\n\t * in order to allocate nrblocks\n\t * worse case is one extent per block\n\t */\n\tspin_lock(&ei->i_block_reservation_lock);\n\t/*\n\t * ext4_calc_metadata_amount() has side effects, which we have\n\t * to be prepared undo if we fail to claim space.\n\t */\n\tmd_needed = 0;\n\ttrace_ext4_da_reserve_space(inode, 0);\n\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_delalloc_cluster",
          "args": [
            "inode",
            "map->m_lblk"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_delalloc_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3848-3856",
          "snippet": "int ext4_find_delalloc_cluster(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t lblk_start, lblk_end;\n\tlblk_start = EXT4_LBLK_CMASK(sbi, lblk);\n\tlblk_end = lblk_start + sbi->s_cluster_ratio - 1;\n\n\treturn ext4_find_delalloc_range(inode, lblk_start, lblk_end);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_find_delalloc_cluster(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t lblk_start, lblk_end;\n\tlblk_start = EXT4_LBLK_CMASK(sbi, lblk);\n\tlblk_end = lblk_start + sbi->s_cluster_ratio - 1;\n\n\treturn ext4_find_delalloc_range(inode, lblk_start, lblk_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ind_map_blocks",
          "args": [
            "NULL",
            "inode",
            "map",
            "0"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "513-632",
          "snippet": "int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_map_blocks",
          "args": [
            "NULL",
            "inode",
            "map",
            "0"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4273-4636",
          "snippet": "int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nint ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks_es_recheck",
          "args": [
            "NULL",
            "inode",
            "map",
            "&orig_map",
            "0"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks_es_recheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "392-435",
          "snippet": "static void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "&es"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "&es"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "&es"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "invalid_block"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "&es"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_hole",
          "args": [
            "&es"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "123-126",
          "snippet": "static inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_lookup_extent",
          "args": [
            "inode",
            "iblock",
            "&es"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_lookup_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "773-831",
          "snippet": "int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nint ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext_debug",
          "args": [
            "\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\"",
            "inode->i_ino",
            "map->m_len",
            "(unsigned long) map->m_lblk"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "EXT4_SB(inode->i_sb)->s_es"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&orig_map",
            "map",
            "sizeof(*map)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio <= 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode, iblock);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_bh_delay_or_unwritten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1380-1383",
    "snippet": "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh)\n{\n\treturn (buffer_delay(bh) || buffer_unwritten(bh)) && buffer_dirty(bh);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh)\n{\n\treturn (buffer_delay(bh) || buffer_unwritten(bh)) && buffer_dirty(bh);\n}"
  },
  {
    "function_name": "ext4_print_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1358-1378",
    "snippet": "static void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"i_reserved_data_blocks=%u\"",
            "ei->i_reserved_data_blocks"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "percpu_counter_sum(&sbi->s_dirtyclusters_counter)"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&sbi->s_dirtyclusters_counter"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "percpu_counter_sum(&sbi->s_freeclusters_counter)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sum",
          "args": [
            "&sbi->s_freeclusters_counter"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "ext4_count_free_clusters(sb)"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_count_free_clusters",
          "args": [
            "sb"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_count_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "658-717",
          "snippet": "ext4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_count_free_clusters(struct super_block *sb)\n{\n\text4_fsblk_t desc_count;\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_info *grp;\n#ifdef EXT4FS_DEBUG\n\tstruct ext4_super_block *es;\n\text4_fsblk_t bitmap_count;\n\tunsigned int x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT4_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext4_count_free(bitmap_bh->b_data,\n\t\t\t\t    EXT4_CLUSTERS_PER_GROUP(sb) / 8);\n\t\tprintk(KERN_DEBUG \"group %u: stored = %d, counted = %u\\n\",\n\t\t\ti, ext4_free_group_clusters(sb, gdp), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(KERN_DEBUG \"ext4_count_free_clusters: stored = %llu\"\n\t       \", computed = %llu, %llu\\n\",\n\t       EXT4_NUM_B2C(EXT4_SB(sb), ext4_free_blocks_count(es)),\n\t       desc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tgrp = NULL;\n\t\tif (EXT4_SB(sb)->s_group_info)\n\t\t\tgrp = ext4_get_group_info(sb, i);\n\t\tif (!grp || !EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tdesc_count += ext4_free_group_clusters(sb, gdp);\n\t}\n\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}"
  },
  {
    "function_name": "mpage_release_unused_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1314-1356",
    "snippet": "static void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "block_invalidatepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1509-1555",
          "snippet": "void block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid block_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t  unsigned int length)\n{\n\tstruct buffer_head *head, *bh, *next;\n\tunsigned int curr_off = 0;\n\tunsigned int stop = length + offset;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\t/*\n\t * Check for overflow\n\t */\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\t\tnext = bh->b_this_page;\n\n\t\t/*\n\t\t * Are we still fully in range ?\n\t\t */\n\t\tif (next_off > stop)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * is this block fully invalidated?\n\t\t */\n\t\tif (offset <= curr_off)\n\t\t\tdiscard_buffer(bh);\n\t\tcurr_off = next_off;\n\t\tbh = next;\n\t} while (bh != head);\n\n\t/*\n\t * We release buffers only if the entire page is being invalidated.\n\t * The get_block cached value has been unconditionally invalidated,\n\t * so real IO is not possible anymore.\n\t */\n\tif (offset == 0)\n\t\ttry_to_release_page(page, 0);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup",
          "args": [
            "&pvec",
            "mapping",
            "index",
            "PAGEVEC_SIZE"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode",
            "start",
            "last - start + 1"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}"
  },
  {
    "function_name": "ext4_da_page_release_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1245-1292",
    "snippet": "static void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tclear_buffer_delay(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (to_release) {\n\t\tlblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, lblk, to_release);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);",
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_da_release_space",
          "args": [
            "inode",
            "1"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_release_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "1210-1243",
          "snippet": "static void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_delalloc_cluster",
          "args": [
            "inode",
            "lblk"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_delalloc_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3848-3856",
          "snippet": "int ext4_find_delalloc_cluster(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t lblk_start, lblk_end;\n\tlblk_start = EXT4_LBLK_CMASK(sbi, lblk);\n\tlblk_end = lblk_start + sbi->s_cluster_ratio - 1;\n\n\treturn ext4_find_delalloc_range(inode, lblk_start, lblk_end);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_find_delalloc_cluster(struct inode *inode, ext4_lblk_t lblk)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_lblk_t lblk_start, lblk_end;\n\tlblk_start = EXT4_LBLK_CMASK(sbi, lblk);\n\tlblk_end = lblk_start + sbi->s_cluster_ratio - 1;\n\n\treturn ext4_find_delalloc_range(inode, lblk_start, lblk_end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "to_release"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_remove_extent",
          "args": [
            "inode",
            "lblk",
            "to_release"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "938-964",
          "snippet": "int ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\n\tif (!len)\n\t\treturn err;\n\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\n\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\text4_es_print_tree(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_delay",
          "args": [
            "bh"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "stop > PAGE_CACHE_SIZE || stop < length"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_CACHE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tclear_buffer_delay(bh);\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (to_release) {\n\t\tlblk = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, lblk, to_release);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}"
  },
  {
    "function_name": "ext4_da_release_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1210-1243",
    "snippet": "static void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_release_reservation_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, to_free)"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "to_free"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT4_I(inode)->i_block_reservation_lock"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "to_free"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\"",
            "inode->i_ino",
            "to_free",
            "ei->i_reserved_data_blocks"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "to_free > ei->i_reserved_data_blocks"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_release_space",
          "args": [
            "inode",
            "to_free"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT4_I(inode)->i_block_reservation_lock"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}"
  },
  {
    "function_name": "ext4_da_reserve_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1170-1208",
    "snippet": "static int ext4_da_reserve_space(struct inode *inode, ext4_lblk_t lblock)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int md_needed;\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * recalculate the amount of metadata blocks to reserve\n\t * in order to allocate nrblocks\n\t * worse case is one extent per block\n\t */\n\tspin_lock(&ei->i_block_reservation_lock);\n\t/*\n\t * ext4_calc_metadata_amount() has side effects, which we have\n\t * to be prepared undo if we fail to claim space.\n\t */\n\tmd_needed = 0;\n\ttrace_ext4_da_reserve_space(inode, 0);\n\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ei->i_block_reservation_lock"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_release_reservation_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, 1)"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "1"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_claim_free_clusters",
          "args": [
            "sbi",
            "1",
            "0"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_claim_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "576-584",
          "snippet": "int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_reserve_space",
          "args": [
            "inode",
            "0"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ei->i_block_reservation_lock"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_reserve_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, 1)"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "1"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_da_reserve_space(struct inode *inode, ext4_lblk_t lblock)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int md_needed;\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * recalculate the amount of metadata blocks to reserve\n\t * in order to allocate nrblocks\n\t * worse case is one extent per block\n\t */\n\tspin_lock(&ei->i_block_reservation_lock);\n\t/*\n\t * ext4_calc_metadata_amount() has side effects, which we have\n\t * to be prepared undo if we fail to claim space.\n\t */\n\tmd_needed = 0;\n\ttrace_ext4_da_reserve_space(inode, 0);\n\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}"
  },
  {
    "function_name": "ext4_journalled_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1094-1165",
    "snippet": "static int ext4_journalled_write_end(struct file *file,\n\t\t\t\t     struct address_space *mapping,\n\t\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t     struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\tint size_changed = 0;\n\n\ttrace_ext4_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (ext4_has_inline_data(inode))\n\t\tcopied = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t    copied, page);\n\telse {\n\t\tif (copied < len) {\n\t\t\tif (!PageUptodate(page))\n\t\t\t\tcopied = 0;\n\t\t\tpage_zero_new_buffers(page, from+copied, to);\n\t\t}\n\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\t\t     to, &partial, write_end_fn);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t}\n\tsize_changed = ext4_update_inode_size(inode, pos + copied);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\n\tif (size_changed) {\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\n\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3375-3384",
          "snippet": "int ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "old_size",
            "pos"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_JDATA"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_update_inode_size",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "&partial",
            "write_end_fn"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_zero_new_buffers",
          "args": [
            "page",
            "from+copied",
            "to"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "page_zero_new_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1845-1879",
          "snippet": "void page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid page_zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\treturn;\n\n\tbh = head = page_buffers(page);\n\tblock_start = 0;\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t}\n\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied",
            "page"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_handle_valid(handle)"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_journalled_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_journalled_write_end(struct file *file,\n\t\t\t\t     struct address_space *mapping,\n\t\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t     struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\tint size_changed = 0;\n\n\ttrace_ext4_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (ext4_has_inline_data(inode))\n\t\tcopied = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t    copied, page);\n\telse {\n\t\tif (copied < len) {\n\t\t\tif (!PageUptodate(page))\n\t\t\t\tcopied = 0;\n\t\t\tpage_zero_new_buffers(page, from+copied, to);\n\t\t}\n\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\t\t     to, &partial, write_end_fn);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t}\n\tsize_changed = ext4_update_inode_size(inode, pos + copied);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\n\tif (size_changed) {\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\n\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "ext4_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1020-1092",
    "snippet": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_can_truncate",
          "args": [
            "inode"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3375-3384",
          "snippet": "int ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_isize_extended",
          "args": [
            "inode",
            "old_size",
            "pos"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_update_inode_size",
          "args": [
            "inode",
            "pos + copied"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_write_inline_data_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied",
            "page"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_write_inline_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "715-750",
          "snippet": "int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,\n\t\t\t       unsigned copied, struct page *page)\n{\n\tint ret;\n\tvoid *kaddr;\n\tstruct ext4_iloc iloc;\n\n\tif (unlikely(copied < len)) {\n\t\tif (!PageUptodate(page)) {\n\t\t\tcopied = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret) {\n\t\text4_std_error(inode->i_sb, ret);\n\t\tcopied = 0;\n\t\tgoto out;\n\t}\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tBUG_ON(!ext4_has_inline_data(inode));\n\n\tkaddr = kmap_atomic(page);\n\text4_write_inline_data(inode, &iloc, kaddr, pos, len);\n\tkunmap_atomic(kaddr);\n\tSetPageUptodate(page);\n\t/* clear page dirty so that writepages wouldn't work for us. */\n\tClearPageDirty(page);\n\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\tbrelse(iloc.bh);\nout:\n\treturn copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_jbd2_file_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "364-369",
          "snippet": "static inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_file_inode(handle, EXT4_I(inode)->jinode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_ORDERED_MODE"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_write_end",
          "args": [
            "inode",
            "pos",
            "len",
            "copied"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}"
  },
  {
    "function_name": "write_end_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "1001-1011",
    "snippet": "static int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_prio",
          "args": [
            "bh"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_meta",
          "args": [
            "bh"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "891-998",
    "snippet": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "NULL",
            "inode"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate_failed_write",
          "args": [
            "inode"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate_failed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "11-15",
          "snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_orphan_add",
          "args": [
            "handle",
            "inode"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2540-2615",
          "snippet": "int ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_add(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_iloc iloc;\n\tint err = 0, rc;\n\tbool dirty = false;\n\n\tif (!sbi->s_journal || is_bad_inode(inode))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/*\n\t * Exit early if inode already is on orphan list. This is a big speedup\n\t * since we don't have to contend on the global s_orphan_lock.\n\t */\n\tif (!list_empty(&EXT4_I(inode)->i_orphan))\n\t\treturn 0;\n\n\t/*\n\t * Orphan handling is only valid for files with data blocks\n\t * being truncated, or files being unlinked. Note that we either\n\t * hold i_mutex, or the inode can not be referenced from outside,\n\t * so i_nlink should not be bumped due to race\n\t */\n\tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);\n\n\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\tif (err)\n\t\tgoto out;\n\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\tgoto out;\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\t/*\n\t * Due to previous errors inode may be already a part of on-disk\n\t * orphan list. If so skip on-disk list modification.\n\t */\n\tif (!NEXT_ORPHAN(inode) || NEXT_ORPHAN(inode) >\n\t    (le32_to_cpu(sbi->s_es->s_inodes_count))) {\n\t\t/* Insert this inode at the head of the on-disk orphan list */\n\t\tNEXT_ORPHAN(inode) = le32_to_cpu(sbi->s_es->s_last_orphan);\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);\n\t\tdirty = true;\n\t}\n\tlist_add(&EXT4_I(inode)->i_orphan, &sbi->s_orphan);\n\tmutex_unlock(&sbi->s_orphan_lock);\n\n\tif (dirty) {\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t\trc = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\t\tif (!err)\n\t\t\terr = rc;\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * We have to remove inode from in-memory list if\n\t\t\t * addition to on disk orphan list failed. Stray orphan\n\t\t\t * list entries can cause panics at unmount time.\n\t\t\t */\n\t\t\tmutex_lock(&sbi->s_orphan_lock);\n\t\t\tlist_del(&EXT4_I(inode)->i_orphan);\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t}\n\t}\n\tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);\n\tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",\n\t\t\tinode->i_ino, NEXT_ORPHAN(inode));\nout:\n\text4_std_error(sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_can_truncate",
          "args": [
            "inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_can_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3375-3384",
          "snippet": "int ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "NULL",
            "do_journal_get_write_access"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "809-838",
          "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "ext4_get_block"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_dioread_nolock",
          "args": [
            "inode"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_dioread_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "437-448",
          "snippet": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_stable_page",
          "args": [
            "page"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_WRITE_PAGE",
            "needed_blocks"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page_write_begin",
          "args": [
            "mapping",
            "index",
            "flags"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_try_to_write_inline_data",
          "args": [
            "mapping",
            "inode",
            "pos",
            "len",
            "flags",
            "pagep"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_try_to_write_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "638-713",
          "snippet": "int ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  loff_t pos, unsigned len,\n\t\t\t\t  unsigned flags,\n\t\t\t\t  struct page **pagep)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\n\tif (pos + len > ext4_get_max_inline_size(inode))\n\t\tgoto convert;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * The possible write could happen in the inode,\n\t * so try to reserve the space in inode first.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* We don't have space in inline inode, so convert it to extent. */\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tbrelse(iloc.bh);\n\t\tgoto convert;\n\t}\n\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*pagep = page;\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto out_up_read;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_up_read;\n\t}\n\n\tret = 1;\n\thandle = NULL;\nout_up_read:\n\tup_read(&EXT4_I(inode)->xattr_sem);\nout:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\nconvert:\n\treturn ext4_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t  inode, flags);\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_try_to_write_inline_data(struct address_space *mapping,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  loff_t pos, unsigned len,\n\t\t\t\t  unsigned flags,\n\t\t\t\t  struct page **pagep)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct page *page;\n\tstruct ext4_iloc iloc;\n\n\tif (pos + len > ext4_get_max_inline_size(inode))\n\t\tgoto convert;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * The possible write could happen in the inode,\n\t * so try to reserve the space in inode first.\n\t */\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto out;\n\t}\n\n\tret = ext4_prepare_inline_data(handle, inode, pos + len);\n\tif (ret && ret != -ENOSPC)\n\t\tgoto out;\n\n\t/* We don't have space in inline inode, so convert it to extent. */\n\tif (ret == -ENOSPC) {\n\t\text4_journal_stop(handle);\n\t\tbrelse(iloc.bh);\n\t\tgoto convert;\n\t}\n\n\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, 0, flags);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*pagep = page;\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tret = 0;\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tgoto out_up_read;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tret = ext4_read_inline_page(inode, page);\n\t\tif (ret < 0)\n\t\t\tgoto out_up_read;\n\t}\n\n\tret = 1;\n\thandle = NULL;\nout_up_read:\n\tup_read(&EXT4_I(inode)->xattr_sem);\nout:\n\tif (handle)\n\t\text4_journal_stop(handle);\n\tbrelse(iloc.bh);\n\treturn ret;\nconvert:\n\treturn ext4_convert_inline_data_to_extent(mapping,\n\t\t\t\t\t\t  inode, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_MAY_INLINE_DATA"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_writepage_trans_blocks",
          "args": [
            "inode"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_writepage_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4769-4780",
          "snippet": "int ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_write_begin",
          "args": [
            "inode",
            "pos",
            "len",
            "flags"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\n\nstatic int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tpage_cache_release(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block_write);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tpage_cache_release(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_journal_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "864-887",
    "snippet": "int do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_write_begin() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_write_begin() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tBUFFER_TRACE(bh, \"get write access\");\n\tret = ext4_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bh"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get write access\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_freed",
          "args": [
            "bh"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_write_begin() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_write_begin() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tBUFFER_TRACE(bh, \"get write access\");\n\tret = ext4_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_walk_page_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "809-838",
    "snippet": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "handle",
            "bh"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "791-807",
    "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ | REQ_META | REQ_PRIO",
            "1",
            "&bh"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_getblk",
          "args": [
            "handle",
            "inode",
            "block",
            "create"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_getblk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "734-789",
          "snippet": "struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "ext4_getblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "734-789",
    "snippet": "struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"not a new buffer\""
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call ext4_handle_dirty_metadata\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"call get_create_access\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "create != 0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "map.m_pblk"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "handle",
            "inode",
            "&map",
            "create ? EXT4_GET_BLOCKS_CREATE : 0"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "handle != NULL || create == 0"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int create)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map,\n\t\t\t      create ? EXT4_GET_BLOCKS_CREATE : 0);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ext4_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "724-729",
    "snippet": "int ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh, int create)\n{\n\treturn _ext4_get_block(inode, iblock, bh,\n\t\t\t       create ? EXT4_GET_BLOCKS_CREATE : 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ext4_get_block",
          "args": [
            "inode",
            "iblock",
            "bh",
            "create ? EXT4_GET_BLOCKS_CREATE : 0"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "_ext4_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "675-722",
          "snippet": "static int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define DIO_MAX_BLOCKS 4096"
          ],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh, int create)\n{\n\treturn _ext4_get_block(inode, iblock, bh,\n\t\t\t       create ? EXT4_GET_BLOCKS_CREATE : 0);\n}"
  },
  {
    "function_name": "_ext4_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "675-722",
    "snippet": "static int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define DIO_MAX_BLOCKS 4096"
    ],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_defer_completion",
          "args": [
            "bh"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DAX",
          "args": [
            "inode"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "map.m_pblk"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_aio",
          "args": [
            "inode"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_aio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1392-1395",
          "snippet": "static inline ext4_io_end_t *ext4_inode_aio(struct inode *inode)\n{\n\treturn inode->i_private;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_io_end_t *ext4_inode_aio(struct inode *inode)\n{\n\treturn inode->i_private;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "handle",
            "inode",
            "&map",
            "flags"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_MAP_BLOCKS",
            "dio_credits"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_chunk_trans_blocks",
          "args": [
            "inode",
            "map.m_len"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chunk_trans_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4791-4794",
          "snippet": "int ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_current_handle",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "331-334",
          "snippet": "static inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext4_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\n#define DIO_MAX_BLOCKS 4096\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct ext4_map_blocks map;\n\tint ret = 0, started = 0;\n\tint dio_credits;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tif (flags && !(flags & EXT4_GET_BLOCKS_NO_LOCK) && !handle) {\n\t\t/* Direct IO write... */\n\t\tif (map.m_len > DIO_MAX_BLOCKS)\n\t\t\tmap.m_len = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, map.m_len);\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t    dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (ret > 0) {\n\t\text4_io_end_t *io_end = ext4_inode_aio(inode);\n\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | map.m_flags;\n\t\tif (IS_DAX(inode) && buffer_unwritten(bh) && !io_end) {\n\t\t\tbh->b_assoc_map = inode->i_mapping;\n\t\t\tbh->b_private = (void *)(unsigned long)iblock;\n\t\t\tbh->b_end_io = ext4_end_io_unwritten;\n\t\t}\n\t\tif (io_end && io_end->flag & EXT4_IO_END_UNWRITTEN)\n\t\t\tset_buffer_defer_completion(bh);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_end_io_unwritten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "660-670",
    "snippet": "static void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)\n{\n\tstruct inode *inode = bh->b_assoc_map->host;\n\t/* XXX: breaks on 32-bit > 16GB. Is that even supported? */\n\tloff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;\n\tint err;\n\tif (!uptodate)\n\t\treturn;\n\tWARN_ON(!buffer_unwritten(bh));\n\terr = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_convert_unwritten_extents",
          "args": [
            "NULL",
            "inode",
            "offset",
            "bh->b_size"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_convert_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4998-5059",
          "snippet": "int ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t   loff_t offset, ssize_t len)\n{\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\t/*\n\t * We can't just convert len to max_blocks because\n\t * If blocksize = 4096 offset = 3072 and len = 2048\n\t */\n\tmax_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -\n\t\t      map.m_lblk);\n\t/*\n\t * This is somewhat ugly but the idea is clear: When transaction is\n\t * reserved, everything goes into it. Otherwise we rather start several\n\t * smaller transactions for conversion of each extent separately.\n\t */\n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tcredits = 0;\n\t} else {\n\t\t/*\n\t\t * credits to insert 1 extent into extent tree\n\t\t */\n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\tif (credits) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t\t    credits);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0)\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"inode #%lu: block %u: len %u: \"\n\t\t\t\t     \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t     inode->i_ino, map.m_lblk,\n\t\t\t\t     map.m_len, ret);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tif (credits)\n\t\t\tret2 = ext4_journal_stop(handle);\n\t\tif (ret <= 0 || ret2)\n\t\t\tbreak;\n\t}\n\tif (!credits)\n\t\tret2 = ext4_journal_stop(handle);\n\treturn ret > 0 ? ret2 : ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_convert_unwritten_extents(handle_t *handle, struct inode *inode,\n\t\t\t\t   loff_t offset, ssize_t len)\n{\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint ret2 = 0;\n\tstruct ext4_map_blocks map;\n\tunsigned int credits, blkbits = inode->i_blkbits;\n\n\tmap.m_lblk = offset >> blkbits;\n\t/*\n\t * We can't just convert len to max_blocks because\n\t * If blocksize = 4096 offset = 3072 and len = 2048\n\t */\n\tmax_blocks = ((EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits) -\n\t\t      map.m_lblk);\n\t/*\n\t * This is somewhat ugly but the idea is clear: When transaction is\n\t * reserved, everything goes into it. Otherwise we rather start several\n\t * smaller transactions for conversion of each extent separately.\n\t */\n\tif (handle) {\n\t\thandle = ext4_journal_start_reserved(handle,\n\t\t\t\t\t\t     EXT4_HT_EXT_CONVERT);\n\t\tif (IS_ERR(handle))\n\t\t\treturn PTR_ERR(handle);\n\t\tcredits = 0;\n\t} else {\n\t\t/*\n\t\t * credits to insert 1 extent into extent tree\n\t\t */\n\t\tcredits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t}\n\twhile (ret >= 0 && ret < max_blocks) {\n\t\tmap.m_lblk += ret;\n\t\tmap.m_len = (max_blocks -= ret);\n\t\tif (credits) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS,\n\t\t\t\t\t\t    credits);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tret = PTR_ERR(handle);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret = ext4_map_blocks(handle, inode, &map,\n\t\t\t\t      EXT4_GET_BLOCKS_IO_CONVERT_EXT);\n\t\tif (ret <= 0)\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"inode #%lu: block %u: len %u: \"\n\t\t\t\t     \"ext4_ext_map_blocks returned %d\",\n\t\t\t\t     inode->i_ino, map.m_lblk,\n\t\t\t\t     map.m_len, ret);\n\t\text4_mark_inode_dirty(handle, inode);\n\t\tif (credits)\n\t\t\tret2 = ext4_journal_stop(handle);\n\t\tif (ret <= 0 || ret2)\n\t\t\tbreak;\n\t}\n\tif (!credits)\n\t\tret2 = ext4_journal_stop(handle);\n\treturn ret > 0 ? ret2 : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!buffer_unwritten(bh)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nstatic void ext4_end_io_unwritten(struct buffer_head *bh, int uptodate)\n{\n\tstruct inode *inode = bh->b_assoc_map->host;\n\t/* XXX: breaks on 32-bit > 16GB. Is that even supported? */\n\tloff_t offset = (loff_t)(uintptr_t)bh->b_private << inode->i_blkbits;\n\tint err;\n\tif (!uptodate)\n\t\treturn;\n\tWARN_ON(!buffer_unwritten(bh));\n\terr = ext4_convert_unwritten_extents(NULL, inode, offset, bh->b_size);\n}"
  },
  {
    "function_name": "ext4_map_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "460-658",
    "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
      "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_block_validity",
          "args": [
            "inode",
            "map"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_insert_extent",
          "args": [
            "inode",
            "map->m_lblk",
            "map->m_len",
            "map->m_pblk",
            "status"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "692-733",
          "snippet": "int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __es_insert_extent(struct inode *inode, struct extent_status *newes);",
            "static int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic int __es_insert_extent(struct inode *inode, struct extent_status *newes);\nstatic int __es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t      ext4_lblk_t end);\n\nint ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  ext4_lblk_t len, ext4_fsblk_t pblk,\n\t\t\t  unsigned int status)\n{\n\tstruct extent_status newes;\n\text4_lblk_t end = lblk + len - 1;\n\tint err = 0;\n\n\tes_debug(\"add [%u/%u) %llu %x to extent status tree of inode %lu\\n\",\n\t\t lblk, len, pblk, status, inode->i_ino);\n\n\tif (!len)\n\t\treturn 0;\n\n\tBUG_ON(end < lblk);\n\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = len;\n\text4_es_store_pblock_status(&newes, pblk, status);\n\ttrace_ext4_es_insert_extent(inode, &newes);\n\n\text4_es_insert_extent_check(inode, &newes);\n\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end);\n\tif (err != 0)\n\t\tgoto error;\nretry:\n\terr = __es_insert_extent(inode, &newes);\n\tif (err == -ENOMEM && __es_shrink(EXT4_SB(inode->i_sb),\n\t\t\t\t\t  128, EXT4_I(inode)))\n\t\tgoto retry;\n\tif (err == -ENOMEM && !ext4_es_is_delayed(&newes))\n\t\terr = 0;\n\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\n\text4_es_print_tree(inode);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_find_delalloc_range",
          "args": [
            "inode",
            "map->m_lblk",
            "map->m_lblk + map->m_len - 1"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_find_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "3830-3846",
          "snippet": "int ext4_find_delalloc_range(struct inode *inode,\n\t\t\t     ext4_lblk_t lblk_start,\n\t\t\t     ext4_lblk_t lblk_end)\n{\n\tstruct extent_status es;\n\n\text4_es_find_delayed_extent_range(inode, lblk_start, lblk_end, &es);\n\tif (es.es_len == 0)\n\t\treturn 0; /* there is no delay extent in this tree */\n\telse if (es.es_lblk <= lblk_start &&\n\t\t lblk_start < es.es_lblk + es.es_len)\n\t\treturn 1;\n\telse if (lblk_start <= es.es_lblk && es.es_lblk <= lblk_end)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_find_delalloc_range(struct inode *inode,\n\t\t\t     ext4_lblk_t lblk_start,\n\t\t\t     ext4_lblk_t lblk_end)\n{\n\tstruct extent_status es;\n\n\text4_es_find_delayed_extent_range(inode, lblk_start, lblk_end, &es);\n\tif (es.es_len == 0)\n\t\treturn 0; /* there is no delay extent in this tree */\n\telse if (es.es_lblk <= lblk_start &&\n\t\t lblk_start < es.es_lblk + es.es_len)\n\t\treturn 1;\n\telse if (lblk_start <= es.es_lblk && es.es_lblk <= lblk_end)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_written",
          "args": [
            "&es"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "108-111",
          "snippet": "static inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_WRITTEN\t(1 << ES_WRITTEN_B)\n\nstatic inline int ext4_es_is_written(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_WRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_lookup_extent",
          "args": [
            "inode",
            "map->m_lblk",
            "&es"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_lookup_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "773-831",
          "snippet": "int ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nint ext4_es_lookup_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t  struct extent_status *es)\n{\n\tstruct ext4_es_tree *tree;\n\tstruct ext4_es_stats *stats;\n\tstruct extent_status *es1 = NULL;\n\tstruct rb_node *node;\n\tint found = 0;\n\n\ttrace_ext4_es_lookup_extent_enter(inode, lblk);\n\tes_debug(\"lookup extent in block %u\\n\", lblk);\n\n\ttree = &EXT4_I(inode)->i_es_tree;\n\tread_lock(&EXT4_I(inode)->i_es_lock);\n\n\t/* find extent in cache firstly */\n\tes->es_lblk = es->es_len = es->es_pblk = 0;\n\tif (tree->cache_es) {\n\t\tes1 = tree->cache_es;\n\t\tif (in_range(lblk, es1->es_lblk, es1->es_len)) {\n\t\t\tes_debug(\"%u cached by [%u/%u)\\n\",\n\t\t\t\t lblk, es1->es_lblk, es1->es_len);\n\t\t\tfound = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnode = tree->root.rb_node;\n\twhile (node) {\n\t\tes1 = rb_entry(node, struct extent_status, rb_node);\n\t\tif (lblk < es1->es_lblk)\n\t\t\tnode = node->rb_left;\n\t\telse if (lblk > ext4_es_end(es1))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tstats = &EXT4_SB(inode->i_sb)->s_es_stats;\n\tif (found) {\n\t\tBUG_ON(!es1);\n\t\tes->es_lblk = es1->es_lblk;\n\t\tes->es_len = es1->es_len;\n\t\tes->es_pblk = es1->es_pblk;\n\t\tif (!ext4_es_is_referenced(es))\n\t\t\text4_es_set_referenced(es);\n\t\tstats->es_stats_cache_hits++;\n\t} else {\n\t\tstats->es_stats_cache_misses++;\n\t}\n\n\tread_unlock(&EXT4_I(inode)->i_es_lock);\n\n\ttrace_ext4_es_lookup_extent_exit(inode, es, found);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\"",
            "inode->i_ino",
            "retval",
            "map->m_len"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != map->m_len"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_da_update_reserve_space",
          "args": [
            "inode",
            "retval",
            "1"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_da_update_reserve_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "328-371",
          "snippet": "void ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_EXT_MIGRATE"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_ind_map_blocks",
          "args": [
            "handle",
            "inode",
            "map",
            "flags"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "513-632",
          "snippet": "int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_map_blocks",
          "args": [
            "handle",
            "inode",
            "map",
            "flags"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4273-4636",
          "snippet": "int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nint ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_block_validity",
          "args": [
            "inode",
            "map"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "retval != map->m_len"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks_es_recheck",
          "args": [
            "handle",
            "inode",
            "map",
            "&orig_map",
            "flags"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks_es_recheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "392-435",
          "snippet": "static void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_es_is_hole",
          "args": [
            "&es"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "123-126",
          "snippet": "static inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_HOLE\t(1 << ES_HOLE_B)\n\nstatic inline int ext4_es_is_hole(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_HOLE) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_delayed",
          "args": [
            "&es"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_delayed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "118-121",
          "snippet": "static inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_DELAYED\t(1 << ES_DELAYED_B)\n\nstatic inline int ext4_es_is_delayed(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_DELAYED) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_pblock",
          "args": [
            "&es"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_pblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "143-146",
          "snippet": "static inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define ES_MASK (~((ext4_fsblk_t)0) << ES_SHIFT)\n\nstatic inline ext4_fsblk_t ext4_es_pblock(struct extent_status *es)\n{\n\treturn es->es_pblk & ~ES_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_es_is_unwritten",
          "args": [
            "&es"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_is_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.h",
          "lines": "113-116",
          "snippet": "static inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}",
          "includes": [],
          "macros_used": [
            "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define EXTENT_STATUS_UNWRITTEN (1 << ES_UNWRITTEN_B)\n\nstatic inline int ext4_es_is_unwritten(struct extent_status *es)\n{\n\treturn (ext4_es_type(es) & EXTENT_STATUS_UNWRITTEN) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map->m_lblk >= EXT_MAX_BLOCKS"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map->m_len > INT_MAX"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext_debug",
          "args": [
            "\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\"",
            "inode->i_ino",
            "flags",
            "map->m_len",
            "(unsigned long) map->m_lblk"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&orig_map",
            "map",
            "sizeof(*map)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "ext4_map_blocks_es_recheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "392-435",
    "snippet": "static void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\"",
            "inode->i_ino",
            "es_map->m_lblk",
            "es_map->m_len",
            "es_map->m_pblk",
            "es_map->m_flags",
            "map->m_lblk",
            "map->m_len",
            "map->m_pblk",
            "map->m_flags",
            "retval",
            "flags"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "(&EXT4_I(inode)->i_data_sem)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ind_map_blocks",
          "args": [
            "handle",
            "inode",
            "map",
            "flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ind_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/indirect.c",
          "lines": "513-632",
          "snippet": "int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/aio.h>\n\nint ext4_ind_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map,\n\t\t\tint flags)\n{\n\tstruct ext4_allocation_request ar;\n\tint err = -EIO;\n\text4_lblk_t offsets[4];\n\tIndirect chain[4];\n\tIndirect *partial;\n\tint indirect_blks;\n\tint blocks_to_boundary = 0;\n\tint depth;\n\tint count = 0;\n\text4_fsblk_t first_block = 0;\n\n\ttrace_ext4_ind_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\tJ_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));\n\tJ_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);\n\tdepth = ext4_block_to_path(inode, map->m_lblk, offsets,\n\t\t\t\t   &blocks_to_boundary);\n\n\tif (depth == 0)\n\t\tgoto out;\n\n\tpartial = ext4_get_branch(inode, depth, offsets, chain, &err);\n\n\t/* Simplest case - block found, no allocation needed */\n\tif (!partial) {\n\t\tfirst_block = le32_to_cpu(chain[depth - 1].key);\n\t\tcount++;\n\t\t/*map more blocks*/\n\t\twhile (count < map->m_len && count <= blocks_to_boundary) {\n\t\t\text4_fsblk_t blk;\n\n\t\t\tblk = le32_to_cpu(*(chain[depth-1].p + count));\n\n\t\t\tif (blk == first_block + count)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\t/* Next simple case - plain lookup or failed read of indirect block */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0 || err == -EIO)\n\t\tgoto cleanup;\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t*/\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {\n\t\tEXT4_ERROR_INODE(inode, \"Can't allocate blocks for \"\n\t\t\t\t \"non-extent mapped inodes with bigalloc\");\n\t\treturn -ENOSPC;\n\t}\n\n\t/* Set up for the direct block allocation */\n\tmemset(&ar, 0, sizeof(ar));\n\tar.inode = inode;\n\tar.logical = map->m_lblk;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\n\tar.goal = ext4_find_goal(inode, map->m_lblk, partial);\n\n\t/* the number of blocks need to allocate for [d,t]indirect blocks */\n\tindirect_blks = (chain + depth) - partial - 1;\n\n\t/*\n\t * Next look up the indirect map to count the totoal number of\n\t * direct blocks to allocate for this branch.\n\t */\n\tar.len = ext4_blks_to_allocate(partial, indirect_blks,\n\t\t\t\t       map->m_len, blocks_to_boundary);\n\n\t/*\n\t * Block out ext4_truncate while we alter the tree\n\t */\n\terr = ext4_alloc_branch(handle, &ar, indirect_blks,\n\t\t\t\toffsets + (partial - chain), partial);\n\n\t/*\n\t * The ext4_splice_branch call will free and forget any buffers\n\t * on the new chain if there is a failure, but that risks using\n\t * up transaction credits, especially for bitmaps where the\n\t * credits cannot be returned.  Can we handle this somehow?  We\n\t * may need to return -EAGAIN upwards in the worst case.  --sct\n\t */\n\tif (!err)\n\t\terr = ext4_splice_branch(handle, &ar, partial, indirect_blks);\n\tif (err)\n\t\tgoto cleanup;\n\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\text4_update_inode_fsync_trans(handle, inode, 1);\n\tcount = ar.len;\ngot_it:\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = le32_to_cpu(chain[depth-1].key);\n\tmap->m_len = count;\n\tif (count > blocks_to_boundary)\n\t\tmap->m_flags |= EXT4_MAP_BOUNDARY;\n\terr = count;\n\t/* Clean up and exit */\n\tpartial = chain + depth - 1;\t/* the whole chain */\ncleanup:\n\twhile (partial > chain) {\n\t\tBUFFER_TRACE(partial->bh, \"call brelse\");\n\t\tbrelse(partial->bh);\n\t\tpartial--;\n\t}\nout:\n\ttrace_ext4_ind_map_blocks_exit(inode, flags, map, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_ext_map_blocks",
          "args": [
            "handle",
            "inode",
            "map",
            "flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "4273-4636",
          "snippet": "int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);",
            "static int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_split_extent(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\tint split_flag,\n\t\t\t\tint flags);\nstatic int ext4_split_extent_at(handle_t *handle,\n\t\t\t     struct inode *inode,\n\t\t\t     struct ext4_ext_path **ppath,\n\t\t\t     ext4_lblk_t split,\n\t\t\t     int split_flag,\n\t\t\t     int flags);\n\nint ext4_ext_map_blocks(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext4_map_blocks *map, int flags)\n{\n\tstruct ext4_ext_path *path = NULL;\n\tstruct ext4_extent newex, *ex, *ex2;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\text4_fsblk_t newblock = 0;\n\tint free_on_err = 0, err = 0, depth, ret;\n\tunsigned int allocated = 0, offset = 0;\n\tunsigned int allocated_clusters = 0;\n\tstruct ext4_allocation_request ar;\n\text4_io_end_t *io = ext4_inode_aio(inode);\n\text4_lblk_t cluster_offset;\n\tint set_unwritten = 0;\n\tbool map_from_cluster = false;\n\n\text_debug(\"blocks %u/%u requested for inode %lu\\n\",\n\t\t  map->m_lblk, map->m_len, inode->i_ino);\n\ttrace_ext4_ext_map_blocks_enter(inode, map->m_lblk, map->m_len, flags);\n\n\t/* find extent for this block */\n\tpath = ext4_find_extent(inode, map->m_lblk, NULL, 0);\n\tif (IS_ERR(path)) {\n\t\terr = PTR_ERR(path);\n\t\tpath = NULL;\n\t\tgoto out2;\n\t}\n\n\tdepth = ext_depth(inode);\n\n\t/*\n\t * consistent leaf must not be empty;\n\t * this situation is possible, though, _during_ tree modification;\n\t * this is why assert can't be put in ext4_find_extent()\n\t */\n\tif (unlikely(path[depth].p_ext == NULL && depth != 0)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extent address \"\n\t\t\t\t \"lblock: %lu, depth: %d pblock %lld\",\n\t\t\t\t (unsigned long) map->m_lblk, depth,\n\t\t\t\t path[depth].p_block);\n\t\terr = -EIO;\n\t\tgoto out2;\n\t}\n\n\tex = path[depth].p_ext;\n\tif (ex) {\n\t\text4_lblk_t ee_block = le32_to_cpu(ex->ee_block);\n\t\text4_fsblk_t ee_start = ext4_ext_pblock(ex);\n\t\tunsigned short ee_len;\n\n\n\t\t/*\n\t\t * unwritten extents are treated as holes, except that\n\t\t * we split out initialized portions during a write.\n\t\t */\n\t\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\ttrace_ext4_ext_show_extent(inode, ee_block, ee_start, ee_len);\n\n\t\t/* if found extent covers block, simply return it */\n\t\tif (in_range(map->m_lblk, ee_block, ee_len)) {\n\t\t\tnewblock = map->m_lblk - ee_block + ee_start;\n\t\t\t/* number of remaining blocks in the extent */\n\t\t\tallocated = ee_len - (map->m_lblk - ee_block);\n\t\t\text_debug(\"%u fit into %u:%d -> %llu\\n\", map->m_lblk,\n\t\t\t\t  ee_block, ee_len, newblock);\n\n\t\t\t/*\n\t\t\t * If the extent is initialized check whether the\n\t\t\t * caller wants to convert it to unwritten.\n\t\t\t */\n\t\t\tif ((!ext4_ext_is_unwritten(ex)) &&\n\t\t\t    (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)) {\n\t\t\t\tallocated = convert_initialized_extent(\n\t\t\t\t\t\thandle, inode, map, &path,\n\t\t\t\t\t\tflags, allocated, newblock);\n\t\t\t\tgoto out2;\n\t\t\t} else if (!ext4_ext_is_unwritten(ex))\n\t\t\t\tgoto out;\n\n\t\t\tret = ext4_ext_handle_unwritten_extents(\n\t\t\t\thandle, inode, map, &path, flags,\n\t\t\t\tallocated, newblock);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t\telse\n\t\t\t\tallocated = ret;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\t/*\n\t * requested block isn't allocated yet;\n\t * we couldn't try to create block if create flag is zero\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {\n\t\t/*\n\t\t * put just found gap into cache to speed up\n\t\t * subsequent requests\n\t\t */\n\t\text4_ext_put_gap_in_cache(inode, path, map->m_lblk);\n\t\tgoto out2;\n\t}\n\n\t/*\n\t * Okay, we need to do block allocation.\n\t */\n\tnewex.ee_block = cpu_to_le32(map->m_lblk);\n\tcluster_offset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\n\t/*\n\t * If we are doing bigalloc, check to see if the extent returned\n\t * by ext4_find_extent() implies a cluster we can use.\n\t */\n\tif (cluster_offset && ex &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/* find neighbour allocated blocks */\n\tar.lleft = map->m_lblk;\n\terr = ext4_ext_search_left(inode, path, &ar.lleft, &ar.pleft);\n\tif (err)\n\t\tgoto out2;\n\tar.lright = map->m_lblk;\n\tex2 = NULL;\n\terr = ext4_ext_search_right(inode, path, &ar.lright, &ar.pright, &ex2);\n\tif (err)\n\t\tgoto out2;\n\n\t/* Check if the extent after searching to the right implies a\n\t * cluster we can use. */\n\tif ((sbi->s_cluster_ratio > 1) && ex2 &&\n\t    get_implied_cluster_alloc(inode->i_sb, map, ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tmap_from_cluster = true;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out2;\n\text_debug(\"allocate new block: goal %llu, found %llu/%u\\n\",\n\t\t  ar.goal, newblock, allocated);\n\tfree_on_err = 1;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\text4_ext_store_pblock(&newex, newblock + offset);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT){\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\t/*\n\t\t * io_end structure was created for every IO write to an\n\t\t * unwritten extent. To avoid unnecessary conversion,\n\t\t * here we flag the IO that really needs the conversion.\n\t\t * For non asycn direct IO case, flag the inode state\n\t\t * that we need to perform conversion when IO is done.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_PRE_IO)\n\t\t\tset_unwritten = 1;\n\t}\n\n\terr = 0;\n\tif ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0)\n\t\terr = check_eofblocks_fl(handle, inode, map->m_lblk,\n\t\t\t\t\t path, ar.len);\n\tif (!err)\n\t\terr = ext4_ext_insert_extent(handle, inode, &path,\n\t\t\t\t\t     &newex, flags);\n\n\tif (!err && set_unwritten) {\n\t\tif (io)\n\t\t\text4_set_io_unwritten_flag(inode, io);\n\t\telse\n\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t     EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (err && free_on_err) {\n\t\tint fb_flags = flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ?\n\t\t\tEXT4_FREE_BLOCKS_NO_QUOT_UPDATE : 0;\n\t\t/* free data blocks we just allocated */\n\t\t/* not a good idea to call discard here directly,\n\t\t * but otherwise we'd need to call it every free() */\n\t\text4_discard_preallocations(inode);\n\t\text4_free_blocks(handle, inode, NULL, newblock,\n\t\t\t\t EXT4_C2B(sbi, allocated_clusters), fb_flags);\n\t\tgoto out2;\n\t}\n\n\t/* previous routine could use block we allocated */\n\tnewblock = ext4_ext_pblock(&newex);\n\tallocated = ext4_ext_get_actual_len(&newex);\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\tmap->m_flags |= EXT4_MAP_NEW;\n\n\t/*\n\t * Update reserved blocks/metadata blocks after successful\n\t * block allocation which had been deferred till now.\n\t */\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {\n\t\tunsigned int reserved_clusters;\n\t\t/*\n\t\t * Check how many clusters we had reserved this allocated range\n\t\t */\n\t\treserved_clusters = get_reserved_cluster_alloc(inode,\n\t\t\t\t\t\tmap->m_lblk, allocated);\n\t\tif (map_from_cluster) {\n\t\t\tif (reserved_clusters) {\n\t\t\t\t/*\n\t\t\t\t * We have clusters reserved for this range.\n\t\t\t\t * But since we are not doing actual allocation\n\t\t\t\t * and are simply using blocks from previously\n\t\t\t\t * allocated cluster, we should release the\n\t\t\t\t * reservation and not claim quota.\n\t\t\t\t */\n\t\t\t\text4_da_update_reserve_space(inode,\n\t\t\t\t\t\treserved_clusters, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tBUG_ON(allocated_clusters < reserved_clusters);\n\t\t\tif (reserved_clusters < allocated_clusters) {\n\t\t\t\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\t\t\t\tint reservation = allocated_clusters -\n\t\t\t\t\t\t  reserved_clusters;\n\t\t\t\t/*\n\t\t\t\t * It seems we claimed few clusters outside of\n\t\t\t\t * the range of this allocation. We should give\n\t\t\t\t * it back to the reservation pool. This can\n\t\t\t\t * happen in the following case:\n\t\t\t\t *\n\t\t\t\t * * Suppose s_cluster_ratio is 4 (i.e., each\n\t\t\t\t *   cluster has 4 blocks. Thus, the clusters\n\t\t\t\t *   are [0-3],[4-7],[8-11]...\n\t\t\t\t * * First comes delayed allocation write for\n\t\t\t\t *   logical blocks 10 & 11. Since there were no\n\t\t\t\t *   previous delayed allocated blocks in the\n\t\t\t\t *   range [8-11], we would reserve 1 cluster\n\t\t\t\t *   for this write.\n\t\t\t\t * * Next comes write for logical blocks 3 to 8.\n\t\t\t\t *   In this case, we will reserve 2 clusters\n\t\t\t\t *   (for [0-3] and [4-7]; and not for [8-11] as\n\t\t\t\t *   that range has a delayed allocated blocks.\n\t\t\t\t *   Thus total reserved clusters now becomes 3.\n\t\t\t\t * * Now, during the delayed allocation writeout\n\t\t\t\t *   time, we will first write blocks [3-8] and\n\t\t\t\t *   allocate 3 clusters for writing these\n\t\t\t\t *   blocks. Also, we would claim all these\n\t\t\t\t *   three clusters above.\n\t\t\t\t * * Now when we come here to writeout the\n\t\t\t\t *   blocks [10-11], we would expect to claim\n\t\t\t\t *   the reservation of 1 cluster we had made\n\t\t\t\t *   (and we would claim it since there are no\n\t\t\t\t *   more delayed allocated blocks in the range\n\t\t\t\t *   [8-11]. But our reserved cluster count had\n\t\t\t\t *   already gone to 0.\n\t\t\t\t *\n\t\t\t\t *   Thus, at the step 4 above when we determine\n\t\t\t\t *   that there are still some unwritten delayed\n\t\t\t\t *   allocated blocks outside of our current\n\t\t\t\t *   block range, we should increment the\n\t\t\t\t *   reserved clusters count so that when the\n\t\t\t\t *   remaining blocks finally gets written, we\n\t\t\t\t *   could claim them.\n\t\t\t\t */\n\t\t\t\tdquot_reserve_block(inode,\n\t\t\t\t\t\tEXT4_C2B(sbi, reservation));\n\t\t\t\tspin_lock(&ei->i_block_reservation_lock);\n\t\t\t\tei->i_reserved_data_blocks += reservation;\n\t\t\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We will claim quota for all newly allocated blocks.\n\t\t\t * We're updating the reserved space *after* the\n\t\t\t * correction above so we do not accidentally free\n\t\t\t * all the metadata reservation because we might\n\t\t\t * actually need it later on.\n\t\t\t */\n\t\t\text4_da_update_reserve_space(inode, allocated_clusters,\n\t\t\t\t\t\t\t1);\n\t\t}\n\t}\n\n\t/*\n\t * Cache the extent and update transaction to commit on fdatasync only\n\t * when it is _not_ an unwritten extent.\n\t */\n\tif ((flags & EXT4_GET_BLOCKS_UNWRIT_EXT) == 0)\n\t\text4_update_inode_fsync_trans(handle, inode, 1);\n\telse\n\t\text4_update_inode_fsync_trans(handle, inode, 0);\nout:\n\tif (allocated > map->m_len)\n\t\tallocated = map->m_len;\n\text4_ext_show_leaf(inode, path);\n\tmap->m_flags |= EXT4_MAP_MAPPED;\n\tmap->m_pblk = newblock;\n\tmap->m_len = allocated;\nout2:\n\text4_ext_drop_refs(path);\n\tkfree(path);\n\n\ttrace_ext4_ext_map_blocks_exit(inode, flags, map,\n\t\t\t\t       err ? err : allocated);\n\treturn err ? err : allocated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}"
  },
  {
    "function_name": "__check_block_validity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "373-386",
    "snippet": "static int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "inode",
            "func",
            "line",
            "map->m_pblk",
            "\"lblock %lu mapped to illegal pblock \"\n\t\t\t\t \"(length %d)\"",
            "(unsigned long) map->m_lblk",
            "map->m_len"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "map->m_pblk",
            "map->m_len"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\n\nstatic int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_da_update_reserve_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "328-371",
    "snippet": "void ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_writecount"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_release_reservation_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, used)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "used"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_claim_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, used)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "used"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT4_I(inode)->i_block_reservation_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "used"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\"",
            "__func__",
            "inode->i_ino",
            "used",
            "ei->i_reserved_data_blocks"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "609-625",
          "snippet": "void __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_warning(struct super_block *sb, const char *function,\n\t\t    unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_warning_ratelimit_state),\n\t\t\t  \"EXT4-fs warning\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_WARNING \"EXT4-fs warning (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "used > ei->i_reserved_data_blocks"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_da_update_reserve_space",
          "args": [
            "inode",
            "used",
            "quota_claim"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ei->i_block_reservation_lock"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}"
  },
  {
    "function_name": "ext4_get_reserved_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "318-321",
    "snippet": "qsize_t *ext4_get_reserved_space(struct inode *inode)\n{\n\treturn &EXT4_I(inode)->i_reserved_quota;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nqsize_t *ext4_get_reserved_space(struct inode *inode)\n{\n\treturn &EXT4_I(inode)->i_reserved_quota;\n}"
  },
  {
    "function_name": "ext4_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "184-315",
    "snippet": "void ext4_evict_inode(struct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\n\ttrace_ext4_evict_inode(inode);\n\n\tif (inode->i_nlink) {\n\t\t/*\n\t\t * When journalling data dirty buffers are tracked only in the\n\t\t * journal. So although mm thinks everything is clean and\n\t\t * ready for reaping the inode might still have some pages to\n\t\t * write in the running transaction or waiting to be\n\t\t * checkpointed. Thus calling jbd2_journal_invalidatepage()\n\t\t * (via truncate_inode_pages()) to discard these buffers can\n\t\t * cause data loss. Also even if we did not discard these\n\t\t * buffers, we would have no way to find them after the inode\n\t\t * is reaped and thus user could see stale data if he tries to\n\t\t * read them before the transaction is checkpointed. So be\n\t\t * careful and force everything to disk here... We use\n\t\t * ei->i_datasync_tid to store the newest transaction\n\t\t * containing inode's data.\n\t\t *\n\t\t * Note that directories do not have this problem because they\n\t\t * don't use page cache.\n\t\t */\n\t\tif (ext4_should_journal_data(inode) &&\n\t\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t\t    inode->i_ino != EXT4_JOURNAL_INO) {\n\t\t\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\t\t\ttid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n\n\t\t\tjbd2_complete_transaction(journal, commit_tid);\n\t\t\tfilemap_write_and_wait(&inode->i_data);\n\t\t}\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\tWARN_ON(atomic_read(&EXT4_I(inode)->i_ioend_count));\n\t\tgoto no_delete;\n\t}\n\n\tif (is_bad_inode(inode))\n\t\tgoto no_delete;\n\tdquot_initialize(inode);\n\n\tif (ext4_should_order_data(inode))\n\t\text4_begin_ordered_truncate(inode, 0);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tWARN_ON(atomic_read(&EXT4_I(inode)->i_ioend_count));\n\n\t/*\n\t * Protect us against freezing - iput() caller didn't have to have any\n\t * protection against it\n\t */\n\tsb_start_intwrite(inode->i_sb);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE,\n\t\t\t\t    ext4_blocks_for_truncate(inode)+3);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text4_orphan_del(NULL, inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_size = 0;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"couldn't mark inode dirty (err %d)\", err);\n\t\tgoto stop_handle;\n\t}\n\tif (inode->i_blocks)\n\t\text4_truncate(inode);\n\n\t/*\n\t * ext4_ext_truncate() doesn't reserve any slop when it\n\t * restarts journal transactions; therefore there may not be\n\t * enough credits left in the handle to remove the inode from\n\t * the orphan list and set the dtime field.\n\t */\n\tif (!ext4_handle_has_enough_credits(handle, 3)) {\n\t\terr = ext4_journal_extend(handle, 3);\n\t\tif (err > 0)\n\t\t\terr = ext4_journal_restart(handle, 3);\n\t\tif (err != 0) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"couldn't extend journal (err %d)\", err);\n\t\tstop_handle:\n\t\t\text4_journal_stop(handle);\n\t\t\text4_orphan_del(NULL, inode);\n\t\t\tsb_end_intwrite(inode->i_sb);\n\t\t\tgoto no_delete;\n\t\t}\n\t}\n\n\t/*\n\t * Kill off the orphan record which ext4_truncate created.\n\t * AKPM: I think this can be inside the above `if'.\n\t * Note that ext4_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - this is because we don't\n\t * know if ext4_truncate() actually created an orphan record.\n\t * (Well, we could do this if we need to, but heck - it works)\n\t */\n\text4_orphan_del(handle, inode);\n\tEXT4_I(inode)->i_dtime\t= get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext4_mark_inode_dirty(handle, inode))\n\t\t/* If that failed, just do the required in-core inode clear. */\n\t\text4_clear_inode(inode);\n\telse\n\t\text4_free_inode(handle, inode);\n\text4_journal_stop(handle);\n\tsb_end_intwrite(inode->i_sb);\n\treturn;\nno_delete:\n\text4_clear_inode(inode);\t/* We must guarantee clearing of inode... */\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_inode",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "960-973",
          "snippet": "void ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid ext4_clear_inode(struct inode *inode)\n{\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\text4_discard_preallocations(inode);\n\text4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);\n\tif (EXT4_I(inode)->jinode) {\n\t\tjbd2_journal_release_jbd_inode(EXT4_JOURNAL(inode),\n\t\t\t\t\t       EXT4_I(inode)->jinode);\n\t\tjbd2_free_inode(EXT4_I(inode)->jinode);\n\t\tEXT4_I(inode)->jinode = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ialloc.c",
          "lines": "229-353",
          "snippet": "void ext4_free_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\text4_group_t block_group;\n\tunsigned long bit;\n\tstruct ext4_group_desc *gdp;\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi;\n\tint fatal = 0, err, count, cleared;\n\tstruct ext4_group_info *grp;\n\n\tif (!sb) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s:%d: inode on \"\n\t\t       \"nonexistent device\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: count=%d\",\n\t\t\t __func__, __LINE__, inode->i_ino,\n\t\t\t atomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: nlink=%d\\n\",\n\t\t\t __func__, __LINE__, inode->i_ino, inode->i_nlink);\n\t\treturn;\n\t}\n\tsbi = EXT4_SB(sb);\n\n\tino = inode->i_ino;\n\text4_debug(\"freeing inode %lu\\n\", ino);\n\ttrace_ext4_free_inode(inode);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\tdquot_initialize(inode);\n\text4_xattr_delete_inode(handle, inode);\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\t/* Do this BEFORE marking the inode not in use or returning an error */\n\text4_clear_inode(inode);\n\n\tes = EXT4_SB(sb)->s_es;\n\tif (ino < EXT4_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text4_error(sb, \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\t/* Don't bother if the inode bitmap is corrupt. */\n\tgrp = ext4_get_group_info(sb, block_group);\n\tif (unlikely(EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) || !bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\tfatal = -ESRCH;\n\tgdp = ext4_get_group_desc(sb, block_group, &bh2);\n\tif (gdp) {\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext4_journal_get_write_access(handle, bh2);\n\t}\n\text4_lock_group(sb, block_group);\n\tcleared = ext4_test_and_clear_bit(bit, bitmap_bh->b_data);\n\tif (fatal || !cleared) {\n\t\text4_unlock_group(sb, block_group);\n\t\tgoto out;\n\t}\n\n\tcount = ext4_free_inodes_count(sb, gdp) + 1;\n\text4_free_inodes_set(sb, gdp, count);\n\tif (is_directory) {\n\t\tcount = ext4_used_dirs_count(sb, gdp) - 1;\n\t\text4_used_dirs_set(sb, gdp, count);\n\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\t}\n\text4_inode_bitmap_csum_set(sb, block_group, gdp, bitmap_bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t f = ext4_flex_group(sbi, block_group);\n\n\t\tatomic_inc(&sbi->s_flex_groups[f].free_inodes);\n\t\tif (is_directory)\n\t\t\tatomic_dec(&sbi->s_flex_groups[f].used_dirs);\n\t}\n\tBUFFER_TRACE(bh2, \"call ext4_handle_dirty_metadata\");\n\tfatal = ext4_handle_dirty_metadata(handle, NULL, bh2);\nout:\n\tif (cleared) {\n\t\tBUFFER_TRACE(bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!fatal)\n\t\t\tfatal = err;\n\t} else {\n\t\text4_error(sb, \"bit already cleared for inode %lu\", ino);\n\t\tif (gdp && !EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, fatal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bitops.h>",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <asm/byteorder.h>\n#include <linux/blkdev.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid ext4_free_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint is_directory;\n\tunsigned long ino;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *bh2;\n\text4_group_t block_group;\n\tunsigned long bit;\n\tstruct ext4_group_desc *gdp;\n\tstruct ext4_super_block *es;\n\tstruct ext4_sb_info *sbi;\n\tint fatal = 0, err, count, cleared;\n\tstruct ext4_group_info *grp;\n\n\tif (!sb) {\n\t\tprintk(KERN_ERR \"EXT4-fs: %s:%d: inode on \"\n\t\t       \"nonexistent device\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\tif (atomic_read(&inode->i_count) > 1) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: count=%d\",\n\t\t\t __func__, __LINE__, inode->i_ino,\n\t\t\t atomic_read(&inode->i_count));\n\t\treturn;\n\t}\n\tif (inode->i_nlink) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: nlink=%d\\n\",\n\t\t\t __func__, __LINE__, inode->i_ino, inode->i_nlink);\n\t\treturn;\n\t}\n\tsbi = EXT4_SB(sb);\n\n\tino = inode->i_ino;\n\text4_debug(\"freeing inode %lu\\n\", ino);\n\ttrace_ext4_free_inode(inode);\n\n\t/*\n\t * Note: we must free any quota before locking the superblock,\n\t * as writing the quota to disk may need the lock as well.\n\t */\n\tdquot_initialize(inode);\n\text4_xattr_delete_inode(handle, inode);\n\tdquot_free_inode(inode);\n\tdquot_drop(inode);\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\t/* Do this BEFORE marking the inode not in use or returning an error */\n\text4_clear_inode(inode);\n\n\tes = EXT4_SB(sb)->s_es;\n\tif (ino < EXT4_FIRST_INO(sb) || ino > le32_to_cpu(es->s_inodes_count)) {\n\t\text4_error(sb, \"reserved or nonexistent inode %lu\", ino);\n\t\tgoto error_return;\n\t}\n\tblock_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tbit = (ino - 1) % EXT4_INODES_PER_GROUP(sb);\n\tbitmap_bh = ext4_read_inode_bitmap(sb, block_group);\n\t/* Don't bother if the inode bitmap is corrupt. */\n\tgrp = ext4_get_group_info(sb, block_group);\n\tif (unlikely(EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) || !bitmap_bh)\n\t\tgoto error_return;\n\n\tBUFFER_TRACE(bitmap_bh, \"get_write_access\");\n\tfatal = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (fatal)\n\t\tgoto error_return;\n\n\tfatal = -ESRCH;\n\tgdp = ext4_get_group_desc(sb, block_group, &bh2);\n\tif (gdp) {\n\t\tBUFFER_TRACE(bh2, \"get_write_access\");\n\t\tfatal = ext4_journal_get_write_access(handle, bh2);\n\t}\n\text4_lock_group(sb, block_group);\n\tcleared = ext4_test_and_clear_bit(bit, bitmap_bh->b_data);\n\tif (fatal || !cleared) {\n\t\text4_unlock_group(sb, block_group);\n\t\tgoto out;\n\t}\n\n\tcount = ext4_free_inodes_count(sb, gdp) + 1;\n\text4_free_inodes_set(sb, gdp, count);\n\tif (is_directory) {\n\t\tcount = ext4_used_dirs_count(sb, gdp) - 1;\n\t\text4_used_dirs_set(sb, gdp, count);\n\t\tpercpu_counter_dec(&sbi->s_dirs_counter);\n\t}\n\text4_inode_bitmap_csum_set(sb, block_group, gdp, bitmap_bh,\n\t\t\t\t   EXT4_INODES_PER_GROUP(sb) / 8);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tpercpu_counter_inc(&sbi->s_freeinodes_counter);\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t f = ext4_flex_group(sbi, block_group);\n\n\t\tatomic_inc(&sbi->s_flex_groups[f].free_inodes);\n\t\tif (is_directory)\n\t\t\tatomic_dec(&sbi->s_flex_groups[f].used_dirs);\n\t}\n\tBUFFER_TRACE(bh2, \"call ext4_handle_dirty_metadata\");\n\tfatal = ext4_handle_dirty_metadata(handle, NULL, bh2);\nout:\n\tif (cleared) {\n\t\tBUFFER_TRACE(bitmap_bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!fatal)\n\t\t\tfatal = err;\n\t} else {\n\t\text4_error(sb, \"bit already cleared for inode %lu\", ino);\n\t\tif (gdp && !EXT4_MB_GRP_IBITMAP_CORRUPT(grp)) {\n\t\t\tint count;\n\t\t\tcount = ext4_free_inodes_count(sb, gdp);\n\t\t\tpercpu_counter_sub(&sbi->s_freeinodes_counter,\n\t\t\t\t\t   count);\n\t\t}\n\t\tset_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, fatal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_orphan_del",
          "args": [
            "handle",
            "inode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_orphan_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "2621-2698",
          "snippet": "int ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_orphan_del(handle_t *handle, struct inode *inode)\n{\n\tstruct list_head *prev;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 ino_next;\n\tstruct ext4_iloc iloc;\n\tint err = 0;\n\n\tif (!sbi->s_journal && !(sbi->s_mount_state & EXT4_ORPHAN_FS))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!(inode->i_state & (I_NEW | I_FREEING)) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\t/* Do this quick check before taking global s_orphan_lock. */\n\tif (list_empty(&ei->i_orphan))\n\t\treturn 0;\n\n\tif (handle) {\n\t\t/* Grab inode buffer early before taking global s_orphan_lock */\n\t\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\t}\n\n\tmutex_lock(&sbi->s_orphan_lock);\n\tjbd_debug(4, \"remove inode %lu from orphan list\\n\", inode->i_ino);\n\n\tprev = ei->i_orphan.prev;\n\tlist_del_init(&ei->i_orphan);\n\n\t/* If we're on an error path, we may not have a valid\n\t * transaction handle with which to update the orphan list on\n\t * disk, but we still need to remove the inode from the linked\n\t * list in memory. */\n\tif (!handle || err) {\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\tgoto out_err;\n\t}\n\n\tino_next = NEXT_ORPHAN(inode);\n\tif (prev == &sbi->s_orphan) {\n\t\tjbd_debug(4, \"superblock will point to %u\\n\", ino_next);\n\t\tBUFFER_TRACE(sbi->s_sbh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, sbi->s_sbh);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tsbi->s_es->s_last_orphan = cpu_to_le32(ino_next);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\terr = ext4_handle_dirty_super(handle, inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc2;\n\t\tstruct inode *i_prev =\n\t\t\t&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;\n\n\t\tjbd_debug(4, \"orphan inode %lu will point to %u\\n\",\n\t\t\t  i_prev->i_ino, ino_next);\n\t\terr = ext4_reserve_inode_write(handle, i_prev, &iloc2);\n\t\tif (err) {\n\t\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t\t\tgoto out_brelse;\n\t\t}\n\t\tNEXT_ORPHAN(i_prev) = ino_next;\n\t\terr = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);\n\t\tmutex_unlock(&sbi->s_orphan_lock);\n\t}\n\tif (err)\n\t\tgoto out_brelse;\n\tNEXT_ORPHAN(inode) = 0;\n\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\nout_err:\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n\nout_brelse:\n\tbrelse(iloc.bh);\n\tgoto out_err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"couldn't extend journal (err %d)\"",
            "err"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "3"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_extend",
          "args": [
            "handle",
            "3"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "336-341",
          "snippet": "static inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_extend(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_extend(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_has_enough_credits",
          "args": [
            "handle",
            "3"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_has_enough_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "292-297",
          "snippet": "static inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_handle_has_enough_credits(handle_t *handle, int needed)\n{\n\tif (ext4_handle_valid(handle) && handle->h_buffer_credits < needed)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_truncate",
          "args": [
            "inode"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3577-3671",
          "snippet": "void ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!mutex_is_locked(&inode->i_mutex));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "inode->i_sb",
            "\"couldn't mark inode dirty (err %d)\"",
            "err"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "PTR_ERR(handle)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_TRUNCATE",
            "ext4_blocks_for_truncate(inode)+3"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_for_truncate",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_blocks_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/truncate.h",
          "lines": "21-42",
          "snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long ext4_blocks_for_truncate(struct inode *inode)\n{\n\text4_lblk_t needed;\n\n\tneeded = inode->i_blocks >> (inode->i_sb->s_blocksize_bits - 9);\n\n\t/* Give ourselves just enough room to cope with inodes in which\n\t * i_blocks is corrupt: we've seen disk corruptions in the past\n\t * which resulted in random data in an inode which looked enough\n\t * like a regular file for ext4 to try to delete it.  Things\n\t * will go a bit crazy if that happens, but at least we should\n\t * try not to panic the whole kernel. */\n\tif (needed < 2)\n\t\tneeded = 2;\n\n\t/* But we need to bound the transaction so we don't overflow the\n\t * journal. */\n\tif (needed > EXT4_MAX_TRANS_DATA)\n\t\tneeded = EXT4_MAX_TRANS_DATA;\n\n\treturn EXT4_DATA_TRANS_BLOCKS(inode->i_sb) + needed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "inode->i_sb"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&EXT4_I(inode)->i_ioend_count)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&EXT4_I(inode)->i_ioend_count"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_begin_ordered_truncate",
          "args": [
            "inode",
            "0"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_begin_ordered_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "117-132",
          "snippet": "static inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_should_order_data",
          "args": [
            "inode"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "418-421",
          "snippet": "static inline int ext4_should_order_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_ORDERED_DATA_MODE\t0x02 /* ordered data mode */\n\nstatic inline int ext4_should_order_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_ORDERED_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&EXT4_I(inode)->i_ioend_count)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&EXT4_I(inode)->i_ioend_count"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "&inode->i_data"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_complete_transaction",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_complete_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "733-754",
          "snippet": "int jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_journal_data",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_journal_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "413-416",
          "snippet": "static inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_JOURNAL_DATA_MODE\t0x01 /* journal data mode */\n\nstatic inline int ext4_should_journal_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_JOURNAL_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_evict_inode",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ext4_evict_inode(struct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\n\ttrace_ext4_evict_inode(inode);\n\n\tif (inode->i_nlink) {\n\t\t/*\n\t\t * When journalling data dirty buffers are tracked only in the\n\t\t * journal. So although mm thinks everything is clean and\n\t\t * ready for reaping the inode might still have some pages to\n\t\t * write in the running transaction or waiting to be\n\t\t * checkpointed. Thus calling jbd2_journal_invalidatepage()\n\t\t * (via truncate_inode_pages()) to discard these buffers can\n\t\t * cause data loss. Also even if we did not discard these\n\t\t * buffers, we would have no way to find them after the inode\n\t\t * is reaped and thus user could see stale data if he tries to\n\t\t * read them before the transaction is checkpointed. So be\n\t\t * careful and force everything to disk here... We use\n\t\t * ei->i_datasync_tid to store the newest transaction\n\t\t * containing inode's data.\n\t\t *\n\t\t * Note that directories do not have this problem because they\n\t\t * don't use page cache.\n\t\t */\n\t\tif (ext4_should_journal_data(inode) &&\n\t\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t\t    inode->i_ino != EXT4_JOURNAL_INO) {\n\t\t\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\t\t\ttid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n\n\t\t\tjbd2_complete_transaction(journal, commit_tid);\n\t\t\tfilemap_write_and_wait(&inode->i_data);\n\t\t}\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\tWARN_ON(atomic_read(&EXT4_I(inode)->i_ioend_count));\n\t\tgoto no_delete;\n\t}\n\n\tif (is_bad_inode(inode))\n\t\tgoto no_delete;\n\tdquot_initialize(inode);\n\n\tif (ext4_should_order_data(inode))\n\t\text4_begin_ordered_truncate(inode, 0);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\tWARN_ON(atomic_read(&EXT4_I(inode)->i_ioend_count));\n\n\t/*\n\t * Protect us against freezing - iput() caller didn't have to have any\n\t * protection against it\n\t */\n\tsb_start_intwrite(inode->i_sb);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE,\n\t\t\t\t    ext4_blocks_for_truncate(inode)+3);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text4_orphan_del(NULL, inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_size = 0;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"couldn't mark inode dirty (err %d)\", err);\n\t\tgoto stop_handle;\n\t}\n\tif (inode->i_blocks)\n\t\text4_truncate(inode);\n\n\t/*\n\t * ext4_ext_truncate() doesn't reserve any slop when it\n\t * restarts journal transactions; therefore there may not be\n\t * enough credits left in the handle to remove the inode from\n\t * the orphan list and set the dtime field.\n\t */\n\tif (!ext4_handle_has_enough_credits(handle, 3)) {\n\t\terr = ext4_journal_extend(handle, 3);\n\t\tif (err > 0)\n\t\t\terr = ext4_journal_restart(handle, 3);\n\t\tif (err != 0) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"couldn't extend journal (err %d)\", err);\n\t\tstop_handle:\n\t\t\text4_journal_stop(handle);\n\t\t\text4_orphan_del(NULL, inode);\n\t\t\tsb_end_intwrite(inode->i_sb);\n\t\t\tgoto no_delete;\n\t\t}\n\t}\n\n\t/*\n\t * Kill off the orphan record which ext4_truncate created.\n\t * AKPM: I think this can be inside the above `if'.\n\t * Note that ext4_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - this is because we don't\n\t * know if ext4_truncate() actually created an orphan record.\n\t * (Well, we could do this if we need to, but heck - it works)\n\t */\n\text4_orphan_del(handle, inode);\n\tEXT4_I(inode)->i_dtime\t= get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext4_mark_inode_dirty(handle, inode))\n\t\t/* If that failed, just do the required in-core inode clear. */\n\t\text4_clear_inode(inode);\n\telse\n\t\text4_free_inode(handle, inode);\n\text4_journal_stop(handle);\n\tsb_end_intwrite(inode->i_sb);\n\treturn;\nno_delete:\n\text4_clear_inode(inode);\t/* We must guarantee clearing of inode... */\n}"
  },
  {
    "function_name": "ext4_truncate_restart_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "160-179",
    "snippet": "int ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3920-4020",
          "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_restart",
          "args": [
            "handle",
            "nblocks"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "343-348",
          "snippet": "static inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_journal_restart(handle_t *handle, int nblocks)\n{\n\tif (ext4_handle_valid(handle))\n\t\treturn jbd2_journal_restart(handle, nblocks);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->i_data_sem"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"restarting handle %p\\n\"",
            "handle"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "EXT4_JOURNAL(inode) == NULL"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_inode_is_fast_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "144-153",
    "snippet": "static int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTER_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}"
  },
  {
    "function_name": "ext4_begin_ordered_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "117-132",
    "snippet": "static inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_begin_ordered_truncate",
          "args": [
            "EXT4_JOURNAL(inode)",
            "EXT4_I(inode)->jinode",
            "new_size"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_begin_ordered_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2453-2480",
          "snippet": "int jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\t\tstruct jbd2_inode *jinode,\n\t\t\t\t\tloff_t new_size)\n{\n\ttransaction_t *inode_trans, *commit_trans;\n\tint ret = 0;\n\n\t/* This is a quick check to avoid locking if not necessary */\n\tif (!jinode->i_transaction)\n\t\tgoto out;\n\t/* Locks are here just to force reading of recent values, it is\n\t * enough that the transaction was not committing before we started\n\t * a transaction adding the inode to orphan list */\n\tread_lock(&journal->j_state_lock);\n\tcommit_trans = journal->j_committing_transaction;\n\tread_unlock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tinode_trans = jinode->i_transaction;\n\tspin_unlock(&journal->j_list_lock);\n\tif (inode_trans == commit_trans) {\n\t\tret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n\t\t\tnew_size, LLONG_MAX);\n\t\tif (ret)\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_begin_ordered_truncate(journal_t *journal,\n\t\t\t\t\tstruct jbd2_inode *jinode,\n\t\t\t\t\tloff_t new_size)\n{\n\ttransaction_t *inode_trans, *commit_trans;\n\tint ret = 0;\n\n\t/* This is a quick check to avoid locking if not necessary */\n\tif (!jinode->i_transaction)\n\t\tgoto out;\n\t/* Locks are here just to force reading of recent values, it is\n\t * enough that the transaction was not committing before we started\n\t * a transaction adding the inode to orphan list */\n\tread_lock(&journal->j_state_lock);\n\tcommit_trans = journal->j_committing_transaction;\n\tread_unlock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tinode_trans = jinode->i_transaction;\n\tspin_unlock(&journal->j_list_lock);\n\tif (inode_trans == commit_trans) {\n\t\tret = filemap_fdatawrite_range(jinode->i_vfs_inode->i_mapping,\n\t\t\tnew_size, LLONG_MAX);\n\t\tif (ret)\n\t\t\tjbd2_journal_abort(journal, ret);\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_begin_ordered_truncate",
          "args": [
            "inode",
            "new_size"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}"
  },
  {
    "function_name": "ext4_inode_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "100-115",
    "snippet": "static void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "csum >> 16"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw",
            "ei",
            "i_checksum_hi"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "csum & 0xFFFF"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_csum",
          "args": [
            "inode",
            "raw",
            "ei"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "100-115",
          "snippet": "static void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_OS_LINUX"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}"
  },
  {
    "function_name": "ext4_inode_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "79-98",
    "snippet": "static int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw->i_checksum_hi"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw",
            "ei",
            "i_checksum_hi"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_inode_csum",
          "args": [
            "inode",
            "raw",
            "ei"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "100-115",
          "snippet": "static void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_OS_LINUX"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}"
  },
  {
    "function_name": "ext4_inode_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
    "lines": "52-77",
    "snippet": "static __u32 ext4_inode_csum(struct inode *inode, struct ext4_inode *raw,\n\t\t\t      struct ext4_inode_info *ei)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u16 csum_lo;\n\t__u16 csum_hi = 0;\n\t__u32 csum;\n\n\tcsum_lo = le16_to_cpu(raw->i_checksum_lo);\n\traw->i_checksum_lo = 0;\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi)) {\n\t\tcsum_hi = le16_to_cpu(raw->i_checksum_hi);\n\t\traw->i_checksum_hi = 0;\n\t}\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)raw,\n\t\t\t   EXT4_INODE_SIZE(inode->i_sb));\n\n\traw->i_checksum_lo = cpu_to_le16(csum_lo);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum_hi);\n\n\treturn csum;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include \"truncate.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/aio.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/slab.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/bio.h>",
      "#include <linux/uio.h>",
      "#include <linux/namei.h>",
      "#include <linux/mpage.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highuid.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "csum_hi"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw",
            "ei",
            "i_checksum_hi"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "csum_lo"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "ei->i_csum_seed",
            "(__u8 *)raw",
            "EXT4_INODE_SIZE(inode->i_sb)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "raw->i_checksum_hi"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_FITS_IN_INODE",
          "args": [
            "raw",
            "ei",
            "i_checksum_hi"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_INODE_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic __u32 ext4_inode_csum(struct inode *inode, struct ext4_inode *raw,\n\t\t\t      struct ext4_inode_info *ei)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u16 csum_lo;\n\t__u16 csum_hi = 0;\n\t__u32 csum;\n\n\tcsum_lo = le16_to_cpu(raw->i_checksum_lo);\n\traw->i_checksum_lo = 0;\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi)) {\n\t\tcsum_hi = le16_to_cpu(raw->i_checksum_hi);\n\t\traw->i_checksum_hi = 0;\n\t}\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)raw,\n\t\t\t   EXT4_INODE_SIZE(inode->i_sb));\n\n\traw->i_checksum_lo = cpu_to_le16(csum_lo);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum_hi);\n\n\treturn csum;\n}"
  }
]