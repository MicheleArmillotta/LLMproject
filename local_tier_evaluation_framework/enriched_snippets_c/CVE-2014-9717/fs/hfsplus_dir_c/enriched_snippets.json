[
  {
    "function_name": "hfsplus_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "526-547",
    "snippet": "static int hfsplus_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint res;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tif (d_is_dir(new_dentry))\n\t\t\tres = hfsplus_rmdir(new_dir, new_dentry);\n\t\telse\n\t\t\tres = hfsplus_unlink(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfsplus_rename_cat((u32)(unsigned long)old_dentry->d_fsdata,\n\t\t\t\t old_dir, &old_dentry->d_name,\n\t\t\t\t new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\tnew_dentry->d_fsdata = old_dentry->d_fsdata;\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_rename_cat",
          "args": [
            "(u32)(unsigned long)old_dentry->d_fsdata",
            "old_dir",
            "&old_dentry->d_name",
            "new_dir",
            "&new_dentry->d_name"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_rename_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "413-520",
          "snippet": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_unlink",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "353-408",
          "snippet": "static int hfsplus_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tcnid = (u32)(unsigned long)dentry->d_fsdata;\n\tif (inode->i_ino == cnid &&\n\t    atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\tstr.name = name;\n\t\tstr.len = sprintf(name, \"temp%lu\", inode->i_ino);\n\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t dir, &dentry->d_name,\n\t\t\t\t\t sbi->hidden_dir, &str);\n\t\tif (!res) {\n\t\t\tinode->i_flags |= S_DEAD;\n\t\t\tdrop_nlink(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tres = hfsplus_delete_cat(cnid, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tif (inode->i_ino == cnid)\n\t\tclear_nlink(inode);\n\tif (!inode->i_nlink) {\n\t\tif (inode->i_ino != cnid) {\n\t\t\tsbi->file_count--;\n\t\t\tif (!atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\t\t\tres = hfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t\t\t sbi->hidden_dir,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\thfsplus_delete_inode(inode);\n\t\t\t} else\n\t\t\t\tinode->i_flags |= S_DEAD;\n\t\t} else\n\t\t\thfsplus_delete_inode(inode);\n\t} else\n\t\tsbi->file_count--;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tcnid = (u32)(unsigned long)dentry->d_fsdata;\n\tif (inode->i_ino == cnid &&\n\t    atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\tstr.name = name;\n\t\tstr.len = sprintf(name, \"temp%lu\", inode->i_ino);\n\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t dir, &dentry->d_name,\n\t\t\t\t\t sbi->hidden_dir, &str);\n\t\tif (!res) {\n\t\t\tinode->i_flags |= S_DEAD;\n\t\t\tdrop_nlink(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tres = hfsplus_delete_cat(cnid, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tif (inode->i_ino == cnid)\n\t\tclear_nlink(inode);\n\tif (!inode->i_nlink) {\n\t\tif (inode->i_ino != cnid) {\n\t\t\tsbi->file_count--;\n\t\t\tif (!atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\t\t\tres = hfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t\t\t sbi->hidden_dir,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\thfsplus_delete_inode(inode);\n\t\t\t} else\n\t\t\t\tinode->i_flags |= S_DEAD;\n\t\t} else\n\t\t\thfsplus_delete_inode(inode);\n\t} else\n\t\tsbi->file_count--;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_rmdir",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "410-430",
          "snippet": "static int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "new_dentry"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t  struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint res;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tif (d_is_dir(new_dentry))\n\t\t\tres = hfsplus_rmdir(new_dir, new_dentry);\n\t\telse\n\t\t\tres = hfsplus_unlink(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfsplus_rename_cat((u32)(unsigned long)old_dentry->d_fsdata,\n\t\t\t\t old_dir, &old_dentry->d_name,\n\t\t\t\t new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\tnew_dentry->d_fsdata = old_dentry->d_fsdata;\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "521-524",
    "snippet": "static int hfsplus_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn hfsplus_mknod(dir, dentry, mode | S_IFDIR, 0);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mknod",
          "args": [
            "dir",
            "dentry",
            "mode | S_IFDIR",
            "0"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "474-513",
          "snippet": "static int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\treturn hfsplus_mknod(dir, dentry, mode | S_IFDIR, 0);\n}"
  },
  {
    "function_name": "hfsplus_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "515-519",
    "snippet": "static int hfsplus_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t  bool excl)\n{\n\treturn hfsplus_mknod(dir, dentry, mode, 0);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mknod",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "474-513",
          "snippet": "static int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t  bool excl)\n{\n\treturn hfsplus_mknod(dir, dentry, mode, 0);\n}"
  },
  {
    "function_name": "hfsplus_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "474-513",
    "snippet": "static int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_inode",
          "args": [
            "inode"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "414-434",
          "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_instantiate",
          "args": [
            "dentry",
            "inode",
            "inode->i_ino"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "22-27",
          "snippet": "static inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_init_inode_security",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_inode_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
          "lines": "107-117",
          "snippet": "int hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_create_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name",
            "inode"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "252-319",
          "snippet": "int hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "mode",
            "rdev"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_new_inode",
          "args": [
            "dir->i_sb",
            "mode"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "356-412",
          "snippet": "struct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
            "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
            "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nstruct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t umode_t mode, dev_t rdev)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out;\n\n\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode))\n\t\tinit_special_inode(inode, mode, rdev);\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto failed_mknod;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto failed_mknod;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nfailed_mknod:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "432-472",
    "snippet": "static int hfsplus_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t   const char *symname)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, S_IFLNK | S_IRWXUGO);\n\tif (!inode)\n\t\tgoto out;\n\n\tres = page_symlink(inode, symname, strlen(symname) + 1);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto out_err;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nout_err:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_inode",
          "args": [
            "inode"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "414-434",
          "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_instantiate",
          "args": [
            "dentry",
            "inode",
            "inode->i_ino"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "22-27",
          "snippet": "static inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_init_inode_security",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_init_inode_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr_security.c",
          "lines": "107-117",
          "snippet": "int hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/security.h>\n\nint hfsplus_init_inode_security(struct inode *inode,\n\t\t\t\t\t\tstruct inode *dir,\n\t\t\t\t\t\tconst struct qstr *qstr)\n{\n\tint err;\n\n\terr = hfsplus_init_posix_acl(inode, dir);\n\tif (!err)\n\t\terr = hfsplus_init_security(inode, dir, qstr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_create_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name",
            "inode"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "252-319",
          "snippet": "int hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "strlen(symname) + 1"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_new_inode",
          "args": [
            "dir->i_sb",
            "S_IFLNK | S_IRWXUGO"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "356-412",
          "snippet": "struct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};",
            "static const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};",
            "static const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nconst struct address_space_operations hfsplus_aops = {\n\t.readpage\t= hfsplus_readpage,\n\t.writepage\t= hfsplus_writepage,\n\t.write_begin\t= hfsplus_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfsplus_bmap,\n\t.direct_IO\t= hfsplus_direct_IO,\n\t.writepages\t= hfsplus_writepages,\n};\nstatic const struct inode_operations hfsplus_file_inode_operations = {\n\t.setattr\t= hfsplus_setattr,\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= hfsplus_listxattr,\n\t.removexattr\t= generic_removexattr,\n#ifdef CONFIG_HFSPLUS_FS_POSIX_ACL\n\t.get_acl\t= hfsplus_get_posix_acl,\n\t.set_acl\t= hfsplus_set_posix_acl,\n#endif\n};\nstatic const struct file_operations hfsplus_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfsplus_file_fsync,\n\t.open\t\t= hfsplus_file_open,\n\t.release\t= hfsplus_file_release,\n\t.unlocked_ioctl = hfsplus_ioctl,\n};\n\nstruct inode *hfsplus_new_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct inode *inode = new_inode(sb);\n\tstruct hfsplus_inode_info *hip;\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = sbi->next_cnid++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\n\thip = HFSPLUS_I(inode);\n\tINIT_LIST_HEAD(&hip->open_dir_list);\n\tmutex_init(&hip->extents_lock);\n\tatomic_set(&hip->opencnt, 0);\n\thip->extent_state = 0;\n\thip->flags = 0;\n\thip->userflags = 0;\n\thip->subfolders = 0;\n\tmemset(hip->first_extents, 0, sizeof(hfsplus_extent_rec));\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->alloc_blocks = 0;\n\thip->first_blocks = 0;\n\thip->cached_start = 0;\n\thip->cached_blocks = 0;\n\thip->phys_size = 0;\n\thip->fs_blocks = 0;\n\thip->rsrc_inode = NULL;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_size = 2;\n\t\tsbi->folder_count++;\n\t\tinode->i_op = &hfsplus_dir_inode_operations;\n\t\tinode->i_fop = &hfsplus_dir_operations;\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &hfsplus_file_inode_operations;\n\t\tinode->i_fop = &hfsplus_file_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = sbi->data_clump_blocks;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tsbi->file_count++;\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &hfsplus_aops;\n\t\thip->clump_blocks = 1;\n\t} else\n\t\tsbi->file_count++;\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\thfsplus_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t   const char *symname)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode;\n\tint res = -ENOSPC;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tinode = hfsplus_new_inode(dir->i_sb, S_IFLNK | S_IRWXUGO);\n\tif (!inode)\n\t\tgoto out;\n\n\tres = page_symlink(inode, symname, strlen(symname) + 1);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_create_cat(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = hfsplus_init_inode_security(inode, dir, &dentry->d_name);\n\tif (res == -EOPNOTSUPP)\n\t\tres = 0; /* Operation is not supported. */\n\telse if (res) {\n\t\t/* Try to delete anyway without error analysis. */\n\t\thfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\t\tgoto out_err;\n\t}\n\n\thfsplus_instantiate(dentry, inode, inode->i_ino);\n\tmark_inode_dirty(inode);\n\tgoto out;\n\nout_err:\n\tclear_nlink(inode);\n\thfsplus_delete_inode(inode);\n\tiput(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "410-430",
    "snippet": "static int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_inode",
          "args": [
            "inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "414-434",
          "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "353-408",
    "snippet": "static int hfsplus_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tcnid = (u32)(unsigned long)dentry->d_fsdata;\n\tif (inode->i_ino == cnid &&\n\t    atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\tstr.name = name;\n\t\tstr.len = sprintf(name, \"temp%lu\", inode->i_ino);\n\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t dir, &dentry->d_name,\n\t\t\t\t\t sbi->hidden_dir, &str);\n\t\tif (!res) {\n\t\t\tinode->i_flags |= S_DEAD;\n\t\t\tdrop_nlink(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tres = hfsplus_delete_cat(cnid, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tif (inode->i_ino == cnid)\n\t\tclear_nlink(inode);\n\tif (!inode->i_nlink) {\n\t\tif (inode->i_ino != cnid) {\n\t\t\tsbi->file_count--;\n\t\t\tif (!atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\t\t\tres = hfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t\t\t sbi->hidden_dir,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\thfsplus_delete_inode(inode);\n\t\t\t} else\n\t\t\t\tinode->i_flags |= S_DEAD;\n\t\t} else\n\t\t\thfsplus_delete_inode(inode);\n\t} else\n\t\tsbi->file_count--;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_inode",
          "args": [
            "inode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/inode.c",
          "lines": "414-434",
          "snippet": "void hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n\nvoid hfsplus_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFSPLUS_SB(sb)->folder_count--;\n\t\thfsplus_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFSPLUS_SB(sb)->file_count--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfsplus_file_truncate(inode);\n\t\t}\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\thfsplus_file_truncate(inode);\n\t}\n\thfsplus_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_delete_cat",
          "args": [
            "inode->i_ino",
            "sbi->hidden_dir",
            "NULL"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_delete_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "321-411",
          "snippet": "int hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_delete_cat(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_fork_raw fork;\n\tstruct list_head *pos;\n\tint err, off;\n\tu16 type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\tif (!str) {\n\t\tint len;\n\n\t\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\t\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_thread, nodeName);\n\t\tfd.search_key->cat.parent = cpu_to_be32(dir->i_ino);\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.length, off, 2);\n\t\tlen = be16_to_cpu(fd.search_key->cat.name.length) * 2;\n\t\thfs_bnode_read(fd.bnode,\n\t\t\t&fd.search_key->cat.name.unicode,\n\t\t\toff + 2, len);\n\t\tfd.search_key->key_len = cpu_to_be16(6 + len);\n\t} else\n\t\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u16(fd.bnode, fd.entryoffset);\n\tif (type == HFSPLUS_FILE) {\n#if 0\n\t\toff = fd.entryoffset + offsetof(hfsplus_cat_file, data_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_DATA);\n#endif\n\n\t\toff = fd.entryoffset +\n\t\t\toffsetof(struct hfsplus_cat_file, rsrc_fork);\n\t\thfs_bnode_read(fd.bnode, &fork, off, sizeof(fork));\n\t\thfsplus_free_fork(sb, cnid, &fork, HFSPLUS_TYPE_RSRC);\n\t}\n\n\tlist_for_each(pos, &HFSPLUS_I(dir)->open_dir_list) {\n\t\tstruct hfsplus_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfsplus_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\terr = hfs_brec_remove(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tdir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\tif (type == HFSPLUS_FILE || type == HFSPLUS_FOLDER) {\n\t\tif (HFSPLUS_SB(sb)->attr_tree)\n\t\t\thfsplus_delete_all_attrs(dir, cnid);\n\t}\n\nout:\n\thfs_find_exit(&fd);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&HFSPLUS_I(inode)->opencnt"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "127-131",
          "snippet": "static inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_drop_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink > 2)\n\t\tdrop_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_rename_cat",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name",
            "sbi->hidden_dir",
            "&str"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_rename_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "413-520",
          "snippet": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"temp%lu\"",
            "inode->i_ino"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&HFSPLUS_I(inode)->opencnt"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tcnid = (u32)(unsigned long)dentry->d_fsdata;\n\tif (inode->i_ino == cnid &&\n\t    atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\tstr.name = name;\n\t\tstr.len = sprintf(name, \"temp%lu\", inode->i_ino);\n\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t dir, &dentry->d_name,\n\t\t\t\t\t sbi->hidden_dir, &str);\n\t\tif (!res) {\n\t\t\tinode->i_flags |= S_DEAD;\n\t\t\tdrop_nlink(inode);\n\t\t}\n\t\tgoto out;\n\t}\n\tres = hfsplus_delete_cat(cnid, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\n\tif (inode->i_nlink > 0)\n\t\tdrop_nlink(inode);\n\tif (inode->i_ino == cnid)\n\t\tclear_nlink(inode);\n\tif (!inode->i_nlink) {\n\t\tif (inode->i_ino != cnid) {\n\t\t\tsbi->file_count--;\n\t\t\tif (!atomic_read(&HFSPLUS_I(inode)->opencnt)) {\n\t\t\t\tres = hfsplus_delete_cat(inode->i_ino,\n\t\t\t\t\t\t\t sbi->hidden_dir,\n\t\t\t\t\t\t\t NULL);\n\t\t\t\tif (!res)\n\t\t\t\t\thfsplus_delete_inode(inode);\n\t\t\t} else\n\t\t\t\tinode->i_flags |= S_DEAD;\n\t\t} else\n\t\t\thfsplus_delete_inode(inode);\n\t} else\n\t\tsbi->file_count--;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "295-351",
    "snippet": "static int hfsplus_link(struct dentry *src_dentry, struct inode *dst_dir,\n\t\t\tstruct dentry *dst_dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dst_dir->i_sb);\n\tstruct inode *inode = src_dentry->d_inode;\n\tstruct inode *src_dir = src_dentry->d_parent->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid, id;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tif (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {\n\t\tfor (;;) {\n\t\t\tget_random_bytes(&id, sizeof(cnid));\n\t\t\tid &= 0x3fffffff;\n\t\t\tstr.name = name;\n\t\t\tstr.len = sprintf(name, \"iNode%d\", id);\n\t\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t\t src_dir, &src_dentry->d_name,\n\t\t\t\t\t\t sbi->hidden_dir, &str);\n\t\t\tif (!res)\n\t\t\t\tbreak;\n\t\t\tif (res != -EEXIST)\n\t\t\t\tgoto out;\n\t\t}\n\t\tHFSPLUS_I(inode)->linkid = id;\n\t\tcnid = sbi->next_cnid++;\n\t\tsrc_dentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\tres = hfsplus_create_cat(cnid, src_dir,\n\t\t\t&src_dentry->d_name, inode);\n\t\tif (res)\n\t\t\t/* panic? */\n\t\t\tgoto out;\n\t\tsbi->file_count++;\n\t}\n\tcnid = sbi->next_cnid++;\n\tres = hfsplus_create_cat(cnid, dst_dir, &dst_dentry->d_name, inode);\n\tif (res)\n\t\tgoto out;\n\n\tinc_nlink(inode);\n\thfsplus_instantiate(dst_dentry, inode, cnid);\n\tihold(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tsbi->file_count++;\n\thfsplus_mark_mdb_dirty(dst_dir->i_sb);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_mdb_dirty",
          "args": [
            "dst_dir->i_sb"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_mdb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "258-273",
          "snippet": "void hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\n\nvoid hfsplus_mark_mdb_dirty(struct super_block *sb)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_instantiate",
          "args": [
            "dst_dentry",
            "inode",
            "cnid"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
          "lines": "22-27",
          "snippet": "static inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/random.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "coda_dir_inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "121-125",
          "snippet": "static inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic inline void coda_dir_inc_nlink(struct inode *dir)\n{\n\tif (dir->i_nlink >= 2)\n\t\tinc_nlink(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_create_cat",
          "args": [
            "cnid",
            "dst_dir",
            "&dst_dentry->d_name",
            "inode"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_create_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "252-319",
          "snippet": "int hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_create_cat(u32 cnid, struct inode *dir,\n\t\tstruct qstr *str, struct inode *inode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct hfs_find_data fd;\n\thfsplus_cat_entry entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry,\n\t\tS_ISDIR(inode->i_mode) ?\n\t\t\tHFSPLUS_FOLDER_THREAD : HFSPLUS_FILE_THREAD,\n\t\tdir->i_ino, str);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto err2;\n\t}\n\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tif (unlikely(err))\n\t\tgoto err1;\n\n\tentry_size = hfsplus_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tif (S_ISDIR(inode->i_mode))\n\t\thfsplus_subfolders_inc(dir);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_mark_inode_dirty(dir, HFSPLUS_I_CAT_DIRTY);\n\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, cnid);\n\tif (!hfs_brec_find(&fd, hfs_find_rec_by_key))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_rename_cat",
          "args": [
            "inode->i_ino",
            "src_dir",
            "&src_dentry->d_name",
            "sbi->hidden_dir",
            "&str"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_rename_cat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "413-520",
          "snippet": "int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\ttype = be16_to_cpu(entry.type);\n\n\t/* create new dir entry with the data from the old entry */\n\terr = hfsplus_cat_build_key(sb, dst_fd.search_key,\n\t\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_inc(dst_dir);\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* finally remove the old entry */\n\terr = hfsplus_cat_build_key(sb, src_fd.search_key,\n\t\t\tsrc_dir->i_ino, src_name);\n\tif (unlikely(err))\n\t\tgoto out;\n\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tif (type == HFSPLUS_FOLDER)\n\t\thfsplus_subfolders_dec(src_dir);\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t/* remove old thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, src_fd.search_key, cnid);\n\terr = hfs_brec_find(&src_fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfsplus_cat_build_key_with_cnid(sb, dst_fd.search_key, cnid);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\tif (unlikely(entry_size < 0)) {\n\t\terr = entry_size;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_find(&dst_fd, hfs_find_rec_by_key);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"iNode%d\"",
            "id"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&id",
            "sizeof(cnid)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->vh_mutex"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "dst_dir->i_sb"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_link(struct dentry *src_dentry, struct inode *dst_dir,\n\t\t\tstruct dentry *dst_dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dst_dir->i_sb);\n\tstruct inode *inode = src_dentry->d_inode;\n\tstruct inode *src_dir = src_dentry->d_parent->d_inode;\n\tstruct qstr str;\n\tchar name[32];\n\tu32 cnid, id;\n\tint res;\n\n\tif (HFSPLUS_IS_RSRC(inode))\n\t\treturn -EPERM;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tif (inode->i_ino == (u32)(unsigned long)src_dentry->d_fsdata) {\n\t\tfor (;;) {\n\t\t\tget_random_bytes(&id, sizeof(cnid));\n\t\t\tid &= 0x3fffffff;\n\t\t\tstr.name = name;\n\t\t\tstr.len = sprintf(name, \"iNode%d\", id);\n\t\t\tres = hfsplus_rename_cat(inode->i_ino,\n\t\t\t\t\t\t src_dir, &src_dentry->d_name,\n\t\t\t\t\t\t sbi->hidden_dir, &str);\n\t\t\tif (!res)\n\t\t\t\tbreak;\n\t\t\tif (res != -EEXIST)\n\t\t\t\tgoto out;\n\t\t}\n\t\tHFSPLUS_I(inode)->linkid = id;\n\t\tcnid = sbi->next_cnid++;\n\t\tsrc_dentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\tres = hfsplus_create_cat(cnid, src_dir,\n\t\t\t&src_dentry->d_name, inode);\n\t\tif (res)\n\t\t\t/* panic? */\n\t\t\tgoto out;\n\t\tsbi->file_count++;\n\t}\n\tcnid = sbi->next_cnid++;\n\tres = hfsplus_create_cat(cnid, dst_dir, &dst_dentry->d_name, inode);\n\tif (res)\n\t\tgoto out;\n\n\tinc_nlink(inode);\n\thfsplus_instantiate(dst_dentry, inode, cnid);\n\tihold(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tsbi->file_count++;\n\thfsplus_mark_mdb_dirty(dst_dir->i_sb);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "283-293",
    "snippet": "static int hfsplus_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfsplus_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tlist_del(&rd->list);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rd->list"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfsplus_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tlist_del(&rd->list);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "131-281",
    "snippet": "static int hfsplus_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar *strbuf;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (file->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, inode->i_ino);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t/* This is completely artificial... */\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tpr_err(\"truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\ttype = be16_to_cpu(entry.type);\n\t\tlen = NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tu16 mode;\n\t\t\tunsigned type = DT_UNKNOWN;\n\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmode = be16_to_cpu(entry.file.permissions.mode);\n\t\t\tif (S_ISREG(mode))\n\t\t\t\ttype = DT_REG;\n\t\t\telse if (S_ISLNK(mode))\n\t\t\t\ttype = DT_LNK;\n\t\t\telse if (S_ISFIFO(mode))\n\t\t\t\ttype = DT_FIFO;\n\t\t\telse if (S_ISCHR(mode))\n\t\t\t\ttype = DT_CHR;\n\t\t\telse if (S_ISBLK(mode))\n\t\t\t\ttype = DT_BLK;\n\t\t\telse if (S_ISSOCK(mode))\n\t\t\t\ttype = DT_SOCK;\n\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t      be32_to_cpu(entry.file.id), type))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\tkfree(strbuf);\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "strbuf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rd->key",
            "fd.key",
            "sizeof(struct hfsplus_cat_key)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rd->list",
            "&HFSPLUS_I(inode)->open_dir_list"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct hfsplus_readdir_data)",
            "GFP_KERNEL"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_goto",
          "args": [
            "&fd",
            "1"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_goto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "232-295",
          "snippet": "int hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog entry type\\n\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "strbuf",
            "len",
            "be32_to_cpu(entry.file.id)",
            "type"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.file.id"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.file.permissions.mode"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"small file entry\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "strbuf",
            "len",
            "be32_to_cpu(entry.folder.id)",
            "DT_DIR"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.folder.id"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.folder.id"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"small dir entry\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_uni2asc",
          "args": [
            "sb",
            "&fd.key->cat.name",
            "strbuf",
            "&len"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_uni2asc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/unicode.c",
          "lines": "121-249",
          "snippet": "int hfsplus_uni2asc(struct super_block *sb,\n\t\tconst struct hfsplus_unistr *ustr,\n\t\tchar *astr, int *len_p)\n{\n\tconst hfsplus_unichr *ip;\n\tstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\n\tu8 *op;\n\tu16 cc, c0, c1;\n\tu16 *ce1, *ce2;\n\tint i, len, ustrlen, res, compose;\n\n\top = astr;\n\tip = ustr->unicode;\n\tustrlen = be16_to_cpu(ustr->length);\n\tlen = *len_p;\n\tce1 = NULL;\n\tcompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\n\twhile (ustrlen > 0) {\n\t\tc0 = be16_to_cpu(*ip++);\n\t\tustrlen--;\n\t\t/* search for single decomposed char */\n\t\tif (likely(compose))\n\t\t\tce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\n\t\tif (ce1)\n\t\t\tcc = ce1[0];\n\t\telse\n\t\t\tcc = 0;\n\t\tif (cc) {\n\t\t\t/* start of a possibly decomposed Hangul char */\n\t\t\tif (cc != 0xffff)\n\t\t\t\tgoto done;\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip) - Hangul_VBase;\n\t\t\tif (c1 < Hangul_VCount) {\n\t\t\t\t/* compose the Hangul char */\n\t\t\t\tcc = (c0 - Hangul_LBase) * Hangul_VCount;\n\t\t\t\tcc = (cc + c1) * Hangul_TCount;\n\t\t\t\tcc += Hangul_SBase;\n\t\t\t\tip++;\n\t\t\t\tustrlen--;\n\t\t\t\tif (!ustrlen)\n\t\t\t\t\tgoto done;\n\t\t\t\tc1 = be16_to_cpu(*ip) - Hangul_TBase;\n\t\t\t\tif (c1 > 0 && c1 < Hangul_TCount) {\n\t\t\t\t\tcc += c1;\n\t\t\t\t\tip++;\n\t\t\t\t\tustrlen--;\n\t\t\t\t}\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\t/* main loop for common case of not composed chars */\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip);\n\t\t\tif (likely(compose))\n\t\t\t\tce1 = hfsplus_compose_lookup(\n\t\t\t\t\thfsplus_compose_table, c1);\n\t\t\tif (ce1)\n\t\t\t\tbreak;\n\t\t\tswitch (c0) {\n\t\t\tcase 0:\n\t\t\t\tc0 = 0x2400;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc0 = ':';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = nls->uni2char(c0, op, len);\n\t\t\tif (res < 0) {\n\t\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*op = '?';\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t\top += res;\n\t\t\tlen -= res;\n\t\t\tc0 = c1;\n\t\t\tip++;\n\t\t\tustrlen--;\n\t\t}\n\t\tce2 = hfsplus_compose_lookup(ce1, c0);\n\t\tif (ce2) {\n\t\t\ti = 1;\n\t\t\twhile (i < ustrlen) {\n\t\t\t\tce1 = hfsplus_compose_lookup(ce2,\n\t\t\t\t\tbe16_to_cpu(ip[i]));\n\t\t\t\tif (!ce1)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\tce2 = ce1;\n\t\t\t}\n\t\t\tcc = ce2[0];\n\t\t\tif (cc) {\n\t\t\t\tip += i;\n\t\t\t\tustrlen -= i;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nsame:\n\t\tswitch (c0) {\n\t\tcase 0:\n\t\t\tcc = 0x2400;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcc = ':';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcc = c0;\n\t\t}\ndone:\n\t\tres = nls->uni2char(cc, op, len);\n\t\tif (res < 0) {\n\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\tgoto out;\n\t\t\t*op = '?';\n\t\t\tres = 1;\n\t\t}\n\t\top += res;\n\t\tlen -= res;\n\t}\n\tres = 0;\nout:\n\t*len_p = (char *)op - astr;\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define Hangul_TCount\t28",
            "#define Hangul_VCount\t21",
            "#define Hangul_TBase\t0x11a7",
            "#define Hangul_VBase\t0x1161",
            "#define Hangul_LBase\t0x1100",
            "#define Hangul_SBase\t0xac00"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\n#define Hangul_TCount\t28\n#define Hangul_VCount\t21\n#define Hangul_TBase\t0x11a7\n#define Hangul_VBase\t0x1161\n#define Hangul_LBase\t0x1100\n#define Hangul_SBase\t0xac00\n\nint hfsplus_uni2asc(struct super_block *sb,\n\t\tconst struct hfsplus_unistr *ustr,\n\t\tchar *astr, int *len_p)\n{\n\tconst hfsplus_unichr *ip;\n\tstruct nls_table *nls = HFSPLUS_SB(sb)->nls;\n\tu8 *op;\n\tu16 cc, c0, c1;\n\tu16 *ce1, *ce2;\n\tint i, len, ustrlen, res, compose;\n\n\top = astr;\n\tip = ustr->unicode;\n\tustrlen = be16_to_cpu(ustr->length);\n\tlen = *len_p;\n\tce1 = NULL;\n\tcompose = !test_bit(HFSPLUS_SB_NODECOMPOSE, &HFSPLUS_SB(sb)->flags);\n\n\twhile (ustrlen > 0) {\n\t\tc0 = be16_to_cpu(*ip++);\n\t\tustrlen--;\n\t\t/* search for single decomposed char */\n\t\tif (likely(compose))\n\t\t\tce1 = hfsplus_compose_lookup(hfsplus_compose_table, c0);\n\t\tif (ce1)\n\t\t\tcc = ce1[0];\n\t\telse\n\t\t\tcc = 0;\n\t\tif (cc) {\n\t\t\t/* start of a possibly decomposed Hangul char */\n\t\t\tif (cc != 0xffff)\n\t\t\t\tgoto done;\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip) - Hangul_VBase;\n\t\t\tif (c1 < Hangul_VCount) {\n\t\t\t\t/* compose the Hangul char */\n\t\t\t\tcc = (c0 - Hangul_LBase) * Hangul_VCount;\n\t\t\t\tcc = (cc + c1) * Hangul_TCount;\n\t\t\t\tcc += Hangul_SBase;\n\t\t\t\tip++;\n\t\t\t\tustrlen--;\n\t\t\t\tif (!ustrlen)\n\t\t\t\t\tgoto done;\n\t\t\t\tc1 = be16_to_cpu(*ip) - Hangul_TBase;\n\t\t\t\tif (c1 > 0 && c1 < Hangul_TCount) {\n\t\t\t\t\tcc += c1;\n\t\t\t\t\tip++;\n\t\t\t\t\tustrlen--;\n\t\t\t\t}\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\twhile (1) {\n\t\t\t/* main loop for common case of not composed chars */\n\t\t\tif (!ustrlen)\n\t\t\t\tgoto same;\n\t\t\tc1 = be16_to_cpu(*ip);\n\t\t\tif (likely(compose))\n\t\t\t\tce1 = hfsplus_compose_lookup(\n\t\t\t\t\thfsplus_compose_table, c1);\n\t\t\tif (ce1)\n\t\t\t\tbreak;\n\t\t\tswitch (c0) {\n\t\t\tcase 0:\n\t\t\t\tc0 = 0x2400;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tc0 = ':';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tres = nls->uni2char(c0, op, len);\n\t\t\tif (res < 0) {\n\t\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*op = '?';\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t\top += res;\n\t\t\tlen -= res;\n\t\t\tc0 = c1;\n\t\t\tip++;\n\t\t\tustrlen--;\n\t\t}\n\t\tce2 = hfsplus_compose_lookup(ce1, c0);\n\t\tif (ce2) {\n\t\t\ti = 1;\n\t\t\twhile (i < ustrlen) {\n\t\t\t\tce1 = hfsplus_compose_lookup(ce2,\n\t\t\t\t\tbe16_to_cpu(ip[i]));\n\t\t\t\tif (!ce1)\n\t\t\t\t\tbreak;\n\t\t\t\ti++;\n\t\t\t\tce2 = ce1;\n\t\t\t}\n\t\t\tcc = ce2[0];\n\t\t\tif (cc) {\n\t\t\t\tip += i;\n\t\t\t\tustrlen -= i;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\nsame:\n\t\tswitch (c0) {\n\t\tcase 0:\n\t\t\tcc = 0x2400;\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tcc = ':';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcc = c0;\n\t\t}\ndone:\n\t\tres = nls->uni2char(cc, op, len);\n\t\tif (res < 0) {\n\t\t\tif (res == -ENAMETOOLONG)\n\t\t\t\tgoto out;\n\t\t\t*op = '?';\n\t\t\tres = 1;\n\t\t}\n\t\top += res;\n\t\tlen -= res;\n\t}\n\tres = 0;\nout:\n\t*len_p = (char *)op - astr;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&entry",
            "fd.entryoffset",
            "fd.entrylength"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"walked past end of dir\\n\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fd.key->cat.parent"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "be32_to_cpu(entry.thread.parentID)",
            "DT_DIR"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.thread.parentID"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"truncated catalog thread\\n\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog folder thread\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd",
            "hfs_find_rec_by_key"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key_with_cnid",
          "args": [
            "sb",
            "fd.search_key",
            "inode->i_ino"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key_with_cnid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "59-65",
          "snippet": "void hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nvoid hfsplus_cat_build_key_with_cnid(struct super_block *sb,\n\t\t\thfsplus_btree_key *key, u32 parent)\n{\n\tkey->cat.parent = cpu_to_be32(parent);\n\tkey->cat.name.length = 0;\n\tkey->key_len = cpu_to_be16(6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar *strbuf;\n\thfsplus_cat_entry entry;\n\tstruct hfs_find_data fd;\n\tstruct hfsplus_readdir_data *rd;\n\tu16 type;\n\n\tif (file->f_pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\tstrbuf = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN + 1, GFP_KERNEL);\n\tif (!strbuf) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\thfsplus_cat_build_key_with_cnid(sb, fd.search_key, inode->i_ino);\n\terr = hfs_brec_find(&fd, hfs_find_rec_by_key);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t/* This is completely artificial... */\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fd.entrylength < HFSPLUS_MIN_THREAD_SZ) {\n\t\t\tpr_err(\"truncated catalog thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.parentID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.parent) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n\t\t\tfd.entrylength);\n\t\ttype = be16_to_cpu(entry.type);\n\t\tlen = NLS_MAX_CHARSET_SIZE * HFSPLUS_MAX_STRLEN;\n\t\terr = hfsplus_uni2asc(sb, &fd.key->cat.name, strbuf, &len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (type == HFSPLUS_FOLDER) {\n\t\t\tif (fd.entrylength <\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (HFSPLUS_SB(sb)->hidden_dir &&\n\t\t\t    HFSPLUS_SB(sb)->hidden_dir->i_ino ==\n\t\t\t\t\tbe32_to_cpu(entry.folder.id))\n\t\t\t\tgoto next;\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.folder.id), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFSPLUS_FILE) {\n\t\t\tu16 mode;\n\t\t\tunsigned type = DT_UNKNOWN;\n\n\t\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmode = be16_to_cpu(entry.file.permissions.mode);\n\t\t\tif (S_ISREG(mode))\n\t\t\t\ttype = DT_REG;\n\t\t\telse if (S_ISLNK(mode))\n\t\t\t\ttype = DT_LNK;\n\t\t\telse if (S_ISFIFO(mode))\n\t\t\t\ttype = DT_FIFO;\n\t\t\telse if (S_ISCHR(mode))\n\t\t\t\ttype = DT_CHR;\n\t\t\telse if (S_ISBLK(mode))\n\t\t\t\ttype = DT_BLK;\n\t\t\telse if (S_ISSOCK(mode))\n\t\t\t\ttype = DT_SOCK;\n\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t      be32_to_cpu(entry.file.id), type))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\nnext:\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfsplus_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tlist_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));\nout:\n\tkfree(strbuf);\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "30-129",
    "snippet": "static struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\thfsplus_cat_entry entry;\n\tint err;\n\tu32 cnid, linkid = 0;\n\tu16 type;\n\n\tsb = dir->i_sb;\n\n\tdentry->d_fsdata = NULL;\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino,\n\t\t\t&dentry->d_name);\n\tif (unlikely(err < 0))\n\t\tgoto fail;\nagain:\n\terr = hfs_brec_read(&fd, &entry, sizeof(entry));\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\thfs_find_exit(&fd);\n\t\t\t/* No such entry */\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto fail;\n\t}\n\ttype = be16_to_cpu(entry.type);\n\tif (type == HFSPLUS_FOLDER) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.folder.id);\n\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.file.id);\n\t\tif (entry.file.user_info.fdType ==\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE) &&\n\t\t\t\tentry.file.user_info.fdCreator ==\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR) &&\n\t\t\t\t(entry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(HFSPLUS_SB(sb)->hidden_dir)->\n\t\t\t\t\t\tcreate_date ||\n\t\t\t\tentry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(sb->s_root->d_inode)->\n\t\t\t\t\t\tcreate_date) &&\n\t\t\t\tHFSPLUS_SB(sb)->hidden_dir) {\n\t\t\tstruct qstr str;\n\t\t\tchar name[32];\n\n\t\t\tif (dentry->d_fsdata) {\n\t\t\t\t/*\n\t\t\t\t * We found a link pointing to another link,\n\t\t\t\t * so ignore it and treat it as regular file.\n\t\t\t\t */\n\t\t\t\tcnid = (unsigned long)dentry->d_fsdata;\n\t\t\t\tlinkid = 0;\n\t\t\t} else {\n\t\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\t\t\tlinkid =\n\t\t\t\t\tbe32_to_cpu(entry.file.permissions.dev);\n\t\t\t\tstr.len = sprintf(name, \"iNode%d\", linkid);\n\t\t\t\tstr.name = name;\n\t\t\t\terr = hfsplus_cat_build_key(sb, fd.search_key,\n\t\t\t\t\tHFSPLUS_SB(sb)->hidden_dir->i_ino,\n\t\t\t\t\t&str);\n\t\t\t\tif (unlikely(err < 0))\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else if (!dentry->d_fsdata)\n\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else {\n\t\tpr_err(\"invalid catalog entry type in lookup\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\thfs_find_exit(&fd);\n\tinode = hfsplus_iget(dir->i_sb, cnid);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (S_ISREG(inode->i_mode))\n\t\tHFSPLUS_I(inode)->linkid = linkid;\nout:\n\td_add(dentry, inode);\n\treturn NULL;\nfail:\n\thfs_find_exit(&fd);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_iget",
          "args": [
            "dir->i_sb",
            "cnid"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/super.c",
          "lines": "56-95",
          "snippet": "struct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode *hfsplus_alloc_inode(struct super_block *sb);",
            "static void hfsplus_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct inode *hfsplus_alloc_inode(struct super_block *sb);\nstatic void hfsplus_destroy_inode(struct inode *inode);\n\nstruct inode *hfsplus_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct hfs_find_data fd;\n\tstruct inode *inode;\n\tint err;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tINIT_LIST_HEAD(&HFSPLUS_I(inode)->open_dir_list);\n\tmutex_init(&HFSPLUS_I(inode)->extents_lock);\n\tHFSPLUS_I(inode)->flags = 0;\n\tHFSPLUS_I(inode)->extent_state = 0;\n\tHFSPLUS_I(inode)->rsrc_inode = NULL;\n\tatomic_set(&HFSPLUS_I(inode)->opencnt, 0);\n\n\tif (inode->i_ino >= HFSPLUS_FIRSTUSER_CNID ||\n\t    inode->i_ino == HFSPLUS_ROOT_CNID) {\n\t\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &fd);\n\t\tif (!err) {\n\t\t\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &fd);\n\t\t\tif (!err)\n\t\t\t\terr = hfsplus_cat_read_inode(inode, &fd);\n\t\t\thfs_find_exit(&fd);\n\t\t}\n\t} else {\n\t\terr = hfsplus_system_read_inode(inode);\n\t}\n\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"invalid catalog entry type in lookup\\n\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "HFSPLUS_SB(sb)->hidden_dir->i_ino",
            "&str"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/catalog.c",
          "lines": "42-56",
          "snippet": "int hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_cat_build_key(struct super_block *sb,\n\t\thfsplus_btree_key *key, u32 parent, struct qstr *str)\n{\n\tint len, err;\n\n\tkey->cat.parent = cpu_to_be32(parent);\n\terr = hfsplus_asc2uni(sb, &key->cat.name, HFSPLUS_MAX_STRLEN,\n\t\t\tstr->name, str->len);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\tlen = be16_to_cpu(key->cat.name.length);\n\tkey->key_len = cpu_to_be16(6 + 2 * len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"iNode%d\"",
            "linkid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.file.permissions.dev"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_HFSPLUS_CREATOR"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "HFSP_HARDLINK_TYPE"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.file.id"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.folder.id"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "entry.type"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "&fd",
            "&entry",
            "sizeof(entry)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "219-230",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic struct dentry *hfsplus_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\thfsplus_cat_entry entry;\n\tint err;\n\tu32 cnid, linkid = 0;\n\tu16 type;\n\n\tsb = dir->i_sb;\n\n\tdentry->d_fsdata = NULL;\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\terr = hfsplus_cat_build_key(sb, fd.search_key, dir->i_ino,\n\t\t\t&dentry->d_name);\n\tif (unlikely(err < 0))\n\t\tgoto fail;\nagain:\n\terr = hfs_brec_read(&fd, &entry, sizeof(entry));\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\thfs_find_exit(&fd);\n\t\t\t/* No such entry */\n\t\t\tinode = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tgoto fail;\n\t}\n\ttype = be16_to_cpu(entry.type);\n\tif (type == HFSPLUS_FOLDER) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_folder)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.folder.id);\n\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else if (type == HFSPLUS_FILE) {\n\t\tif (fd.entrylength < sizeof(struct hfsplus_cat_file)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcnid = be32_to_cpu(entry.file.id);\n\t\tif (entry.file.user_info.fdType ==\n\t\t\t\tcpu_to_be32(HFSP_HARDLINK_TYPE) &&\n\t\t\t\tentry.file.user_info.fdCreator ==\n\t\t\t\tcpu_to_be32(HFSP_HFSPLUS_CREATOR) &&\n\t\t\t\t(entry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(HFSPLUS_SB(sb)->hidden_dir)->\n\t\t\t\t\t\tcreate_date ||\n\t\t\t\tentry.file.create_date ==\n\t\t\t\t\tHFSPLUS_I(sb->s_root->d_inode)->\n\t\t\t\t\t\tcreate_date) &&\n\t\t\t\tHFSPLUS_SB(sb)->hidden_dir) {\n\t\t\tstruct qstr str;\n\t\t\tchar name[32];\n\n\t\t\tif (dentry->d_fsdata) {\n\t\t\t\t/*\n\t\t\t\t * We found a link pointing to another link,\n\t\t\t\t * so ignore it and treat it as regular file.\n\t\t\t\t */\n\t\t\t\tcnid = (unsigned long)dentry->d_fsdata;\n\t\t\t\tlinkid = 0;\n\t\t\t} else {\n\t\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t\t\t\tlinkid =\n\t\t\t\t\tbe32_to_cpu(entry.file.permissions.dev);\n\t\t\t\tstr.len = sprintf(name, \"iNode%d\", linkid);\n\t\t\t\tstr.name = name;\n\t\t\t\terr = hfsplus_cat_build_key(sb, fd.search_key,\n\t\t\t\t\tHFSPLUS_SB(sb)->hidden_dir->i_ino,\n\t\t\t\t\t&str);\n\t\t\t\tif (unlikely(err < 0))\n\t\t\t\t\tgoto fail;\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t} else if (!dentry->d_fsdata)\n\t\t\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\t} else {\n\t\tpr_err(\"invalid catalog entry type in lookup\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\thfs_find_exit(&fd);\n\tinode = hfsplus_iget(dir->i_sb, cnid);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (S_ISREG(inode->i_mode))\n\t\tHFSPLUS_I(inode)->linkid = linkid;\nout:\n\td_add(dentry, inode);\n\treturn NULL;\nfail:\n\thfs_find_exit(&fd);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "hfsplus_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/dir.c",
    "lines": "22-27",
    "snippet": "static inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/nls.h>",
      "#include <linux/random.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/nls.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline void hfsplus_instantiate(struct dentry *dentry,\n\t\t\t\t       struct inode *inode, u32 cnid)\n{\n\tdentry->d_fsdata = (void *)(unsigned long)cnid;\n\td_instantiate(dentry, inode);\n}"
  }
]