[
  {
    "function_name": "exit_ext3_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1325-1331",
    "snippet": "void\nexit_ext3_xattr(void)\n{\n\tif (ext3_xattr_cache)\n\t\tmb_cache_destroy(ext3_xattr_cache);\n\text3_xattr_cache = NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_destroy",
          "args": [
            "ext3_xattr_cache"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "451-491",
          "snippet": "void\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic struct mb_cache *ext3_xattr_cache;\n\nvoid\nexit_ext3_xattr(void)\n{\n\tif (ext3_xattr_cache)\n\t\tmb_cache_destroy(ext3_xattr_cache);\n\text3_xattr_cache = NULL;\n}"
  },
  {
    "function_name": "init_ext3_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1316-1323",
    "snippet": "int __init\ninit_ext3_xattr(void)\n{\n\text3_xattr_cache = mb_cache_create(\"ext3_xattr\", 6);\n\tif (!ext3_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_create",
          "args": [
            "\"ext3_xattr\"",
            "6"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "324-383",
          "snippet": "struct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;",
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic struct mb_cache *ext3_xattr_cache;\n\nint __init\ninit_ext3_xattr(void)\n{\n\text3_xattr_cache = mb_cache_create(\"ext3_xattr\", 6);\n\tif (!ext3_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1292-1312",
    "snippet": "static void ext3_xattr_rehash(struct ext3_xattr_header *header,\n\t\t\t      struct ext3_xattr_entry *entry)\n{\n\tstruct ext3_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text3_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT3_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [
      "#define BLOCK_HASH_SHIFT 16"
    ],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "here"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "here->e_hash"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "here"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_hash_entry",
          "args": [
            "header",
            "entry"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1256-1280",
          "snippet": "static inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,\n\t\t\t\t\t struct ext3_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [
            "#define VALUE_HASH_SHIFT 16",
            "#define NAME_HASH_SHIFT 5"
          ],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,\n\t\t\t\t\t struct ext3_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *header,\n\t\t\t      struct ext3_xattr_entry *entry)\n{\n\tstruct ext3_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text3_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT3_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext3_xattr_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1256-1280",
    "snippet": "static inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,\n\t\t\t\t\t struct ext3_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [
      "#define VALUE_HASH_SHIFT 16",
      "#define NAME_HASH_SHIFT 5"
    ],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*value++"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic inline void ext3_xattr_hash_entry(struct ext3_xattr_header *header,\n\t\t\t\t\t struct ext3_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT3_XATTR_ROUND) >> EXT3_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext3_xattr_cache_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1206-1246",
    "snippet": "static struct buffer_head *\next3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext3_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t\"inode %lu: block %lu read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT3_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT3_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext3_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_find_next",
          "args": [
            "ce",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "823-841",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_cmp",
          "args": [
            "header",
            "BHDR(bh)"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1166-1196",
          "snippet": "static int\next3_xattr_cmp(struct ext3_xattr_header *header1,\n\t       struct ext3_xattr_header *header2)\n{\n\tstruct ext3_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT3_XATTR_NEXT(entry1);\n\t\tentry2 = EXT3_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_cmp(struct ext3_xattr_header *header1,\n\t       struct ext3_xattr_header *header2)\n{\n\tstruct ext3_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT3_XATTR_NEXT(entry1);\n\t\tentry2 = EXT3_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"block %lu refcount %d>=%d\"",
            "(unsigned long) ce->e_block",
            "le32_to_cpu(BHDR(bh)->h_refcount)",
            "EXT3_XATTR_REFCOUNT_MAX"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"inode %lu: block %lu read error\"",
            "inode->i_ino",
            "(unsigned long) ce->e_block"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "ce->e_block"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ce"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ce"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_find_first",
          "args": [
            "ext3_xattr_cache",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "785-802",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"looking for cached blocks [%x]\"",
            "(int)hash"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic struct buffer_head *\next3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext3_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t\"inode %lu: block %lu read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT3_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT3_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext3_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext3_xattr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1166-1196",
    "snippet": "static int\next3_xattr_cmp(struct ext3_xattr_header *header1,\n\t       struct ext3_xattr_header *header2)\n{\n\tstruct ext3_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT3_XATTR_NEXT(entry1);\n\t\tentry2 = EXT3_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "entry2"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "entry1"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(char *)header1 + le16_to_cpu(entry1->e_value_offs)",
            "(char *)header2 + le16_to_cpu(entry2->e_value_offs)",
            "le32_to_cpu(entry1->e_value_size)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry1->e_value_size"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry2->e_value_offs"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "entry1->e_name",
            "entry2->e_name",
            "entry1->e_name_len"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry1"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header2+1"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header1+1"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_cmp(struct ext3_xattr_header *header1,\n\t       struct ext3_xattr_header *header2)\n{\n\tstruct ext3_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT3_XATTR_NEXT(entry1);\n\t\tentry2 = EXT3_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1133-1156",
    "snippet": "static void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"inserting [%x]\"",
            "(int)hash"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"already in cache\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_insert",
          "args": [
            "ce",
            "bh->b_bdev",
            "bh->b_blocknr",
            "hash"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "578-616",
          "snippet": "int\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"out of memory\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_alloc",
          "args": [
            "ext3_xattr_cache",
            "GFP_NOFS"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "501-561",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_hash"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
  },
  {
    "function_name": "ext3_xattr_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1119-1123",
    "snippet": "void\next3_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_shrink",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "395-441",
          "snippet": "void\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nvoid\next3_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}"
  },
  {
    "function_name": "ext3_xattr_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1086-1112",
    "snippet": "void\next3_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t\"inode %lu: block \"E3FSBLK\" read error\", inode->i_ino,\n\t\t\tEXT3_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\tEXT3_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\text3_xattr_release_block(handle, inode, bh);\n\tEXT3_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_release_block",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "472-508",
          "snippet": "static void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"inode %lu: bad block \"E3FSBLK",
            "inode->i_ino",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_XATTR_MAGIC"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\n\nvoid\next3_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t\"inode %lu: block \"E3FSBLK\" read error\", inode->i_ino,\n\t\t\tEXT3_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\tEXT3_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\text3_xattr_release_block(handle, inode, bh);\n\tEXT3_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "ext3_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "1052-1077",
    "snippet": "int\next3_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext3_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext3_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1462-1470",
          "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "name_index",
            "name",
            "value",
            "value_len",
            "flags"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "940-1042",
          "snippet": "int\next3_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext3_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext3_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext3_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\terror = ext3_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW)) {\n\t\tstruct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\t\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\t}\n\n\terror = ext3_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT3_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text3_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\terror = ext3_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext3_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tup_write(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nint\next3_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext3_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext3_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext3_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\terror = ext3_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW)) {\n\t\tstruct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\t\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\t}\n\n\terror = ext3_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT3_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text3_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\terror = ext3_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext3_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tup_write(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "EXT3_DATA_TRANS_BLOCKS(inode->i_sb)"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DATA_TRANS_BLOCKS",
          "args": [
            "inode->i_sb"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nint\next3_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext3_journal_start(inode, EXT3_DATA_TRANS_BLOCKS(inode->i_sb));\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext3_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext3_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext3_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_set_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "940-1042",
    "snippet": "int\next3_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext3_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext3_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext3_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\terror = ext3_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW)) {\n\t\tstruct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\t\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\t}\n\n\terror = ext3_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT3_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text3_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\terror = ext3_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext3_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tup_write(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT3_I(inode)->xattr_sem"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bs.bh"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_update_super_block",
          "args": [
            "handle",
            "inode->i_sb"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_update_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "456-466",
          "snippet": "static void ext3_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tif (ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh) == 0) {\n\t\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR);\n\t\text3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tif (ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh) == 0) {\n\t\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR);\n\t\text3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_ibody_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_ibody_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "903-926",
          "snippet": "static int\next3_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext3_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\text3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text3_clear_inode_state(inode, EXT3_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext3_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\text3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text3_clear_inode_state(inode, EXT3_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_block_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&bs"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_block_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "674-866",
          "snippet": "static int\next3_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext3_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n#define header(x) ((struct ext3_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext3_xattr_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\terror = ext3_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext3_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text3_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text3_xattr_cache_insert(bs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tjournal_release_buffer(handle, bs->bh);\n\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text3_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext3_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\terror = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text3_fsblk_t goal = ext3_group_first_block_no(sb,\n\t\t\t\t\t\tEXT3_I(inode)->i_block_group);\n\t\t\text3_fsblk_t block;\n\n\t\t\t/*\n\t\t\t * Protect us agaist concurrent allocations to the\n\t\t\t * same inode from ext3_..._writepage(). Reservation\n\t\t\t * code does not expect racing allocations.\n\t\t\t */\n\t\t\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tblock = ext3_new_block(handle, inode, goal, &error);\n\t\t\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\ngetblk_failed:\n\t\t\t\text3_free_blocks(handle, inode, block, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext3_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text3_xattr_cache_insert(new_bh);\n\t\t\terror = ext3_journal_dirty_metadata(handle, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text3_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, 1);\n\tgoto cleanup;\n\nbad_block:\n\text3_error(inode->i_sb, __func__,\n\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t   EXT3_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic int\next3_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext3_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n#define header(x) ((struct ext3_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext3_xattr_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\terror = ext3_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext3_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text3_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text3_xattr_cache_insert(bs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tjournal_release_buffer(handle, bs->bh);\n\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text3_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext3_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\terror = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text3_fsblk_t goal = ext3_group_first_block_no(sb,\n\t\t\t\t\t\tEXT3_I(inode)->i_block_group);\n\t\t\text3_fsblk_t block;\n\n\t\t\t/*\n\t\t\t * Protect us agaist concurrent allocations to the\n\t\t\t * same inode from ext3_..._writepage(). Reservation\n\t\t\t * code does not expect racing allocations.\n\t\t\t */\n\t\t\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tblock = ext3_new_block(handle, inode, goal, &error);\n\t\t\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\ngetblk_failed:\n\t\t\t\text3_free_blocks(handle, inode, block, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext3_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text3_xattr_cache_insert(new_bh);\n\t\t\terror = ext3_journal_dirty_metadata(handle, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text3_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, 1);\n\tgoto cleanup;\n\nbad_block:\n\text3_error(inode->i_sb, __func__,\n\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t   EXT3_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_block_find",
          "args": [
            "inode",
            "&i",
            "&bs"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "631-672",
          "snippet": "static int\next3_xattr_block_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT3_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext3_xattr_check_block(bs->bh)) {\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t\tEXT3_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext3_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_block_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT3_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext3_xattr_check_block(bs->bh)) {\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t\tEXT3_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext3_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "873-901",
          "snippet": "static int\next3_xattr_ibody_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext3_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\tif (ext3_test_inode_state(inode, EXT3_STATE_XATTR)) {\n\t\terror = ext3_xattr_check_names(IFIRST(header), is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext3_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_ibody_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext3_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\tif (ext3_test_inode_state(inode, EXT3_STATE_XATTR)) {\n\t\terror = ext3_xattr_check_names(IFIRST(header), is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext3_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_clear_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_NEW"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "727-730",
          "snippet": "static inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "EXT3_SB(inode->i_sb)->s_inode_size"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_NEW"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "is.iloc.bh"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_loc",
          "args": [
            "inode",
            "&is.iloc"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2805-2810",
          "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT3_I(inode)->xattr_sem"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nint\next3_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext3_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext3_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext3_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\terror = ext3_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext3_test_inode_state(inode, EXT3_STATE_NEW)) {\n\t\tstruct ext3_inode *raw_inode = ext3_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT3_SB(inode->i_sb)->s_inode_size);\n\t\text3_clear_inode_state(inode, EXT3_STATE_NEW);\n\t}\n\n\terror = ext3_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext3_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT3_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext3_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext3_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext3_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text3_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\terror = ext3_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext3_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tup_write(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_ibody_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "903-926",
    "snippet": "static int\next3_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext3_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\text3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text3_clear_inode_state(inode, EXT3_STATE_XATTR);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_clear_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_clear_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "727-730",
          "snippet": "static inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_clear_inode_state(struct inode *inode, int bit)\n{\n\tclear_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "722-725",
          "snippet": "static inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline void ext3_set_inode_state(struct inode *inode, int bit)\n{\n\tset_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_XATTR_MAGIC"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "ext3_raw_inode(&is->iloc)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&is->iloc"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_set_entry",
          "args": [
            "i",
            "s"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "525-624",
          "snippet": "static int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext3_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\text3_set_inode_state(inode, EXT3_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text3_clear_inode_state(inode, EXT3_STATE_XATTR);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_ibody_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "873-901",
    "snippet": "static int\next3_xattr_ibody_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext3_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\tif (ext3_test_inode_state(inode, EXT3_STATE_XATTR)) {\n\t\terror = ext3_xattr_check_names(IFIRST(header), is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext3_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_xattr_find_entry",
          "args": [
            "&is->s.here",
            "i->name_index",
            "i->name",
            "is->s.end -\n\t\t\t\t\t      (void *)is->s.base",
            "0"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "183-208",
          "snippet": "static int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_names",
          "args": [
            "IFIRST(header)",
            "is->s.end"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "148-158",
          "snippet": "static int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&is->iloc"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_ibody_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_ibody_find *is)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tint error;\n\n\tif (EXT3_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext3_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\tif (ext3_test_inode_state(inode, EXT3_STATE_XATTR)) {\n\t\terror = ext3_xattr_check_names(IFIRST(header), is->s.end);\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext3_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_block_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "674-866",
    "snippet": "static int\next3_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext3_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n#define header(x) ((struct ext3_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext3_xattr_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\terror = ext3_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext3_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text3_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text3_xattr_cache_insert(bs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tjournal_release_buffer(handle, bs->bh);\n\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text3_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext3_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\terror = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text3_fsblk_t goal = ext3_group_first_block_no(sb,\n\t\t\t\t\t\tEXT3_I(inode)->i_block_group);\n\t\t\text3_fsblk_t block;\n\n\t\t\t/*\n\t\t\t * Protect us agaist concurrent allocations to the\n\t\t\t * same inode from ext3_..._writepage(). Reservation\n\t\t\t * code does not expect racing allocations.\n\t\t\t */\n\t\t\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tblock = ext3_new_block(handle, inode, goal, &error);\n\t\t\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\ngetblk_failed:\n\t\t\t\text3_free_blocks(handle, inode, block, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext3_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text3_xattr_cache_insert(new_bh);\n\t\t\terror = ext3_journal_dirty_metadata(handle, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text3_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, 1);\n\tgoto cleanup;\n\nbad_block:\n\text3_error(inode->i_sb, __func__,\n\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t   EXT3_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"inode %lu: bad block \"E3FSBLK",
            "inode->i_ino",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "1"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->base"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_release_block",
          "args": [
            "handle",
            "inode",
            "bs->bh"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "472-508",
          "snippet": "static void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_cache_insert",
          "args": [
            "new_bh"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1133-1156",
          "snippet": "static void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "new_bh"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "new_bh"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_bh->b_data",
            "s->base",
            "new_bh->b_size"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_create_access",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "block",
            "1"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_bh"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"creating block %d\"",
            "block"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&EXT3_I(inode)->truncate_mutex"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_new_block",
          "args": [
            "handle",
            "inode",
            "goal",
            "&error"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1763-1769",
          "snippet": "ext3_fsblk_t ext3_new_block(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext3_new_blocks(handle, inode, goal, &count, errp);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_new_block(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext3_new_blocks(handle, inode, goal, &count, errp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&EXT3_I(inode)->truncate_mutex"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "EXT3_I(inode)->i_block_group"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_bh"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"keeping this block\""
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"reusing; refcount now=%d\"",
            "le32_to_cpu(BHDR(new_bh)->h_refcount)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(new_bh)->h_refcount"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "new_bh"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&BHDR(new_bh)->h_refcount",
            "1"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "new_bh"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "1"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"keeping\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_cache_find",
          "args": [
            "inode",
            "header(s->base)",
            "&ce"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_cache_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1206-1246",
          "snippet": "static struct buffer_head *\next3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext3_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t\"inode %lu: block %lu read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT3_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT3_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext3_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic struct buffer_head *\next3_xattr_cache_find(struct inode *inode, struct ext3_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext3_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text3_error(inode->i_sb, __func__,\n\t\t\t\t\"inode %lu: block %lu read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT3_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT3_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext3_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "header",
          "args": [
            "s->base"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "header_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "33-39",
          "snippet": "static void header_in(struct dlm_header *hd)\n{\n\thd->h_version\t\t= le32_to_cpu(hd->h_version);\n\thd->h_lockspace\t\t= le32_to_cpu(hd->h_lockspace);\n\thd->h_nodeid\t\t= le32_to_cpu(hd->h_nodeid);\n\thd->h_length\t\t= le16_to_cpu(hd->h_length);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nstatic void header_in(struct dlm_header *hd)\n{\n\thd->h_version\t\t= le32_to_cpu(hd->h_version);\n\thd->h_lockspace\t\t= le32_to_cpu(hd->h_lockspace);\n\thd->h_nodeid\t\t= le32_to_cpu(hd->h_nodeid);\n\thd->h_length\t\t= le16_to_cpu(hd->h_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_rehash",
          "args": [
            "header(s->base)",
            "s->here"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1292-1312",
          "snippet": "static void ext3_xattr_rehash(struct ext3_xattr_header *header,\n\t\t\t      struct ext3_xattr_entry *entry)\n{\n\tstruct ext3_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text3_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT3_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [
            "#define BLOCK_HASH_SHIFT 16"
          ],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *header,\n\t\t\t      struct ext3_xattr_entry *entry)\n{\n\tstruct ext3_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text3_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT3_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_set_entry",
          "args": [
            "i",
            "s"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "525-624",
          "snippet": "static int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_XATTR_MAGIC"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "s->base + offset"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->base",
            "BHDR(bs->bh)",
            "bs->bh->b_size"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bs->bh->b_size",
            "GFP_NOFS"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"cloning\""
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_release_buffer",
          "args": [
            "handle",
            "bs->bh"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "journal_release_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1212-1216",
          "snippet": "void\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid\njournal_release_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUFFER_TRACE(bh, \"entry\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bs->bh"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"modifying in-place\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bs->bh"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext3_xattr_cache",
            "bs->bh->b_bdev",
            "bs->bh->b_blocknr"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic int\next3_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext3_xattr_info *i,\n\t\t     struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext3_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n#define header(x) ((struct ext3_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext3_xattr_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\terror = ext3_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext3_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text3_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text3_xattr_cache_insert(bs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tjournal_release_buffer(handle, bs->bh);\n\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT3_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext3_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text3_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext3_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\terror = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext3_journal_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t    new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text3_fsblk_t goal = ext3_group_first_block_no(sb,\n\t\t\t\t\t\tEXT3_I(inode)->i_block_group);\n\t\t\text3_fsblk_t block;\n\n\t\t\t/*\n\t\t\t * Protect us agaist concurrent allocations to the\n\t\t\t * same inode from ext3_..._writepage(). Reservation\n\t\t\t * code does not expect racing allocations.\n\t\t\t */\n\t\t\tmutex_lock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tblock = ext3_new_block(handle, inode, goal, &error);\n\t\t\tmutex_unlock(&EXT3_I(inode)->truncate_mutex);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\ngetblk_failed:\n\t\t\t\text3_free_blocks(handle, inode, block, 1);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext3_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text3_xattr_cache_insert(new_bh);\n\t\t\terror = ext3_journal_dirty_metadata(handle, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT3_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text3_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, 1);\n\tgoto cleanup;\n\nbad_block:\n\text3_error(inode->i_sb, __func__,\n\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t   EXT3_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}"
  },
  {
    "function_name": "ext3_xattr_block_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "631-672",
    "snippet": "static int\next3_xattr_block_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT3_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext3_xattr_check_block(bs->bh)) {\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t\tEXT3_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext3_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_xattr_find_entry",
          "args": [
            "&bs->s.here",
            "i->name_index",
            "i->name",
            "bs->bh->b_size",
            "1"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "183-208",
          "snippet": "static int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bs->bh"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"inode %lu: bad block \"E3FSBLK",
            "inode->i_ino",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_block",
          "args": [
            "bs->bh"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "160-170",
          "snippet": "static inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\n\nstatic inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bs->bh->b_count))",
            "le32_to_cpu(BHDR(bs->bh)->h_refcount)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bs->bh)->h_refcount"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bs->bh->b_count)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, value=%p, value_len=%ld\"",
            "i->name_index",
            "i->name",
            "i->value",
            "(long)i->value_len"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int\next3_xattr_block_find(struct inode *inode, struct ext3_xattr_info *i,\n\t\t      struct ext3_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT3_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext3_xattr_check_block(bs->bh)) {\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t\tEXT3_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext3_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_set_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "525-624",
    "snippet": "static int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "i->value",
            "i->value_len"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT3_XATTR_PAD",
            "0",
            "EXT3_XATTR_PAD"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "min_offs - size"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->value_len"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "size"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "s->here",
            "(void *)s->here + size",
            "(void *)last - (void *)s->here + sizeof(__u32)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "(void *)last - size"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "o + size"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->e_value_offs"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "first_val",
            "0",
            "size"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "first_val + size",
            "first_val",
            "val - first_val"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "i->value",
            "i->value_len"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT3_XATTR_PAD",
            "0",
            "EXT3_XATTR_PAD"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->value_len"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "le32_to_cpu(s->here->e_value_size)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "s->here->e_value_size"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->here->e_name",
            "i->name",
            "name_len"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s->here",
            "0",
            "size"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(void *)s->here + size",
            "s->here",
            "rest"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "i->name"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_set_entry(struct ext3_xattr_info *i, struct ext3_xattr_search *s)\n{\n\tstruct ext3_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT3_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT3_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT3_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT3_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT3_XATTR_LEN(name_len) +\n\t\t\t   EXT3_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT3_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT3_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t\t       EXT3_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT3_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT3_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT3_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tmemset(val + size - EXT3_XATTR_PAD, 0,\n\t\t\t       EXT3_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_release_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "472-508",
    "snippet": "static void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
      "static struct mb_cache *ext3_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "inode->i_sb",
            "error"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"refcount now=%d; releasing\"",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "1"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&BHDR(bh)->h_refcount",
            "-1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_forget",
          "args": [
            "handle",
            "1",
            "inode",
            "bh",
            "bh->b_blocknr"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "58-97",
          "snippet": "int ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_forget(handle_t *handle, int is_metadata, struct inode *inode,\n\t\t\tstruct buffer_head *bh, ext3_fsblk_t blocknr)\n{\n\tint err;\n\n\tmight_sleep();\n\n\ttrace_ext3_forget(inode, is_metadata, blocknr);\n\tBUFFER_TRACE(bh, \"enter\");\n\n\tjbd_debug(4, \"forgetting bh %p: is_metadata = %d, mode %o, \"\n\t\t  \"data mode %lx\\n\",\n\t\t  bh, is_metadata, inode->i_mode,\n\t\t  test_opt(inode->i_sb, DATA_FLAGS));\n\n\t/* Never use the revoke function if we are doing full data\n\t * journaling: there is no need to, and a V1 superblock won't\n\t * support it.  Otherwise, only skip the revoke on un-journaled\n\t * data blocks. */\n\n\tif (test_opt(inode->i_sb, DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ||\n\t    (!is_metadata && !ext3_should_journal_data(inode))) {\n\t\tif (bh) {\n\t\t\tBUFFER_TRACE(bh, \"call journal_forget\");\n\t\t\treturn ext3_journal_forget(handle, bh);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * data!=journal && (is_metadata || should_journal_data(inode))\n\t */\n\tBUFFER_TRACE(bh, \"call ext3_journal_revoke\");\n\terr = ext3_journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_abort(inode->i_sb, __func__,\n\t\t\t   \"error %d when attempting revoke\", err);\n\tBUFFER_TRACE(bh, \"exit\");\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_blocks",
          "args": [
            "handle",
            "inode",
            "bh->b_blocknr",
            "1"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "680-691",
          "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"refcount now=0; freeing\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext3_xattr_cache",
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\n\tce = mb_cache_entry_get(ext3_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\terror = ext3_journal_get_write_access(handle, bh);\n\tif (error)\n\t\t goto out;\n\n\tlock_buffer(bh);\n\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text3_free_blocks(handle, inode, bh->b_blocknr, 1);\n\t\tget_bh(bh);\n\t\text3_forget(handle, 1, inode, bh, bh->b_blocknr);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\terror = ext3_journal_dirty_metadata(handle, bh);\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\tdquot_free_block(inode, 1);\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t}\n\tunlock_buffer(bh);\nout:\n\text3_std_error(inode->i_sb, error);\n\treturn;\n}"
  },
  {
    "function_name": "ext3_xattr_update_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "456-466",
    "snippet": "static void ext3_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tif (ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh) == 0) {\n\t\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR);\n\t\text3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SET_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "EXT3_SB(sb)->s_sbh"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tif (ext3_journal_get_write_access(handle, EXT3_SB(sb)->s_sbh) == 0) {\n\t\tEXT3_SET_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_EXT_ATTR);\n\t\text3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\t}\n}"
  },
  {
    "function_name": "ext3_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "430-450",
    "snippet": "static int\next3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint i_error, b_error;\n\n\tdown_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\ti_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (i_error < 0) {\n\t\tb_error = 0;\n\t} else {\n\t\tif (buffer) {\n\t\t\tbuffer += i_error;\n\t\t\tbuffer_size -= i_error;\n\t\t}\n\t\tb_error = ext3_xattr_block_list(dentry, buffer, buffer_size);\n\t\tif (b_error < 0)\n\t\t\ti_error = 0;\n\t}\n\tup_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\treturn i_error + b_error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT3_I(dentry->d_inode)->xattr_sem"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_block_list",
          "args": [
            "dentry",
            "buffer",
            "buffer_size"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_block_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "355-389",
          "snippet": "static int\next3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\terror = ext3_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\terror = ext3_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_ibody_list",
          "args": [
            "dentry",
            "buffer",
            "buffer_size"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_ibody_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "391-418",
          "snippet": "static int\next3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn 0;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(IFIRST(header), end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn 0;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(IFIRST(header), end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT3_I(dentry->d_inode)->xattr_sem"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint i_error, b_error;\n\n\tdown_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\ti_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (i_error < 0) {\n\t\tb_error = 0;\n\t} else {\n\t\tif (buffer) {\n\t\t\tbuffer += i_error;\n\t\t\tbuffer_size -= i_error;\n\t\t}\n\t\tb_error = ext3_xattr_block_list(dentry, buffer, buffer_size);\n\t\tif (b_error < 0)\n\t\t\ti_error = 0;\n\t}\n\tup_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\treturn i_error + b_error;\n}"
  },
  {
    "function_name": "ext3_xattr_ibody_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "391-418",
    "snippet": "static int\next3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn 0;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(IFIRST(header), end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_list_entries",
          "args": [
            "dentry",
            "IFIRST(header)",
            "buffer",
            "buffer_size"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "329-353",
          "snippet": "static int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_names",
          "args": [
            "IFIRST(header)",
            "end"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "148-158",
          "snippet": "static int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2805-2810",
          "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn 0;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(IFIRST(header), end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_block_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "355-389",
    "snippet": "static int\next3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\terror = ext3_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_list_entries",
          "args": [
            "dentry",
            "BFIRST(bh)",
            "buffer",
            "buffer_size"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "329-353",
          "snippet": "static int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_cache_insert",
          "args": [
            "bh"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1133-1156",
          "snippet": "static void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"inode %lu: bad block \"E3FSBLK",
            "inode->i_ino",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_block",
          "args": [
            "bh"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "160-170",
          "snippet": "static inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\n\nstatic inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %u\"",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"buffer=%p, buffer_size=%ld\"",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\n\t\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\terror = ext3_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_list_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "329-353",
    "snippet": "static int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "buffer",
            "rest",
            "entry->e_name",
            "entry->e_name_len",
            "handler->flags"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_handler",
          "args": [
            "entry->e_name_index"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "127-135",
          "snippet": "static inline const struct xattr_handler *\next3_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext3_xattr_handler_map))\n\t\thandler = ext3_xattr_handler_map[name_index];\n\treturn handler;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ext3_xattr_handler_map[] = {\n\t[EXT3_XATTR_INDEX_USER]\t\t     = &ext3_xattr_user_handler,\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t[EXT3_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT3_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT3_XATTR_INDEX_TRUSTED]\t     = &ext3_xattr_trusted_handler,\n#ifdef CONFIG_EXT3_FS_SECURITY\n\t[EXT3_XATTR_INDEX_SECURITY]\t     = &ext3_xattr_security_handler,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic const struct xattr_handler *ext3_xattr_handler_map[] = {\n\t[EXT3_XATTR_INDEX_USER]\t\t     = &ext3_xattr_user_handler,\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t[EXT3_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT3_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT3_XATTR_INDEX_TRUSTED]\t     = &ext3_xattr_trusted_handler,\n#ifdef CONFIG_EXT3_FS_SECURITY\n\t[EXT3_XATTR_INDEX_SECURITY]\t     = &ext3_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next3_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext3_xattr_handler_map))\n\t\thandler = ext3_xattr_handler_map[name_index];\n\treturn handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_list_entries(struct dentry *dentry, struct ext3_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text3_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
  },
  {
    "function_name": "ext3_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "313-327",
    "snippet": "int\next3_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tdown_read(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext3_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT3_I(inode)->xattr_sem"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_block_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_block_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "210-258",
          "snippet": "static int\next3_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext3_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\nbad_block:\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\tentry = BFIRST(bh);\n\terror = ext3_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext3_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\nbad_block:\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\tentry = BFIRST(bh);\n\terror = ext3_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_ibody_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_ibody_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "260-301",
          "snippet": "static int\next3_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_entry *entry;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(entry, end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_entry *entry;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(entry, end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT3_I(inode)->xattr_sem"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next3_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tdown_read(&EXT3_I(inode)->xattr_sem);\n\terror = ext3_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext3_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT3_I(inode)->xattr_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_ibody_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "260-301",
    "snippet": "static int\next3_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_entry *entry;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(entry, end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs)",
            "size"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_find_entry",
          "args": [
            "&entry",
            "name_index",
            "name",
            "end - (void *)entry",
            "0"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "183-208",
          "snippet": "static int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_names",
          "args": [
            "entry",
            "end"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "148-158",
          "snippet": "static int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "951-954",
          "snippet": "static inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);",
            "extern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);",
            "extern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh))",
            "int ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t\t    unsigned int block_group,\n\t\t\t\t\t\t    struct buffer_head ** bh);\nextern int ext3_get_inode_loc(struct inode *, struct ext3_iloc *);\nextern __printf(3, 4)\nvoid ext3_error(struct super_block *, const char *, const char *, ...);\nextern void __ext3_std_error (struct super_block *, const char *, int);\nextern __printf(3, 4)\nvoid ext3_abort(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_warning(struct super_block *, const char *, const char *, ...);\nextern __printf(3, 4)\nvoid ext3_msg(struct super_block *, const char *, const char *, ...);\nextern void ext3_update_dynamic_rev (struct super_block *sb);\n\n#define ext3_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext3_std_error((sb), __func__, (errno));\t\\\n} while (0)\n\n/*\n * Inodes and files operations\n */\n\n/* dir.c */\nextern const struct file_operations ext3_dir_operations;\n\n/* file.c */\nextern const struct inode_operations ext3_file_inode_operations;\nextern const struct file_operations ext3_file_operations;\n\n/* namei.c */\nextern const struct inode_operations ext3_dir_inode_operations;\nextern const struct inode_operations ext3_special_inode_operations;\n\n/* symlink.c */\nextern const struct inode_operations ext3_symlink_inode_operations;\nextern const struct inode_operations ext3_fast_symlink_inode_operations;\n\n#define EXT3_JOURNAL(inode)\t(EXT3_SB((inode)->i_sb)->s_journal)\n\n/* Define the number of blocks we need to account to a transaction to\n * modify one block of data.\n *\n * We may have to touch one inode, one bitmap buffer, up to three\n * indirection blocks, the group and superblock summaries, and the data\n * block to complete the transaction.  */\n\n#define EXT3_SINGLEDATA_TRANS_BLOCKS\t8U\n\n/* Extended attribute operations touch at most two data buffers,\n * two bitmap buffers, and two group summaries, in addition to the inode\n * and the superblock, which are already accounted for. */\n\n#define EXT3_XATTR_TRANS_BLOCKS\t\t6U\n\n/* Define the minimum size for a transaction which modifies data.  This\n * needs to take into account the fact that we may end up modifying two\n * quota files too (one for the group, one for the user quota).  The\n * superblock only gets updated once, of course, so don't bother\n * counting that again for the quota updates. */\n\n#define EXT3_DATA_TRANS_BLOCKS(sb)\t(EXT3_SINGLEDATA_TRANS_BLOCKS + \\\n\t\t\t\t\t EXT3_XATTR_TRANS_BLOCKS - 2 + \\\n\t\t\t\t\t EXT3_MAXQUOTAS_TRANS_BLOCKS(sb))\n\n/* Delete operations potentially hit one directory's namespace plus an\n * entire inode, plus arbitrary amounts of bitmap/indirection data.  Be\n * generous.  We can grow the delete transaction later if necessary. */\n\n#define EXT3_DELETE_TRANS_BLOCKS(sb)   (EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) + 64)\n\n/* Define an arbitrary limit for the amount of data we will anticipate\n * writing to any given transaction.  For unbounded transactions such as\n * write(2) and truncate(2) we can write more than this, but we always\n * start off at the maximum transaction size and grow the transaction\n * optimistically as we go. */\n\n#define EXT3_MAX_TRANS_DATA\t\t64U\n\n/* We break up a large truncate or write transaction once the handle's\n * buffer credits gets this low, we need either to extend the\n * transaction or to start a new one.  Reserve enough space here for\n * inode, bitmap, superblock, group and indirection updates for at least\n * one block, plus two quota updates.  Quota allocations are not\n * needed. */\n\n#define EXT3_RESERVE_TRANS_BLOCKS\t12U\n\n#define EXT3_INDEX_EXTRA_TRANS_BLOCKS\t8\n\n#ifdef CONFIG_QUOTA\n/* Amount of blocks needed for quota update - we know that the structure was\n * allocated so we need to update only inode+data */\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) (test_opt(sb, QUOTA) ? 2 : 0)\n/* Amount of blocks needed for quota insert/delete - we do some block writes\n * but inode, sb and group updates are done only once */\n#define EXT3_QUOTA_INIT_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_INIT_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_INIT_REWRITE) : 0)\n#define EXT3_QUOTA_DEL_BLOCKS(sb) (test_opt(sb, QUOTA) ? (DQUOT_DEL_ALLOC*\\\n\t\t(EXT3_SINGLEDATA_TRANS_BLOCKS-3)+3+DQUOT_DEL_REWRITE) : 0)\n#else\n#define EXT3_QUOTA_TRANS_BLOCKS(sb) 0\n#define EXT3_QUOTA_INIT_BLOCKS(sb) 0\n#define EXT3_QUOTA_DEL_BLOCKS(sb) 0\n#endif\n#define EXT3_MAXQUOTAS_TRANS_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_TRANS_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_INIT_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_INIT_BLOCKS(sb))\n#define EXT3_MAXQUOTAS_DEL_BLOCKS(sb) (EXT3_MAXQUOTAS*EXT3_QUOTA_DEL_BLOCKS(sb))\n\nint\next3_mark_iloc_dirty(handle_t *handle,\n\t\t     struct inode *inode,\n\t\t     struct ext3_iloc *iloc);\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint ext3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\tstruct ext3_iloc *iloc);\n\nint ext3_mark_inode_dirty(handle_t *handle, struct inode *inode);\n\n/*\n * Wrapper functions with which ext3 calls into JBD.  The intent here is\n * to allow these to be turned into appropriate stubs so ext3 can control\n * ext2 filesystems, so ext2+ext3 systems only nee one fs.  This work hasn't\n * been done yet.\n */\n\nstatic inline void ext3_journal_release_buffer(handle_t *handle,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\tjournal_release_buffer(handle, bh);\n}\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err);\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh);\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh);\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh);\n\n#define ext3_journal_get_undo_access(handle, bh) \\\n\t__ext3_journal_get_undo_access(__func__, (handle), (bh))\n#define ext3_journal_get_write_access(handle, bh) \\\n\t__ext3_journal_get_write_access(__func__, (handle), (bh));\nint ext3_journal_dirty_data(handle_t *handle, struct buffer_head *bh);\n\nstatic inline struct ext3_inode *ext3_raw_inode(struct ext3_iloc *iloc)\n{\n\treturn (struct ext3_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2805-2810",
          "snippet": "int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext3_get_inode_loc(inode, iloc,\n\t\t!ext3_test_inode_state(inode, EXT3_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_inode_state",
          "args": [
            "inode",
            "EXT3_STATE_XATTR"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_inode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "717-720",
          "snippet": "static inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline int ext3_test_inode_state(struct inode *inode, int bit)\n{\n\treturn test_bit(bit, &EXT3_I(inode)->i_state_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext3_xattr_ibody_header *header;\n\tstruct ext3_xattr_entry *entry;\n\tstruct ext3_inode *raw_inode;\n\tstruct ext3_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext3_test_inode_state(inode, EXT3_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext3_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext3_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT3_SB(inode->i_sb)->s_inode_size;\n\terror = ext3_xattr_check_names(entry, end);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext3_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_block_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "210-258",
    "snippet": "static int\next3_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext3_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\nbad_block:\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\tentry = BFIRST(bh);\n\terror = ext3_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);",
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);",
      "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "bh->b_data + le16_to_cpu(entry->e_value_offs)",
            "size"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_find_entry",
          "args": [
            "&entry",
            "name_index",
            "name",
            "bh->b_size",
            "1"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "183-208",
          "snippet": "static int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_xattr_cache_insert",
          "args": [
            "bh"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "1133-1156",
          "snippet": "static void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);",
            "static struct mb_cache *ext3_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext3_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext3_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\nstatic struct mb_cache *ext3_xattr_cache;\n\nstatic void\next3_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext3_xattr_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"inode %lu: bad block \"E3FSBLK",
            "inode->i_ino",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_xattr_check_block",
          "args": [
            "bh"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "160-170",
          "snippet": "static inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_cache_insert(struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\n\nstatic inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %u\"",
            "EXT3_I(inode)->i_file_acl"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, buffer=%p, buffer_size=%ld\"",
            "name_index",
            "name",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext3_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT3_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %u\", EXT3_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT3_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext3_xattr_check_block(bh)) {\nbad_block:\text3_error(inode->i_sb, __func__,\n\t\t\t   \"inode %lu: bad block \"E3FSBLK, inode->i_ino,\n\t\t\t   EXT3_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text3_xattr_cache_insert(bh);\n\tentry = BFIRST(bh);\n\terror = ext3_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "183-208",
    "snippet": "static int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_xattr_check_entry",
          "args": [
            "entry",
            "size"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "172-181",
          "snippet": "static inline int\next3_xattr_check_entry(struct ext3_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic inline int\next3_xattr_check_entry(struct ext3_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "entry->e_name",
            "name_len"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_find_entry(struct ext3_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext3_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT3_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext3_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
  },
  {
    "function_name": "ext3_xattr_check_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "172-181",
    "snippet": "static inline int\next3_xattr_check_entry(struct ext3_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic inline int\next3_xattr_check_entry(struct ext3_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_xattr_check_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "160-170",
    "snippet": "static inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_cache_insert(struct buffer_head *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_xattr_check_names",
          "args": [
            "BFIRST(bh)",
            "bh->b_data + bh->b_size"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "148-158",
          "snippet": "static int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT3_XATTR_MAGIC"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_cache_insert(struct buffer_head *);\n\nstatic inline int\next3_xattr_check_block(struct buffer_head *bh)\n{\n\tint error;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT3_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\terror = ext3_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size);\n\treturn error;\n}"
  },
  {
    "function_name": "ext3_xattr_check_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "148-158",
    "snippet": "static int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic void ext3_xattr_rehash(struct ext3_xattr_header *,\n\t\t\t      struct ext3_xattr_entry *);\n\nstatic int\next3_xattr_check_names(struct ext3_xattr_entry *entry, void *end)\n{\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext3_xattr_entry *next = EXT3_XATTR_NEXT(entry);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\tentry = next;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "142-146",
    "snippet": "ssize_t\next3_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext3_xattr_list(dentry, buffer, size);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_xattr_list",
          "args": [
            "dentry",
            "buffer",
            "size"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_xattr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
          "lines": "430-450",
          "snippet": "static int\next3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint i_error, b_error;\n\n\tdown_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\ti_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (i_error < 0) {\n\t\tb_error = 0;\n\t} else {\n\t\tif (buffer) {\n\t\t\tbuffer += i_error;\n\t\t\tbuffer_size -= i_error;\n\t\t}\n\t\tb_error = ext3_xattr_block_list(dentry, buffer, buffer_size);\n\t\tif (b_error < 0)\n\t\t\ti_error = 0;\n\t}\n\tup_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\treturn i_error + b_error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic int ext3_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next3_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint i_error, b_error;\n\n\tdown_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\ti_error = ext3_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (i_error < 0) {\n\t\tb_error = 0;\n\t} else {\n\t\tif (buffer) {\n\t\t\tbuffer += i_error;\n\t\t\tbuffer_size -= i_error;\n\t\t}\n\t\tb_error = ext3_xattr_block_list(dentry, buffer, buffer_size);\n\t\tif (b_error < 0)\n\t\t\ti_error = 0;\n\t}\n\tup_read(&EXT3_I(dentry->d_inode)->xattr_sem);\n\treturn i_error + b_error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nssize_t\next3_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext3_xattr_list(dentry, buffer, size);\n}"
  },
  {
    "function_name": "ext3_xattr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/xattr.c",
    "lines": "127-135",
    "snippet": "static inline const struct xattr_handler *\next3_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext3_xattr_handler_map))\n\t\thandler = ext3_xattr_handler_map[name_index];\n\treturn handler;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *ext3_xattr_handler_map[] = {\n\t[EXT3_XATTR_INDEX_USER]\t\t     = &ext3_xattr_user_handler,\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t[EXT3_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT3_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT3_XATTR_INDEX_TRUSTED]\t     = &ext3_xattr_trusted_handler,\n#ifdef CONFIG_EXT3_FS_SECURITY\n\t[EXT3_XATTR_INDEX_SECURITY]\t     = &ext3_xattr_security_handler,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ext3_xattr_handler_map"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include \"ext3.h\"\n\nstatic const struct xattr_handler *ext3_xattr_handler_map[] = {\n\t[EXT3_XATTR_INDEX_USER]\t\t     = &ext3_xattr_user_handler,\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n\t[EXT3_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT3_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT3_XATTR_INDEX_TRUSTED]\t     = &ext3_xattr_trusted_handler,\n#ifdef CONFIG_EXT3_FS_SECURITY\n\t[EXT3_XATTR_INDEX_SECURITY]\t     = &ext3_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next3_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext3_xattr_handler_map))\n\t\thandler = ext3_xattr_handler_map[name_index];\n\treturn handler;\n}"
  }
]