[
  {
    "function_name": "scan_revoke_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "840-872",
    "snippet": "static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjbd2_journal_revoke_header_t *header;\n\tint offset, max;\n\tint record_len = 4;\n\n\theader = (jbd2_journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(jbd2_journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\tif (!jbd2_revoke_block_csum_verify(journal, header))\n\t\treturn -EINVAL;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\trecord_len = 8;\n\n\twhile (offset + record_len <= max) {\n\t\tunsigned long long blocknr;\n\t\tint err;\n\n\t\tif (record_len == 4)\n\t\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\telse\n\t\t\tblocknr = be64_to_cpu(* ((__be64 *) (bh->b_data+offset)));\n\t\toffset += record_len;\n\t\terr = jbd2_journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_set_revoke",
          "args": [
            "journal",
            "blocknr",
            "sequence"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "702-717",
          "snippet": "int jbd2_journal_set_revoke(journal_t *journal,\n\t\t       unsigned long long blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_set_revoke(journal_t *journal,\n\t\t       unsigned long long blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "* ((__be64 *) (bh->b_data+offset))"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "* ((__be32 *) (bh->b_data+offset))"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_revoke_block_csum_verify",
          "args": [
            "journal",
            "header"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_revoke_block_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "818-836",
          "snippet": "static int jbd2_revoke_block_csum_verify(journal_t *j,\n\t\t\t\t\t void *buf)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\tprovided = tail->r_checksum;\n\ttail->r_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->r_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_revoke_block_csum_verify(journal_t *j,\n\t\t\t\t\t void *buf)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\tprovided = tail->r_checksum;\n\ttail->r_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->r_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "header->r_count"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjbd2_journal_revoke_header_t *header;\n\tint offset, max;\n\tint record_len = 4;\n\n\theader = (jbd2_journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(jbd2_journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\tif (!jbd2_revoke_block_csum_verify(journal, header))\n\t\treturn -EINVAL;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\trecord_len = 8;\n\n\twhile (offset + record_len <= max) {\n\t\tunsigned long long blocknr;\n\t\tint err;\n\n\t\tif (record_len == 4)\n\t\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\telse\n\t\t\tblocknr = be64_to_cpu(* ((__be64 *) (bh->b_data+offset)));\n\t\toffset += record_len;\n\t\terr = jbd2_journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_revoke_block_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "818-836",
    "snippet": "static int jbd2_revoke_block_csum_verify(journal_t *j,\n\t\t\t\t\t void *buf)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\tprovided = tail->r_checksum;\n\ttail->r_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->r_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "calculated"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "buf",
            "j->j_blocksize"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_revoke_block_csum_verify(journal_t *j,\n\t\t\t\t\t void *buf)\n{\n\tstruct jbd2_journal_revoke_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_revoke_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_revoke_tail));\n\tprovided = tail->r_checksum;\n\ttail->r_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->r_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
  },
  {
    "function_name": "do_one_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "420-816",
    "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\"",
            "pass",
            "next_commit_ID",
            "info->end_transaction"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"Unrecognised magic %d, end of scan.\\n\"",
            "blocktype"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_revoke_records",
          "args": [
            "journal",
            "bh",
            "next_commit_ID",
            "info"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "scan_revoke_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "840-872",
          "snippet": "static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjbd2_journal_revoke_header_t *header;\n\tint offset, max;\n\tint record_len = 4;\n\n\theader = (jbd2_journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(jbd2_journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\tif (!jbd2_revoke_block_csum_verify(journal, header))\n\t\treturn -EINVAL;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\trecord_len = 8;\n\n\twhile (offset + record_len <= max) {\n\t\tunsigned long long blocknr;\n\t\tint err;\n\n\t\tif (record_len == 4)\n\t\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\telse\n\t\t\tblocknr = be64_to_cpu(* ((__be64 *) (bh->b_data+offset)));\n\t\toffset += record_len;\n\t\terr = jbd2_journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjbd2_journal_revoke_header_t *header;\n\tint offset, max;\n\tint record_len = 4;\n\n\theader = (jbd2_journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(jbd2_journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\tif (!jbd2_revoke_block_csum_verify(journal, header))\n\t\treturn -EINVAL;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\trecord_len = 8;\n\n\twhile (offset + record_len <= max) {\n\t\tunsigned long long blocknr;\n\t\tint err;\n\n\t\tif (record_len == 4)\n\t\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\telse\n\t\t\tblocknr = be64_to_cpu(* ((__be64 *) (bh->b_data+offset)));\n\t\toffset += record_len;\n\t\terr = jbd2_journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_commit_block_csum_verify",
          "args": [
            "journal",
            "bh->b_data"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_commit_block_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "382-398",
          "snippet": "static int jbd2_commit_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct commit_header *h;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\th = buf;\n\tprovided = h->h_chksum[0];\n\th->h_chksum[0] = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\th->h_chksum[0] = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_commit_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct commit_header *h;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\th = buf;\n\tprovided = h->h_chksum[0];\n\th->h_chksum[0] = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\th->h_chksum[0] = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "cbh->h_chksum[0]"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_COMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "nbh"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "nbh",
            "\"marking uptodate\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "nbh"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "nbh"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "nbh",
            "\"marking dirty\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nbh->b_data",
            "obh->b_data",
            "journal->j_blocksize"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_fs_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_block_tag_csum_verify",
          "args": [
            "journal",
            "tag",
            "obh->b_data",
            "be32_to_cpu(tmp->h_sequence)"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_block_tag_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "400-418",
          "snippet": "static int jbd2_block_tag_csum_verify(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t      void *buf, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\tseq = cpu_to_be32(sequence);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, buf, j->j_blocksize);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn tag3->t_checksum == cpu_to_be32(csum32);\n\telse\n\t\treturn tag->t_checksum == cpu_to_be16(csum32);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_block_tag_csum_verify(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t      void *buf, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\tseq = cpu_to_be32(sequence);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, buf, j->j_blocksize);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn tag3->t_checksum == cpu_to_be32(csum32);\n\telse\n\t\treturn tag->t_checksum == cpu_to_be16(csum32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp->h_sequence"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_test_revoke",
          "args": [
            "journal",
            "blocknr",
            "next_commit_ID"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_test_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "726-738",
          "snippet": "int jbd2_journal_test_revoke(journal_t *journal,\n\t\t\tunsigned long long blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_test_revoke(journal_t *journal,\n\t\t\tunsigned long long blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd2_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tag_block",
          "args": [
            "journal",
            "tag"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "read_tag_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "341-348",
          "snippet": "static inline unsigned long long read_tag_block(journal_t *journal,\n\t\t\t\t\t\tjournal_block_tag_t *tag)\n{\n\tunsigned long long block = be32_to_cpu(tag->t_blocknr);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\tblock |= (u64)be32_to_cpu(tag->t_blocknr_high) << 32;\n\treturn block;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline unsigned long long read_tag_block(journal_t *journal,\n\t\t\t\t\t\tjournal_block_tag_t *tag)\n{\n\tunsigned long long block = be32_to_cpu(tag->t_blocknr);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\tblock |= (u64)be32_to_cpu(tag->t_blocknr_high) << 32;\n\treturn block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "obh != NULL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jread",
          "args": [
            "&obh",
            "journal",
            "io_block"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "jread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "132-175",
          "snippet": "static int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap",
          "args": [
            "journal",
            "next_log_block"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "fsdlm_blocking_ast_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "689-694",
          "snippet": "static void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "tag->t_flags"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_tags",
          "args": [
            "journal",
            "bh"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "count_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "201-226",
          "snippet": "static int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_chksums",
          "args": [
            "journal",
            "bh",
            "&next_log_block",
            "&crc32_sum"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "calc_chksums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "354-380",
          "snippet": "static int calc_chksums(journal_t *journal, struct buffer_head *bh,\n\t\t\tunsigned long *next_log_block, __u32 *crc32_sum)\n{\n\tint i, num_blks, err;\n\tunsigned long io_block;\n\tstruct buffer_head *obh;\n\n\tnum_blks = count_tags(journal, bh);\n\t/* Calculate checksum of the descriptor block. */\n\t*crc32_sum = crc32_be(*crc32_sum, (void *)bh->b_data, bh->b_size);\n\n\tfor (i = 0; i < num_blks; i++) {\n\t\tio_block = (*next_log_block)++;\n\t\twrap(journal, *next_log_block);\n\t\terr = jread(&obh, journal, io_block);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\", err, io_block);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*crc32_sum = crc32_be(*crc32_sum, (void *)obh->b_data,\n\t\t\t\t     obh->b_size);\n\t\t}\n\t\tput_bh(obh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int calc_chksums(journal_t *journal, struct buffer_head *bh,\n\t\t\tunsigned long *next_log_block, __u32 *crc32_sum)\n{\n\tint i, num_blks, err;\n\tunsigned long io_block;\n\tstruct buffer_head *obh;\n\n\tnum_blks = count_tags(journal, bh);\n\t/* Calculate checksum of the descriptor block. */\n\t*crc32_sum = crc32_be(*crc32_sum, (void *)bh->b_data, bh->b_size);\n\n\tfor (i = 0; i < num_blks; i++) {\n\t\tio_block = (*next_log_block)++;\n\t\twrap(journal, *next_log_block);\n\t\terr = jread(&obh, journal, io_block);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\", err, io_block);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*crc32_sum = crc32_be(*crc32_sum, (void *)obh->b_data,\n\t\t\t\t     obh->b_size);\n\t\t}\n\t\tput_bh(obh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_COMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_descr_block_csum_verify",
          "args": [
            "journal",
            "bh->b_data"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_descr_block_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "177-195",
          "snippet": "static int jbd2_descr_block_csum_verify(journal_t *j,\n\t\t\t\t\tvoid *buf)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_block_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\tprovided = tail->t_checksum;\n\ttail->t_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->t_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_descr_block_csum_verify(journal_t *j,\n\t\t\t\t\tvoid *buf)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_block_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\tprovided = tail->t_checksum;\n\ttail->t_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->t_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"Found magic %d, sequence %d\\n\"",
            "blocktype",
            "sequence"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp->h_sequence"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp->h_blocktype"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD2: checking block %ld\\n\"",
            "next_log_block"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Scanning for sequence ID %u at %lu/%lu\\n\"",
            "next_commit_ID",
            "next_log_block",
            "journal->j_last"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "next_commit_ID",
            "info->end_transaction"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Starting recovery pass %d\\n\"",
            "pass"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_start"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_tag_bytes",
          "args": [
            "journal"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "journal_tag_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2178-2194",
          "snippet": "size_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nsize_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_block_tag_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "400-418",
    "snippet": "static int jbd2_block_tag_csum_verify(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t      void *buf, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\tseq = cpu_to_be32(sequence);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, buf, j->j_blocksize);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn tag3->t_checksum == cpu_to_be32(csum32);\n\telse\n\t\treturn tag->t_checksum == cpu_to_be16(csum32);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "csum32"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum32"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "j",
            "JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "csum32",
            "buf",
            "j->j_blocksize"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "(__u8 *)&seq",
            "sizeof(seq)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sequence"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_block_tag_csum_verify(journal_t *j, journal_block_tag_t *tag,\n\t\t\t\t      void *buf, __u32 sequence)\n{\n\tjournal_block_tag3_t *tag3 = (journal_block_tag3_t *)tag;\n\t__u32 csum32;\n\t__be32 seq;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\tseq = cpu_to_be32(sequence);\n\tcsum32 = jbd2_chksum(j, j->j_csum_seed, (__u8 *)&seq, sizeof(seq));\n\tcsum32 = jbd2_chksum(j, csum32, buf, j->j_blocksize);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(j, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn tag3->t_checksum == cpu_to_be32(csum32);\n\telse\n\t\treturn tag->t_checksum == cpu_to_be16(csum32);\n}"
  },
  {
    "function_name": "jbd2_commit_block_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "382-398",
    "snippet": "static int jbd2_commit_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct commit_header *h;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\th = buf;\n\tprovided = h->h_chksum[0];\n\th->h_chksum[0] = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\th->h_chksum[0] = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "calculated"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "buf",
            "j->j_blocksize"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_commit_block_csum_verify(journal_t *j, void *buf)\n{\n\tstruct commit_header *h;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\th = buf;\n\tprovided = h->h_chksum[0];\n\th->h_chksum[0] = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\th->h_chksum[0] = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
  },
  {
    "function_name": "calc_chksums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "354-380",
    "snippet": "static int calc_chksums(journal_t *journal, struct buffer_head *bh,\n\t\t\tunsigned long *next_log_block, __u32 *crc32_sum)\n{\n\tint i, num_blks, err;\n\tunsigned long io_block;\n\tstruct buffer_head *obh;\n\n\tnum_blks = count_tags(journal, bh);\n\t/* Calculate checksum of the descriptor block. */\n\t*crc32_sum = crc32_be(*crc32_sum, (void *)bh->b_data, bh->b_size);\n\n\tfor (i = 0; i < num_blks; i++) {\n\t\tio_block = (*next_log_block)++;\n\t\twrap(journal, *next_log_block);\n\t\terr = jread(&obh, journal, io_block);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\", err, io_block);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*crc32_sum = crc32_be(*crc32_sum, (void *)obh->b_data,\n\t\t\t\t     obh->b_size);\n\t\t}\n\t\tput_bh(obh);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "obh"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "*crc32_sum",
            "(void *)obh->b_data",
            "obh->b_size"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\"",
            "err",
            "io_block"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jread",
          "args": [
            "&obh",
            "journal",
            "io_block"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "jread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "132-175",
          "snippet": "static int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap",
          "args": [
            "journal",
            "*next_log_block"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "fsdlm_blocking_ast_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "689-694",
          "snippet": "static void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_be",
          "args": [
            "*crc32_sum",
            "(void *)bh->b_data",
            "bh->b_size"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_tags",
          "args": [
            "journal",
            "bh"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "count_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "201-226",
          "snippet": "static int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int calc_chksums(journal_t *journal, struct buffer_head *bh,\n\t\t\tunsigned long *next_log_block, __u32 *crc32_sum)\n{\n\tint i, num_blks, err;\n\tunsigned long io_block;\n\tstruct buffer_head *obh;\n\n\tnum_blks = count_tags(journal, bh);\n\t/* Calculate checksum of the descriptor block. */\n\t*crc32_sum = crc32_be(*crc32_sum, (void *)bh->b_data, bh->b_size);\n\n\tfor (i = 0; i < num_blks; i++) {\n\t\tio_block = (*next_log_block)++;\n\t\twrap(journal, *next_log_block);\n\t\terr = jread(&obh, journal, io_block);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: IO error %d recovering block \"\n\t\t\t\t\"%lu in log\\n\", err, io_block);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*crc32_sum = crc32_be(*crc32_sum, (void *)obh->b_data,\n\t\t\t\t     obh->b_size);\n\t\t}\n\t\tput_bh(obh);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "read_tag_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "341-348",
    "snippet": "static inline unsigned long long read_tag_block(journal_t *journal,\n\t\t\t\t\t\tjournal_block_tag_t *tag)\n{\n\tunsigned long long block = be32_to_cpu(tag->t_blocknr);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\tblock |= (u64)be32_to_cpu(tag->t_blocknr_high) << 32;\n\treturn block;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tag->t_blocknr_high"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tag->t_blocknr"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic inline unsigned long long read_tag_block(journal_t *journal,\n\t\t\t\t\t\tjournal_block_tag_t *tag)\n{\n\tunsigned long long block = be32_to_cpu(tag->t_blocknr);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\tblock |= (u64)be32_to_cpu(tag->t_blocknr_high) << 32;\n\treturn block;\n}"
  },
  {
    "function_name": "jbd2_journal_skip_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "313-339",
    "snippet": "int jbd2_journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD2_DEBUG\n\t\tint dropped = info.end_transaction - \n\t\t\tbe32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD2: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: ignoring %d transaction%s from the journal.\\n\"",
            "dropped",
            "(dropped == 1) ? \"\" : \"s\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_sequence"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: error %d scanning journal\\n\"",
            "err"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_one_pass",
          "args": [
            "journal",
            "&info",
            "PASS_SCAN"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "420-816",
          "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint jbd2_journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD2_DEBUG\n\t\tint dropped = info.end_transaction - \n\t\t\tbe32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD2: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "248-298",
    "snippet": "int jbd2_journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD2: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD2: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjbd2_journal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Make sure all replayed data is on permanent storage */\n\tif (journal->j_flags & JBD2_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "journal->j_fs_dev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "journal->j_fs_dev"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_clear_revoke",
          "args": [
            "journal"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_clear_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "745-762",
          "snippet": "void jbd2_journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\n\nvoid jbd2_journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd2_revoke_record_s *record;\n\tstruct jbd2_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd2_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(jbd2_revoke_record_cache, record);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: Replayed %d and revoked %d/%d blocks\\n\"",
            "info.nr_replays",
            "info.nr_revoke_hits",
            "info.nr_revokes"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_one_pass",
          "args": [
            "journal",
            "&info",
            "PASS_REPLAY"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "420-816",
          "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned long\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\t__u32\t\t\tcrc32_sum = ~0; /* Transactional Checksums */\n\tint\t\t\tdescr_csum_size = 0;\n\tint\t\t\tblock_error = 0;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %lu/%lu\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD2: checking block %ld\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JBD2_DESCRIPTOR_BLOCK:\n\t\t\t/* Verify checksum first */\n\t\t\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\t\t\tdescr_csum_size =\n\t\t\t\t\tsizeof(struct jbd2_journal_block_tail);\n\t\t\tif (descr_csum_size > 0 &&\n\t\t\t    !jbd2_descr_block_csum_verify(journal,\n\t\t\t\t\t\t\t  bh->b_data)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid checksum \"\n\t\t\t\t       \"recovering block %lu in log\\n\",\n\t\t\t\t       next_log_block);\n\t\t\t\terr = -EIO;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; if journal_checksums enabled, then\n\t\t\t * calculate checksums in PASS_SCAN, otherwise,\n\t\t\t * just skip over the blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tif (pass == PASS_SCAN &&\n\t\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM) &&\n\t\t\t\t    !info->end_transaction) {\n\t\t\t\t\tif (calc_chksums(journal, bh,\n\t\t\t\t\t\t\t&next_log_block,\n\t\t\t\t\t\t\t&crc32_sum)) {\n\t\t\t\t\t\tput_bh(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnext_log_block += count_tags(journal, bh);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tput_bh(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data + tag_bytes)\n\t\t\t       <= journal->j_blocksize - descr_csum_size) {\n\t\t\t\tunsigned long io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be16_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t\"JBD2: IO error %d recovering \"\n\t\t\t\t\t\t\"block %ld in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned long long blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = read_tag_block(journal,\n\t\t\t\t\t\t\t\t tag);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (jbd2_journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Look for block corruption */\n\t\t\t\t\tif (!jbd2_block_tag_csum_verify(\n\t\t\t\t\t\tjournal, tag, obh->b_data,\n\t\t\t\t\t\tbe32_to_cpu(tmp->h_sequence))) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tsuccess = -EIO;\n\t\t\t\t\t\tprintk(KERN_ERR \"JBD2: Invalid \"\n\t\t\t\t\t\t       \"checksum recovering \"\n\t\t\t\t\t\t       \"block %llu in log\\n\",\n\t\t\t\t\t\t       blocknr);\n\t\t\t\t\t\tblock_error = 1;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD2: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JBD2_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += tag_bytes;\n\t\t\t\tif (!(flags & JBD2_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JBD2_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JBD2_COMMIT_BLOCK:\n\t\t\t/*     How to differentiate between interrupted commit\n\t\t\t *               and journal corruption ?\n\t\t\t *\n\t\t\t * {nth transaction}\n\t\t\t *        Checksum Verification Failed\n\t\t\t *\t\t\t |\n\t\t\t *\t\t ____________________\n\t\t\t *\t\t|\t\t     |\n\t\t\t * \tasync_commit             sync_commit\n\t\t\t *     \t\t|                    |\n\t\t\t *\t\t| GO TO NEXT    \"Journal Corruption\"\n\t\t\t *\t\t| TRANSACTION\n\t\t\t *\t\t|\n\t\t\t * {(n+1)th transanction}\n\t\t\t *\t\t|\n\t\t\t * \t _______|______________\n\t\t\t * \t|\t \t      |\n\t\t\t * Commit block found\tCommit block not found\n\t\t\t *      |\t\t      |\n\t\t\t * \"Journal Corruption\"       |\n\t\t\t *\t\t _____________|_________\n\t\t\t *     \t\t|\t           \t|\n\t\t\t *\tnth trans corrupt\tOR   nth trans\n\t\t\t *\tand (n+1)th interrupted     interrupted\n\t\t\t *\tbefore commit block\n\t\t\t *      could reach the disk.\n\t\t\t *\t(Cannot find the difference in above\n\t\t\t *\t mentioned conditions. Hence assume\n\t\t\t *\t \"Interrupted Commit\".)\n\t\t\t */\n\n\t\t\t/* Found an expected commit block: if checksums\n\t\t\t * are present verify them in PASS_SCAN; else not\n\t\t\t * much to do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t    JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\tint chksum_err, chksum_seen;\n\t\t\t\tstruct commit_header *cbh =\n\t\t\t\t\t(struct commit_header *)bh->b_data;\n\t\t\t\tunsigned found_chksum =\n\t\t\t\t\tbe32_to_cpu(cbh->h_chksum[0]);\n\n\t\t\t\tchksum_err = chksum_seen = 0;\n\n\t\t\t\tif (info->end_transaction) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tinfo->end_transaction;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (crc32_sum == found_chksum &&\n\t\t\t\t    cbh->h_chksum_type == JBD2_CRC32_CHKSUM &&\n\t\t\t\t    cbh->h_chksum_size ==\n\t\t\t\t\t\tJBD2_CRC32_CHKSUM_SIZE)\n\t\t\t\t       chksum_seen = 1;\n\t\t\t\telse if (!(cbh->h_chksum_type == 0 &&\n\t\t\t\t\t     cbh->h_chksum_size == 0 &&\n\t\t\t\t\t     found_chksum == 0 &&\n\t\t\t\t\t     !chksum_seen))\n\t\t\t\t/*\n\t\t\t\t * If fs is mounted using an old kernel and then\n\t\t\t\t * kernel with journal_chksum is used then we\n\t\t\t\t * get a situation where the journal flag has\n\t\t\t\t * checksum flag set but checksums are not\n\t\t\t\t * present i.e chksum = 0, in the individual\n\t\t\t\t * commit blocks.\n\t\t\t\t * Hence to avoid checksum failures, in this\n\t\t\t\t * situation, this extra check is added.\n\t\t\t\t */\n\t\t\t\t\t\tchksum_err = 1;\n\n\t\t\t\tif (chksum_err) {\n\t\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t\t   JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)){\n\t\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcrc32_sum = ~0;\n\t\t\t}\n\t\t\tif (pass == PASS_SCAN &&\n\t\t\t    !jbd2_commit_block_csum_verify(journal,\n\t\t\t\t\t\t\t   bh->b_data)) {\n\t\t\t\tinfo->end_transaction = next_commit_ID;\n\n\t\t\t\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\t\t\t\tjournal->j_failed_commit =\n\t\t\t\t\t\tnext_commit_ID;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JBD2_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN) {\n\t\tif (!info->end_transaction)\n\t\t\tinfo->end_transaction = next_commit_ID;\n\t} else {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk(KERN_ERR \"JBD2: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\tif (block_error && success == 0)\n\t\tsuccess = -EIO;\n\treturn success;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"No recovery required, last transaction %d\\n\"",
            "be32_to_cpu(sb->s_sequence)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint jbd2_journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD2: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD2: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjbd2_journal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Make sure all replayed data is on permanent storage */\n\tif (journal->j_flags & JBD2_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "count_tags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "201-226",
    "snippet": "static int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "JBD2_FLAG_LAST_TAG"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "JBD2_FLAG_SAME_UUID"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_tag_bytes",
          "args": [
            "journal"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "journal_tag_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2178-2194",
          "snippet": "size_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nsize_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int count_tags(journal_t *journal, struct buffer_head *bh)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0, size = journal->j_blocksize;\n\tint\t\t\ttag_bytes = journal_tag_bytes(journal);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tsize -= sizeof(struct jbd2_journal_block_tail);\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + tag_bytes) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += tag_bytes;\n\t\tif (!(tag->t_flags & cpu_to_be16(JBD2_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be16(JBD2_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}"
  },
  {
    "function_name": "jbd2_descr_block_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "177-195",
    "snippet": "static int jbd2_descr_block_csum_verify(journal_t *j,\n\t\t\t\t\tvoid *buf)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_block_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\tprovided = tail->t_checksum;\n\ttail->t_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->t_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "calculated"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "j->j_csum_seed",
            "buf",
            "j->j_blocksize"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jbd2_descr_block_csum_verify(journal_t *j,\n\t\t\t\t\tvoid *buf)\n{\n\tstruct jbd2_journal_block_tail *tail;\n\t__be32 provided;\n\t__u32 calculated;\n\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\ttail = (struct jbd2_journal_block_tail *)(buf + j->j_blocksize -\n\t\t\tsizeof(struct jbd2_journal_block_tail));\n\tprovided = tail->t_checksum;\n\ttail->t_checksum = 0;\n\tcalculated = jbd2_chksum(j, j->j_csum_seed, buf, j->j_blocksize);\n\ttail->t_checksum = provided;\n\n\treturn provided == cpu_to_be32(calculated);\n}"
  },
  {
    "function_name": "jread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "132-175",
    "snippet": "static int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: Failed to read block at offset %u\\n\"",
            "offset"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_readahead",
          "args": [
            "journal",
            "offset"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "do_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "70-123",
          "snippet": "static int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = jbd2_journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [
            "#define MAXBUF 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\n#define MAXBUF 8\n\nstatic int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = jbd2_journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_bmap",
          "args": [
            "journal",
            "offset",
            "&blocknr"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "784-805",
          "snippet": "int jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD2: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = jbd2_journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk(KERN_ERR \"JBD2: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "70-123",
    "snippet": "static int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = jbd2_journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [
      "#define MAXBUF 8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_brelse_array",
          "args": [
            "bufs",
            "nbufs"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "journal_brelse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "50-54",
          "snippet": "static void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "nbufs",
            "bufs"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: bad block at offset %u\\n\"",
            "next"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_bmap",
          "args": [
            "journal",
            "next",
            "&blocknr"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "784-805",
          "snippet": "int jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\n#define MAXBUF 8\n\nstatic int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned long long blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = jbd2_journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"JBD2: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_brelse_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
    "lines": "50-54",
    "snippet": "static void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/crc32.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b[n]"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}"
  }
]